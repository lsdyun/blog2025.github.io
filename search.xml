<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo使用、博客编写教程：</title>
    <url>/blog2025.github.io/2025/03/10/hello-world/</url>
    <content><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="一、流程"><a href="#一、流程" class="headerlink" title="一、流程"></a>一、流程</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">cmd进入hexo-blog目录本地库，</span><br><span class="line">使用命令进行操作，</span><br><span class="line">操作完成后使用 <span class="attribute">hexo</span> g -d 生成静态页面并上传到GitHub。</span><br></pre></td></tr></table></figure>

<h3 id="二、创建新帖子"><a href="#二、创建新帖子" class="headerlink" title="二、创建新帖子"></a>二、创建新帖子</h3><p>方法一：直接生成文章：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> new <span class="comment"># 文章名称</span></span><br></pre></td></tr></table></figure>

<p>方法二：生成文章和对应同名目录(用于存储图片资源等)：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> new post <span class="comment"># 文章名称</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/03/10/hello-world/image-20250313130306915.png"></p>
<p>注：文章存储路径为：hexo-blog&#x2F;source&#x2F;_posts</p>
<h3 id="三、Hexo命令："><a href="#三、Hexo命令：" class="headerlink" title="三、Hexo命令："></a>三、Hexo命令：</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span> init <span class="comment"># 初始化 </span></span><br><span class="line">npm install <span class="comment"># (一般来讲，这个只会在第一次安装hexo时使用)</span></span><br><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">hexo g <span class="comment"># 生成静态页面</span></span><br><span class="line">hexo d <span class="comment"># 上传到GitHub</span></span><br><span class="line">hexo s <span class="comment"># 本地预览</span></span><br><span class="line">hexo g -d <span class="comment"># 生成静态页面并上传到github</span></span><br><span class="line">ssh -T git<span class="variable">@github</span>.com <span class="comment"># 测试连通性</span></span><br></pre></td></tr></table></figure>

<p>更多命令: <a href="https://hexo.io/zh-cn/docs/commands">链接</a></p>
<h3 id="四、注意事项："><a href="#四、注意事项：" class="headerlink" title="四、注意事项："></a>四、注意事项：</h3><p>问题一:   “You’ve successfully authenticated, but GitHub does not provide shell access.”	</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">·需要生成本地<span class="attribute">SSH</span> ，再配置到GitHub中。</span><br><span class="line">·因为本次采用SSH进行远程连接，所以对于本地hexo-blog中的_config.xml进行配置为SSH格式。</span><br><span class="line">deploy:</span><br><span class="line">   type: git	</span><br><span class="line">   repo: git<span class="variable">@github</span>.com:lsdyun/blog2025.github.io.git</span><br><span class="line">   branch: main</span><br></pre></td></tr></table></figure>

<p>问题二：采用Http和SSH区别:(!!!推荐使用SSH)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">采用Http每次都需要输入账号和密码，使用SSH则不需要。</span><br><span class="line">此外，GitHub已经禁止密码验证，强制要求使用个人访问令牌(PAT),所以此处才使用SSH。</span><br></pre></td></tr></table></figure>

<p>注：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">认证机制：</span><br><span class="line">  SSH：</span><br><span class="line">     ·基于非对称加密，通过本机生成的密钥对（公钥+私钥）进行身份验证，无需每次输入密码。</span><br><span class="line">     ·密钥需手动生成并添加至GitHub账户的SSH Keys配置页，实现一次性配置长期生效。</span><br><span class="line">  HTTP(S)：</span><br><span class="line">     ·依赖用户名+密码或令牌(PAT)认证。GitHub已禁用密码验证，强制要求使用个人访问令牌(PAT)。</span><br><span class="line">     ·令牌需在GitHub账户中生成并赋予权限(如repo权限)，操作时需手动输入或依赖凭证缓存。</span><br></pre></td></tr></table></figure>

<p>生成SSH和配置到GitHub参考: <a href="https://zhuanlan.zhihu.com/p/392994381">链接</a></p>
<h3 id="五：补充："><a href="#五：补充：" class="headerlink" title="五：补充："></a>五：补充：</h3><p>·Hexo默认主题存放在node_modules&#x2F;hexo-theme-landscape目录下，可对_config.yml进行处理。</p>
<p><font color="red">·当使用steam++加速GitHub时，会导致本地host被污染，导致无法上传项目到GitHub，最好先关闭加速在上传。</font></p>
<h3 id="六、Hexo渲染和Typora图片问题"><a href="#六、Hexo渲染和Typora图片问题" class="headerlink" title="六、Hexo渲染和Typora图片问题"></a>六、Hexo渲染和Typora图片问题</h3><p>1.修改 Hexo 根目录的 <code>_config.yml</code>，确保以下配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">post_asset_folder: <span class="attribute">true</span>  <span class="comment"># 自动生成文章同名资源夹</span></span><br><span class="line">relative_link: <span class="literal">false</span>     <span class="comment"># 禁止生成相对路径</span></span><br><span class="line"></span><br><span class="line">同时增加：(没这个也会导致渲染出问题)</span><br><span class="line"><span class="comment"># 解决typera和hexo图片加载问题  </span></span><br><span class="line">marked:</span><br><span class="line">  prependRoot: <span class="literal">true</span></span><br><span class="line">  postAsset: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>2.安装官方推荐的渲染插件：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">npm</span> uninstall hexo-renderer-marked --save  <span class="comment"># 先卸载旧版本（如有）</span></span><br><span class="line">npm install hexo-renderer-marked<span class="variable">@latest</span> --save</span><br></pre></td></tr></table></figure>

<p>3.Typora 设置路径：</p>
<p>偏好设置 → 图像 → 插入图片时选择 “复制到指定路径”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保存路径填：./$&#123;filename&#125;.assets/  </span><br><span class="line">勾选：优先使用相对路径</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/03/10/hello-world/image-20250313225230399.png" alt="image-20250313225230399"></p>
<p>4.格式→图像→设置图片根目录 “选择对应文件的存储位置”</p>
<p>5‌.插入图片后检查格式：</p>
<p>在 Markdown 中必须显示为 <code>![描述](图片名.jpg)</code>，而不是 <code>![描述](文章名/图片名.jpg)</code><br>（若出现多余路径，手动删除前缀）</p>
<p>6.<font color="red">添加图片步骤</font></p>
<p>方法一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步、使用截图工具,不保存；</span><br><span class="line">第二步、直接将图片复制到Typora中；</span><br><span class="line">第三步、从Typora将图片保存到对应文件夹中；</span><br><span class="line">第四步、将Typora中的文件名的&quot;/&quot;删除，格式为：![描述](image.png)</span><br></pre></td></tr></table></figure>

<p>方法二：（图片最后格式一定没有”&#x2F;“）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步、使用截图工具，保存到对应目录；</span><br><span class="line">第二步、在Typora中，右击插入图像；</span><br><span class="line">第三步、将Typora中的文件名的&quot;/&quot;删除，格式为：![描述](image.png)</span><br></pre></td></tr></table></figure>

<h3 id="七、Hexo高亮问题："><a href="#七、Hexo高亮问题：" class="headerlink" title="七、Hexo高亮问题："></a>七、Hexo高亮问题：</h3><p>1.Hexo 7.x的配置文件(_config.xml)中:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">syntax_highlighter: highlight.js</span><br><span class="line">highlight:</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#x27;&#x27;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line">prismjs:</span><br><span class="line">  preprocess: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>syntax_highlighter: 可选Hexo默认的highlight.js,也可选prismjs</p>
<p>2.Next 8.22.0主题的配置文件(_config.xml)中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # All available themes: https://theme-next.js.org/highlight/</span><br><span class="line">  theme:</span><br><span class="line">    light: default  ##这里决定了最后展示的效果</span><br><span class="line">    dark: stackoverflow-dark ##这里决定了最后展示的效果</span><br><span class="line">  prism:</span><br><span class="line">    light: prism-tomorrow  ##这里决定了最后展示的效果</span><br><span class="line">    dark: prism-tomorrow-dark ##这里决定了最后展示的效果</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: </span><br><span class="line">  # Fold code block</span><br><span class="line">  fold:</span><br><span class="line">    enable: false</span><br><span class="line">    height: 500</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/03/10/hello-world/BB1msOOV.jpg"></p>
<h3 id="八、个性化Next主题："><a href="#八、个性化Next主题：" class="headerlink" title="八、个性化Next主题："></a>八、个性化Next主题：</h3><p>1.开启themes&#x2F;next_config.xml中的选项</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">	style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>2.在hexo-blog&#x2F;source&#x2F;_data中新建styles.styl</p>
<p>3.开始在styles.styl中自定义CSS</p>
<h3 id="九、开启动态背景："><a href="#九、开启动态背景：" class="headerlink" title="九、开启动态背景："></a>九、开启动态背景：</h3><p>在themes&#x2F;next_config.xml中开启</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">canvas_ribbon:</span><br><span class="line">  enable: true</span><br><span class="line">  size: 300 # The width of the ribbon</span><br><span class="line">  alpha: 0.6 # The transparency of the ribbon</span><br><span class="line">  zIndex: -1 # The display level of the ribbon</span><br></pre></td></tr></table></figure>

<h3 id="十、参考资料："><a href="#十、参考资料：" class="headerlink" title="十、参考资料："></a>十、参考资料：</h3><p>安装教程一: <a href="https://blog.csdn.net/yaorongke/article/details/119089190">链接</a></p>
<p>安装教程二: <a href="https://zhuanlan.zhihu.com/p/392994381">链接</a></p>
<p>Next主题使用方法：<a href="https://zhuanlan.zhihu.com/p/618864711">链接</a></p>
<p>Next 8 版本使用方法：<a href="https://www.cnblogs.com/jinwei26/articles/18460312">链接</a>（代码块，动态人物|本项目采用该版本）</p>
<p>Next新旧版本对比：<a href="https://www.imczw.com/post/tech/hexo5-next8-updated.html#%E9%BB%98%E8%AE%A4%E9%A1%B5%E5%A4%84%E7%90%86">链接</a></p>
<p>图标icon：<a href="https://fontawesome.dashgame.com/">链接</a></p>
<p>分类和标签功能：<a href="https://juejin.cn/post/6921750181297782798">链接</a></p>
<p>阅读全文功能：<a href="https://blog.csdn.net/codejoker_7/article/details/123235687">链接</a>要搭配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Typora中编写文档时配合&lt;!--more--&gt;使用，可以将文章内容截断，解决网页首页展示过多内容。</span><br></pre></td></tr></table></figure>

<p>暗黑模式：<a href="https://blog.csdn.net/rqh656418510/article/details/123676457">链接</a></p>
<p>Hexo 7.x 语法高亮：<a href="https://hexo.io/zh-cn/docs/syntax-highlight">链接</a></p>
<p>Hexo-Next:<a href="https://hexo-next.readthedocs.io/zh-cn/latest/">链接</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>自建网站</category>
      </categories>
  </entry>
  <entry>
    <title>计算机操作系统</title>
    <url>/blog2025.github.io/2025/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ol>
<li><p>计算机系统上配置操作系统，主要目标是：方便性、有效性、可扩充性、开放性。</p>
</li>
<li><p>操作系统作用：①用户与硬件交互；②资源管理者；③资源的抽象。</p>
</li>
<li><p>发展过程：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特性</th>
<th>优点</th>
<th>缺点</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>未配置操作系统的计算机系统</td>
<td></td>
<td></td>
<td></td>
<td>人工（纸带）、脱机IO（磁带）</td>
</tr>
<tr>
<td>单道批处理系统</td>
<td>单道性、顺序性、自动性</td>
<td></td>
<td>不能充分利用资源</td>
<td></td>
</tr>
<tr>
<td>多道批处理系统</td>
<td>多道性、无序性、调度性</td>
<td>能提高整个系统的性能，吞吐量大，利用率高</td>
<td>资源竞争问题，不能提高任何单个进程的性能。</td>
<td></td>
</tr>
<tr>
<td>分时系统</td>
<td>单主机、多用户、（多路、独立、及时、交互）</td>
<td>可靠、交互性强、响应快</td>
<td></td>
<td>多路卡64位，缓冲区、内存、轮转运行（时间片）</td>
</tr>
<tr>
<td>实时系统</td>
<td>工业化、信息查询、多媒体、嵌入式</td>
<td>高可靠性，交互性仅对特定服务</td>
<td></td>
<td>①周期、非周期</br>②硬实时，软实时</br>③截止时间（最后期限）</td>
</tr>
<tr>
<td>微机系统</td>
<td></td>
<td></td>
<td></td>
<td>Windows</td>
</tr>
</tbody></table>
<span id="more"></span></li>
</ol>
<h3 id="二、特性（多道、分时、实时）"><a href="#二、特性（多道、分时、实时）" class="headerlink" title="二、特性（多道、分时、实时）"></a>二、特性（多道、分时、实时）</h3><ol>
<li><p>最基本特性：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>并发</td>
<td>并行与并发、进程</td>
</tr>
<tr>
<td>共享</td>
<td>资源共享或复用、互斥（只允许一个）（临界资源）（栈、变量）</td>
</tr>
<tr>
<td>虚拟</td>
<td>时分复用、空分复用</td>
</tr>
<tr>
<td>异步</td>
<td>进程的不可预知性</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="三、功能"><a href="#三、功能" class="headerlink" title="三、功能"></a>三、功能</h3><table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>处理机</td>
<td>进程控制、进程同步、进程通信、调度</td>
</tr>
<tr>
<td>存储器</td>
<td>内存分配、内存保护、地址映射、内存扩充</td>
</tr>
<tr>
<td>设备</td>
<td>缓存管理、设备分配、设备处理</td>
</tr>
<tr>
<td>文件</td>
<td>文件存储空间、目录管理、文件的读&#x2F;写管理和保护</td>
</tr>
<tr>
<td>操作系统与用户之间的接口</td>
<td>用户接口、程序接口</td>
</tr>
<tr>
<td>现代操作系统的新功能</td>
<td>系统安全、网络的功能和服务、支持多媒体</td>
</tr>
</tbody></table>
<h3 id="四、结构"><a href="#四、结构" class="headerlink" title="四、结构"></a>四、结构</h3><table>
<thead>
<tr>
<th>类型</th>
<th>包含</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>传统结构OS</td>
<td>无结构OS、模块化OS（高内聚低耦合）、分层式OS</td>
<td></td>
</tr>
<tr>
<td>现代结构OS</td>
<td>微内核</td>
<td></td>
</tr>
<tr>
<td>C&#x2F;S</td>
<td>客户端&#x2F;服务端</td>
<td></td>
</tr>
</tbody></table>
<h3 id="五、进程"><a href="#五、进程" class="headerlink" title="五、进程"></a>五、进程</h3><ol>
<li><p>概念：前趋图（有向无循环）记为：DAG（类似于拓扑图）,</p>
<p>前趋图中不允许有玄幻，所以是<strong>单向的</strong>。</p>
<p>pi—weight权—&gt;pj；pi是pj的直接前趋，pj是pi的直接后继</p>
<p><img src="/blog2025.github.io/2025/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/DAG.png"></p>
</li>
<li><p>程序执行：</p>
<p>①顺序：</p>
<p><img src="/blog2025.github.io/2025/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B1.png"></p>
<p>特性：顺序性（严格一个接一个）、封闭性（独占资源）、可再现性（条件不改变，结果总相同）</p>
<p>②并发：（不存在前趋关系）</p>
<p><img src="/blog2025.github.io/2025/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B2.png"></p>
<p>特性：间断性、失去封闭性、不可再现性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;emsp;空格</span><br></pre></td></tr></table></figure>
</li>
<li><p>进程定义：</p>
<p>①进程控制块PCB:记录了OS所需要的，用于描述进程的当前情况以及管理进程运行的全部信息。</p>
<p>②程序段</p>
<p>③相关数据段</p>
<p>特征：动态性、并发性、独立性、异步性</p>
</li>
<li><p>进程形态：</p>
<p>就绪Ready、执行Running、阻塞Block、创建、终止、挂起Suspend、激活Active</p>
</li>
</ol>
<p><img src="/blog2025.github.io/2025/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p>
<ol start="5">
<li><p>进程控制块PCB：</p>
<p>包含信息：进程标识符、处理机状态、进程调度信息、进程控制信息</p>
<p>组织方式：线性方式（线性表）、链接方式（队列）、索引方式（索引表）</p>
</li>
<li><p>进程控制</p>
<p>（1）OS内核：</p>
<p>&emsp;&emsp;&emsp;&emsp;①支撑功能：中断处理、时钟管理、原语操作（完成一定功能的若干条指令）</p>
<p>&emsp;&emsp;&emsp;&emsp;②资源管理功能：进程管理、存储器管理、设备管理。</p>
<p>（2）进程的层次结构：</p>
<p>&emsp;&emsp;&emsp;&emsp;UNIX存在层次结构，Windows不存在层次结构，所有进程都有相同的地位。</p>
<p>&emsp;&emsp;&emsp;&emsp;进程图：树型结构。</p>
<p>（3）引起进程创建的事件：</p>
<p>&emsp;&emsp;&emsp;&emsp;用户登录、作业调度、提供服务、应用请求</p>
<p>（4）进程的创建：</p>
<p>&emsp;&emsp;&emsp;&emsp;①申请空白PCB</p>
<p>&emsp;&emsp;&emsp;&emsp;②分配资源</p>
<p>&emsp;&emsp;&emsp;&emsp;③初始化PCB</p>
<p>&emsp;&emsp;&emsp;&emsp;④就绪队列</p>
<p>（5）引起进程终止的事件：</p>
<p>&emsp;&emsp;&emsp;&emsp;正常结束、异常结束、外界干预</p>
<p>（6）进程的终止：</p>
<p>&emsp;&emsp;&emsp;&emsp;①根据终止标识符检查PCB</p>
<p>&emsp;&emsp;&emsp;&emsp;②处于执行状态的进程——&gt;终止</p>
<p>&emsp;&emsp;&emsp;&emsp;③子孙进程——&gt;终止</p>
<p>&emsp;&emsp;&emsp;&emsp;④归还资源</p>
<p>&emsp;&emsp;&emsp;&emsp;⑤将终止PCB移除所在队列或链表</p>
<p>（7）引起进程阻塞和唤醒的事件：</p>
<p>&emsp;&emsp;&emsp;&emsp;请求共享资源失败、等待操作完成、新数据尚未到达、等待新任务的到达。</p>
<p>（8）进程同步：</p>
<p>&emsp;&emsp;&emsp;&emsp;原则：空闲让进、忙则等待、有限等待、让权等待。</p>
<p>&emsp;&emsp;&emsp;临界资源：打印机、磁带。</p>
<p>&emsp;&emsp;&emsp;临界区：临界资源所在的区域</p>
</li>
<li><p><font color="red">信号量机制：PV操作</font></p>
<p>wait()；申请资源</p>
<p>signal()；释放资源</p>
<p>典型问题：生产者-消费者问题</p>
</li>
<li><p>进程和管程：</p>
<table>
<thead>
<tr>
<th></th>
<th>类型</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td>私有数据结构PCB</td>
<td>顺序执行、并发、主动</td>
</tr>
<tr>
<td>管程</td>
<td>公共数据结构</td>
<td>同步、初始化、互斥、被动</td>
</tr>
</tbody></table>
</li>
<li><p>进程通信：</p>
<p>类型：共享存储器系统、管道pipe通信系统、消息传递系统、客户机-服务器系统</p>
<p>实现方式：直接消息传递系统、信箱通信</p>
</li>
<li><p>线程：提高程序并发执行的程度。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>进程</td>
<td>可拥有资源的独立单位，可独立调度和分派的基本单位（传统OS）</td>
<td>PCB、拥有系统资源、开销大</td>
</tr>
<tr>
<td>线程</td>
<td>可独立调度和分派的基本单位（引入线程的OS）</td>
<td>TCB、不拥有系统资源，仅拥有控制线程运行的TCB、共享进程资源、开销小</td>
</tr>
</tbody></table>
</li>
<li><p>线程的实现：</p>
<p>（1）分类：</p>
<p>&emsp;&emsp;&emsp;内核支持线程KST：阻塞在线程一级；</p>
<p>&emsp;&emsp;&emsp;用户级线程ULT：阻塞在用户进程</p>
<p>（2）实现：内核支持、用户级</p>
</li>
</ol>
<h3 id="六、处理及调度与死锁"><a href="#六、处理及调度与死锁" class="headerlink" title="六、处理及调度与死锁"></a>六、处理及调度与死锁</h3><ol>
<li><p>处理机调度的层次：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>调度对象</th>
<th>目的</th>
<th>应用于</th>
<th>调度算法（看下）</th>
</tr>
</thead>
<tbody><tr>
<td>高级调度（长程调度、作业调度）</td>
<td>作业</td>
<td>外存调入内存</td>
<td>多道批处理系统</td>
<td></td>
</tr>
<tr>
<td>低级调度（短程调度、进程调度）</td>
<td>进程</td>
<td>决定哪个进程获得处理机</td>
<td>多道批、分时、实时系统</td>
<td></td>
</tr>
<tr>
<td>中级调度（内存调度）</td>
<td>内外存交互</td>
<td>将暂时不能运行的进程从内存调至外存</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>处理机调度算法目标：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>处理机调度</td>
<td>资源利用率、公平、平衡、策略强制执行</td>
</tr>
<tr>
<td>批处理系统</td>
<td>平均周转时间短、系统吞吐量高、处理机利用率高</td>
</tr>
<tr>
<td>分时系统</td>
<td>响应时间快、均衡</td>
</tr>
<tr>
<td>实时系统</td>
<td>截止时间的保证、可预测</td>
</tr>
</tbody></table>
</li>
<li><p><strong>作业调度算法：</strong></p>
<p>（1）作业、作业步、作业控制块JCB</p>
<p>（2）状态：收容阶段（后备状态）、运行阶段（运行状态）、完成阶段（完成状态）</p>
<p>（3）算法：</p>
<p>&emsp;&emsp;①先来先服务FCFS</p>
<p>&emsp;&emsp;②短作业优先SJF</p>
<p>&emsp;&emsp;③优先级调度PSA</p>
<p>&emsp;&emsp;④高响应比优先调度HRRN：</p>
<p>&emsp;&emsp;&emsp;&emsp;优先权&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间&#x3D;1+（等待时间&#x2F;要求服务时间）</p>
<p>完成时刻&#x3D;开始时刻+运行时间</p>
<p>周转时间&#x3D;完成时刻-进入时刻</p>
<p>带权周转时间&#x3D;周转时间&#x2F;运行时间</p>
<p>平均等待时间&#x3D;Σ（周转时间-运行时间）÷ n</p>
<p>平均带权周转时间&#x3D;带权周转时间&#x2F;作业个数</p>
</li>
<li><p><strong>进程调度算法：</strong></p>
<p>调度方式：</p>
<p>&emsp;&emsp;非抢占方式：</p>
<p>&emsp;&emsp;抢占方式：优先权原则、短进程优先原则、时间片原则</p>
<p>算法：</p>
<p>（1）轮转调度算法RR（round robin）</p>
<p>（2）优先级调度算法：分为：非抢占式和抢占式。</p>
<p>&emsp;&emsp;优先级类型：静态、动态（每次调度都要计算响应比增加系统开销）</p>
<p>（3）多队列调度算法</p>
<p>（4）多级反馈队列调度算法（multileved feedback queue）</p>
<p>（5）基于公平原则的调度算法</p>
</li>
<li><p><strong>实时调度算法：</strong></p>
<p>调度方式：</p>
<p>&emsp;&emsp;非抢占方式：轮转、优先级</p>
<p>&emsp;&emsp;抢占方式：时钟中断、立即抢占的优先级</p>
<p>算法：</p>
<p>（1）最早截止时间优先EDF（Earliest Deadline First）:分为抢占式和非抢占式</p>
<p>（2）最低松弛度优先LLF（Least Laxity First）：松弛度越高任务越紧急</p>
<p>&emsp;&emsp;松弛度&#x3D;必须完成时间-其本身的运行时间-当前时间</p>
<p>（3）优先级倒置（priority inversion problem）</p>
<p>参考： <a href="https://blog.csdn.net/m0_48241022/article/details/142188201">链接</a></p>
</li>
<li><p>死锁：</p>
<p>（1）类型：</p>
<p>&emsp;&emsp;①竞争不可抢占资源</p>
<p>&emsp;&emsp;②竞争可消耗资源</p>
<p>&emsp;&emsp;③进程推进顺序不当</p>
<p>（2）定义：</p>
<p>&emsp;&emsp;进程A一直等待进程B所占有的资源。</p>
<p>（3）发生必要条件：</p>
<p>&emsp;&emsp;①互斥</p>
<p>&emsp;&emsp;②请求和保持</p>
<p>&emsp;&emsp;③不可抢占</p>
<p>&emsp;&emsp;④循环等待</p>
<p>（4）处理方法：</p>
<table>
<thead>
<tr>
<th>方法类型</th>
<th>是否允许死锁</th>
<th>破坏条件</th>
</tr>
</thead>
<tbody><tr>
<td>预防死锁</td>
<td>不允许</td>
<td>（1）两种协议：<br>①一次性申请全部资源<br>②仅获取运行初期资源<br>（2）破坏不可抢占条件<br>破坏循环等待条件</td>
</tr>
<tr>
<td>避免死锁</td>
<td>不允许</td>
<td>安全态&#x3D;可避免发生死锁；<br>不安全态，可能进入死锁<br>安全态-&gt;不安全态<br>银行家算法、安全性算法</td>
</tr>
<tr>
<td>检测死锁</td>
<td>允许</td>
<td></td>
</tr>
<tr>
<td>解除死锁</td>
<td>允许</td>
<td></td>
</tr>
</tbody></table>
<p>&emsp;&emsp;①<strong>银行家算法：</strong>（确定Request过程）</p>
<p>&emsp;&emsp;&emsp;系统中有五个进程{P0,P1,P2,P3,P4}和三类资源{A,B,C}，各种资源的数量分别为10，5，7，在<strong>T0</strong>时刻的资源分配情况为：</p>
<table>
<thead>
<tr>
<th>进程\资源情况</th>
<th>Max（总共需要资源）</th>
<th>Allocation（已匹配）</th>
<th>Need（ 还需要）</th>
<th>Available（现在可用）</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&emsp;A&emsp;&emsp;B&emsp;&emsp;C</td>
<td>&emsp;A&emsp;&emsp;B&emsp;&emsp;C</td>
<td>&emsp;A&emsp;&emsp;B&emsp;&emsp;C</td>
<td>&emsp;A&emsp;&emsp;B&emsp;&emsp;C</td>
</tr>
<tr>
<td>P0</td>
<td>&emsp;7&emsp;&emsp;5&emsp;&emsp;3</td>
<td>&emsp;0&emsp;&emsp;1&emsp;&emsp;0</td>
<td>&emsp;7&emsp;&emsp;4&emsp;&emsp;3</td>
<td>&emsp;3&emsp;&emsp;3&emsp;&emsp;2</td>
</tr>
<tr>
<td>P1</td>
<td>&emsp;3&emsp;&emsp;2&emsp;&emsp;2</td>
<td>&emsp;2&emsp;&emsp;0&emsp;&emsp;0</td>
<td>&emsp;1&emsp;&emsp;2&emsp;&emsp;2</td>
<td></td>
</tr>
<tr>
<td>P2</td>
<td>&emsp;9&emsp;&emsp;0&emsp;&emsp;2</td>
<td>&emsp;3&emsp;&emsp;0&emsp;&emsp;2</td>
<td>&emsp;6&emsp;&emsp;0&emsp;&emsp;0</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td>&emsp;2&emsp;&emsp;2&emsp;&emsp;2</td>
<td>&emsp;2&emsp;&emsp;1&emsp;&emsp;1</td>
<td>&emsp;0&emsp;&emsp;1&emsp;&emsp;1</td>
<td></td>
</tr>
<tr>
<td>P4</td>
<td>&emsp;4&emsp;&emsp;3&emsp;&emsp;3</td>
<td>&emsp;0&emsp;&emsp;0&emsp;&emsp;2</td>
<td>&emsp;4&emsp;&emsp;3&emsp;&emsp;1</td>
<td></td>
</tr>
</tbody></table>
<p>&emsp;&emsp;②<strong>安全性算法：</strong>（确定安全序列）</p>
<p>&emsp;&emsp;（起始）Work&#x3D;Available</p>
<p>&emsp;&emsp;（后续）Work&#x3D;Work+Allocation</p>
<p>&emsp;&emsp;<strong>（安全性判定）Need≤Work（这是一个全程操作，每进行一次请求(Request)都要进行安全检查）</strong></p>
<p>&emsp;借助于该安全性算法，可以<strong>确定安全序列</strong>，如下：</p>
<p>&emsp;推断<strong>T0</strong>时刻的安全序列：</p>
<p>&emsp;此时Available&#x3D;3 3 2，<strong>Work1</strong>&#x3D;3 3 2</p>
<p>&emsp;P1的Need&#x3D;1 2 2&lt;<strong>Work1</strong>&#x3D;3 3 2安全，释放P1的Allocation资源，</p>
<p>&emsp;&emsp;&emsp;<font color="red"><strong>Work2</strong>&#x3D;Work1+P1的Allocation&#x3D;3 3 2+2 0 0&#x3D;5 3 2</font></p>
<p>&emsp;P2的Need&#x3D;6 0 0&gt;<strong>Work2</strong>&#x3D;5 3 2不安全，舍去；</p>
<p>&emsp;P3的Need&#x3D;0 1 1&lt;<strong>Work2</strong>&#x3D;5 3 2安全，释放P3的Allocation资源，<br>&emsp;&emsp;&emsp;<font color="red"><strong>Work3</strong>&#x3D;Work2+P3的Allocation&#x3D;5 3 2+2 1 1&#x3D;7 4 3</font></p>
<p>&emsp;P4的Need&#x3D;4 3 1&lt;<strong>Work3</strong>&#x3D;7 4 3安全，释放P4的Allocation资源，</p>
<p>&emsp;&emsp;&emsp;<font color="red"><strong>Work4</strong>&#x3D;Work3+P4的Allocation&#x3D;7 4 3+0 0 2&#x3D;7 4 5</font></p>
<p>&emsp;P2的Need&#x3D;6 0 0&lt;<strong>Work4</strong>&#x3D;7 4 5安全，释放P2的Allocation资源，</p>
<p>&emsp;&emsp;&emsp;<font color="red"><strong>Work5</strong>&#x3D;Work4+P2的Allocation&#x3D;7 4 5+3 0 2&#x3D;10 4 7</font></p>
<p>&emsp;P0的Need&#x3D;7 4 3&lt;<strong>Work5</strong>&#x3D;10 4 7安全，释放P0的Allocation资源，</p>
<p>&emsp;&emsp;&emsp;<font color="red"><strong>Work6</strong>&#x3D;Work5+P0的Allocation&#x3D;10 4 7+0 1 0&#x3D;10 5 7</font></p>
<p>&emsp;&emsp;&emsp;到此资源全部释放。</p>
<p>&emsp;得到安全序列为：{P1,P3,P4,P2,P0}。</p>
<p>&emsp;如果不存在安全序列，则该系统不安全。</p>
<table>
<thead>
<tr>
<th>进程\资源情况</th>
<th>Work（工作向量）</th>
<th>Need（ 还需要）</th>
<th>Allocation（已匹配）</th>
<th>Work+Allocation</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td><font color="red">3     3     2</font></td>
<td>1     2     2</td>
<td>2     0     0</td>
<td><font color="blue">5     3     2</font></td>
</tr>
<tr>
<td>P3</td>
<td><font color="blue">5     3     2</font></td>
<td>0     1     1</td>
<td>2     1     1</td>
<td><font color="green">7     4     3</font></td>
</tr>
<tr>
<td>P4</td>
<td><font color="green">7     4     3</font></td>
<td>4     3     1</td>
<td>0     0     2</td>
<td><font color="orange">7     4     5</font></td>
</tr>
<tr>
<td>P2</td>
<td><font color="orange">7     4     5</font></td>
<td>6     0     0</td>
<td>3     0     2</td>
<td><font color="purple">10     4     7</font></td>
</tr>
<tr>
<td>P0</td>
<td><font color="purple">10     4     7</font></td>
<td>7     4     3</td>
<td>0     1     0</td>
<td><font color="red">10     5     7</font></td>
</tr>
</tbody></table>
<p>&emsp;&emsp;③银行家算法续：</p>
<p>&emsp;&emsp;对Pi发出Request请求后，启用Request去比较对Pi得分Need[i]和Available[i]，</p>
<p>&emsp;&emsp;&emsp;&emsp;如果Request&lt;Need[i]，则继续比较Request&lt;Available[i]；否则报错。</p>
<p>&emsp;&emsp;&emsp;&emsp;当Request&lt;Available[i]时，Available[i]&#x3D;Available[i]-Request；</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Allocation[i]&#x3D;Allocation[i]+Request；</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Need[i]&#x3D;Need[i]-Request；</p>
<p>&emsp;&emsp;再次确认安全序列；</p>
<p>&emsp;&emsp;进行下一轮Request。</p>
<p>&emsp;&emsp;例1：当前安全序列为{P1,P3,P4,P2,P0}：P1发出请求Request(1，0，2)，采用银行家算法进行检查：</p>
<p>&emsp;&emsp;&emsp;&emsp;Request(1，0，2)&lt;Need[1]&#x3D;1，2，2</p>
<p>&emsp;&emsp;&emsp;&emsp;Request(1，0，2)&lt;Available(3，3，2)</p>
<p>&emsp;&emsp;&emsp;&emsp;<strong>Available[1]</strong>&#x3D;Available[1]-Request(1，0，2)&#x3D;3 3 2 - 1 0 2 &#x3D; <font color="red"><strong>2，3，0</strong>；</font></p>
<p>&emsp;&emsp;&emsp;&emsp;Allocation[1]&#x3D;Allocation[1]+Request(1，0，2)&#x3D;2 0 0 + 1 0 2 &#x3D; 3，0，2；</p>
<p>&emsp;&emsp;&emsp;&emsp;Need[1]&#x3D;Need[1]-Request(1，0，2)&#x3D;1 2 2 - 1 0 2 &#x3D; 0，2，0；</p>
<table>
<thead>
<tr>
<th>进程\资源情况</th>
<th>Work（Work1&#x3D;Available）</th>
<th>Need（ 还需要）</th>
<th>Allocation（已匹配）</th>
<th>Work+Allocation</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td><strong><font color="red">2 3 0</font></strong></td>
<td>0     2     0</td>
<td>3     0     2</td>
<td><font color="blue">5     3     2</font></td>
</tr>
</tbody></table>
<p>根据目前的安全序列{P1,P3,P4,P2,P0}进行安全检查：</p>
<p>⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️</p>
<table>
<thead>
<tr>
<th>进程\资源情况</th>
<th>Work（Work1&#x3D;Available）</th>
<th>Need（ 还需要）初始</th>
<th>Allocation（已匹配）初始</th>
<th>Work+Allocation</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td><strong><font color="red">2 3 0</font></strong></td>
<td>0     2     0</td>
<td>3     0     2</td>
<td><font color="blue">5     3     2</font></td>
</tr>
<tr>
<td>P3</td>
<td><font color="blue">5     3     2</font></td>
<td>0     1     1</td>
<td>2     1     1</td>
<td><font color="green">7     4     3</font></td>
</tr>
<tr>
<td>P4</td>
<td><font color="green">7     4     3</font></td>
<td>4     3     1</td>
<td>0     0     2</td>
<td><font color="orange">7     4     5</font></td>
</tr>
<tr>
<td>P2</td>
<td><font color="orange">7     4     5</font></td>
<td>6     0     0</td>
<td>3     0     2</td>
<td><font color="purple">10 4 7</font></td>
</tr>
<tr>
<td>P0</td>
<td><font color="purple">10 4 7</font></td>
<td>7     4     3</td>
<td>0     1     0</td>
<td><font color="red">10     5     7</font></td>
</tr>
</tbody></table>
<p>得到安全序列1{P1,P3,P4,P2,P0}，或者：</p>
<table>
<thead>
<tr>
<th>进程\资源情况</th>
<th>Work（Work1&#x3D;Available）</th>
<th>Need（ 还需要）初始</th>
<th>Allocation（已匹配）初始</th>
<th>Work+Allocation</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td><font color="red">2 3 0</font></td>
<td>0     2     0</td>
<td>3     0     2</td>
<td><font color="blue">5     3     2</font></td>
</tr>
<tr>
<td>P3</td>
<td><font color="blue">5     3     2</font></td>
<td>0     1     1</td>
<td>2     1     1</td>
<td><font color="green">7     4     3</font></td>
</tr>
<tr>
<td>P4</td>
<td><font color="green">7     4     3</font></td>
<td>4     3     1</td>
<td>0     0     2</td>
<td><font color="orange">7     4     5</font></td>
</tr>
<tr>
<td>P0</td>
<td><font color="orange">7     4     5</font></td>
<td>7     4     3</td>
<td>0     1     0</td>
<td><font color="purple">7 5 5</font></td>
</tr>
<tr>
<td>P2</td>
<td><font color="purple">7 5 5</font></td>
<td>6     0     0</td>
<td>3     0     2</td>
<td><font color="red">10     5     7</font></td>
</tr>
</tbody></table>
<p>得到安全序列2{P1,P3,P4,P0,P2}。</p>
<p>&emsp;&emsp;例2：继P1发出Request(1，0，2)请求后，P0发出请求Request(0，2，0)，采用银行家算法进行检查：</p>
<p>&emsp;&emsp;&emsp;&emsp;Request(0，2，0)&lt;Need[0]&#x3D;7，4，3</p>
<p>&emsp;&emsp;&emsp;&emsp;Request(0，2，0)&lt;Available(<strong>2，3，0</strong>)</p>
<p>&emsp;&emsp;&emsp;&emsp;Available[0]&#x3D;Available[0]-Request(0，2，0)&#x3D;2 3 0 - 0 2 0 &#x3D; <font color="red"><strong>2，1，0；</strong></font></p>
<p>&emsp;&emsp;&emsp;&emsp;Allocation[0]&#x3D;Allocation[0]+Request(0，2，0)&#x3D;0 1 0 + 0 2 0&#x3D; 0，3，0；</p>
<p>&emsp;&emsp;&emsp;&emsp;Need[0]&#x3D;Need[0]-Request(0，2，0)&#x3D;7 4 3 - 0 2 0 &#x3D; 7，2，3；</p>
<table>
<thead>
<tr>
<th>进程\资源情况</th>
<th>Work（Work1&#x3D;Available）</th>
<th>Need（ 还需要）</th>
<th>Allocation（已匹配）</th>
<th>Work+Allocation</th>
</tr>
</thead>
<tbody><tr>
<td>P0</td>
<td><strong><font color="red">2 1 0</font></strong></td>
<td>7     2     3</td>
<td>0     3     0</td>
<td><font color="blue">2 4 0</font></td>
</tr>
<tr>
<td>P1</td>
<td></td>
<td>1 2 2-&gt;0 2 0<br>这里是因为例1的P1请求(Request)引得变化</td>
<td>2 0 0-&gt;3 0 2<br/>这里是因为例1的P1请求(Request)引得变化</td>
<td></td>
</tr>
<tr>
<td>P2</td>
<td></td>
<td>6     0     0</td>
<td>3     0     2</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td></td>
<td>0     1     1</td>
<td>2     1     1</td>
<td></td>
</tr>
<tr>
<td>P4</td>
<td></td>
<td>4     3     1</td>
<td>0     0     2</td>
<td></td>
</tr>
</tbody></table>
<p>此时的Work1+available&#x3D;210已经不能满足剩下的进程Need，所以此时系统进入不安全状态，此时系统不分配资源。</p>
<p>&emsp;&emsp;例3：当P0发出请求Request(0，1，0)，采用银行家算法进行检查：</p>
<p>&emsp;&emsp;&emsp;&emsp;Request(0，1，0)&lt;Need[0]&#x3D;7，4，3</p>
<p>&emsp;&emsp;&emsp;&emsp;Request(0，1，0)&lt;Available(<strong>2，3，0</strong>)</p>
<p>&emsp;&emsp;&emsp;&emsp;Available[0]&#x3D;Available[0]-Request(0，1，0)&#x3D;2 3 0 - 0 1 0 &#x3D;<font color="red"> <strong>2，2，0</strong>；</font></p>
<p>&emsp;&emsp;&emsp;&emsp;Allocation[0]&#x3D;Allocation[0]+Request(0，1，0)&#x3D;0 1 0 + 0 1 0&#x3D; 0，2，0；</p>
<p>&emsp;&emsp;&emsp;&emsp;Need[0]&#x3D;Need[0]-Request(0，1，0)&#x3D;7 4 3 - 0 1 0 &#x3D; 7，3，3；</p>
<table>
<thead>
<tr>
<th>进程\资源情况</th>
<th>Work（Work1&#x3D;Available）</th>
<th>Need（ 还需要）</th>
<th>Allocation（已匹配）</th>
<th>Work+Allocation</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td><strong><font color="red">2 2 0</font></strong></td>
<td>1 2 2-&gt;<strong>0 2 0</strong><br/>这里是因为例1的P1请求(Request)引得变化</td>
<td>2 0 0-&gt;3 0 2<br/>这里是因为例1的P1请求(Request)引得变化</td>
<td><font color="blue">5 2 2</font></td>
</tr>
<tr>
<td>P3</td>
<td><font color="blue">5 2 2</font></td>
<td>0     1     1</td>
<td>2     1     1</td>
<td><font color="green">7 3 3</font></td>
</tr>
<tr>
<td>P2</td>
<td><font color="green">7 3 3</font></td>
<td>6     0     0</td>
<td>3     0     2</td>
<td><font color="orange">10 3 5</font></td>
</tr>
<tr>
<td>P0</td>
<td><font color="orange">10 3 5</font></td>
<td>7     3     3</td>
<td>0     2     0</td>
<td><font color="purple">10 5 5</font></td>
</tr>
<tr>
<td>P4</td>
<td><font color="purple">10 5 5</font></td>
<td>4     3     1</td>
<td>0     0     2</td>
<td>10 5 7</td>
</tr>
</tbody></table>
<p>得到安全序列：{P1,P3,P2,P0,P4}</p>
<p>（5）死锁检测：</p>
<p>&emsp;&emsp;死锁定理：进程处于死锁状态的充分条件是当且仅当该进程的资源分布图是不可简化的。</p>
<p>&emsp;&emsp;资源分布图的简化：P1释放资源后，便可使P2获得资源而继续运行，在进行一些的简化后，若能消除途中所有的边，使所有的的进程节点都成为孤立结点，则称该图是可完全简化的。</p>
<p>（6）死锁解除：</p>
<p>&emsp;&emsp;抢占资源、终止或撤销进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;emsp;空格七、存储器管理</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="七、存储器管理"><a href="#七、存储器管理" class="headerlink" title="七、存储器管理"></a>七、存储器管理</h3><ol>
<li><p>程序的接入：</p>
<table>
<thead>
<tr>
<th>内存接入情况</th>
<th>适用于</th>
</tr>
</thead>
<tbody><tr>
<td>绝对接入方式</td>
<td>单道程序环境</td>
</tr>
<tr>
<td>可重定位装入方式</td>
<td>单道程序环境</td>
</tr>
<tr>
<td>动态运行时的装入方式</td>
<td>多道程序环境</td>
</tr>
</tbody></table>
</li>
<li><p>程序的链接：</p>
<p>静态链接方式、装入时动态链接、运行时动态链接。</p>
</li>
<li><p>连续分配存储器管理方式：</p>
<p>（1）单一连续分配：程序独占空间。</p>
<p>（2）固定分区分配：每个分区装入一道作业。</p>
<p>&emsp;&emsp;&emsp;划分分区方法：①分区大小相等；②分区大小不等。</p>
<p>&emsp;&emsp;&emsp;内存分配：分区表（分区的起始地址、大小、状态）</p>
<p>&emsp;&emsp;&emsp;&emsp;外碎片：在分区外未使用。内碎片：在分区内未使用。</p>
<p>（3）动态分区分配：</p>
<p>&emsp;&emsp;&emsp;①基于顺序搜索的动态分区分配算法：</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;首次适应算法First fit(FF)、循环首次适应算法Next fit(NF)、最佳适应算法Best fit(BF)、</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;最坏适应算法Worst fit(WF)</p>
<p>&emsp;&emsp;&emsp;②基于索引搜索的动态分区分配算法：</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;快速适应算法Quick fit、伙伴系统Buddy system、哈希算法</p>
<p>（4）动态可重定位分区分配：紧凑、动态重定位</p>
</li>
<li><p>对换：将内存中暂时无法运行或不用的程序和数据换出到外存上，以便腾出足够的内存空间，再把需要运行的换入内存。</p>
<p>类型：整体对换、页面（分段）对换</p>
</li>
<li><p>分页存储管理方式：</p>
<p>页块、物理块、地址结构（页号|位偏移）、页表、多级页表、反置页表</p>
</li>
<li><p>分段存储管理方式：</p>
<p>地址结构（段号|段内地址）、段表、信息共享、越界</p>
<p>分页与分段区别：页是信息的物理单位、页的大小固定且由系统决定、分页的用户程序地址空间是一位的</p>
</li>
<li><p>段页式存储管理方式：</p>
<p>用户程序——&gt;若干段——&gt;若干页；</p>
<p>地址变换过程：</p>
<p>&emsp;&emsp;访问数据需要3次内存调用：第1次：内存段表，第2次：内存页表，第3次：数据</p>
<p>&emsp;&emsp;高速缓冲寄存器的设定便是为了提升该3次内存调用速度</p>
</li>
</ol>
<h3 id="八、虚拟存储器"><a href="#八、虚拟存储器" class="headerlink" title="八、虚拟存储器"></a>八、虚拟存储器</h3><ol>
<li><p>实现方式：请求分页系统、请求分段系统</p>
</li>
<li><p>请求分页系统：缺页中断</p>
</li>
<li><p>页面置换算法：</p>
<p>①最佳置换算法Optimal</p>
<p>②先进先出页面置换算法FIFO</p>
<p>③最近最久未使用置换算法LRU</p>
<p>④最少使用置换算法LFU</p>
<p>⑤Clock置换算法</p>
<p>⑥页面缓冲算法PBA（Page Buffering Algorithm）</p>
<p>缺页次数&#x3D;缺页中断：即当所要访问的页面不在内存中时，便产生缺页中断。</p>
<p>缺页率&#x3D;缺页次数&#x2F;总页数（总访问次数）</p>
<p>例：LRU</p>
<table>
<thead>
<tr>
<th></th>
<th>7</th>
<th></th>
<th>0</th>
<th></th>
<th>1</th>
<th></th>
<th>2</th>
<th></th>
<th>0</th>
<th>3</th>
<th></th>
<th>0</th>
<th>4</th>
<th></th>
<th>2</th>
<th></th>
<th>3</th>
<th></th>
<th>0</th>
<th></th>
<th>3</th>
<th>2</th>
<th>1</th>
<th></th>
<th>2</th>
<th>0</th>
<th></th>
<th>1</th>
<th>7</th>
<th></th>
<th>0</th>
<th>1</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>7</td>
<td></td>
<td>7</td>
<td></td>
<td>7</td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td>4</td>
<td></td>
<td>4</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td>0</td>
<td></td>
<td>3</td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td></td>
<td>3</td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>7</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺页中断：</td>
<td></td>
<td>1次</td>
<td></td>
<td>2</td>
<td></td>
<td>3</td>
<td></td>
<td>4</td>
<td></td>
<td></td>
<td>5</td>
<td></td>
<td></td>
<td>6</td>
<td></td>
<td>7</td>
<td></td>
<td>8</td>
<td></td>
<td>9</td>
<td></td>
<td></td>
<td></td>
<td>10</td>
<td></td>
<td></td>
<td>11</td>
<td></td>
<td></td>
<td>12</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>缺页率为：12&#x2F;20&#x3D;60%</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/blog2025.github.io/2025/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ol>
<li><h4 id="TCP-IP五层协议"><a href="#TCP-IP五层协议" class="headerlink" title="TCP&#x2F;IP五层协议"></a>TCP&#x2F;IP五层协议</h4><table>
<thead>
<tr>
<th>层</th>
<th>内容</th>
<th>作用</th>
<th>协议</th>
<th>设备</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>报文：消息、数据传输的基本单位</td>
<td>提供网络服务的接口</td>
<td>文件传输FTP、域名服务DNS、超文本传输HTTP、SMTP邮件传输</td>
<td>网关</td>
</tr>
<tr>
<td>传输层</td>
<td>数据段：信息传递的协议数据单元</td>
<td>将上层数据分段并提供端到端的传输、差错控制和流量控制。</td>
<td>TCP面向连接、UDP</td>
<td>进程、端口</td>
</tr>
<tr>
<td>网络层</td>
<td>数据包&#x2F;分组</td>
<td>将网络地址翻译为物理地址，将数据从发送方路由到接收方。子网间的数据报进行路由选择，拥塞控制、网际互通。</td>
<td>IP、ARP地址解析、RARP反向地址转换、ICMP控制报文、IGMP组播</td>
<td>路由器、防火墙</td>
</tr>
<tr>
<td>数据链路层</td>
<td>帧（该层的传输单位）&#x3D;首+数据报+尾<br />星型拓扑</td>
<td>物理地址寻址、数据的成帧、流量控制、数据检错、重发等。</td>
<td>以太网协议、PPP点对点、CSMA&#x2F;CD载波监听和碰撞检测、ARQ纠错</td>
<td>网桥、网卡、交换机</td>
</tr>
<tr>
<td>物理层</td>
<td>比特流</td>
<td>物理媒体</td>
<td></td>
<td>中继器（放大信号）、集线器、网线、调制解调器</td>
</tr>
</tbody></table>
</li>
</ol>
<p>&emsp;&emsp;参考: <a href="https://bbs.huaweicloud.com/blogs/378087">链接</a></p>
<span id="more"></span>

<ol start="2">
<li><h4 id="IP地址："><a href="#IP地址：" class="headerlink" title="IP地址："></a>IP地址：</h4><h5 id="（1）传统"><a href="#（1）传统" class="headerlink" title="（1）传统"></a>（1）传统</h5><table>
<thead>
<tr>
<th>传统IP(32位)</th>
<th>Net-id</th>
<th>Host-id</th>
</tr>
</thead>
<tbody><tr>
<td>IP地址</td>
<td>网络号</td>
<td>主机号</td>
</tr>
<tr>
<td>A类</td>
<td>0.（8位）</td>
<td>0.0.0（24位）</td>
</tr>
<tr>
<td>B类</td>
<td>0.0（16位）</td>
<td>0.0（16位）</td>
</tr>
<tr>
<td>C类</td>
<td>0.0.0（24位）</td>
<td>0（8位）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>分类</th>
<th></th>
<th>补充</th>
<th>默认子网掩码</th>
</tr>
</thead>
<tbody><tr>
<td>A类</td>
<td>0.0.0.0~127.255.255.255</td>
<td>0.0.0.0(寻找自己的IP)和127.0.0.1(回环地址即本机地址，用于对本机的测试)一般不作为A类地址</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B类</td>
<td>128.0.0.0~191.255.255.255</td>
<td></td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C类</td>
<td>192.0.0.0~223.255.255.255</td>
<td></td>
<td>255.255.255.0</td>
</tr>
<tr>
<td>D类</td>
<td>224.0.0.0~239.255.255.255</td>
<td>多播&#x2F;组播地址：（一对多）供特殊协议使用</td>
<td></td>
</tr>
<tr>
<td>E类</td>
<td>240.0.0.0~255.255.255.255</td>
<td>保留地址：供以后使用</td>
<td></td>
</tr>
</tbody></table>
<h5 id="（2）-VLSM-CIDR下"><a href="#（2）-VLSM-CIDR下" class="headerlink" title="（2）(VLSM&#x2F;CIDR下)"></a>（2）(VLSM&#x2F;CIDR下)</h5><table>
<thead>
<tr>
<th>新IP(32位)(VLSM(借主机号作为网络号)&#x2F;CIDR下)</th>
<th>Net-id</th>
<th>Subnet-id</th>
<th>Host-id</th>
</tr>
</thead>
<tbody><tr>
<td>IP地址</td>
<td>网络号</td>
<td>子网号</td>
<td>主机号</td>
</tr>
<tr>
<td></td>
<td>新网络号</td>
<td>新网络号</td>
<td>主机号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>IP地址（常用）</td>
<td>网络部分</td>
<td>主机部分</td>
</tr>
<tr>
<td>广播地址</td>
<td>主机部分</td>
<td>网络部分</td>
</tr>
</tbody></table>
<p>例：（VLSM&#x2F;CIDR下）172.31.128.255&#x2F;18</p>
<p>18为子网掩码，表示32位中高18位是1，其他位为0</p>
<p>IP地址：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;10101100.00011111.10<strong>000000.11111111</strong>  </p>
<p>子网掩码二进制形式：11111111.11111111.11<strong>000000.00000000</strong></p>
<p>子网掩码十进制形式：&emsp;&emsp;255.&emsp;&emsp;255.&emsp;&emsp;&emsp;192.&emsp;&emsp;&emsp;0</p>
<p>网络号：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;10101100.00011111.10<strong>000000.00000000</strong></p>
<p>子网掩码反码：&emsp;&emsp;&emsp;00000000.00000000.00111111.11111111</p>
<p>主机号：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;00000000.00000000.00000000.11111111</p>
<p>‘与(&amp;)’运算：1&amp;1&#x3D;1，1&amp;0&#x3D;0，0&amp;1&#x3D;0，0&amp;0&#x3D;0；</p>
<p>IP地址与子网掩码‘与(&amp;)’运算得网络号；</p>
<p>IP地址与子网掩码反码‘与(&amp;)’运算得主机号；</p>
<p>广播地址：&emsp;&emsp;&emsp;&emsp;&emsp;10101100.00011111.10<strong>111111.11111111</strong></p>
<p>广播地址就是在网络号的基础上，将网络号右边表示IP地址的主机部分(字体加粗)的二进制全部改为1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;emsp;空格</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="子网划分场景下-VLSM-CIDR下-：网络地址（包括网络号与子网号两部分）是IP地址与子网掩码的‘与’运算结果。"><a href="#子网划分场景下-VLSM-CIDR下-：网络地址（包括网络号与子网号两部分）是IP地址与子网掩码的‘与’运算结果。" class="headerlink" title="子网划分场景下(VLSM&#x2F;CIDR下)：网络地址（包括网络号与子网号两部分）是IP地址与子网掩码的‘与’运算结果。"></a>子网划分场景下(VLSM&#x2F;CIDR下)：网络地址（包括网络号与子网号两部分）是IP地址与子网掩码的‘与’运算结果。</h4><p>（1）当子网掩码不默认时，网络地址≠网络号</p>
<p>&emsp;&emsp;如：172.16.10.2（B类）</p>
<p>&emsp;&emsp;&emsp;此时子网掩码为：255.255.255.0，进行‘与’运算</p>
<p>&emsp;&emsp;&emsp;此时网络地址为：172.16.10.0</p>
<p>&emsp;&emsp;&emsp;而默认子网掩码为：255.255.0.0，得到网络号为：172.16.0.0 </p>
<p>&emsp;&emsp;&emsp;网络地址≠网络号</p>
<p>（2）子网掩码默认时，网络地址＝网络号</p>
<p>&emsp;&emsp;如：172.16.10.2</p>
<p>&emsp;&emsp;&emsp;默认子网掩码为255.255.0.0，进行‘与’运算</p>
<p>&emsp;&emsp;&emsp;此时网络地址为：172.16.0.0</p>
<p>&emsp;&emsp;&emsp;网络地址&#x3D;网络号</p>
<p>（3）在无子网划分场景下，网络地址&#x3D;网络号；（传统子网号）</p>
<p>&emsp;&emsp;&emsp;&emsp;网络地址&#x3D;IP地址&amp;子网掩码</p>
<p>&emsp;&emsp;&emsp;&emsp;网络地址&#x3D;网络号</p>
<p>&emsp;&emsp;在子网划分场景下，网络地址是网络号的扩展；（VLSM&#x2F;CIDR下）</p>
<p>&emsp;&emsp;&emsp;&emsp;网络地址&#x3D;IP地址&amp;子网掩码</p>
<p>&emsp;&emsp;&emsp;&emsp;网络地址≠网络号</p>
</li>
<li><h4 id="划分子网：（VLSM-CIDR下）"><a href="#划分子网：（VLSM-CIDR下）" class="headerlink" title="划分子网：（VLSM&#x2F;CIDR下）"></a>划分子网：（VLSM&#x2F;CIDR下）</h4><p>（1）根据主机号中子网掩码借默认的子网掩码的位数n&#x3D;&gt;<strong>2^n为子网数</strong></p>
<p>&emsp;例：C类IP192.168.1.113</p>
<p>&emsp;&emsp;&emsp;默认子网掩码：255.255.255.0</p>
<p>&emsp;&emsp;&emsp;二进制形式：11111111.11111111.11111111.<strong>00</strong>000000</p>
<p>&emsp;&emsp;&emsp;现有子网掩码：255.255.255.192</p>
<p>&emsp;&emsp;&emsp;二进制形式：11111111.11111111.11111111.<strong>11</strong>000000</p>
<p>&emsp;&emsp;&emsp;网络号借了主机号<strong>两位</strong>，即<strong>子网号为11</strong>，则原IP可以被划分为2^2&#x3D;4个子网；</p>
<p>&emsp;&emsp;&emsp;&emsp;4个子网为：—.—.—.00000000&emsp;即255.255.255.0</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;—.—.—.01000000&emsp;即255.255.255.64</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;—.—.—.10000000&emsp;即255.255.255.128</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;—.—.—.11000000&emsp;即255.255.255.192</p>
<p>&emsp;&emsp;&emsp;&emsp;得网络地址为：192.168.1.0</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.64</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.128</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.192</p>
<p>&emsp;&emsp;&emsp;&emsp;广播地址为：—.—.—.11111111&emsp;即255.255.255.255</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;—.—.—.10111111&emsp;即255.255.255.191</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;—.—.—.01111111&emsp;即255.255.255.127</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;—.—.—.00111111&emsp;即255.255.255.63</p>
<p>&emsp;&emsp;&emsp;&emsp;得广播地址为：192.168.1.255</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.191</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.127</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.63</p>
<p>&emsp;&emsp;&emsp;&emsp;去除网络地址和广播地址即可用主机IP地址：</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.1  ——&gt; 192.168.1.62</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.65——-&gt; 192.168.1.126  </p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.129——&gt; 192.168.1.190</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;192.168.1.193——&gt; 192.168.1.254</p>
<p>&emsp;&emsp;划分子网过程：</p>
<p>&emsp;&emsp;&emsp;①根据IP分类和默认掩码得到子网号和划分子网个数；</p>
<p>&emsp;&emsp;&emsp;②根据划分区域推出子网，在转十进制；</p>
<p>&emsp;&emsp;&emsp;③组合原IP和子网。</p>
<p>&emsp;&emsp;参考: <a href="https://blog.csdn.net/qq_41207757/article/details/107839099">链接</a></p>
<p>（2）根据IP地址和子网掩码计算主机数：</p>
<p>&emsp;例：子网掩码为：255.255.255.0</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;11111111.11111111.11111111.<strong>00000000</strong></p>
<p>&emsp;&emsp;则有2^8-2&#x3D;254台主机（去除0.0.0.0和127.0.0.1）</p>
<p>&emsp;再例：255.255.240.0</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;11111111.11111111.1111<strong>0000.00000000</strong></p>
<p>&emsp;&emsp;则有2^12-2&#x3D;4094台</p>
</li>
<li><h4 id="TCP协议："><a href="#TCP协议：" class="headerlink" title="TCP协议："></a>TCP协议：</h4><h5 id="（1）三次握手，四次挥手"><a href="#（1）三次握手，四次挥手" class="headerlink" title="（1）三次握手，四次挥手"></a>（1）三次握手，四次挥手</h5><p><img src="/blog2025.github.io/2025/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<p><img src="/blog2025.github.io/2025/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p>
<p>&emsp;参考: <a href="https://blog.csdn.net/m0_56649557/article/details/119492899">链接</a></p>
<h5 id="（2）TCP协议与UDP协议区别："><a href="#（2）TCP协议与UDP协议区别：" class="headerlink" title="（2）TCP协议与UDP协议区别："></a>（2）TCP协议与UDP协议区别：</h5><table>
<thead>
<tr>
<th></th>
<th>连接性</th>
<th>可靠性</th>
<th>流量控制</th>
<th>开销</th>
<th>拥塞控制</th>
<th>数据传输顺序</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>面向连接</td>
<td>可靠</td>
<td>高延迟流</td>
<td>高</td>
<td>拥塞控制</td>
<td>保证数据包顺序到达</td>
<td>文件传输、电子邮件、远程登录</td>
</tr>
<tr>
<td>UDP</td>
<td>无连接性</td>
<td>不可靠</td>
<td>低延迟</td>
<td>低</td>
<td>数据报分组</td>
<td>不保证数据包顺序到达</td>
<td>视频流、在线游戏</td>
</tr>
</tbody></table>
<p>参考: <a href="https://developer.aliyun.com/article/1632460">链接</a></p>
</li>
<li><h4 id="RIP协议："><a href="#RIP协议：" class="headerlink" title="RIP协议："></a>RIP协议：</h4><p>A的路由器表：</p>
<table>
<thead>
<tr>
<th>目的</th>
<th>距离</th>
<th>下一跳</th>
</tr>
</thead>
<tbody><tr>
<td>N1</td>
<td>4</td>
<td>B</td>
</tr>
<tr>
<td>N2</td>
<td>2</td>
<td>C</td>
</tr>
<tr>
<td>N3</td>
<td>1</td>
<td>F</td>
</tr>
<tr>
<td>N4</td>
<td>5</td>
<td>G</td>
</tr>
</tbody></table>
<p>现A收到来自C的路由信息：</p>
<table>
<thead>
<tr>
<th>目的</th>
<th>距离</th>
</tr>
</thead>
<tbody><tr>
<td>N1</td>
<td>2</td>
</tr>
<tr>
<td>N2</td>
<td>1</td>
</tr>
<tr>
<td>N3</td>
<td>3</td>
</tr>
<tr>
<td>N4</td>
<td>7</td>
</tr>
<tr>
<td>N5</td>
<td>10</td>
</tr>
</tbody></table>
<p>更新A的路由器表：</p>
<table>
<thead>
<tr>
<th>目的</th>
<th>距离</th>
<th>下一条</th>
<th>理由</th>
</tr>
</thead>
<tbody><tr>
<td>N1</td>
<td>2+1&#x3D;3</td>
<td>C</td>
<td>不同的下一条，收到的表距离更短，更新</td>
</tr>
<tr>
<td>N2</td>
<td>1+1&#x3D;2</td>
<td>C</td>
<td>相同的下一条，更新</td>
</tr>
<tr>
<td>N3</td>
<td>1</td>
<td>F</td>
<td>不同的下一条，收到的表距离更长，不变</td>
</tr>
<tr>
<td>N4</td>
<td>5</td>
<td>G</td>
<td>不同的下一条，收到的表距离更长，不变</td>
</tr>
<tr>
<td>N5</td>
<td>10+1&#x3D;11</td>
<td>C</td>
<td>新的下一条，更新</td>
</tr>
</tbody></table>
</li>
</ol>
<p>&emsp;&emsp;参考: <a href="https://blog.csdn.net/qq_41904773/article/details/107103092">链接</a></p>
<h3 id="二、补充："><a href="#二、补充：" class="headerlink" title="二、补充："></a>二、补充：</h3><ol>
<li><p>计算机网络由若干结点和连接这些节点的链路组成。</p>
</li>
<li><p>1983年互联网诞生。</p>
</li>
<li><p>发展：单个网络ARPANET——&gt;三级结构互联网——&gt;多层次ISP结构互联网。</p>
</li>
<li><p>网络通信方式：C&#x2F;S和P2P。</p>
</li>
<li><p>网络核心部分其特殊作用的是路由器（实现分组交换）。</p>
</li>
<li><p>分组交换特点：</p>
<p>①采用存储转发技术</p>
<p>②报文-细分-&gt;数据段</p>
<p>③（包）分组&#x3D;数据段+首部（目的地址和源地址）</p>
<p>④优点：高效、灵活、迅速、可靠</p>
</li>
<li><p>电路交换：源——&gt;终</p>
<p>报文交换：起——&gt;相邻点——&gt;相邻点——&gt;……——&gt;终点</p>
<p>分组交换：类似于报文交换（分组比报文更小）</p>
</li>
<li><p>分类：</p>
<table>
<thead>
<tr>
<th>按作用</th>
<th>按使用者</th>
</tr>
</thead>
<tbody><tr>
<td>广域网WAN</td>
<td>公用网</td>
</tr>
<tr>
<td>城域网MAN</td>
<td>专用网</td>
</tr>
<tr>
<td>局域网LAN</td>
<td></td>
</tr>
<tr>
<td>个人局域网PAN</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>性能：</p>
<p>（1）速率：比特bit&#x2F;s</p>
<p>（2）带宽：赫</p>
<p>（3）吞吐量</p>
<p>（4）时延：发送时延、传播<del>、处理</del>、排队~</p>
<p>（5）时延带宽积</p>
<p>（6）往返时间RTT</p>
<p>（7）利用率</p>
</li>
<li><p>网络体系：</p>
<p>（1）OSI模型（7层）、TCP&#x2F;IP协议（4层）</p>
<p>（2）体系结构：计算机网络的各层及其协议的集合</p>
</li>
<li><p>物理层：</p>
<p>（1）信道</p>
<p>（2）媒介：双绞线——&gt;屏蔽双绞线STP、无屏蔽双绞线OTP</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;同轴电缆：有线电视</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;光缆、光纤</p>
<p>（3）信道复用技术：允许用户使用一个共享信道进行通信，降低成本，提高利用率；</p>
<p>（4）宽带接入技术：用户要连接到互联网，必须先连接到某个ISP。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;emsp;空格</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据链路层：</p>
<p>（1）点对点信道（CSMA&#x2F;CD）</p>
<p>&emsp;&emsp;&emsp;接受网络层IP数据报、添加首尾部、封装成帧、发送到另一结点或上交（有检错过程）</p>
<p>&emsp;&emsp;&emsp;封装成帧、透明传输、差错检测。</p>
<p>&emsp;&emsp;&emsp;可采用转义字符ESC解决丢失问题。</p>
<p>（2）广播信道（PPP）</p>
<p>&emsp;&emsp;&emsp; ①全双工、</p>
<p>&emsp;&emsp;&emsp; ②简单、封装成帧、透明性、多种网络层协议、多种类型链路、差错检测、检测连接状态、最大传递单元、网络层地址协商、数据压缩协商。</p>
<p>&emsp;&emsp;&emsp;③用户——&gt;PPP协议——&gt;ISP——&gt;互联网</p>
<p>&emsp;&emsp;&emsp;④用户拨号——&gt;ISP——&gt;LCP——&gt;NCP——&gt;得到IP地址</p>
<p>&emsp;&emsp;&emsp;封装IP数据报到串行链路，测试、建立、配置数据链路连接的LCP，网络控制协议NCP</p>
<p>（3）封装成帧（首尾）</p>
<p>（4）广播信道的数据链路层：</p>
<p>&emsp;&emsp;&emsp;星形网、环形网、总线网；</p>
<p>&emsp;&emsp;&emsp;采用集线器的星形拓扑：双绞线；</p>
<p>&emsp;&emsp;&emsp;以太网的MAC层：硬件地址又称为物理地址或MAC地址；</p>
<p>&emsp;&emsp;&emsp;MAC帧：单播帧、广播帧、多播帧。</p>
<p>（5）集线器：所有站点共享总带宽，属于冲突域，同一时间只能与一个站点传输数据，带宽按站点数平均分配；</p>
<p>&emsp;&emsp;&emsp;交换机：每个站口独立带宽，支持全双工通信，站点间并行传输数据，每个站点的带宽等于端口速率。</p>
<p><img src="/blog2025.github.io/2025/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9B%86%E7%BA%BF%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA.png"></p>
<p>例：有10个站连接到以太网上，试计算三种情况下每个站所能得到的带宽。</p>
<p>&emsp; ①10个站都连接到一个10Mb&#x2F;s以太网集线器：1Mb&#x2F;s</p>
<p>&emsp; ②10个站都连接到一个100Mb&#x2F;s以太网集线器：10Mb&#x2F;s</p>
<p>&emsp; ③10个站都连接到一个10Mb&#x2F;s以太网交换机：10Mb&#x2F;s</p>
</li>
<li><p>网络层：</p>
<p>（1）数据链路层看不到封装后的IP地址；</p>
<p>&emsp;&emsp;IP地址的源和目的始终不变（被封装了，变不了）<br>&emsp;&emsp;MAC帧中的则要变化（负责带IP一层一层跑）</p>
</li>
<li><p>应用层</p>
<p>mail.cctv.com</p>
<table>
<thead>
<tr>
<th>mail.</th>
<th>cctv.</th>
<th>com</th>
</tr>
</thead>
<tbody><tr>
<td>三级域名</td>
<td>二级域名</td>
<td>顶级域名</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>软件工程导论</title>
    <url>/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="一-软件危机"><a href="#一-软件危机" class="headerlink" title="一. 软件危机"></a>一. 软件危机</h3><ol>
<li>定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。<br>表现：<br>（1）开发成本和进度的估计不准确；（开发滞后）<br>（2）用户对开发的软件不满意；<br>（3）软件的质量靠不住；<br>（4）软件不可维护；（重复开发相同的软件）<br>（5）软件不可维护；（重复开发相同的软件）<br>（6）软件开发成本在计算机系统总成本中所占的比例逐年上升；<br>（7）软件开发生产率跟不上计算机应用的发展；（供不应求）<br>等等。</li>
<li>产生原因：<br>（1）软件本身的特点有关；（软件本身）<br>（2）软件开发与维护的方法不正确；（软件开发不匹配计算机发展）<br>（3）对用户要求没有完整准确的认识就匆忙着手编写程序；（开发人员）</li>
<li>消除方法：<br>（1）对计算机软件有一个正确的认识；（消除软件就是程序的错误）<br>软件定义：软件是程序，数据及相关文档的完整集合；<br>（2）软件开发不是某个体劳动的神秘技巧，而是一种团队配合的工程项目，必须吸收和借鉴人类长期以来积累的原理、概念、技术和方法，尤其是教训；<br>（3）推广实践中总结出来的经验、技术和方法，并研究新的；<br>（4）开发和使用更好的软件工具。 </li>
<li><font color="red">总结：技术措施（方法、工具），必要的组织管理措施。</font></li>
</ol>
<span id="more"></span>

<h3 id="二-软件工程"><a href="#二-软件工程" class="headerlink" title="二. 软件工程"></a>二. 软件工程</h3><ol>
<li><p>定义：指导计算机软件开发和维护的一门工程学科。</p>
</li>
<li><p>本质特征：<br>（1）关注于大型程序的构造；<br>（2）中心课题是控制复杂性；<br>（3）软件的效率非常重要；<br>（4）开发软件的效率非常重要；<br>（5）和谐地合作是开发软件的关键；<br>（6）软件必须有效地支持它的用户；<br>（7）一种文化背景的人替另一种文化背景的人创造产品；</p>
</li>
<li><p>基本原理：<br>（1）用分阶段的生命周期计划严格管理；<br>（2）坚持进行阶段评审；<br>（3）实行严格的产品控制；<br>（4）采用现代化程序设计技术；<br>（5）结果应清除审查；<br>（6）开发小组的人员少二精；<br>（7）承认不断改进软件工程实践的必要性；</p>
</li>
<li><p>软件工程方法学：<br>（1） 软件工程包含技术和管理两方面的内容：<br>（2） <font color="red">范型（方法学）</font>：在软件生命周期全过程中使用的一整套技术方法的集合；<br>&emsp;&emsp;包含三个要素： 方法、工具、过程；<br>&emsp;&emsp;常用——&gt;<font color="red">传统方法学和面向对象方法学</font><br>（3）传统方法学（<font color="red">生命周期方法学 &#x2F; 结构化范型</font>）（大部分采用瀑布模型）<br>&emsp;&emsp;面向行为或数据，两者权重不同；（行为和数据分离）<br>&emsp;&emsp;🟪-&gt;🟪-&gt;🟪-&gt;🟪（一个阶段一个阶段地顺序开发）</p>
<p>&emsp;&emsp;优点：软件生命周期划分为若干个阶段，每个阶段任务相对独立，而且简单，便于分工协作，降低开发困难程度。</p>
<p>&emsp;&emsp;缺点：软件规模较大时，或者软件需求随时间变化时，开发出的软件往往不成功，且维护困难。</p>
<p>（4）面向对象方法学：（规模庞大，需求模糊或不断变化）<br>&emsp;&emsp;数据和行为的权重一样大；<br>&emsp;&emsp;特点：<br>&emsp;&emsp;① 对象；（数据和行为的统一）object<br>&emsp;&emsp;② 对象——&gt;类；（数据和操作）class<br>&emsp;&emsp;③ 父类、子类、派生类；<br>&emsp;&emsp;④ 对象间仅能通过发送消息互相联系；<br>&emsp;&emsp;对象间的所有私有private信息都被封装在该对象内，不可从外界直接访问（<font color="red">封装性</font>）<br>&emsp;&emsp;最终产品是由许多较小的基本独立的对象组成。</p>
<p>&emsp;&emsp;优点：符合人类思维方法，各阶段使用方法具有高度的连续性，各个阶段有机集成，有利于系统的稳定。</p>
</li>
</ol>
<h3 id="三、软件生命周期"><a href="#三、软件生命周期" class="headerlink" title="三、软件生命周期"></a>三、软件生命周期</h3><p>​	组成：软件定义、软件开发、运行维护；</p>
<ol>
<li><p>软件定义（系统分析）：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>解决</th>
</tr>
</thead>
<tbody><tr>
<td>问题定义</td>
<td>问题是什么？</td>
</tr>
<tr>
<td>可行性研究</td>
<td>问题能否解决？</td>
</tr>
<tr>
<td>需求分析</td>
<td>解决问题需要做什么？</td>
</tr>
</tbody></table>
</li>
<li><p>软件开发：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>分类</th>
<th>细分</th>
<th>解决</th>
</tr>
</thead>
<tbody><tr>
<td>系统设计</td>
<td>总体设计</td>
<td>如何实现</td>
</tr>
<tr>
<td></td>
<td>详细设计</td>
<td>如何具体实现</td>
</tr>
<tr>
<td>系统实现</td>
<td>编码和单元测试</td>
<td></td>
</tr>
<tr>
<td></td>
<td>综合测试</td>
<td></td>
</tr>
</tbody></table>
<ol start="3">
<li><p>软件维护：</p>
<p>改正性维护、适应性维护、完善性维护、预防性维护；</p>
</li>
</ol>
<p><font color="red">总结：系统分析——&gt;系统设计——&gt;系统实现——&gt;维护</font></p>
<h3 id="四、软件过程（采用生命周期模型）（过程模型）"><a href="#四、软件过程（采用生命周期模型）（过程模型）" class="headerlink" title="四、软件过程（采用生命周期模型）（过程模型）"></a>四、软件过程（采用生命周期模型）（过程模型）</h3><ol>
<li><p>目的：为了开发出客户需要的软件；（who,when,what,how）</p>
</li>
<li><p>生命周期模型：<br>（1）<font color="red">瀑布模型</font>：（每个阶段都有文档）<br>特点：<br>① 阶段间具有顺序性和依赖性；<br>② 推迟实现的观点；（越大的项目越需要早期的准备）<br>③ 质量保证的观点；（文档）<br>优点：强迫开发人员采用规范，维护比较容易；（文档驱动）<br>缺点：交付给用户之前，用户只能通过文档了解产品，最终导致产品与用户需求发生争执；（文档驱动）</p>
<p>适用于：用户需求清晰，且开发过程无变化；开发人员的熟练，用户的使用环境非常稳定；开发中用户参与要求很低。</p>
</li>
</ol>
<img src="瀑布模型.png" style="zoom: 80%;" />

<p>​		（2） 快速原型模型：</p>
<p>&emsp;&emsp;特点：先开发一个原型，后续根据用户要求快速修改原型。（线性）</p>
<p>&emsp;&emsp;本质：快速，节约开发成本。</p>
<p>&emsp;&emsp;应用：UNIX Shell和超文本</p>
<p>&emsp;&emsp;优点：容易适应需求变化；有利于开发与培训的同步；开发费用低、周期短，对用户更友好。</p>
<p>&emsp;&emsp;缺点：客户与开发者对原型的理解不同；准确的原型设计比较困难；不利于开发人员的创新。</p>
<p>&emsp;&emsp;适用范围：对开发领域熟悉且有快速原型工具；项目投标时有原型展示；产品升级或移植，对已有产品进行服务。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&amp;emsp;空格</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%9E%8B.png"></p>
<p>​		（3）增量模型（渐增模型）</p>
<p>&emsp;&emsp;特点：将功能分为构件，逐步向用户提交产品，功能逐步推给用户；</p>
<p>&emsp;&emsp;&emsp;&emsp;与之相比，瀑布和快速模型则是一次把所有功能塞给用户；</p>
<p>&emsp;&emsp;优点：较短时间内向用户提交；</p>
<p>&emsp;&emsp;① 可完成部分工作的产品；</p>
<p>&emsp;&emsp;② 逐步增加产品功能可以使用户有充裕的时间学习和适应新产品；</p>
<p>&emsp;&emsp;缺点：技术要求高。</p>
<p>&emsp;&emsp;适用范围：进行已有产品升级或新版本开发；对完成期限要求严格；所开发领域熟悉且已有原型系统。</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B.png"></p>
<p>&emsp;&emsp;风险更大的增量模型：（并行开发）</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B2.png"></p>
<p>​		（4）螺旋模型：（用于大项目、应对风险即风险驱动）</p>
<p>&emsp;&emsp;<font color="red">实质上是在每个阶段之前增加了风险分析过程的<strong>快速原型</strong>模型</font></p>
<p>&emsp;&emsp;优点：</p>
<p>&emsp;&emsp;① 强调已有软件的重用，有助于把软件质量作为软件开发的一个重要目标；</p>
<p>&emsp;&emsp;② 减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险。</p>
<p>&emsp;&emsp;缺点：风险驱动的同时也会使开发人员未意识到真正风险的发生。</p>
<p>&emsp;&emsp;适用范围：内部开发的大规模项目。</p>
<img src="螺旋模型.png" style="zoom: 50%;" />

<p>​		（5）喷泉模型：（迭代）<font color="red"><strong>面向对象范型</strong>中常见</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;emsp;空格</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;解释：圆圈相互重叠代表活动存在交迭；向下的箭头代表该阶段内的迭代；较小的圆圈代表维护。</p>
<img src="喷泉模型.png" style="zoom: 50%;" />

<p>​		（6）RUP统一过程：</p>
<p>&emsp;&emsp;迭代开发，管理需求（用例分析），使用基于构件的体系结构（第三方架构Vue、Spring之类），可视化建模（UML），验证软件质量，控制软件变更。</p>
<p>&emsp;&emsp;优点：提高团队生产力。</p>
<p>&emsp;&emsp;缺点：没有涵盖软件工程的全部内容，缺少软件运行和支持方面的内容，不支持多项目的开发结构，重用可能性降低。</p>
<h3 id="五、可行性研究"><a href="#五、可行性研究" class="headerlink" title="五、可行性研究"></a>五、可行性研究</h3><ol>
<li><p>实质：是要进行一次大大压缩简化了的系统分析（抽象化）和设计的过程</p>
</li>
<li><p>目的：用最小的代价，在尽可能短的时间内研究并确定客户提出的问题是否有行得通的解决办法。</p>
</li>
<li><p>定义：</p>
<p>（1）进一步分析和澄清问题定义；</p>
<p>（2）导出系统的逻辑模型；</p>
<p>（3）探索若干种可供选择的主要解法：</p>
<p>&emsp;&emsp;① 技术可行性，② 经济可行性，③ 操作可行性，④ 法律</p>
</li>
<li><p>过程：8步</p>
<p>复查系统规模和目标、研究现有系统、导出新系统模型、进一步定义问题、导出和评价解法、推荐行动方针、草拟开发计划、写文档提交审查。</p>
</li>
<li><p>各类图：（详细看汇总图章节）</p>
<p>（1）系统流程图</p>
<p>（2）数据流图（数据流程图）</p>
<p>（3）数据字典：（开发数据库的第一步）</p>
<p>&emsp;&emsp;定义：关于数据的信息的集合，对数据流图中包含的所有元素的定义的集合；</p>
<p>&emsp;&emsp;包含：数据流（动态）、数据存储（静态）、数据流分量\数据元素（处理）</p>
</li>
</ol>
<h3 id="六、需求分析（访谈）"><a href="#六、需求分析（访谈）" class="headerlink" title="六、需求分析（访谈）"></a>六、需求分析（访谈）</h3><ol>
<li><p>实质：回答系统必须做什么。</p>
</li>
<li><p>任务：</p>
<p>（1）确定对系统的综合要求：</p>
<p>&emsp;&emsp;功能需求，性能<del>，可靠性和可用性</del>，出错处理<del>，接口</del>，约束，逆向<del>，将来可能提出的</del></p>
<p>（2）分析系统的数据要求；</p>
<p>（3）导出系统的逻辑模型：</p>
<p>&emsp;&emsp;采用数据流图、实体-联系图、状态转换图、数据字典和主要算法描述该模型。</p>
<p>（4）修正系统开发计划；</p>
</li>
<li><p>软件需求规格说明：（详细看汇总图章节）</p>
<p>（1）实体-联系图（E-R图）：数据对象、属性、联系（1:1，1:n，n:m）,（1NF冗余最高，2NF，3NF常用）</p>
<p>（2）状态转化图（两种画法）</p>
<p>（3）Warnier图</p>
<p>（4）IPO图</p>
</li>
</ol>
<h3 id="七、总体设计"><a href="#七、总体设计" class="headerlink" title="七、总体设计"></a>七、总体设计</h3><ol>
<li><p>阶段组成：系统设计、结构设计；</p>
</li>
<li><p>过程：9步</p>
<p>设想供选择的方案，选取合理的方案，推荐最佳~，功能分解，设计软件架构，设计数据库，确定测试计划，书写文档，审查和复审。</p>
</li>
<li><p>模块：构成程序的基本构件</p>
<p>（1）耦合：追求低耦合</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E8%80%A6%E5%90%88.png"></p>
<p>（2）内聚：追求高内聚</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E5%86%85%E8%81%9A.png"></p>
</li>
<li><p>描述软件架构工具：（详细看汇总图章节）</p>
<p>（1）层次图</p>
<p>（2）HIPO图</p>
<p>（3）软件结构图</p>
</li>
</ol>
<h3 id="八、详细设计（算法）"><a href="#八、详细设计（算法）" class="headerlink" title="八、详细设计（算法）"></a>八、详细设计（算法）</h3><ol>
<li><p>结构设计：顺序、选择、循环</p>
</li>
<li><p>过程设计工具：（描述程序处理过程的工具）（详细看汇总图章节）</p>
<p>（1）程序流程图</p>
<p>（2）盒图（N-S图）</p>
<p>（3）PAD图</p>
<p>（4）判定表</p>
<p>（5）判定树</p>
</li>
<li><p>面向数据结构的设计方法：Jackson图</p>
</li>
<li><p>程序复杂程度：计算环形复杂度</p>
</li>
</ol>
<h3 id="九、实现"><a href="#九、实现" class="headerlink" title="九、实现"></a>九、实现</h3><ol>
<li><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4></li>
<li><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>（1）确认测试：需求分析阶段（Alpha测试、Beta测试）</p>
<p>（2）单元测试：详细设计&#x2F;编码阶段（代码审查）</p>
<p>（3）集成测试：概要设计阶段（回归测试）</p>
<p>（4）系统测试：整体系统实现</p>
<p>（5）黑盒测试</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.png"></p>
<p>（6）白盒测试：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.png"></p>
</li>
<li><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4></li>
</ol>
<h3 id="十、维护"><a href="#十、维护" class="headerlink" title="十、维护"></a>十、维护</h3><ol>
<li><p>决定软件的可维护性的因素：</p>
<p>可理解性、可测试性、可修改性、可重用性</p>
</li>
<li><p>提高软件产品的可维护性的方法：</p>
<p>①建立明确的软件直连目标；</p>
<p>②使用先进的软件开发技术和工具；</p>
<p>③建立明确的质量保证；</p>
<p>④选择可维护的程序设计语言；</p>
<p>⑤改进程序文档。</p>
</li>
<li><p>文档：</p>
<p>用户文档、系统文档</p>
</li>
</ol>
<h3 id="十一、面向对象方法学（类是对象的蓝图或模板，而对象是类的实例。）"><a href="#十一、面向对象方法学（类是对象的蓝图或模板，而对象是类的实例。）" class="headerlink" title="十一、面向对象方法学（类是对象的蓝图或模板，而对象是类的实例。）"></a>十一、面向对象方法学（类是对象的蓝图或模板，而对象是类的实例。）</h3><ol>
<li><p>什么是面向对象方法学？</p>
<p>尽可能模拟人类习惯，开发过程接近人类解决问题的方法与过程。</p>
<p>优点：与人类思维方法一致；软件稳定性好；软件可重用性好；较易开发大型软件产品；可维护性好。</p>
</li>
<li><p>什么是对象？</p>
<p>对问题域某个实体的抽象；既有静态的属性（姓名…），又有动态的属性（方法…）。</p>
</li>
<li><p>什么是类？</p>
<p>对具有相同数据结构和操作的一组相似对象的定义，即类是对具有相同属性和行为的一个或多个对象的描述。</p>
</li>
<li><p>用例图（详细看汇总图章节）</p>
</li>
<li><p>类图（详细看汇总图章节）</p>
</li>
</ol>
<h3 id="十二、面向对象分析"><a href="#十二、面向对象分析" class="headerlink" title="十二、面向对象分析"></a>十二、面向对象分析</h3><ol>
<li><p>状态图（详细看汇总图章节）</p>
</li>
<li><p>事件跟踪图</p>
</li>
<li><table>
<thead>
<tr>
<th>模型类型</th>
<th>图</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>对象模型</td>
<td>类图结合功能过程</td>
<td>最基础、最重要、最核心</td>
</tr>
<tr>
<td>动态模型</td>
<td>时间跟踪图或状态图</td>
<td></td>
</tr>
<tr>
<td>功能模型</td>
<td>数据流图或程序流程图</td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="十三、软件工程导论各类图汇总"><a href="#十三、软件工程导论各类图汇总" class="headerlink" title="十三、软件工程导论各类图汇总"></a>十三、软件工程导论各类图汇总</h3><h4 id="汇总："><a href="#汇总：" class="headerlink" title="汇总："></a>汇总：</h4><ol>
<li><p>可行性分析：</p>
<p>（1）系统流程图（整个系统功能）</p>
<p>（2）数据流(程)图</p>
<p>（3）数据字典</p>
</li>
<li><p>需求分析：</p>
<p>（1）实体联系图（E-R图）</p>
<p>（2）状态(转换)图（两种画法）</p>
<p>（3）IPO图</p>
</li>
<li><p>总体设计：</p>
<p>（1）层次图</p>
<p>（2）HIPO图</p>
<p>（3）软件结构图</p>
</li>
<li><p>详细设计：</p>
<p>（1）程序流程图（某一程序执行任务的过程）</p>
<p>（2）N-S盒图</p>
<p>（3）PAD图</p>
<p>（4）判定表</p>
<p>（5）判定树</p>
<p>（6）Jackson图</p>
</li>
<li><p>其他</p>
<p>（1）用例图</p>
<p>（2）类图</p>
<p>（3）事件跟踪图</p>
<p>（4）状态图（两种画法）</p>
</li>
</ol>
<h4 id="绘制："><a href="#绘制：" class="headerlink" title="绘制："></a>绘制：</h4><ol>
<li><h5 id="可行性分析："><a href="#可行性分析：" class="headerlink" title="可行性分析："></a>可行性分析：</h5><p>（1）系统流程图：</p>
<p>&emsp;&emsp;<img src="系统流程图1.png" style="zoom:50%;" /><img src="系统流程图2.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;例：</p>
<img src="系统流程图3.png" alt="系统流程图3" style="zoom:50%;" />

<p>（2）数据流(程)图：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE1.png"></p>
<p>&emsp;&emsp;例1：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE2.png"></p>
<p>&emsp;&emsp;例2：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE3.png"></p>
<p>&emsp;&emsp;D1，D2，1，2：加这些编号是为了方便引用和追踪</p>
<p>（3）数据字典：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
<th>允许非空</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>char</td>
<td>编号</td>
<td>NO</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td>varchar</td>
<td>姓名</td>
<td>NO</td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li><h5 id="需求分析："><a href="#需求分析：" class="headerlink" title="需求分析："></a>需求分析：</h5><p>（1）实体联系图（E-R图）：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/ER%E5%9B%BE1.png"></p>
<p>&emsp;&emsp;例：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/ER%E5%9B%BE2.png"></p>
<p>（2）状态图&#x2F;状态转换图：（两种画法）</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E7%8A%B6%E6%80%81%E5%9B%BE1.png"></p>
<p>&emsp;&emsp;例：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E7%8A%B6%E6%80%81%E5%9B%BE2.png"></p>
<p>（3）IPO图：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/IPO%E5%9B%BE1.png"></p>
<p>&emsp;&emsp;IPO表：</p>
<img src="IPO表.png"  />
</li>
<li><h5 id="总体设计："><a href="#总体设计：" class="headerlink" title="总体设计："></a>总体设计：</h5><p>（1）层次图：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E6%A8%A1%E5%9D%97.png"></p>
<p>&emsp;&emsp;例：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E5%B1%82%E6%AC%A1%E5%9B%BE.png"></p>
<p>（2）HIPO图：（IPO图+层次图）</p>
<p>&emsp;&emsp;在层次图除了最顶层的方框之外，每个方框中都加编号。</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/HIPO%E5%9B%BE.png"></p>
<p>（3）软件结构图：</p>
<p>&emsp;&emsp;类似于层次图，但是为模块调用模块。</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE1.png"></p>
<p>&emsp;&emsp;例：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE2.png"></p>
</li>
<li><h5 id="详细设计："><a href="#详细设计：" class="headerlink" title="详细设计："></a>详细设计：</h5><p>（1）程序流程图：（环形复杂度计算）</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<p>（2）N-S盒图：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E7%9B%92%E5%9B%BE.png"></p>
<p>&emsp;&emsp;例：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E7%9B%92%E5%9B%BE1.png"></p>
<p>（3）PAD图：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/PAD%E5%9B%BE.png"></p>
<p>&emsp;&emsp;例：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/PAD%E5%9B%BE1.png"></p>
<p>（4）判定表：</p>
<p>&emsp;&emsp;例：某航空公司规定，乘客可以免费托运不超过20公斤的行李。当行李重量超过20公斤时，对头等舱的乘客超重部分每公斤收费4元，其它舱的乘客收费6元。对残疾乘客超重部分在舱位等次相同的情况下收费减半。</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>未超重</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>超重</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>头等舱</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>其他舱</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>残疾乘客</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>普通乘客</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>免费</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>超出部分2元&#x2F;公斤</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>超出部分3元&#x2F;公斤</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>超出部分4元&#x2F;公斤</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>超出部分6元&#x2F;公斤</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<p>（5）判定树：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E5%88%A4%E5%AE%9A%E6%A0%91.png"></p>
<p>（6）Jackson图：</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/Jackson%E5%9B%BE.png"></p>
</li>
<li><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>（1）用例图</p>
<table>
<thead>
<tr>
<th>关系类型</th>
<th>说明</th>
<th>表示符号</th>
</tr>
</thead>
<tbody><tr>
<td>关联</td>
<td>参与者与用例之间的关系</td>
<td>—&gt;</td>
</tr>
<tr>
<td>泛化</td>
<td>参与者之间或用例之间的关系</td>
<td>—▷</td>
</tr>
<tr>
<td>包含</td>
<td>用例之间的关系</td>
<td>—&lt;&lt;include&gt;&gt;—&gt;</td>
</tr>
<tr>
<td>扩展</td>
<td>用例之间的关系</td>
<td>—&lt;&lt;extend&gt;&gt;—-&gt;</td>
</tr>
</tbody></table>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E7%94%A8%E4%BE%8B%E5%9B%BE.png"></p>
<p>（2）类图</p>
<p>&emsp;&emsp;参考：<a href="https://blog.csdn.net/realmagicboy/article/details/90289062">链接</a></p>
<p>（3）事件跟踪图</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%BA%8B%E4%BB%B6%E8%BF%BD%E8%B8%AA%E5%9B%BE.png"></p>
<p>（4）状态图（两种画法）</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E7%8A%B6%E6%80%81%E5%9B%BE.png"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;emsp;空格</span><br></pre></td></tr></table></figure>

<h3 id="十四、补充知识点："><a href="#十四、补充知识点：" class="headerlink" title="十四、补充知识点："></a>十四、补充知识点：</h3><ol>
<li><p>判定是否结构化：</p>
<p>程序流程图只有一个出口，则结构化；有多个出口，则非结构化。（非结构化&#x3D;&gt;结构化）</p>
</li>
<li><p>非渐增式测试：</p>
<p>先将模块进行单元测试然后组装到一起再测试整体；</p>
<p>渐增式测试：（自下而上、自上而下）</p>
<p>逐个将未经检测的模块组装到已经测试过的模块上进行集成测试。即加一个测一个，便于发现接口错误。</p>
</li>
<li><p>结构化设计方法（传统法）是面对数据流和功能的设计。</p>
</li>
<li><p>数据流设计方法：</p>
<p>（1）变换型：输入——&gt;处理——&gt;输出</p>
<p>（2）事务性：事务层、操作层、细节层（一起入、一起滚）</p>
</li>
<li><p>好的程序注释要占到程序总量的1&#x2F;3。</p>
</li>
<li><p>找到错误位置占排错总工作量的95%。</p>
</li>
<li><p>数据流和文件命名情况：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>数据流命名</th>
<th>文件命名</th>
</tr>
</thead>
<tbody><tr>
<td>数据流与文件交互</td>
<td>不需要</td>
<td>需要</td>
</tr>
<tr>
<td>数据流再加工之间传递</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>流入&#x2F;流出文件的数据流不同</td>
<td>需要</td>
<td>需要</td>
</tr>
</tbody></table>
</li>
<li><p>功能性内聚是最强的，偶然内聚是最弱的。</p>
</li>
<li><p>Jackson图是面向数据结构的.</p>
</li>
<li><p>模块中所以成分引用共同的数据，该模块内的联系类型为：通信内聚。</p>
</li>
<li><p>不适应于数据流图处理（加工）名称的是工资支票数据。（因为不存在计算&#x2F;操作）</p>
</li>
<li><p>采用结构化分析方法时，采用的基本手段是：分解与抽象。</p>
</li>
<li><table>
<thead>
<tr>
<th>阶段</th>
<th>产生</th>
</tr>
</thead>
<tbody><tr>
<td>系统分析</td>
<td>模块结构图与模块说明书</td>
</tr>
<tr>
<td>需求&#x2F;设计阶段</td>
<td>系统说明书</td>
</tr>
<tr>
<td>需求分析阶段</td>
<td>数据字典&#x2F;数据流图</td>
</tr>
</tbody></table>
</li>
<li><p>结构化设计是面向数据流的设计方法。</p>
</li>
<li><p>维护过程中，应先确定维护类型。</p>
</li>
<li><p>结构化设计方法：数据流图导出初始结构图，再以此为基础构件模块化的软件系统架构。</p>
</li>
<li><p>结构化系统分析主要通过处理功能进行分析。</p>
</li>
<li><p>结构化系统分析中，判定表和判定树常用于表达数据流图中的加工逻辑。</p>
</li>
<li><p>驱动模块：自底向上测试</p>
<p>桩模块：自顶向下测试</p>
</li>
<li><p>结构化设计采用模块化方法的主要出发点是：降低复杂度。</p>
</li>
<li><p>数据流图所描述的是实际系统的逻辑模型。</p>
</li>
<li><p>在软件生命周期中，占工作量比例最大的是：维护。</p>
</li>
<li><p>SA(结构化)方法再描述方式上的特点，是尽量采用图形表示。</p>
</li>
<li><p>决定软件系统中各个模块的外部特性（输入、输出和功能）是概要设计阶段的任务。</p>
</li>
<li><p>通过对软件的测试，可以证明错误所在。</p>
</li>
<li><p>决定软件工程方法论所有步骤的攻击目标是提高软件的可维护性。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;emsp;空格</span><br></pre></td></tr></table></figure>

<h3 id="十五、习题："><a href="#十五、习题：" class="headerlink" title="十五、习题："></a>十五、习题：</h3><ol>
<li><h4 id="可行性研究："><a href="#可行性研究：" class="headerlink" title="可行性研究："></a>可行性研究：</h4><p>该类题解法：①写出问题定义，②再根据技术、经济、操作可行性进行分析，③画出系统流程图和数据流图。</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%981.1.png"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%981.2.png" alt="习题1.2"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%981.3.png" alt="习题1.3"></p>
</li>
<li><h4 id="需求分析：-1"><a href="#需求分析：-1" class="headerlink" title="需求分析："></a>需求分析：</h4><p>此类题解法：画数据流图，画E-R图。</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%982.1.png"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%982.2.png" alt="习题2.2"></p>
</li>
<li><h4 id="总体设计：-1"><a href="#总体设计：-1" class="headerlink" title="总体设计："></a>总体设计：</h4><p>此类题解法：画数据流图和软件结构图，还会有HIPO图的绘制。</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%983.1.png"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%983.2.png" alt="习题3.2"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%983.3.png" alt="习题3.3"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%983.4.png" alt="习题3.4"></p>
</li>
<li><h4 id="详细设计：-1"><a href="#详细设计：-1" class="headerlink" title="详细设计："></a>详细设计：</h4><p>此类题解法：①根据代码绘制程序流程图和盒图。②根据图或代码判定是否结构化，若非结构化则&#x3D;&gt;结构化（画图）。③判定表和判定树的绘制。④画出程序的程序流程图并转化为程序流图，再计算环形复杂度。⑤Jackson图绘制？？？</p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%984.1.png"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%984.2.png" alt="习题4.2"></p>
</li>
</ol>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%985.1.png"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%985.2.png" alt="习题5.2"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%985.3.png" alt="习题5.3"></p>
<p><img src="/blog2025.github.io/2025/03/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E4%B9%A0%E9%A2%985.4.png" alt="习题5.4"></p>
<ol start="5">
<li><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><p>此类题解法：①根据提供的伪代码，进行纠错，修改循环结构，画程序流程图，判定是否结构化，画盒图。</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;②进行各类测试。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
</search>
