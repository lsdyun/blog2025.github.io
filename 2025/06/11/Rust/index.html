<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog2025.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog2025.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog2025.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog2025.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog2025.github.io/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lsdyun.github.io","root":"/blog2025.github.io/","images":"/blog2025.github.io/images","scheme":"Pisces","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog2025.github.io/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog2025.github.io/js/config.js"></script>

    <meta name="description" content="Rust前言Rust 应用：  底层系统编码 命令行应用、网络服务器 编写网页 树莓派 等等  Rust 特点：">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust">
<meta property="og:url" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/index.html">
<meta property="og:site_name" content="记录博客">
<meta property="og:description" content="Rust前言Rust 应用：  底层系统编码 命令行应用、网络服务器 编写网页 树莓派 等等  Rust 特点：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611105416951.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611124045772.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611113219788.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611114324964.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611114407384.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/image-20250611115805239.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611115945414.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611120157547.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611120216495.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611120451144.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611121515302.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611121616909.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611121831549.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611121931669.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611123657319.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611122548845.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611122630660.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611122926339.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611123008116.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250612102551821.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250614103552095.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250614105500546.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250614110811892.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250614112404232.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250614114659097.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250614114934090.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250615080012057.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250615082006983.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250615082419365.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250615082440356.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250615082509941.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250618085001458.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250618091006833.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250618092322631.png">
<meta property="article:published_time" content="2025-06-11T01:55:23.828Z">
<meta property="article:modified_time" content="2025-07-29T07:02:25.286Z">
<meta property="article:author" content="lsdyun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/image-20250611105416951.png">


<link rel="canonical" href="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/","path":"2025/06/11/Rust/","title":"Rust"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Rust | 记录博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/blog2025.github.io/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog2025.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">记录博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog2025.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog2025.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/blog2025.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/blog2025.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Rust"><span class="nav-number">1.</span> <span class="nav-text">Rust</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E5%AE%89%E8%A3%85%EF%BC%9A"><span class="nav-number">1.1.1.</span> <span class="nav-text">Rust 安装：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E6%8F%92%E4%BB%B6"><span class="nav-number">1.1.2.</span> <span class="nav-text">Rust 插件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hello-World"><span class="nav-number">1.2.</span> <span class="nav-text">Hello,World!</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cargo"><span class="nav-number">1.3.</span> <span class="nav-text">Cargo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cargo-new"><span class="nav-number">1.3.1.</span> <span class="nav-text">cargo new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cargo-build"><span class="nav-number">1.3.2.</span> <span class="nav-text">cargo build</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cargo-run"><span class="nav-number">1.3.3.</span> <span class="nav-text">cargo run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cargo-check"><span class="nav-number">1.3.4.</span> <span class="nav-text">cargo check</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="nav-number">1.4.</span> <span class="nav-text">猜数字游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">1.4.1.</span> <span class="nav-text">输入输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93-std"><span class="nav-number">1.4.2.</span> <span class="nav-text">标准库 std</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#crate%EF%BC%9A%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="nav-number">1.4.3.</span> <span class="nav-text">crate：第三方库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%95%B0%E5%AD%97"><span class="nav-number">1.4.4.</span> <span class="nav-text">生成数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8C%9C%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.4.5.</span> <span class="nav-text">猜大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-number">1.4.6.</span> <span class="nav-text">完整代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B"><span class="nav-number">1.5.</span> <span class="nav-text">开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%AE%E8%94%BD"><span class="nav-number">1.5.3.</span> <span class="nav-text">遮蔽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.4.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.5.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.6.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">1.5.7.</span> <span class="nav-text">控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">1.5.8.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">1.6.</span> <span class="nav-text">所有权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9F"><span class="nav-number">1.6.1.</span> <span class="nav-text">什么是所有权？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">1.6.2.</span> <span class="nav-text">垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86"><span class="nav-number">1.6.3.</span> <span class="nav-text">栈和堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99"><span class="nav-number">1.6.4.</span> <span class="nav-text">所有权规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.5.</span> <span class="nav-text">String 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D"><span class="nav-number">1.6.6.</span> <span class="nav-text">内存与分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%85%8B%E9%9A%86"><span class="nav-number">1.6.7.</span> <span class="nav-text">移动和克隆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8"><span class="nav-number">1.6.7.1.</span> <span class="nav-text">移动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="nav-number">1.6.7.2.</span> <span class="nav-text">作用域与赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%8B%E9%9A%86"><span class="nav-number">1.6.7.3.</span> <span class="nav-text">克隆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Copy-%E7%89%B9%E6%80%A7"><span class="nav-number">1.6.7.4.</span> <span class="nav-text">Copy  特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.8.</span> <span class="nav-text">所有权与函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.6.9.</span> <span class="nav-text">返回值与作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">1.6.10.</span> <span class="nav-text">引用&amp;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%9F%E7%94%A8"><span class="nav-number">1.6.10.1.</span> <span class="nav-text">借用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8"><span class="nav-number">1.6.10.2.</span> <span class="nav-text">悬垂引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-number">1.6.10.3.</span> <span class="nav-text">引用的规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87-Slice"><span class="nav-number">1.6.11.</span> <span class="nav-text">切片 Slice</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.7.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.7.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.7.2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="nav-number">1.7.3.</span> <span class="nav-text">方法语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.4.</span> <span class="nav-text">关联函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.8.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">1.8.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E4%BD%93%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE"><span class="nav-number">1.8.2.</span> <span class="nav-text">变体关联数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94"><span class="nav-number">1.8.3.</span> <span class="nav-text">复杂数据关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Option-%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.8.4.</span> <span class="nav-text">Option 枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#match"><span class="nav-number">1.8.5.</span> <span class="nav-text">match</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if-let-%E5%92%8C-let-else"><span class="nav-number">1.8.6.</span> <span class="nav-text">if let 和 let else </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E3%80%81crate%E3%80%81%E6%A8%A1%E5%9D%97"><span class="nav-number">1.9.</span> <span class="nav-text">包、crate、模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%92%8C-Crate"><span class="nav-number">1.9.1.</span> <span class="nav-text">包和 Crate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">1.9.2.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.9.3.</span> <span class="nav-text">模块路径与可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#use-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.9.4.</span> <span class="nav-text">use 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6%E6%8B%86%E5%88%86"><span class="nav-number">1.9.5.</span> <span class="nav-text">模块文件拆分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.10.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E9%87%8F%EF%BC%88vector%EF%BC%89"><span class="nav-number">1.10.1.</span> <span class="nav-text">向量（vector）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88string%EF%BC%89"><span class="nav-number">1.10.2.</span> <span class="nav-text">字符串（string）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C-map%EF%BC%88hash-map%EF%BC%89"><span class="nav-number">1.10.3.</span> <span class="nav-text">哈希 map（hash map）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.11.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#panic"><span class="nav-number">1.11.1.</span> <span class="nav-text">panic!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Result"><span class="nav-number">1.11.2.</span> <span class="nav-text">Result</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#panic-vs-Result"><span class="nav-number">1.11.3.</span> <span class="nav-text">panic! vs Result</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E3%80%81Trait-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.12.</span> <span class="nav-text">泛型、Trait 和生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%EF%BC%9A"><span class="nav-number">1.12.1.</span> <span class="nav-text">泛型：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trait"><span class="nav-number">1.12.2.</span> <span class="nav-text">Trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.12.3.</span> <span class="nav-text">生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="nav-number">1.13.</span> <span class="nav-text">自动化测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95"><span class="nav-number">1.13.1.</span> <span class="nav-text">如何编写测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%8B%E8%AF%95"><span class="nav-number">1.13.2.</span> <span class="nav-text">控制测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="nav-number">1.13.3.</span> <span class="nav-text">测试的组织结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O"><span class="nav-number">1.14.</span> <span class="nav-text">I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">1.14.1.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">1.14.2.</span> <span class="nav-text">读取文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E6%94%B9%E8%BF%9B%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.14.3.</span> <span class="nav-text">重构改进和错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%87%E7%94%A8-TDD-%E5%AE%8C%E5%96%84%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD"><span class="nav-number">1.14.4.</span> <span class="nav-text">采用 TDD 完善搜索功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E"><span class="nav-number">1.14.4.1.</span> <span class="nav-text">搜索功能说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%94%AF%E6%8C%81"><span class="nav-number">1.14.5.</span> <span class="nav-text">集成环境变量支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.14.5.1.</span> <span class="nav-text">测试增强</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%A4%84%E7%90%86%E8%AF%B4%E6%98%8E"><span class="nav-number">1.14.5.2.</span> <span class="nav-text">环境变量处理说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96"><span class="nav-number">1.14.6.</span> <span class="nav-text">错误信息输出优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%B5%81%E5%8C%BA%E5%88%86%E8%AF%B4%E6%98%8E"><span class="nav-number">1.14.6.1.</span> <span class="nav-text">输出流区分说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%BA%E6%99%AF%E6%B5%8B%E8%AF%95"><span class="nav-number">1.14.6.2.</span> <span class="nav-text">重定向场景测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E5%88%86%E7%A6%BB%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.14.6.3.</span> <span class="nav-text">输出分离的优势</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="nav-number">1.15.</span> <span class="nav-text">迭代器与闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">1.15.1.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.15.2.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-%E9%A1%B9%E7%9B%AE%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%94%B9%E8%BF%9B"><span class="nav-number">1.15.3.</span> <span class="nav-text">I&#x2F;O 项目迭代器改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-vs-%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.15.4.</span> <span class="nav-text">迭代器 vs 循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cargo-%E5%92%8C-Cates-io-%E9%AB%98%E7%BA%A7"><span class="nav-number">1.16.</span> <span class="nav-text">Cargo 和 Cates.io 高级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA"><span class="nav-number">1.16.1.</span> <span class="nav-text">发布配置自定义构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Crate-%E5%8F%91%E5%B8%83%E4%B8%8E%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99"><span class="nav-number">1.16.2.</span> <span class="nav-text">Crate 发布与文档编写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cargo-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4"><span class="nav-number">1.16.3.</span> <span class="nav-text">Cargo 工作空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-cargo-install"><span class="nav-number">1.16.4.</span> <span class="nav-text">Rust cargo install</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cargo-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4"><span class="nav-number">1.16.5.</span> <span class="nav-text">Cargo 自定义扩展命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.17.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-Box"><span class="nav-number">1.17.1.</span> <span class="nav-text">Rust Box&lt;T&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-Deref-Trait"><span class="nav-number">1.17.2.</span> <span class="nav-text">Rust Deref Trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-Drop-Trait"><span class="nav-number">1.17.3.</span> <span class="nav-text">Rust Drop Trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-Rc-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.17.4.</span> <span class="nav-text">Rust Rc&lt;T&gt; 引用计数智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RefCell-%E4%B8%8E%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.17.5.</span> <span class="nav-text">RefCell&lt;T&gt; 与内部可变性模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">1.17.6.</span> <span class="nav-text">引用循环与内存泄漏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91"><span class="nav-number">1.18.</span> <span class="nav-text">Rust 无畏并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B-1"><span class="nav-number">1.18.1.</span> <span class="nav-text">开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8"><span class="nav-number">1.18.2.</span> <span class="nav-text">Rust 线程使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%B9%B6%E5%8F%91"><span class="nav-number">1.18.3.</span> <span class="nav-text">Rust 消息传递并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E5%B9%B6%E5%8F%91"><span class="nav-number">1.18.4.</span> <span class="nav-text">Rust 共享状态并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Send-%E4%B8%8E-Sync-Trait"><span class="nav-number">1.18.5.</span> <span class="nav-text">Send 与 Sync Trait</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.19.</span> <span class="nav-text">Rust 异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">1.19.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%8E-Futures"><span class="nav-number">1.19.2.</span> <span class="nav-text">Rust 异步编程与 Futures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.19.3.</span> <span class="nav-text">Rust 异步并发编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E5%BC%82%E6%AD%A5-Future-%E7%AE%A1%E7%90%86"><span class="nav-number">1.19.4.</span> <span class="nav-text">Rust 异步 Future 管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%EF%BC%88Streams%EF%BC%89%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-number">1.19.5.</span> <span class="nav-text">流（Streams）快速入门</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Async-Traits-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">1.19.6.</span> <span class="nav-text">深入理解 Async Traits 核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E3%80%81%E4%BB%BB%E5%8A%A1%E4%B8%8E-Future-%E5%8D%8F%E5%90%8C"><span class="nav-number">1.19.7.</span> <span class="nav-text">线程、任务与 Future 协同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.20.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81"><span class="nav-number">1.20.1.</span> <span class="nav-text">Rust 面向对象特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-Trait-%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.20.2.</span> <span class="nav-text">Rust Trait 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%B2%BE%E8%A6%81"><span class="nav-number">1.20.3.</span> <span class="nav-text">Rust 状态模式实现精要</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">1.21.</span> <span class="nav-text">模式与模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E4%BD%8D%E7%BD%AE%E7%B2%BE%E8%A6%81"><span class="nav-number">1.21.1.</span> <span class="nav-text">Rust 模式匹配位置精要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E6%A8%A1%E5%BC%8F%E5%8F%AF%E5%8F%8D%E9%A9%B3%E6%80%A7%E7%B2%BE%E8%A6%81"><span class="nav-number">1.21.2.</span> <span class="nav-text">Rust 模式可反驳性精要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E6%A8%A1%E5%BC%8F%E8%AF%AD%E6%B3%95%E7%B2%BE%E8%A6%81"><span class="nav-number">1.21.3.</span> <span class="nav-text">Rust 模式语法精要</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.22.</span> <span class="nav-text">高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8-Rust"><span class="nav-number">1.22.1.</span> <span class="nav-text">不安全 Rust</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E9%AB%98%E7%BA%A7-Trait"><span class="nav-number">1.22.2.</span> <span class="nav-text">Rust 高级 Trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.22.3.</span> <span class="nav-text">Rust 高级类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85%E7%B2%BE%E8%A6%81"><span class="nav-number">1.22.4.</span> <span class="nav-text">高级函数与闭包精要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E5%AE%8F%E7%B2%BE%E8%A6%81"><span class="nav-number">1.22.5.</span> <span class="nav-text">Rust 宏精要</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B-web-server"><span class="nav-number">1.23.</span> <span class="nav-text">构建多线程 web server</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B-Web-Server-%E7%B2%BE%E8%A6%81"><span class="nav-number">1.23.1.</span> <span class="nav-text">单线程 Web Server 精要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-Web-Server-%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.23.2.</span> <span class="nav-text">多线程 Web Server ：线程池实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA%E4%B8%8E%E6%B8%85%E7%90%86"><span class="nav-number">1.23.3.</span> <span class="nav-text">优雅停机与清理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-number">1.24.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%BD%95-A%EF%BC%9A%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.24.1.</span> <span class="nav-text">附录 A：关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%BD%95-B%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%AC%A6%E5%8F%B7"><span class="nav-number">1.24.2.</span> <span class="nav-text">附录 B：运算符与符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%BD%95-C%EF%BC%9A%E5%8F%AF%E6%B4%BE%E7%94%9F%E7%9A%84-trait"><span class="nav-number">1.24.3.</span> <span class="nav-text">附录 C：可派生的 trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%BD%95-D%EF%BC%9A%E5%AE%9E%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="nav-number">1.24.4.</span> <span class="nav-text">附录 D：实用开发工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%BD%95-E%EF%BC%9A%E7%89%88%E6%9C%AC"><span class="nav-number">1.24.5.</span> <span class="nav-text">附录 E：版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%BD%95-F%EF%BC%9ARust-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%8E-%E2%80%9CNightly-Rust%E2%80%9D"><span class="nav-number">1.24.6.</span> <span class="nav-text">附录 F：Rust 是如何开发的与 “Nightly Rust”</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lsdyun"
      src="/blog2025.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">lsdyun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog2025.github.io/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog2025.github.io/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lsdyun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lsdyun" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lsdyun.github.io/blog2025.github.io/2025/06/11/Rust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog2025.github.io/images/avatar.png">
      <meta itemprop="name" content="lsdyun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Rust | 记录博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Rust
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-11 09:55:23" itemprop="dateCreated datePublished" datetime="2025-06-11T09:55:23+08:00">2025-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-29 15:02:25" itemprop="dateModified" datetime="2025-07-29T15:02:25+08:00">2025-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog2025.github.io/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


		<!--  设置置顶图标  -->
		        
		<!--  设置置顶图标  -->
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/">Rust</a></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Rust 应用：</strong></p>
<ul>
<li>底层系统编码</li>
<li>命令行应用、网络服务器</li>
<li>编写网页</li>
<li>树莓派</li>
<li>等等</li>
</ul>
<p><strong>Rust 特点：</strong></p>
<ul>
<li>高效（提升开发效率）<ul>
<li>其他语言中，需要通过额外的工作去捕捉 bug</li>
<li>Rust 编译器：拒绝编译难以察觉的的错误代码（降低捕捉 bug 的频率）</li>
</ul>
</li>
<li>开发工具<ul>
<li><strong>Cargo：内置的依赖管理器和构建工具</strong>。</li>
<li><strong>Rustfmt：格式化工具</strong>，确保开发者遵循一致的代码风格。</li>
<li><strong>rust-analyzer：为 IDE 提供代码补全和内联错误信息功能</strong>。</li>
</ul>
</li>
<li>稳定（安全）<ul>
<li>Rust 编译器的检查确保了增加功能和重构代码时的稳定性</li>
</ul>
</li>
</ul>
<h3 id="Rust-安装："><a href="#Rust-安装：" class="headerlink" title="Rust 安装："></a><strong>Rust 安装：</strong></h3><p><a target="_blank" rel="noopener" href="https://www.rust-lang.org/zh-CN/tools/install"><strong>RUST-INIT.EXE 下载</strong></a></p>
<p>rustup-init.exe打开后出现以下情况：</p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611105416951.png" alt="image-20250611105416951"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中文翻译：</span></span><br><span class="line"></span><br><span class="line">Rust 的 Visual C++ 前置要求</span><br><span class="line"></span><br><span class="line">Rust 需要一个链接器和 Windows API 库，但这些组件似乎不可用。</span><br><span class="line"></span><br><span class="line">这些组件可以通过 Visual Studio 安装程序获取。</span><br><span class="line"></span><br><span class="line">1)快速安装： 通过 Visual Studio Community 安装程序安装（对个人、学术用途和开源免费）。</span><br><span class="line"></span><br><span class="line">2)手动安装前置要求：（适用于企业用户和高级用户）。</span><br><span class="line"></span><br><span class="line">3)不安装前置要求：（如果您打算使用 GNU ABI 进行开发）。</span><br></pre></td></tr></table></figure>

<p>配置可选两种：</p>
<p><em>（如果需要，可以参考方案二的国内镜像配置）</em></p>
<ul>
<li><p><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/rust/rust-setup.html">方案一</a>：</strong>（也就是上述的**<code>1)一路下一步即可</code>**）</p>
<p><em>当只是需要安装环境不需要VS编译器时选择下面的方法</em></p>
<p>安装 MSVC 工具链（推荐，Rust 官方默认）</p>
<ul>
<li>下载 <a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/"><strong>Visual Studio Build Tools</strong></a><ul>
<li>运行安装程序 → 勾选 <strong>“C++ 生成工具”</strong>（含编译器、链接器、Windows SDK）</li>
<li>无需安装完整 Visual Studio，仅需 3-5GB 空间</li>
</ul>
</li>
<li><strong>重启终端后 Rust 将自动识别 MSVC 工具链</strong><ul>
<li>Rust 项目编译时自动调用 <code>link.exe</code>（来自 MSVC）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>方案二：</strong>（轻量化）</p>
<p>改用 GNU 工具链（需额外安装 MinGW）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74823292/article/details/146432853">https://blog.csdn.net/m0_74823292/article/details/146432853</a></p>
</li>
</ul>
<p><strong>Rust 更新：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup update</span><br></pre></td></tr></table></figure>

<p><strong>Rust 卸载：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup self uninstall</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Rust-插件"><a href="#Rust-插件" class="headerlink" title="Rust 插件"></a>Rust 插件</h3><p>rust-analyzer</p>
<p>better toml 高亮 <code>.toml</code> 文件</p>
<p>Error Lens 直接在代码行提示错误和警告</p>
<hr>
<hr>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello,World!"></a>Hello,World!</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello-world.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello,world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fn main()&#123;&#125;</code>：一个名叫 <code>main</code> 的函数</li>
<li><code>println!()</code>：<strong>Rust 宏（macro）</strong>，看到 <strong><code>!</code></strong> 就是调用的宏</li>
<li><font color="red"><code>println()</code>：Rust 不存在该函数</font></li>
<li><strong><code>;</code></strong>：大部分 Rust 代码以分号结尾</li>
</ul>
<p><strong>编译：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc 文件.rs</span><br></pre></td></tr></table></figure>

<p><strong>运行：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\文件</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611124045772.png" alt="image-20250611124045772"></p>
<p>运行 <strong>hello-world.rs</strong> 后会生成一个同名 <strong>.exe</strong> 文件</p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611113219788.png" alt="image-20250611113219788"></p>
<p>这意味着，可以在不安装 Rust 环境运行该 <strong>.exe</strong> 文件。</p>
<hr>
<hr>
<h2 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h2><p>Cargo 是 Rust 的构建系统和包管理器。（有点 Maven + SpringBoot的意思）</p>
<h3 id="cargo-new"><a href="#cargo-new" class="headerlink" title="cargo new"></a>cargo new</h3><p><strong>使用 Cargo 创建项目：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_cargo</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611114324964.png" alt="image-20250611114324964"></p>
<p><strong>生成：（直接生成目录）</strong></p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611114407384.png" alt="image-20250611114407384"></p>
<ul>
<li><p><strong>Cargo.toml</strong></p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span>  <span class="comment"># 与目录同名</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2024&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>[package]</code>：配置一个包</li>
<li><code>[dependencies]</code>：罗列项目依赖的开始</li>
</ul>
</li>
<li><p><strong>src&#x2F;main.rs</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>补充：</strong></p>
<p>将其他非 Cargo 项目转化为使用 Cargo 的项目，比如说上述的第一个 <strong>hello-world.rs</strong> 项目：</p>
<p><img src="/blog2025.github.io/image-20250611115805239.png"></p>
<ul>
<li><p><strong>步骤一：</strong></p>
<p>命令框进入 hello 文件夹</p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611115945414.png" alt="image-20250611115945414"></p>
</li>
<li><p><strong>步骤二：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo init</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611120157547.png" alt="image-20250611120157547"></p>
<p>效果：</p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611120216495.png" alt="image-20250611120216495"></p>
<p>注意：生成的 <strong>Cargo.toml</strong> 与目录同名</p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611120451144.png" alt="image-20250611120451144"></p>
</li>
<li><p>将 <strong>hello-world.exe</strong> 和 <strong>hello-world.rs</strong> 移入 src 文件夹即可</p>
</li>
</ul>
<hr>
<h3 id="cargo-build"><a href="#cargo-build" class="headerlink" title="cargo build"></a>cargo build</h3><p><strong>使用 Cargo 构建项目：</strong></p>
<p>生成的 <strong>.exe</strong> 文件不会放到 <strong>.rs</strong> 同级目录，而是放到 <strong>&#x2F;target&#x2F;debug</strong> 中，且与目录同名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611121515302.png" alt="image-20250611121515302"></p>
<p><strong>生成：</strong></p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611121616909.png" alt="image-20250611121616909"></p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611121831549.png" alt="image-20250611121831549"></p>
<p><strong>运行：</strong></p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611121931669.png" alt="image-20250611121931669"></p>
<p><strong>Cargo.lock：</strong></p>
<p>记录项目依赖的实际版本，Cargo会自动管理该文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is automatically @generated by Cargo.</span></span><br><span class="line"><span class="comment"># It is not intended for manual editing.</span></span><br><span class="line">version = 4</span><br><span class="line"></span><br><span class="line">[[package]]</span><br><span class="line">name = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>发布（release）构建：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br><span class="line"><span class="comment"># 会在 target/release 而不是 target/debug 下生成 .exe 文件</span></span><br><span class="line"><span class="comment"># 可以让 Rust 代码运行的更快</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611123657319.png" alt="image-20250611123657319"></p>
<hr>
<h3 id="cargo-run"><a href="#cargo-run" class="headerlink" title="cargo run"></a>cargo run</h3><p><strong>使用 Cargo 一步构建并运行项目</strong>：<strong>（常用）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611122548845.png" alt="image-20250611122548845"></p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611122630660.png" alt="image-20250611122630660"></p>
<hr>
<h3 id="cargo-check"><a href="#cargo-check" class="headerlink" title="cargo check"></a>cargo check</h3><p><strong>使用 Cargo 在不生成二进制文件的情况下构建项目来检查错误。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo check</span><br><span class="line"><span class="comment"># 该命令快速检查代码确保其可以编译，但并不产生可执行文件：</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611122926339.png" alt="image-20250611122926339"></p>
<p>生成的文件中不包含同名的 <strong>.exe</strong> 文件</p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250611123008116.png" alt="image-20250611123008116"></p>
<hr>
<hr>
<h2 id="猜数字游戏"><a href="#猜数字游戏" class="headerlink" title="猜数字游戏"></a>猜数字游戏</h2><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p><strong>创建 <code>guessing_game</code> 项目：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new guessing_game</span><br></pre></td></tr></table></figure>

<p><strong>进入项目：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> guessing_game</span><br></pre></td></tr></table></figure>

<p><strong>运行项目：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><p><code>use std::io;</code></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>use</code></td>
<td>显式引入到当前作用域</td>
</tr>
<tr>
<td><code>std</code></td>
<td>标准库</td>
</tr>
<tr>
<td><code>::</code></td>
<td>运算符、关联函数</td>
</tr>
<tr>
<td><code>io</code></td>
<td>输入&#x2F;输出库（属于标准库）</td>
</tr>
</tbody></table>
<p>默认情况下，Rust 会自动预导入（prelude）若干个标准库内容。</p>
</li>
<li><p><code>fn main()&#123;&#125;</code></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>fn</code></td>
<td>声明一个新函数</td>
</tr>
<tr>
<td><code>main</code></td>
<td>函数名</td>
</tr>
<tr>
<td><code>()</code></td>
<td>没有参数</td>
</tr>
<tr>
<td><code>&#123;&#125;</code></td>
<td>函数体的开始与结束</td>
</tr>
</tbody></table>
</li>
<li><p><code>let mut guess = String::new();</code></p>
<p>创建了一个可变变量 <code>guess</code> ，当前它绑定到一个新的 <code>String</code> 空实例上。</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>let</code></td>
<td>定义变量</td>
</tr>
<tr>
<td><code>mut</code></td>
<td><strong>使变量可变</strong></td>
</tr>
<tr>
<td><code>guess</code></td>
<td>变量名</td>
</tr>
<tr>
<td><code>String</code></td>
<td>返回一个 String 类型的新实例</td>
</tr>
<tr>
<td><code>::</code></td>
<td>new 是 String 类型的关联函数（针对某个类型实现的函数）</td>
</tr>
<tr>
<td><code>new()</code></td>
<td>创建了一个新的空字符串</td>
</tr>
</tbody></table>
<p>在 Rust 中，变量声明后默认是不可变的，即变量赋值后不可以再修改。此时可以使用<code>mut</code>来使变量可变。</p>
</li>
<li><p><code>io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line">io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line"><span class="comment">//可写为：</span></span><br><span class="line">std::io::<span class="title function_ invoke__">stdin</span>()</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>io::stdin()</code></td>
<td>调用<code>io</code>库中的函数<code>stdin</code></td>
</tr>
<tr>
<td><code>.read_line()</code></td>
<td>调用标准输入句柄上的 <code>read_line()</code> 方法，获取用户输入</td>
</tr>
<tr>
<td><code>&amp;mut guess</code></td>
<td>作为<strong>可变</strong>参数传递给 <code>read_line()</code> 方法</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>表示参数是一个引用*（reference）*</td>
</tr>
</tbody></table>
<p><code>.read_line()</code> 会将用户输入附加到传递给它的字符串中，也会返回一个类型为 <code>Result</code>的值，<code>Result</code> 是一种 <em>enum</em> 枚举类型（包括：<em>Ok</em> 和 <em>Err</em>）</p>
<p><code>Result</code> 的实例拥有 <code>expect()</code> 方法</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>.expect(&quot;&quot;)</code></td>
<td><code>Result</code> 实例的方法</td>
</tr>
</tbody></table>
<ul>
<li><code>.read_line()</code>返回值 <code>Result</code> 为 <em>Ok</em> 时，<code>.expect()</code> 会获取 <em>Ok</em> 中的值并原样返回。</li>
<li><code>.read_line()</code>返回值 <code>Result</code> 为 <em>Err</em> 时，<code>.expect()</code> 会导致程序崩溃，并输出当做参数传递给<code>.expect()</code> 的信息。</li>
</ul>
<p>一般来说，都要调用<code>.expect()</code>，保证程序出现错误能够正确处理，<code>.expect()</code>会使程序在出现问题时立即崩溃。</p>
</li>
<li><p><code>println!(&quot;You guessed: &#123;guess&#125;&quot;);</code></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;&#125;</code></td>
<td>占位符</td>
</tr>
</tbody></table>
<ul>
<li>当打印变量的值时，变量名可以写进大括号中。</li>
<li>当打印表达式的执行结果时，格式化字符串（format string）中大括号中<strong>留空</strong>，格式化字符串后跟<strong>逗号分隔</strong>的需要打印的表达式列表，其顺序与每一个空大括号占位符的顺序一致。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125; and y + 2 = &#123;&#125;&quot;</span>, y + <span class="number">2</span>);</span><br><span class="line"><span class="comment">//输出 x = 5 and y + 2 = 12</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="标准库-std"><a href="#标准库-std" class="headerlink" title="标准库 std"></a><strong>标准库 std</strong></h3><ul>
<li>Rust 官方维护，无需额外声明依赖即可使用。</li>
<li>通过<code>use std::...</code>直接导入，无需额外配置。</li>
</ul>
<h3 id="crate：第三方库"><a href="#crate：第三方库" class="headerlink" title="crate：第三方库"></a><strong>crate：第三方库</strong></h3><ul>
<li>需要通过添加依赖到 <strong>Cargo.toml</strong> 引入，由社区维护。</li>
<li>使用<code>use crate_name::...</code>导入功能。</li>
<li>第三方库包含任意能被其他程序使用的代码，但是无法独立执行。</li>
</ul>
<h3 id="生成数字"><a href="#生成数字" class="headerlink" title="生成数字"></a><strong>生成数字</strong></h3><p>Rust <strong>标准库 std</strong> 中尚未包含随机数功能，可使用第三方库中的<code>rand</code> 生成</p>
<ul>
<li><p>引入 <code>rand</code> 依赖</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cargo.toml</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构建项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250612102551821.png" alt="image-20250612102551821"></p>
<p>此过程中，Cargo 不仅会引入 <code>rand</code> 还会引入与之相关的其他第三方库。</p>
<p>同时 <strong>Cargo.lock</strong> 会记录引入的依赖。</p>
<p>更新依赖使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo update</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成随机数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Guess the number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The secret number is: &#123;secret_number&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please input your guess.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You guessed: &#123;guess&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>use rand::Rng;</code></td>
<td>引入<code>rand</code>，并导入其中的 <code>Rng</code> 功能接口（trait）</td>
</tr>
<tr>
<td><code>rand::thread_rng()</code></td>
<td>获取当前线程的随机数生成器</td>
</tr>
<tr>
<td><code>gen_range(1..=100)</code></td>
<td>生成 1 到 100（包含）的随机整数</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="猜大小"><a href="#猜大小" class="headerlink" title="猜大小"></a>猜大小</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;猜数字！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;生成的数字为：&#123;secret_number&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;读错了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将guess从String转化为Integer</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;请输入一个数字&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//println!(&quot;你猜对了:&#123;guess&#125;&quot;);</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;你猜的数字为：&#123;guess&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number)&#123;</span><br><span class="line">        Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;小一些&quot;</span>),</span><br><span class="line">        Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;大一些&quot;</span>),</span><br><span class="line">        Ordering::Equal =&gt; <span class="built_in">println!</span>(<span class="string">&quot;猜对了！&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>代码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>use std::cmp::Ordering;</code></td>
<td><code>Ordering</code> 枚举，成员为： <code>Less</code>、<code>Greater</code> 和 <code>Equal</code></td>
</tr>
<tr>
<td><code>match guess.cmp(&amp;secret_number)</code></td>
<td>比较<code>guess</code>和<code>secret_number</code><br /><code>match</code> 表达式由 <strong>分支（arms）</strong> 构成，一个分支包含一个 <strong>模式</strong>（<em>pattern</em>）和表达式开头的值与分支模式相匹配时应该执行的代码</td>
</tr>
<tr>
<td><code>let guess: u32 = guess.trim().parse().expect(&quot;请输入一个数字&quot;);</code></td>
<td>32 位数字 <code>i32</code>；3<br />2 位无符号数字 <code>u32</code>；<br />64 位数字 <code>i64</code>；<br />Rust 默认使用 <code>i32</code>；<br /><code>trim</code> 方法会去除字符串开头和结尾的空白字符<br /><code>parse</code> 方法 将字符串转换成其他类型， <br /><code>parse</code> 方法返回一个 <code>Result</code> 类型，用 <code>expect</code> 方法处理即可。</td>
</tr>
</tbody></table>
<hr>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>增加循环和数字判定</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;猜数字！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;生成的数字为：&#123;secret_number&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;请输入你猜的数字：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    </span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;读错了&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将guess从String转化为Integer,同时增加输入值是否为数字的判定</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt;num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;请输入数字!!!&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//println!(&quot;你猜对了:&#123;guess&#125;&quot;);</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;你猜的数字为：&#123;guess&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number)&#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;小一些&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;大一些&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;猜对了！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>使用了<code>let</code> 声明变量，变量类型可以省略。</p>
<p>作用于<strong>局部作用域</strong></p>
<p>为什么 Rust 变量默认是<strong>不可改变</strong>的（immutable）？</p>
<p>答：防止变量的值被其他的代码更改，导致原先使用该变量的代码出现问题（<strong>安全性</strong>）</p>
<p>Rust 通过默认不可变将**“安全”<strong>前置，以编译器为</strong>守门员**拦截潜在风险，同时用 <code>mut</code> 保留必要灵活性。这一设计使 Rust 在系统编程领域兼顾安全、性能与开发效率。</p>
<p>Rust 变量<strong>不可改变</strong>的意义：</p>
<ul>
<li><strong>预防并发数据竞争</strong></li>
<li><strong>降低代码复杂性</strong></li>
<li><strong>编译器优化空间</strong></li>
<li><strong>支持函数式编程范式</strong></li>
<li><strong>避免与“变量遮蔽”混淆</strong></li>
</ul>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 报错：</span></span><br><span class="line"><span class="comment">error[E0384]: cannot assign twice to immutable variable `x`</span></span><br><span class="line"><span class="comment"> --&gt; main.rs:4:5</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">2 |     let x = 5;</span></span><br><span class="line"><span class="comment">  |         - first assignment to `x`</span></span><br><span class="line"><span class="comment">3 |     println!(&quot;The value of x is: &#123;x&#125;&quot;);</span></span><br><span class="line"><span class="comment">4 |     x = 6;</span></span><br><span class="line"><span class="comment">  |     ^^^^^ cannot assign twice to immutable variable</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">help: consider making this binding mutable</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">2 |     let mut x = 5;</span></span><br><span class="line"><span class="comment">  |         +++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">error: aborting due to 1 previous error</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">For more information about this error, try `rustc --explain E0384`.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>使变量可变：<code>mut</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Compiling hello_variables v0.1.0 (D:\blog\code\blog2025.github.io\rust\hello_variables)</span></span><br><span class="line"><span class="comment">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s</span></span><br><span class="line"><span class="comment">     Running `target\debug\hello_variables.exe`</span></span><br><span class="line"><span class="comment">The value of x is: 5</span></span><br><span class="line"><span class="comment">The value of x is: 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>不可变</p>
<p>不允许对常量使用 <code>mut</code></p>
<p>声明常量使用 <code>const</code> 关键字，必须显式标注类型</p>
<p>作用于<strong>全局作用域</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br><span class="line"><span class="comment">//const 常量名: 类型 = 值</span></span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h3 id="遮蔽"><a href="#遮蔽" class="headerlink" title="遮蔽"></a>遮蔽</h3><p>方法：</p>
<ul>
<li>可以用相同变量名称来遮蔽一个变量</li>
<li>可以重复使用 <code>let</code> 关键字来多次遮蔽</li>
</ul>
<p>第一个变量 x 被第二个变量 x 遮蔽，此时程序默认使用第二个变量 x</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Compiling hello_variables v0.1.0 (D:\blog\code\blog2025.github.io\rust\hello_variables)</span></span><br><span class="line"><span class="comment">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.17s</span></span><br><span class="line"><span class="comment">     Running `target\debug\hello_variables.exe`</span></span><br><span class="line"><span class="comment">The value of x in the inner scope is: 12</span></span><br><span class="line"><span class="comment">The value of x is: 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>首先，初始x &#x3D; 5，然后新变量 x 获取初始 x 的值并 +1 ,此时新变量 x &#x3D; 6 。依次往下……</p>
<p>总之就是后来的覆盖了原有的。</p>
<p>而对于<code>&#123;&#125;</code>的遮蔽，只是临时性的，当作用域结束时，内部遮蔽的作用域也就结束了，x 仍等于6 。</p>
<p><strong>遮蔽与 mut 的区别：</strong></p>
<table>
<thead>
<tr>
<th>‌<strong>特性</strong>‌</th>
<th>‌**遮蔽（Shadowing）**‌</th>
<th>‌**<code>mut</code>可变变量**‌</th>
</tr>
</thead>
<tbody><tr>
<td>‌<strong>关键字</strong>‌</td>
<td>必须使用 <code>let</code> 重新声明新变量（<code>let x = ...</code>）</td>
<td>仅在声明时使用 <code>mut</code>（<code>let mut x = ...</code>）</td>
</tr>
<tr>
<td>‌<strong>本质</strong>‌</td>
<td>创建同名‌<strong>新变量</strong>‌，隐藏旧绑定</td>
<td>同一变量的‌<strong>值可变</strong>‌</td>
</tr>
<tr>
<td>‌<strong>类型变更</strong>‌</td>
<td>✅ 允许（如 <code>let x=5; let x=&quot;text&quot;;</code>）</td>
<td>❌ 禁止（类型声明后不可变）</td>
</tr>
<tr>
<td>‌<strong>作用域</strong>‌</td>
<td>新变量仅在当前作用域生效，退出后恢复旧值</td>
<td>始终指向同一内存地址</td>
</tr>
<tr>
<td>‌<strong>内存占用</strong>‌</td>
<td>旧变量仍存在（但被隐藏），可能增加内存开销</td>
<td>始终占用同一内存位置</td>
</tr>
<tr>
<td>‌<strong>修改语法</strong>‌</td>
<td>需重新声明：<code>let x = 新值;</code></td>
<td>直接赋值：<code>x = 新值;</code></td>
</tr>
<tr>
<td>‌<strong>典型场景</strong>‌</td>
<td>类型转换（如字符串转长度）或不同阶段语义变更</td>
<td>循环计数器或需要频繁更新的状态</td>
</tr>
</tbody></table>
<hr>
<hr>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。</p>
<p>两类数据类型子集：<strong>标量（scalar）<strong>和</strong>复合（compound）</strong></p>
<ul>
<li><p><strong>标量（scalar）</strong>：代表一个单独的值。</p>
<ul>
<li><p>整型：<strong>有符号</strong> 和 <strong>无符号</strong> 代表数字能否为负值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = -<span class="number">2</span>; <span class="comment">// i32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">u32</span> = <span class="number">3</span>; <span class="comment">// u32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有符号：<strong><code>i</code></strong></p>
<p>每一个有符号的变体可以储存包含从 -(2n - 1) 到 2n - 1 - 1 在内的数字</p>
</li>
<li><p>无符号：<strong><code>u</code></strong></p>
<p>无符号的变体可以储存从 0 到 2n - 1 的数字</p>
</li>
<li><p>字面值：</p>
<table>
<thead>
<tr>
<th>数字字面值</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>Decimal (十进制)</td>
<td><code>98_222</code></td>
</tr>
<tr>
<td>Hex (十六进制)</td>
<td><code>0xff</code></td>
</tr>
<tr>
<td>Octal (八进制)</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>Binary (二进制)</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr>
<td>Byte (单字节字符)(仅限于<code>u8</code>)</td>
<td><code>b&#39;A&#39;</code></td>
</tr>
</tbody></table>
</li>
<li><p>整型溢出</p>
<p>为了显式地处理溢出的可能性，可以使用这几类标准库提供的原始数字类型方法：</p>
<ul>
<li>所有模式下都可以使用 <code>wrapping_*</code> 方法进行 wrapping，如 <code>wrapping_add</code></li>
<li>如果 <code>checked_*</code> 方法出现溢出，则返回 <code>None</code>值</li>
<li>用 <code>overflowing_*</code> 方法返回值和一个布尔值，表示是否出现溢出</li>
<li>用 <code>saturating_*</code> 方法在值的最小值或最大值处进行饱和处理</li>
</ul>
</li>
</ul>
</li>
<li><p>浮点型</p>
<p>默认为 <code>f64</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>布尔类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符类型 <code>char</code> </p>
<p>用<strong>单引号</strong>声明 <code>char</code> 字面值</p>
<p>使用<strong>双引号</strong>声明字符串字面值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>复合（compound）</strong>：</p>
<ul>
<li><p>元组（tuple）</p>
<p>元组中的每个元素的类型<strong>可以不同</strong></p>
<p>元组长度固定：一旦声明，其长度不会增大或缩小。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//解构（destructuring）</span></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line">    <span class="comment">//模式匹配（pattern matching）</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者使用点号（.）后跟值的索引来直接访问所需的元组元素</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//使用点号（.）</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = tup.<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;one&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p>
</li>
<li><p>数组（array）</p>
<p>数组中的每个元素的类型<strong>必须相同</strong></p>
<p>数组长度是<strong>固定</strong>的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者这么写：</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">//特殊写法：</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">/*等价于*/</span> <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>数组并不如 vector 类型灵活。</p>
<p>vector 类型是标准库提供的一个 <strong>允许</strong> 增长和缩小长度的类似数组的集合类型。</p>
<p>当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问数组元素</span></span><br><span class="line"><span class="comment">// 数组是可以在栈 (stack) 上分配的已知固定大小的单个内存块,可以使用索引来访问数组的元素。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一个 Rust 安全原则：</strong></p>
<p>当访问一个不在数组范围内的元素时，<strong>Rust 会检查指定的索引是否小于数组的长度</strong>。如果索引超出了数组长度，Rust 会 <em>panic</em>（恐慌），即 Rust 会因为错误而退出。</p>
<p>其他底层语言没有此类检查，因此其他语言访问一个超出范围的元素时，会访问无效的内存，而不是直接退出，这会导致意外错误。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table>
<thead>
<tr>
<th>‌<strong>类型分类</strong>‌</th>
<th>‌<strong>具体类型</strong>‌</th>
<th>‌<strong>含义</strong>‌</th>
<th>‌<strong>占用字节</strong>‌</th>
<th>‌<strong>取值范围&#x2F;说明</strong>‌</th>
</tr>
</thead>
<tbody><tr>
<td>‌<strong>整数类型</strong>‌</td>
<td><code>i8</code></td>
<td>有符号8位整数</td>
<td>1字节</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td></td>
<td><code>u8</code></td>
<td>无符号8位整数</td>
<td>1字节</td>
<td>0 ~ 255（常用于字节数据）</td>
</tr>
<tr>
<td></td>
<td><code>i16</code></td>
<td>有符号16位整数</td>
<td>2字节</td>
<td>-32,768 ~ 32,767</td>
</tr>
<tr>
<td></td>
<td><code>u16</code></td>
<td>无符号16位整数</td>
<td>2字节</td>
<td>0 ~ 65,535</td>
</tr>
<tr>
<td></td>
<td><code>i32</code></td>
<td>有符号32位整数</td>
<td>4字节</td>
<td>-2,147,483,648 ~ 2,147,483,647（‌<strong>默认整数类型</strong>‌）</td>
</tr>
<tr>
<td></td>
<td><code>u32</code></td>
<td>无符号32位整数</td>
<td>4字节</td>
<td>0 ~ 4,294,967,295（适合计数、ID等场景）</td>
</tr>
<tr>
<td></td>
<td><code>i64</code></td>
<td>有符号64位整数</td>
<td>8字节</td>
<td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td></td>
<td><code>u64</code></td>
<td>无符号64位整数</td>
<td>8字节</td>
<td>0 ~ 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td></td>
<td><code>i128</code></td>
<td>有符号128位整数</td>
<td>16字节</td>
<td>极大范围（科学计算等场景）</td>
</tr>
<tr>
<td></td>
<td><code>u128</code></td>
<td>无符号128位整数</td>
<td>16字节</td>
<td>0 ~ 340 涧（1涧&#x3D;10^36）</td>
</tr>
<tr>
<td></td>
<td><code>isize</code></td>
<td>有符号指针大小整数</td>
<td>平台相关</td>
<td>32位系统占4字节，64位系统占8字节（用于集合索引）</td>
</tr>
<tr>
<td></td>
<td><code>usize</code></td>
<td>无符号指针大小整数</td>
<td>平台相关</td>
<td>同<code>isize</code>，Rust数组索引强制要求此类型</td>
</tr>
<tr>
<td>‌<strong>浮点类型</strong>‌</td>
<td><code>f32</code></td>
<td>单精度浮点数</td>
<td>4字节</td>
<td>约6-7位有效数字（性能优先时使用）</td>
</tr>
<tr>
<td></td>
<td><code>f64</code></td>
<td>双精度浮点数</td>
<td>8字节</td>
<td>约15-16位有效数字（‌<strong>默认浮点类型</strong>‌）</td>
</tr>
<tr>
<td>‌<strong>布尔类型</strong>‌</td>
<td><code>bool</code></td>
<td>布尔值</td>
<td>1字节</td>
<td><code>true</code> 或 <code>false</code>（实际仅需1位，但内存对齐优化为1字节）</td>
</tr>
<tr>
<td>‌<strong>字符类型</strong>‌</td>
<td><code>char</code></td>
<td>Unicode标量值</td>
<td>4字节</td>
<td>任意有效Unicode字符（如<code>&#39;A&#39;</code>, <code>&#39;中&#39;</code>, <code>&#39;😀&#39;</code>）</td>
</tr>
<tr>
<td>‌<strong>特殊类型</strong>‌</td>
<td><code>()</code></td>
<td>单元类型</td>
<td>0字节</td>
<td>表示“无返回值”，类似其他语言的<code>void</code></td>
</tr>
<tr>
<td></td>
<td><code>!</code></td>
<td>Never类型</td>
<td>-</td>
<td>表示永不返回（如<code>panic!()</code>或无限循环的返回值类型）</td>
</tr>
</tbody></table>
<hr>
<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>main</code> 函数：很多程序的入口点。</p>
<p><code>fn</code> 关键字：用来声明新函数。</p>
<p>Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格，即所有字母都是<strong>小写</strong>并使用<strong>下划线</strong>分隔单词。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">	<span class="comment">//调用函数</span></span><br><span class="line">    <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Another function.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>参数（<em>parameters</em>）：</strong></p>
<p>当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。</p>
<p>函数拥有参数时，<strong>必须</strong> 声明每个参数的类型。</p>
<ul>
<li><p>单参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多参数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_labeled_measurement</span>(<span class="number">5</span>, <span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_labeled_measurement</span>(value: <span class="type">i32</span>, unit_label: <span class="type">char</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The measurement is: &#123;value&#125;&#123;unit_label&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>语句与表达式：</strong></p>
<ul>
<li><p><strong>语句</strong>（<em>Statements</em>）是执行一些操作但不返回值的指令。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>表达式</strong>（<em>Expressions</em>）计算并产生一个<strong>值</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>不能把 <code>let</code> 语句赋值给另一个变量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**报错</span></span><br><span class="line"><span class="comment">warning: `functions` (bin &quot;functions&quot;) generated 1 warning</span></span><br><span class="line"><span class="comment">error: could not compile `functions` (bin &quot;functions&quot;) due to 1 previous error; 1 warning emitted</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure>

<p>表达式会计算出一个值，所以能把表达式赋值给另一个变量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>具有返回值的函数：</strong></p>
<p><font color="red">分号**<code>;</code>**的重要性。</font></p>
<p>函数可以向调用它的代码返回值。</p>
<p>我们并不对返回值命名，但要在箭头（<strong><code>-&gt;</code></strong>）后声明它的<strong>类型</strong>。</p>
<p>使用 <code>return</code> 关键字和指定值，可从函数中提前返回。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">5</span>	<span class="comment">//没有加分号，说明是一个表达式，如果加了分号，则会变为语句，会导致报错。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">five</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>Rust 代码中最常见的用来控制执行流的结构是 <code>if</code> 表达式和循环。</p>
<ul>
<li><p><strong><code>if</code></strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 并不会尝试自动地将非布尔值转换为布尔值。</p>
<p>必须总是显式地使用布尔值作为 <code>if</code> 的条件。</p>
<p>即条件<strong>必须</strong>是 <code>bool</code> 值。</p>
</li>
<li><p><code>else if</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用过多的 <code>else if</code> 表达式会使代码显得杂乱无章，所以如果有多于一个 <code>else if</code> 表达式，最好重构代码。为此，可以使用 Rust 分支结构（branching construct），即 <code>match</code>。</p>
</li>
<li><p>在 <code>let</code> 语句中使用 <code>if</code></p>
<p> <code>if</code> 是一个表达式，我们可以在 <code>let</code> 语句的右侧使用它，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;number&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：因为是将表达式赋值给变量 <code>number</code>，所以必须保证 if 表达式中<strong>类型的统一</strong>，如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="string">&quot;six&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 会报错</span></span><br><span class="line"><span class="comment">/**Compiling hello_variables v0.1.0 (D:\blog\code\blog2025.github.io\rust\hello_variables)</span></span><br><span class="line"><span class="comment">error[E0308]: `if` and `else` have incompatible types</span></span><br><span class="line"><span class="comment">  --&gt; src\main.rs:47:44</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">47 |     let number = if condition &#123; 5 &#125; else &#123; &quot;six&quot; &#125;;</span></span><br><span class="line"><span class="comment">   |                                 -          ^^^^^ expected integer, found `&amp;str`</span></span><br><span class="line"><span class="comment">   |                                 |</span></span><br><span class="line"><span class="comment">   |                                 expected because of this</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">For more information about this error, try `rustc --explain E0308`.</span></span><br><span class="line"><span class="comment">error: could not compile `hello_variables` (bin &quot;hello_variables&quot;) due to 1 previous error</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>循环（<em>loops</em>）重复执行</strong></p>
<ul>
<li><p><code>loop</code></p>
<p><code>loop</code> 关键字告诉 Rust 一遍又一遍地执行一段代码直到你<strong>明确要求停止</strong>。</p>
<p>这个搞死循环很方便。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以使用 <strong><code>break</code></strong> 退出循环。</p>
<ul>
<li><p>从循环返回值。</p>
<p><strong><code>break 值;</code></strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用**<code>continue</code>** 告诉程序跳过这个循环迭代中的任何剩余代码，并转到下一个迭代。</p>
</li>
</ul>
<p><strong>循环标签<code>&#39;&#39;</code>：在多个循环之间消除歧义</strong></p>
<p>如果存在嵌套循环，<code>break</code> 和 <code>continue</code> 应用于此时最内层的循环。你可以选择在一个循环上指定一个 <strong>循环标签</strong>（<em>loop label</em>），然后将标签与 <code>break</code> 或 <code>continue</code> 一起使用，使这些关键字<strong>应用于已标记的循环</strong>而不是最内层的循环。</p>
<p>如：</p>
<p>外层循环有一个标签 <code>counting_up</code>，它将从 0 数到 2。没有标签的内部循环从 10 向下数到 9。第一个没有指定标签的 <code>break</code> 将只退出内层循环。<code>break &#39;counting_up;</code> 语句将退出外层循环。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">Compiling hello_variables v0.1.0 (D:\blog\code\blog2025.github.io\rust\hello_variables)</span></span><br><span class="line"><span class="comment">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.17s</span></span><br><span class="line"><span class="comment">     Running `target\debug\hello_variables.exe`</span></span><br><span class="line"><span class="comment">count = 0</span></span><br><span class="line"><span class="comment">remaining = 10</span></span><br><span class="line"><span class="comment">remaining = 9</span></span><br><span class="line"><span class="comment">count = 1</span></span><br><span class="line"><span class="comment">remaining = 10</span></span><br><span class="line"><span class="comment">remaining = 9</span></span><br><span class="line"><span class="comment">count = 2</span></span><br><span class="line"><span class="comment">remaining = 10</span></span><br><span class="line"><span class="comment">End count = 2</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>while</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>while</code> 结构来遍历集合中的元素</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, a[index]);</span><br><span class="line"></span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">$ cargo run</span></span><br><span class="line"><span class="comment">   Compiling loops v0.1.0 (file:///projects/loops)</span></span><br><span class="line"><span class="comment">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s</span></span><br><span class="line"><span class="comment">     Running `target/debug/loops`</span></span><br><span class="line"><span class="comment">the value is: 10</span></span><br><span class="line"><span class="comment">the value is: 20</span></span><br><span class="line"><span class="comment">the value is: 30</span></span><br><span class="line"><span class="comment">the value is: 40</span></span><br><span class="line"><span class="comment">the value is: 50</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure>

<p>这个过程很容易出错；如果索引长度或测试条件不正确会导致程序 panic。例如，如果将 <code>a</code> 数组的定义改为包含 4 个元素而忘记了更新条件 <code>while index &lt; 4</code>，则代码会 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环进行条件检查，以确定在循环的每次迭代中索引是否在数组的边界内。</p>
<p>可以使用 <code>for</code> 来解决</p>
</li>
<li><p><code>for</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;element&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增强了代码安全性，并消除了可能由于超出数组的结尾或遍历长度不够而缺少一些元素而导致的 bug。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒计时</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul>
<li><p>相互转换摄氏与华氏温度。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">celsius_to_fahrenheit</span>(c: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    (c * <span class="number">9.0</span> / <span class="number">5.0</span>) + <span class="number">32.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fahrenheit_to_celsius</span>(f: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">    (f - <span class="number">32.0</span>) * <span class="number">5.0</span> / <span class="number">9.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">celsius</span> = <span class="number">25.0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fahrenheit</span> = <span class="title function_ invoke__">celsius_to_fahrenheit</span>(celsius);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;°C = &#123;&#125;°F&quot;</span>, celsius, fahrenheit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fahrenheit</span> = <span class="number">77.0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">celsius</span> = <span class="title function_ invoke__">fahrenheit_to_celsius</span>(fahrenheit);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;°F = &#123;&#125;°C&quot;</span>, fahrenheit, celsius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成第 n 个斐波那契数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现（时间复杂度O(2^n)）</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fib_recursive</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> n &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="number">1</span>,</span><br><span class="line">        _ =&gt; <span class="title function_ invoke__">fib_recursive</span>(n-<span class="number">1</span>) + <span class="title function_ invoke__">fib_recursive</span>(n-<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代实现（时间复杂度O(n)）</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fib_iterative</span>(n: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> a, <span class="keyword">mut</span> b) = (<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tmp</span> = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp + b;</span><br><span class="line">    &#125;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="number">10</span>;<span class="comment">//打印第10个</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;递归: fib(&#123;&#125;) = &#123;&#125;&quot;</span>, n, <span class="title function_ invoke__">fib_recursive</span>(n));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;迭代: fib(&#123;&#125;) = &#123;&#125;&quot;</span>, n, <span class="title function_ invoke__">fib_iterative</span>(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<hr>
<h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>所有权（系统）是 Rust 最为与众不同的特性，对语言的其他部分有着深刻含义。</p>
<p>所有权让 Rust 无需垃圾回收（garbage collector）即可保障内存安全。</p>
<p><strong>功能：</strong></p>
<ul>
<li><p>借用（borrowing）</p>
</li>
<li><p>slice</p>
</li>
<li><p>Rust 如何在内存中布局数据</p>
</li>
</ul>
<h3 id="什么是所有权？"><a href="#什么是所有权？" class="headerlink" title="什么是所有权？"></a><strong>什么是所有权？</strong></h3><p><strong>所有权</strong>（<em>ownership</em>）是 Rust 用于如何管理<strong>内存</strong>的一组规则。</p>
<p><strong>所有权</strong>的主要目的就是管理堆数据</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><ul>
<li><p>通过<strong>所有权</strong>系统管理内存，编译器在编译时会根据一系列的<strong>规则</strong>进行检查。</p>
<p>如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序的运行。（Rust）</p>
</li>
<li><p>在程序运行时有规律地寻找不再使用的内存，自动回收垃圾。（Java）</p>
</li>
<li><p>程序员必须亲自分配和释放内存。（C）</p>
</li>
</ul>
<h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a><strong>栈和堆</strong></h3><p>入栈比在堆上配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。</p>
<p>在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p>
<p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。</p>
<p><strong>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。</strong></p>
<h3 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a><strong>所有权规则</strong></h3><ol>
<li>Rust 中的每一个值都有一个 <strong>所有者</strong>（<em>owner</em>）。</li>
<li>值在任一时刻有且只有一个所有者。</li>
<li>当所有者离开作用域，这个值将被丢弃。</li>
</ol>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p><strong>字符串字面值：</strong></p>
<ul>
<li><p>**定义：**被硬编码进程序里的字符串值</p>
</li>
<li><p><strong>特性：</strong><font color="red"><strong>不可变</strong></font>，<strong>存在</strong>不可预知性（如需要命令框输入后才能知晓）</p>
</li>
<li><p>硬编码在程序中（如 <code>&quot;hello&quot;</code>），不可变且编译时大小已知，存储在栈或二进制文件的只读段</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125;,world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250614103552095.png" alt="image-20250614103552095"></p>
<p><strong>String类型：</strong></p>
<ul>
<li><p>管理被分配到堆上的数据。</p>
</li>
<li><p>能够存储在编译时未知大小的文本。</p>
</li>
<li><p>使用 <code>from</code> 函数基于字符串字面值来创建 <code>String</code>。</p>
</li>
<li><p><strong>特性</strong>：<font color="red"><strong>可变</strong></font></p>
</li>
<li><p>动态分配在堆上，支持可变性（如追加内容），适用于运行时才能确定的文本（如用户输入）</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() 在字符串后追加字面值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;&quot;</span>); <span class="comment">// 将打印 `hello, world!`</span></span><br></pre></td></tr></table></figure>

<p> <code>::</code> 是运算符，允许将特定的 <code>from</code> 函数置于 <code>String</code> 类型的命名空间（namespace）下，而不需要使用类似 <code>string_from</code> 这样的名字。</p>
<h3 id="内存与分配"><a href="#内存与分配" class="headerlink" title="内存与分配"></a>内存与分配</h3><ol>
<li>‌<strong>字符串字面值是编译时已知的</strong>‌<ul>
<li>例子：<code>let s = &quot;hello&quot;;</code></li>
<li>特点：内容硬编码在程序中，编译时完全确定（包括内容和长度）</li>
<li>结果：直接嵌入可执行文件，高效但不可变</li>
</ul>
</li>
<li>‌<strong>运行时字符串是未知的</strong>‌<ul>
<li>例子：<code>let input = String::new(); std::io::stdin().read_line(&amp;mut input);</code></li>
<li>特点：用户输入&#x2F;网络数据等只能在程序运行时确定</li>
<li>结果：需要堆内存动态分配，支持可变操作</li>
</ul>
</li>
</ol>
<p>两段话实际上是在阐述同一个事实的不同方面：</p>
<ul>
<li>字符串字面值因其‌<strong>编译时确定性</strong>‌获得高性能</li>
<li>但同样因此‌<strong>无法处理运行时不确定的内容</strong>‌</li>
<li>这就引出了需要动态内存管理的 <code>String</code> 类型</li>
</ul>
<p>Rust 通过区分这两种字符串类型，既保证了确定文本的高效处理，又为动态文本提供了灵活性。</p>
<p>对于 <code>String</code> 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块<strong>在编译时未知大小的内存</strong>来存放内容。这意味着：</p>
<ul>
<li><p>必须在运行时向内存分配器（memory allocator）请求内存。</p>
<p>由开发者手动完成：当调用 <code>String::from</code> 时，请求其所需的内存。</p>
</li>
<li><p>需要一个当我们处理完 <code>String</code> 时将内存返回给分配器的方法。</p>
<p>即<strong>垃圾回收机制</strong>。</p>
<p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                                  <span class="comment">// 此作用域已结束，</span></span><br><span class="line">                                   <span class="comment">// s 不再有效</span></span><br></pre></td></tr></table></figure>

<p>当 <code>s</code> 离开作用域的时候，Rust 为我们调用一个特殊的函数。这个函数叫做 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>，去释放内存的代码。（堆内存）</p>
</li>
</ul>
<hr>
<h3 id="移动和克隆"><a href="#移动和克隆" class="headerlink" title="移动和克隆"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BD%BF%E7%94%A8%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">移动和克隆</a></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">y</span> = x; </span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;x&#125;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“将 <code>5</code> 绑定到 <code>x</code>；接着生成一个值 <code>x</code> 的拷贝并绑定到 <code>y</code>”。现在有了两个变量，<code>x</code> 和 <code>y</code>，都等于 <code>5</code>。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 <code>5</code> 被压入了栈中。</p>
<p>这里没有调用<code>clone</code>，但是 x 依然有效，且没有被移动到 y 中，这是因为整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝是快速的，不存在创建变量 <code>y</code> 后使 <code>x</code> 无效。换句话说，这里<strong>没有深浅拷贝的区别</strong>。</p>
<p><strong>而下面的字符串例子则有很大不同：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250614105500546.png" alt="image-20250614105500546"></p>
<p><strong>解释：</strong></p>
<p><strong>上述的代码很像浅拷贝，即 s2 复制了 s1的内容，但没有额外开辟新的内存空间，即 s2 和 s1 指向同一块内存空间。</strong></p>
<p>当变量离开作用域后，Rust 自动调用 <code>drop</code> 函数并<strong>清理变量的堆内存</strong>。这就有了一个问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域，它们都会尝试释放相同的内存。</p>
<p>这是一个叫做 <strong>二次释放</strong>（<em>double free</em>）的错误，也是之前提到过的内存安全性 bug 之一。</p>
<p>两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>为了确保内存安全，在 <code>let s2 = s1;</code> 之后，<strong>Rust 认为 <code>s1</code> 不再有效</strong>，因此 Rust 不需要在 <code>s1</code> 离开作用域后清理任何东西。如上图所示，Rust 禁止你使用无效的引用。</p>
<h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a><strong>移动</strong></h4><p>Rust 对应浅拷贝的新特性：不仅包含浅拷贝的特性，即拷贝指针、长度和容量而不拷贝数据。但其同时也会使第一个变量无效了。就是上述的例子所示，s1 失效，s2 有效。</p>
<p><font color="red"><strong>注意：Rust 永远也不会自动创建数据的 “深拷贝”。</strong></font></p>
<h4 id="作用域与赋值"><a href="#作用域与赋值" class="headerlink" title="作用域与赋值"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E8%B5%8B%E5%80%BC">作用域与赋值</a></h4><p>作用域、所有权和通过 <code>drop</code> 函数释放内存之间的关系反过来也同样成立。</p>
<p>当你给一个已有的变量赋一个全新的值时，Rust 将会立即调用 <code>drop</code> 并释放原始值的内存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">s = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;ahoy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s&#125;, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92">克隆</a></h4><p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，使用<code>clone</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">    let s2 = s1.clone();</span><br><span class="line">    println!(&quot;&#123;s1&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250614110811892.png" alt="image-20250614110811892"></p>
<p>当出现 <code>clone</code> 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。你很容易察觉到一些不寻常的事情正在发生。</p>
<h4 id="Copy-特性"><a href="#Copy-特性" class="headerlink" title="Copy  特性"></a>Copy  特性</h4><p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 <code>Copy</code> trait，那么<strong>一个旧的变量在将其赋值给其他变量后仍然有效。</strong></p>
<p>Rust <strong>不允许</strong>自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。</p>
<p><strong>哪些类型实现了 <code>Copy</code> trait？</strong></p>
<ul>
<li>任何一组简单标量值的组合都可以实现 <code>Copy</code>，任何不需要分配内存或某种形式资源的类型都可以实现 <code>Copy</code>。</li>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li>
</ul>
<hr>
<h3 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%8E%E5%87%BD%E6%95%B0">所有权与函数</a></h3><p>将<strong>值传递给函数</strong>与给<strong>变量赋值</strong>的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);              <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 没有特殊之处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_string&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line">  <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;some_integer&#125;&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。没有特殊之处</span></span><br></pre></td></tr></table></figure>

<p>当尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code> 时，Rust 会抛出一个编译时错误。</p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250614112404232.png" alt="image-20250614112404232"></p>
<hr>
<h3 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F">返回值与作用域</a></h3><p>返回值也可以转移所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();        <span class="comment">// gives_ownership 将它的返回值传递给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);    <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2); <span class="comment">// s2 被传入 takes_and_gives_back, </span></span><br><span class="line">                                       <span class="comment">// 它的返回值又传递给 s3</span></span><br><span class="line">&#125; <span class="comment">// 此处，s3 移出作用域并被丢弃。s2 被 move，所以无事发生</span></span><br><span class="line">  <span class="comment">// s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;       <span class="comment">// gives_ownership 将会把返回值传入</span></span><br><span class="line">                                       <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    some_string                        <span class="comment">// 返回 some_string 并将其移至调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时它会移动。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p>
<p>虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数<strong>使用一个值但不获取所有权</strong>该怎么办呢？<strong>如果我们还要接着使用它的话，每次都传进去再返回来</strong>就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p>
<p>我们可以使用元组来返回多个值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s2&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() 返回字符串的长度</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 <strong>引用</strong>（<em>references</em>）。</p>
<hr>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用&amp;"></a>引用&amp;</h3><p><strong>引用</strong>（<em>reference</em>）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。<strong>允许你使用值但不获取其所有权</strong>。</p>
<p>与指针不同，引用在其生命周期内保证指向某个特定类型的有效值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s1&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：与使用 <code>&amp;</code> 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符 <code>*</code> 实现。</p>
<p>再如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br></pre></td></tr></table></figure>

<p><code>&amp;s1</code> 语法让我们创建一个<strong>指向</strong>值 <code>s1</code> 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。</p>
<p>同理，函数签名使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123; <span class="comment">// s 是 String 的引用</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125; <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生</span></span><br></pre></td></tr></table></figure>

<p>变量 <code>s</code> 有效的作用域与函数参数的作用域一样，不过当 <code>s</code> 停止使用时并不丢弃引用指向的数据，因为 <code>s</code> 并没有所有权。当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。</p>
<h4 id="借用"><a href="#借用" class="headerlink" title="借用"></a><strong>借用</strong></h4><p>我们将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）。</p>
<p>正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完后，必须还回去。因为我们并不拥有它的所有权。</p>
<p><strong>借用的变量是无法修改其值的。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250614114659097.png" alt="image-20250614114659097"></p>
<p>**可变引用：**修复上述问题（加<code>mut</code>）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。这些尝试创建两个 <code>s</code> 的可变引用的代码会失败：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250614114934090.png" alt="image-20250614114934090"></p>
<p>不能在同一时间多次将 <code>s</code> 作为可变变量借用。</p>
<p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p>
<ul>
<li>两个或更多指针同时访问同一数据。</li>
<li>至少有一个指针被用来写入数据。</li>
<li>没有同步数据访问的机制。</li>
</ul>
<p>数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 通过拒绝编译存在数据竞争的代码来避免此问题！</p>
<p><strong>但是可以采用作用域来实现拥有多个可变引用</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    &#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们不能在拥有不可变引用的同时拥有可变引用。</strong></p>
<p>不可变引用的借用者可不希望在借用时值会突然发生改变！</p>
<p><strong>拥有多个不可变引用是可以的</strong>，因为没有哪个只能读取数据的引用者能够影响其他引用者读取到的数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不报错，因为存在了作用域</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;r1&#125; and &#123;r2&#125;&quot;</span>);</span><br><span class="line">    <span class="comment">// 此位置之后 r1 和 r2 不再使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;r3&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8dangling-references">悬垂引用</a></h4><p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个<strong>悬垂指针</strong>（<em>dangling pointer</em>），指向可能已被分配给其他用途的内存位置的指针。</p>
<p>相比之下，在 Rust 中编译器确保引用<strong>永远也不会变成悬垂引用</strong>：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// dangle 返回一个字符串的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 是一个新字符串</span></span><br><span class="line"></span><br><span class="line">    &amp;s <span class="comment">// 返回字符串 s 的引用</span></span><br><span class="line">&#125; <span class="comment">// 这里 s 离开作用域并被丢弃。其内存被释放。</span></span><br><span class="line">  <span class="comment">// 危险！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99">引用的规则</a></h4><p>让我们概括一下之前对引用的讨论：</p>
<ul>
<li>在任意给定时间，<strong>要么</strong>只能有一个可变引用，<strong>要么</strong>只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<hr>
<h3 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片 Slice"></a>切片 Slice</h3><p><strong>切片</strong>（<em>slice</em>）允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一种引用，所以它<strong>不拥有所有权</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();	<span class="comment">// 将 String 转化为字节数组。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个迭代器</span></span><br><span class="line">    <span class="comment">// iter 方法返回集合中的每一个元素，而 enumerate 包装了 iter 的结果</span></span><br><span class="line">    <span class="comment">// enumerate 返回的元组中，第一个元素是索引，第二个元素是集合中元素的引用。</span></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;	</span><br><span class="line">        <span class="comment">// 通过字节的字面值语法来寻找代表空格的字节,如果找到了一个空格，返回它的位置。否则，使用 s.len() 返回字符串的长度。</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>字符串 slice</strong></p>
<p><strong>字符串 slice</strong>（<em>string slice</em>）是 <code>String</code> 中一部分值的引用，它看起来像这样：</p>
<p><code>[starting_index..ending_index]</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从索引0开始到索引2</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从索引3开始到索引末</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..];</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取整个字符串的 slice</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure>

<p>优化上述<strong>切片</strong>代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B0%B1%E6%98%AF-slice"><strong>字符串字面值就是 slice</strong></a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里 <code>s</code> 的类型是 <code>&amp;str</code>：它是一个指向二进制程序特定位置的 slice。这也就是为什么字符串字面值是不可变的；<code>&amp;str</code> 是一个不可变引用。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><strong>字符串 slice 作为参数</strong></a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于 `String`（的 slice），部分或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line">    <span class="comment">// `first_word` 也适用于 `String` 的引用，</span></span><br><span class="line">    <span class="comment">// 这等价于整个 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于字符串字面值，部分或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值已经是字符串 slice 了，</span></span><br><span class="line">    <span class="comment">// 这也是适用的，无需 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84-slice"><strong>其他类型的 slice</strong></a></p>
<p>字符串 slice，正如你想象的那样，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>这个 slice 的类型是 <code>&amp;[i32]</code>。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。</p>
<hr>
<hr>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>结构体和我们在“元组类型”部分论过的元组类似，它们都包含多个相关的值。</p>
<p>和元组一样，结构体的每一部分可以是不同类型。</p>
<p>但不同于元组，结构体需要命名各部分数据以便能清楚的表明其值的意义。</p>
<p>结构体比元组更灵活：不需要依赖顺序来指定或访问实例中的值。</p>
<p><strong>结构：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用<code>.</code>获取值</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数带参数的结构体</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用字段初始化简写语法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username,</span><br><span class="line">        email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>借助旧实例创建新的结构体实例：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用结构体更新语法，我们可以通过更少的代码来达到相同的效果。<strong><code>..</code></strong> 语法指定了剩余未显式设置值的字段应有与给定实例对应字段相同的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1	<span class="comment">//必须放在最后，以指定其余的字段应从 user1 的相应字段中获取其值</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">总体上说我们在创建 <code>user2</code> 后就不能再使用 <code>user1</code> 了，因为 <code>user1</code> 的 <code>username</code> 字段中的 <code>String</code> 被移到 <code>user2</code> 中。</font></p>
<p>如果我们给 <code>user2</code> 的 <code>email</code> 和 <code>username</code> 都赋予新的 <code>String</code> 值，从而只复用 <code>user1</code> 的 <code>active</code> 和 <code>sign_in_count</code> 值，那么 <code>user1</code> 在创建 <code>user2</code> 后仍然有效。</p>
<hr>
<p><strong>使用没有命名字段的元组结构体来创建不同的类型：</strong></p>
<p>也可以定义与元组类似的结构体，称为 <strong>元组结构体</strong>（<em>tuple structs</em>）。</p>
<p>元组结构体有着结构体名称提供的含义，但没有具体的字段名，<strong>只有字段的类型</strong>。</p>
<p>当你想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的，这时像常规结构体那样为每个字段命名就显得多余和形式化了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与元组不同的是，解构元组结构体时必须写明结构体的类型。例如，我们可以写 <code>let Point(x, y, z) = origin;</code>，将 <code>origin</code> 的值解构到名为 <code>x</code>、<code>y</code> 和 <code>z</code> 的变量中。</p>
<hr>
<p><strong>没有任何字段的类单元结构体：</strong></p>
<p><strong>类单元结构体</strong></p>
<p>类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-01-defining-structs.html#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><strong>结构体数据的所有权</strong></a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中的 <code>User</code> 结构体的定义中，我们使用了自身拥有所有权的 <code>String</code> 类型而不是 <code>&amp;str</code> 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。</p>
<p>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 <strong>生命周期</strong>（<em>lifetimes</em>），生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的，比如这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: &amp;<span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250615080012057.png" alt="image-20250615080012057"></p>
<p>编译器会抱怨它需要生命周期标识符。</p>
<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>计算长方形面积</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">width1</span> = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">height1</span> = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">area</span>(width1, height1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用元组重构：（不推荐，因为参数不明）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = (<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">area</span>(rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(dimensions: (<span class="type">u32</span>, <span class="type">u32</span>)) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    dimensions.<span class="number">0</span> * dimensions.<span class="number">1</span>		<span class="comment">// 访问元组数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用结构体重构：赋予更多意义（推荐）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        <span class="title function_ invoke__">area</span>(&amp;rect1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(rectangle: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过派生 trait 增加实用功能：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;&#125;&quot;</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250615082006983.png" alt="image-20250615082006983"></p>
<p>修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;rect1:?&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;rect1:#?&#125;&quot;</span>);<span class="comment">//或者这个。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250615082419365.png" alt="image-20250615082419365"></p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250615082440356.png" alt="image-20250615082440356"></p>
<p><strong>使用 <code>Debug</code> 格式打印数值的方法：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale),</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250615082509941.png" alt="image-20250615082509941"></p>
<hr>
<h3 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95">方法语法</a></h3><p><strong>方法</strong>（method）与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。</p>
<p>不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，并且它们第一个参数总是 <code>self</code>，它代表调用该方法的结构体实例。</p>
<p><strong>定义方法：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>impl</code> 块（<code>impl</code> 是 <em>implementation</em> 的缩写），这个 <code>impl</code> 块中的所有内容都将与 <code>Rectangle</code> 类型相关联。</p>
<p>接着将 <code>area</code> 函数移动到 <code>impl</code> 大括号中，并将签名中的第一个（在这里也是唯一一个）参数和函数体中其他地方的对应参数改成 <code>self</code>。</p>
<p>在 <code>main</code> 中将我们先前调用 <code>area</code> 方法并传递 <code>rect1</code> 作为参数的地方，改成使用 <strong>方法语法</strong>（<em>method syntax</em>）在 <code>Rectangle</code> 实例上调用 <code>area</code> 方法。</p>
<p>方法语法获取一个实例并加上一个点号，后跟方法名、圆括号以及任何参数。</p>
<hr>
<p><strong>带有更多参数的方法:</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>多个 impl 块</strong></p>
<p>每个结构体都允许拥有多个 <code>impl</code> 块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0">关联函数</a></h3><p>所有在 <code>impl</code> 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与 <code>impl</code> 后面命名的类型相关。</p>
<p>不是方法的关联函数经常被用作返回一个结构体新实例的构造函数。这些函数的名称通常为 <code>new</code>，但 <code>new</code> 并不是一个关键字。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sq</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><code>::</code> 语法用于关联函数和模块创建的命名空间</p>
<hr>
<hr>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><em><strong>enums</strong></em></p>
<p><strong>核心知识点</strong></p>
<ol>
<li><strong>枚举定义</strong>：表示值属于一组可能变体之一</li>
<li><strong>变体关联数据</strong>：每个变体可携带不同类型&#x2F;数量的数据</li>
<li><strong>Option 枚举</strong>：安全处理”有值&#x2F;无值”场景（替代空值）</li>
<li><strong>模式匹配</strong>：处理不同变体的基础（后续章节展开）</li>
</ol>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建枚举实例</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数使用枚举类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_kind: IpAddrKind) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变体关联数据"><a href="#变体关联数据" class="headerlink" title="变体关联数据"></a>变体关联数据</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变体可关联不同类型数据</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),    <span class="comment">// 元组形式</span></span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),             <span class="comment">// 单个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例（自动获得构造函数）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="复杂数据关联"><a href="#复杂数据关联" class="headerlink" title="复杂数据关联"></a>复杂数据关联</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,                          <span class="comment">// 无关联数据</span></span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,        <span class="comment">// 匿名结构体</span></span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),                  <span class="comment">// 字符串</span></span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),     <span class="comment">// 多个值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法定义（与结构体类似）</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">msg.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure>

<h3 id="Option-枚举"><a href="#Option-枚举" class="headerlink" title="Option 枚举"></a>Option 枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库定义（预导入）</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,    <span class="comment">// 无值</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T), <span class="comment">// 有值（泛型）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);          <span class="comment">// Option&lt;i32&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_str</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;text&quot;</span>);     <span class="comment">// Option&lt;&amp;str&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;  <span class="comment">// 必须标注类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全特性（编译时检查）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// let sum = x + y; // 错误！必须解包处理</span></span><br></pre></td></tr></table></figure>

<p><strong>关键学习点</strong></p>
<ol>
<li><strong>枚举本质</strong>：类型安全的联合体，每个值都是明确变体之一</li>
<li><strong>数据关联</strong>：变体可携带任意类型数据（元组&#x2F;结构体&#x2F;基础类型等）</li>
<li><strong>Option 设计</strong>：<ul>
<li>强制处理空值场景</li>
<li><code>Some(T)</code>和<code>None</code>都是<code>Option&lt;T&gt;</code>类型</li>
<li>不能直接与<code>T</code>类型混用</li>
</ul>
</li>
<li><strong>模式匹配</strong>：处理不同变体的基础（下一节<code>match</code>语法）</li>
</ol>
<hr>
<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p><strong>核心知识点</strong></p>
<ol>
<li><strong>穷尽性检查</strong>：编译器强制要求处理所有可能情况</li>
<li><strong>模式绑定</strong>：可从枚举变体中提取值</li>
<li><strong>通配模式</strong>：处理未明确指定的情况</li>
<li><strong>返回值</strong>：每个分支代码块的返回值组成整个 match 表达式的值</li>
</ol>
<p><strong>基础语法</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> VALUE &#123;</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    _ =&gt; DEFAULT_EXPRESSION <span class="comment">// 通配分支（可选）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例如：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState), <span class="comment">// 关联数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        <span class="comment">// 简单匹配</span></span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 带代码块的分支</span></span><br><span class="line">        Coin::Dime =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Dime coin!&quot;</span>);</span><br><span class="line">            <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定值的分支</span></span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>Option&lt;T&gt;</code> 匹配（重点！）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="comment">// 处理有值的情况</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 必须处理None情况</span></span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>, <span class="comment">// 穷尽性检查强制要求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five); <span class="comment">// Some(6)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>); <span class="comment">// None</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>通配模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">dice_roll</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定值到变量</span></span><br><span class="line">    other =&gt; <span class="title function_ invoke__">move_player</span>(other), </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或忽略值</span></span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">reroll</span>(), </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>特殊通配符 <code>_</code></strong></p>
<p>这玩意有点像<code>else</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略具体值且不绑定变量</span></span><br><span class="line">    _ =&gt; (), <span class="comment">// 表示&quot;什么都不做&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关键特性</strong></p>
<ol>
<li><p><strong>编译器检查</strong>：</p>
<ul>
<li>确保处理所有可能情况</li>
<li>避免空值错误（如未处理None）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：未处理None</span></span><br><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>) <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模式绑定</strong>：</p>
<ul>
<li>可直接从枚举变体中提取值</li>
<li>如 <code>Coin::Quarter(state)</code> 中的 <code>state</code></li>
</ul>
</li>
<li><p><strong>执行顺序</strong>：</p>
<ul>
<li>按分支顺序匹配</li>
<li>第一个匹配成功的分支会被执行</li>
</ul>
</li>
<li><p><strong>通配模式规则</strong>：</p>
<ul>
<li><code>_</code> 匹配任何值但不绑定</li>
<li>必须放在最后（否则后续分支无法匹配）</li>
<li>可使用 <code>()</code> 表示无操作</li>
</ul>
</li>
</ol>
<hr>
<h3 id="if-let-和-let-else"><a href="#if-let-和-let-else" class="headerlink" title="if let 和 let else "></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch06-03-if-let.html#if-let-%E5%92%8C-let-else-%E7%AE%80%E6%B4%81%E6%8E%A7%E5%88%B6%E6%B5%81"><code>if let</code> 和 <code>let else</code> </a></h3><p><strong>核心知识点</strong></p>
<ol>
<li><strong><code>if let</code> 语法</strong>：简化单模式匹配场景</li>
<li><strong><code>let else</code> 语法</strong>：优化”愉快路径”代码结构</li>
<li><strong>与 <code>match</code> 对比</strong>：在简洁性和穷尽性检查间的权衡</li>
</ol>
<hr>
<p><strong><code>if let</code> 语法</strong></p>
<p><strong>作用</strong>：处理只关心一种匹配模式的情况<br><strong>等价于</strong>：<code>match</code> 的单个分支 + <code>_ =&gt; ()</code> 分支</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// match 写法</span></span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Max: &#123;max&#125;&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if let 等价写法</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Max: &#123;max&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带 <code>else</code> 的 <code>if let</code></strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;state:?&#125;!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>let else</code> 语法</strong></p>
<p><strong>作用</strong>：保持”愉快路径”代码清晰，提前处理错误情况<br><strong>特点</strong>：</p>
<ul>
<li>左侧为模式匹配</li>
<li>右侧为表达式</li>
<li><code>else</code> 分支必须返回（<code>return</code>&#x2F;<code>panic!</code>&#x2F;<code>break</code>等）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统 if let 嵌套写法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">        <span class="keyword">if</span> state.<span class="title function_ invoke__">existed_in</span>(<span class="number">1900</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;Old state: &#123;state:?&#125;&quot;</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;New state: &#123;state:?&#125;&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let else 优化写法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">describe_state_quarter</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>; <span class="comment">// 提前返回</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">existed_in</span>(<span class="number">1900</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;Old state: &#123;state:?&#125;&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="built_in">format!</span>(<span class="string">&quot;New state: &#123;state:?&#125;&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关键对比</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>match</code></th>
<th align="left"><code>if let</code></th>
<th align="left"><code>let else</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">穷尽性检查</td>
<td align="left">✅ 强制</td>
<td align="left">❌ 不强制</td>
<td align="left">❌ 不强制</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">多模式匹配</td>
<td align="left">单模式匹配</td>
<td align="left">模式解构+错误处理</td>
</tr>
<tr>
<td align="left">代码简洁度</td>
<td align="left">可能冗长</td>
<td align="left">简洁</td>
<td align="left">非常简洁</td>
</tr>
<tr>
<td align="left">主要优势</td>
<td align="left">安全，覆盖所有情况</td>
<td align="left">简化单分支逻辑</td>
<td align="left">保持”愉快路径”清晰</td>
</tr>
</tbody></table>
<hr>
<p><strong>使用建议</strong></p>
<ol>
<li><strong>单模式匹配</strong> → 优先使用 <code>if let</code></li>
<li><strong>需要解构值并处理错误</strong> → 优先使用 <code>let else</code></li>
<li><strong>需要处理所有可能情况</strong> → 必须使用 <code>match</code></li>
<li><strong>复杂匹配逻辑</strong> → 使用 <code>match</code>（即使代码稍长）</li>
</ol>
<hr>
<hr>
<h2 id="包、crate、模块"><a href="#包、crate、模块" class="headerlink" title="包、crate、模块"></a>包、crate、模块</h2><p>一个包（package）可以包含多个二进制 crate 项和一个可选的库 crate</p>
<ul>
<li><strong>包</strong>（<em>Packages</em>）：Cargo 的一个功能，它允许你构建、测试和分享 crate。</li>
<li><strong>Crates</strong> ：一个模块的树形结构，它形成了库或可执行文件项目。</li>
<li><strong>模块</strong>（<em>Modules</em>）和 <strong>use</strong>：允许你控制作用域和路径的私有性。</li>
<li><strong>路径</strong>（<em>path</em>）：一个为例如结构体、函数或模块等项命名的方式。</li>
</ul>
<hr>
<h3 id="包和-Crate"><a href="#包和-Crate" class="headerlink" title="包和 Crate"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch07-01-packages-and-crates.html#%E5%8C%85%E5%92%8C-crate">包和 Crate</a></h3><ol>
<li><strong>Crate（箱）</strong><ul>
<li>Rust 编译的最小代码单元，分为两类：<ul>
<li><strong>二进制 crate</strong>：含 <code>main</code> 函数，编译为可执行程序（如命令行工具）。</li>
<li><strong>库 crate</strong>：不含 <code>main</code> 函数，提供可复用功能（如 <code>rand</code> 库）。</li>
</ul>
</li>
<li><strong>Crate Root</strong>：编译器入口文件（如 <code>src/main.rs</code> 或 <code>src/lib.rs</code>），构成 crate 的根模块。</li>
</ul>
</li>
<li><strong>包（Package）</strong><ul>
<li>包含一个或多个 crate 的捆绑，由 <code>Cargo.toml</code> 定义构建规则。</li>
<li>结构限制：<ul>
<li>至多 <strong>1 个库 crate</strong>（名称与包相同）。</li>
<li>任意数量 <strong>二进制 crate</strong>（包内至少需 1 个 crate）。</li>
<li>必须包含 <code>Cargo.toml</code> 文件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>创建包的约定</strong></p>
<ul>
<li><p><strong><code>cargo new</code> 自动生成结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-project  # 创建包</span><br><span class="line">├── Cargo.toml         # 包配置文件</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs        # 二进制 crate 根（默认生成）</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件路径规则</strong>：</p>
<ul>
<li><code>src/main.rs</code> → 与包同名的二进制 crate。</li>
<li><code>src/lib.rs</code> → 与包同名的库 crate。</li>
<li><code>src/bin/*.rs</code> → 每个文件生成独立二进制 crate。</li>
</ul>
</li>
</ul>
<p><strong>典型包结构示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my-package/</span><br><span class="line">├── Cargo.toml          # 包配置</span><br><span class="line">├── src/</span><br><span class="line">│   ├── lib.rs          # 库 crate（名称 = my-package）</span><br><span class="line">│   ├── main.rs         # 二进制 crate（名称 = my-package）</span><br><span class="line">│   └── bin/</span><br><span class="line">│       ├── tool1.rs    # 独立二进制 crate（名称 = tool1）</span><br><span class="line">│       └── tool2.rs    # 独立二进制 crate（名称 = tool2）</span><br></pre></td></tr></table></figure>

<p><strong>关键总结</strong></p>
<ul>
<li><strong>Crate</strong>：代码组织单元（二进制&#x2F;库）。</li>
<li><strong>包</strong>：管理 crate 的容器，通过路径约定自动关联 crate。</li>
<li><strong>Cargo</strong>：既是包（含二进制 crate），也提供构建其他包的库 crate 功能。</li>
</ul>
<hr>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch07-02-defining-modules-to-control-scope-and-privacy.html#%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E6%9D%A5%E6%8E%A7%E5%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%A7%81%E6%9C%89%E6%80%A7">模块</a></h3><p><strong>核心概念</strong></p>
<ol>
<li><p><strong>模块（Modules）</strong></p>
<ul>
<li>用于组织代码的逻辑单元，可嵌套形成层次结构</li>
<li>默认所有项（函数&#x2F;结构体&#x2F;模块等）<strong>私有</strong>（仅父模块可访问）</li>
<li>使用 <code>pub</code> 关键字使项公开（如 <code>pub mod</code> 或 <code>pub fn</code>）</li>
</ul>
</li>
<li><p><strong>模块树（Module Tree）</strong></p>
<ul>
<li><p>以隐式 <code>crate</code> 模块为根节点</p>
</li>
<li><p>示例结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line">└── front_of_house</span><br><span class="line">    ├── hosting  // 子模块</span><br><span class="line">    │   ├── add_to_waitlist</span><br><span class="line">    │   └── seat_at_table</span><br><span class="line">    └── serving  // 同级兄弟模块</span><br><span class="line">        ├── take_order</span><br><span class="line">        ├── serve_order</span><br><span class="line">        └── take_payment</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<p><strong>模块定义规则（编译器查找顺序）</strong></p>
<table>
<thead>
<tr>
<th align="left">声明方式</th>
<th align="left">编译器查找路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>根模块</strong> <code>mod garden;</code></td>
<td align="left">1. 内联代码块（替换分号为 <code>&#123;&#125;</code>） 2. <code>src/garden.rs</code> 3. <code>src/garden/mod.rs</code></td>
</tr>
<tr>
<td align="left"><strong>子模块</strong> <code>mod vegetables;</code> （在 <code>garden</code> 中）</td>
<td align="left">1. 内联代码块 2. <code>src/garden/vegetables.rs</code> 3. <code>src/garden/vegetables/mod.rs</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>文件系统类比</strong>：模块结构直接映射到文件路径</p>
</blockquote>
<hr>
<p><strong>访问控制</strong></p>
<ol>
<li><p><strong>路径规则</strong>：</p>
<ul>
<li>绝对路径：<code>crate::garden::vegetables::Asparagus</code></li>
<li>相对路径：<code>serving::take_order()</code>（当前模块内）</li>
</ul>
</li>
<li><p><strong>可见性</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;          <span class="comment">// 公开子模块</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125; <span class="comment">// 公开函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong><code>use</code> 关键字</strong></p>
<ul>
<li><p>创建路径快捷方式，避免重复长路径</p>
</li>
<li><p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::garden::vegetables::Asparagus;</span><br><span class="line"><span class="comment">// 现在可直接使用 Asparagus</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">plant</span> = Asparagus &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>实战示例（餐厅系统）</strong></p>
<p><strong>文件结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">restaurant</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── front_of_house.rs</span><br><span class="line">    ├── front_of_house</span><br><span class="line">    │   ├── hosting.rs</span><br><span class="line">    │   └── serving.rs</span><br><span class="line">    └── lib.rs</span><br></pre></td></tr></table></figure>

<p><strong>代码组织</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> front_of_house;  <span class="comment">// 声明模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/front_of_house.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;      <span class="comment">// 子模块声明</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/front_of_house/hosting.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;  <span class="comment">// 公开接口</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;        <span class="comment">// 私有实现</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关键总结</strong></p>
<ol>
<li><strong>模块</strong> &#x3D; 代码组织单元（类比文件目录）</li>
<li><strong>路径</strong> &#x3D; 访问项的导航方式（绝对&#x2F;相对路径）</li>
<li><strong>私有性</strong> &#x3D; 默认封装实现细节（<code>pub</code> 显式暴露接口）</li>
<li><strong><code>use</code></strong> &#x3D; 路径别名工具（简化代码）</li>
</ol>
<blockquote>
<p>模块系统通过层次化组织和访问控制，实现高内聚低耦合的代码结构，是构建大型 Rust 项目的基石。</p>
</blockquote>
<hr>
<hr>
<h3 id="模块路径与可见性"><a href="#模块路径与可见性" class="headerlink" title="模块路径与可见性"></a>模块路径与可见性</h3><p><strong>核心概念</strong></p>
<ol>
<li><strong>路径类型</strong>：<ul>
<li><strong>绝对路径</strong>：从 crate 根开始（<code>crate::module::item</code>）</li>
<li><strong>相对路径</strong>：从当前模块开始（<code>self::item</code>，<code>super::item</code> 或直接 <code>item</code>）</li>
</ul>
</li>
<li><strong>访问控制</strong>：<ul>
<li>所有项默认<strong>私有</strong>（仅父模块可访问）</li>
<li>使用 <code>pub</code> 关键字逐级公开访问权限</li>
</ul>
</li>
</ol>
<hr>
<p><strong>路径使用示例</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;          <span class="comment">// 公开子模块</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125; <span class="comment">// 公开函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径调用</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相对路径调用</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可见性规则深度解析</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">解决方案</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>访问子模块函数</strong></td>
<td align="left">模块和函数均需 <code>pub</code></td>
<td align="left"><code>pub mod; pub fn</code></td>
</tr>
<tr>
<td align="left"><strong>跨层级访问</strong></td>
<td align="left">路径中每级都需可见</td>
<td align="left"><code>crate::A::B::C</code></td>
</tr>
<tr>
<td align="left"><strong>访问父模块项</strong></td>
<td align="left">使用 <code>super</code> 相对路径</td>
<td align="left"><code>super::parent_function</code></td>
</tr>
<tr>
<td align="left"><strong>结构体部分公开</strong></td>
<td align="left">字段单独标记 <code>pub</code></td>
<td align="left"><code>pub struct &#123; pub field &#125;</code></td>
</tr>
<tr>
<td align="left"><strong>枚举全公开</strong></td>
<td align="left">枚举本身 <code>pub</code> 即公开所有变体</td>
<td align="left"><code>pub enum &#123; Variant &#125;</code></td>
</tr>
</tbody></table>
<hr>
<p><strong>结构体与枚举可见性对比</strong></p>
<ul>
<li><p><strong>结构体</strong>：字段默认私有（需显式标记公有）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> toast: <span class="type">String</span>,   <span class="comment">// 公有字段</span></span><br><span class="line">    seasonal_fruit: <span class="type">String</span> <span class="comment">// 私有字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>枚举</strong>：所有变体自动公有    </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Appetizer</span> &#123;</span><br><span class="line">    Soup,   <span class="comment">// 自动公有</span></span><br><span class="line">    Salad   <span class="comment">// 自动公有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>关键技巧</strong></p>
<ol>
<li><p><strong><code>super</code> 的使用</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_order</span>() &#123;</span><br><span class="line">        super::<span class="title function_ invoke__">deliver_order</span>(); <span class="comment">// 访问父模块函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造私有字段结构体</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="comment">// 提供公有构造函数</span></span><br><span class="line">        Breakfast &#123; toast: toast.<span class="title function_ invoke__">into</span>(), seasonal_fruit: <span class="string">&quot;peaches&quot;</span>.<span class="title function_ invoke__">into</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>二进制与库 crate 协作</strong>：</p>
<ul>
<li><p>库 crate (<code>src/lib.rs</code>) 定义核心逻辑</p>
</li>
<li><p>二进制 crate (<code>src/main.rs</code>) 调用公有 API</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> restaurant::eat_at_restaurant;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>错误处理总结</strong></p>
<table>
<thead>
<tr>
<th align="left">错误现象</th>
<th align="left">原因</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“module is private”</td>
<td align="left">模块未公开</td>
<td align="left">添加 <code>pub mod</code></td>
</tr>
<tr>
<td align="left">“function is private”</td>
<td align="left">函数未公开</td>
<td align="left">添加 <code>pub fn</code></td>
</tr>
<tr>
<td align="left">“field is private”</td>
<td align="left">结构体字段未公开</td>
<td align="left">添加字段级 <code>pub</code></td>
</tr>
<tr>
<td align="left">无法实例化结构体</td>
<td align="left">私有字段+无构造函数</td>
<td align="left">添加关联构造函数</td>
</tr>
</tbody></table>
<blockquote>
<p>遵循 “最小公开原则”：仅暴露必要的接口，保持内部实现私有，提高代码安全性和可维护性。</p>
</blockquote>
<hr>
<h3 id="use-关键字"><a href="#use-关键字" class="headerlink" title="use 关键字"></a><code>use</code> 关键字</h3><p><strong>核心概念</strong></p>
<ol>
<li><strong><code>use</code> 的作用</strong>：创建路径快捷方式，避免重复书写长路径</li>
<li><strong>作用域规则</strong>：<code>use</code> 引入的路径<strong>仅在当前作用域有效</strong></li>
<li><strong>惯用实践</strong>：<ul>
<li>函数：引入父模块（<code>use module; module::function()</code>）</li>
<li>结构体&#x2F;枚举：直接引入项（<code>use Type;</code>）</li>
</ul>
</li>
</ol>
<hr>
<p><strong>基础用法</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入模块（推荐方式）</span></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>(); <span class="comment">// 简洁调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用域限制</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> customer &#123;</span><br><span class="line">    <span class="comment">// 正确：use 需在相同作用域</span></span><br><span class="line">    <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">dine</span>() &#123;</span><br><span class="line">        hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误：外部作用域的 use 无效</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">error_example</span>() &#123;</span><br><span class="line">        <span class="comment">// hosting::add_to_waitlist(); ❌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>高级技巧</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>解决方案</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>同名冲突</strong></td>
<td align="left">使用 <code>as</code> 别名</td>
<td align="left"><code>use std::io::Result as IoResult;</code></td>
</tr>
<tr>
<td align="left"><strong>重导出</strong></td>
<td align="left"><code>pub use</code> 公开暴露路径</td>
<td align="left"><code>pub use crate::internal::api;</code></td>
</tr>
<tr>
<td align="left"><strong>合并相同前缀路径</strong></td>
<td align="left">嵌套路径 <code>&#123; &#125;</code></td>
<td align="left"><code>use std::&#123;cmp::Ordering, io&#125;;</code></td>
</tr>
<tr>
<td align="left"><strong>包含自身路径</strong></td>
<td align="left">使用 <code>self</code></td>
<td align="left"><code>use std::io::&#123;self, Write&#125;;</code></td>
</tr>
<tr>
<td align="left"><strong>引入所有公有项</strong></td>
<td align="left">glob 运算符 <code>*</code>（谨慎使用）</td>
<td align="left"><code>use std::collections::*;</code></td>
</tr>
</tbody></table>
<hr>
<p><strong>外部包使用流程</strong></p>
<ol>
<li><p><strong>声明依赖</strong>（Cargo.toml）：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引入作用域</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>结构体&#x2F;函数引入对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>类型</strong></th>
<th align="left"><strong>推荐引入方式</strong></th>
<th align="left"><strong>原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">函数</td>
<td align="left"><code>use module;</code></td>
<td align="left">清晰表明函数来源</td>
</tr>
<tr>
<td align="left">结构体</td>
<td align="left"><code>use Type;</code></td>
<td align="left">直接使用类型名更简洁</td>
</tr>
<tr>
<td align="left">同名类型</td>
<td align="left"><code>use parent::Type;</code> 或 <code>as</code></td>
<td align="left">避免命名冲突</td>
</tr>
</tbody></table>
<p><strong>函数引入示例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 惯用方式（引入模块）</span></span><br><span class="line"><span class="keyword">use</span> std::collections;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = collections::HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非常用方式（直接引入函数）</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap::new; <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>重导出（pub use）应用</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部结构</span></span><br><span class="line"><span class="keyword">mod</span> internal &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> api &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">connect</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露简化路径</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> internal::api;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部调用</span></span><br><span class="line"><span class="comment">// restaurant::api::connect() 而非 restaurant::internal::api::connect()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用场景</strong>：创建更符合用户直觉的公共API，隐藏内部实现细节</p>
</blockquote>
<hr>
<p><strong>嵌套路径优化</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前（多行）</span></span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后（单行）</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io, io::Write&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>优势</strong>：减少代码行数，保持相同前缀路径的整洁性</p>
</blockquote>
<hr>
<p><strong>关键原则总结</strong></p>
<ol>
<li><strong>最小暴露</strong>：仅引入必要的项（避免glob滥用）</li>
<li><strong>作用域隔离</strong>：<code>use</code> 只在当前模块&#x2F;作用域有效</li>
<li><strong>一致性</strong>：遵循社区惯用模式提高代码可读性</li>
<li><strong>冲突处理</strong>：优先使用父模块限定，必要时用 <code>as</code></li>
<li><strong>API设计</strong>：<code>pub use</code> 优化公共接口体验</li>
</ol>
<hr>
<hr>
<h3 id="模块文件拆分"><a href="#模块文件拆分" class="headerlink" title="模块文件拆分"></a>模块文件拆分</h3><p><strong>核心原则</strong></p>
<ol>
<li><p><strong>模块声明与定义分离</strong>：</p>
<ul>
<li><code>mod 模块名;</code> 声明模块（在父模块文件中）</li>
<li>实际定义在独立文件中</li>
</ul>
</li>
<li><p><strong>文件路径映射规则</strong>：</p>
<table>
<thead>
<tr>
<th align="left">模块声明位置</th>
<th align="left">编译器查找路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">根模块 (<code>lib.rs</code>&#x2F;<code>main.rs</code>)</td>
<td align="left">1. <code>src/模块名.rs</code> 2. <code>src/模块名/mod.rs</code> (旧风格)</td>
</tr>
<tr>
<td align="left">子模块 (<code>模块名.rs</code>)</td>
<td align="left">1. <code>src/父模块/子模块.rs</code> 2. <code>src/父模块/子模块/mod.rs</code> (旧风格)</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<p><strong>标准文件拆分流程</strong></p>
<p><strong>初始结构</strong> (src&#x2F;lib.rs)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 1：提取父模块</strong></p>
<ol>
<li>修改 src&#x2F;lib.rs：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house; <span class="comment">// 声明模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建 src&#x2F;front_of_house.rs：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting; <span class="comment">// 声明子模块</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2：提取子模块</strong></p>
<ol>
<li>创建目录：<code>src/front_of_house/</code></li>
<li>创建 src&#x2F;front_of_house&#x2F;hosting.rs：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125; <span class="comment">// 实际实现</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>最终文件结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── lib.rs              # crate 根</span><br><span class="line">├── front_of_house.rs   # 父模块声明</span><br><span class="line">└── front_of_house/</span><br><span class="line">    └── hosting.rs      # 子模块实现</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>新旧风格对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>风格</strong></th>
<th align="left"><strong>父模块路径</strong></th>
<th align="left"><strong>子模块路径</strong></th>
<th align="left"><strong>优点</strong></th>
<th align="left"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>新风格</strong></td>
<td align="left"><code>src/模块名.rs</code></td>
<td align="left"><code>src/父模块/子模块.rs</code></td>
<td align="left">文件结构更扁平</td>
<td align="left">目录数量可能较多</td>
</tr>
<tr>
<td align="left"><strong>旧风格</strong></td>
<td align="left"><code>src/模块名/mod.rs</code></td>
<td align="left"><code>src/父模块/子模块/mod.rs</code></td>
<td align="left">集中管理（所有在目录内）</td>
<td align="left">大量 <code>mod.rs</code> 易混淆</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>推荐使用新风格</strong>：避免 <code>mod.rs</code> 文件重名问题</p>
</blockquote>
<hr>
<p><strong>关键注意事项</strong></p>
<ol>
<li><p><strong>路径一致性</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting; <span class="comment">// 路径保持不变！</span></span><br></pre></td></tr></table></figure>

<p>文件拆分后，模块路径引用方式<strong>无需改变</strong></p>
</li>
<li><p><strong>编译规则</strong>：</p>
<ul>
<li>Rust 通过 <code>mod</code> 声明定位文件</li>
<li>每个文件自动成为独立编译单元</li>
</ul>
</li>
<li><p><strong>混用禁止</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误示例：两种风格混用</span></span><br><span class="line">src/</span><br><span class="line">  ├── front_of_house.rs</span><br><span class="line">  └── front_of_house/</span><br><span class="line">      └── <span class="keyword">mod</span>.rs  <span class="comment">// 冲突！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>二进制crate</strong>：<br>相同规则适用于 <code>src/main.rs</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">mod</span> config; <span class="comment">// 查找 src/config.rs</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>最佳实践总结</strong></p>
<ol>
<li><p><strong>模块化思维</strong>：</p>
<ul>
<li>每个逻辑单元独立文件</li>
<li>深度&gt;2时创建子目录</li>
</ul>
</li>
<li><p><strong>路径设计</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐：清晰的分层结构</span></span><br><span class="line">crate::api::v1::users::get_user</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应文件：</span></span><br><span class="line">src/api/v1/users.rs</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重构安全</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码保持不变</span></span><br><span class="line">hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>风格统一</strong>：</p>
<ul>
<li>新项目：优先使用 <code>src/模块/子模块.rs</code> 风格</li>
<li>旧项目：保持现有风格一致</li>
</ul>
</li>
</ol>
<blockquote>
<p>文件拆分使大型项目保持可维护性，同时保持编译器和开发者的清晰认知路径</p>
</blockquote>
<hr>
<hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合指向的数据是储存在堆上。数组和元组是在栈上。</p>
<p>集合的数据数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小。</p>
<ul>
<li><strong>向量</strong>（<em>vector</em>）允许我们一个挨着一个地储存一系列数量可变的值。</li>
<li><strong>字符串</strong>（<em>string</em>）是字符的集合。我们之前见过 <code>String</code> 类型，不过在本章我们将深入了解。</li>
<li><strong>哈希 map</strong>（<em>hash map</em>）允许我们将值与一个特定的键（key）相关联。这是一个叫做 <em>map</em> 的更通用的数据结构的特定实现。</li>
</ul>
<hr>
<h3 id="向量（vector）"><a href="#向量（vector）" class="headerlink" title="向量（vector）"></a><strong>向量</strong>（<em>vector</em>）</h3><p><strong><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch08-01-vectors.html#%E6%96%B0%E5%BB%BA-vector">新建 vector</a></strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p><strong>核心概念</strong></p>
<p><strong><code>Vec&lt;T&gt;</code></strong>：动态数组，用于存储<strong>同类型</strong>元素的集合</p>
<ul>
<li>内存中连续存储</li>
<li>大小可动态增长</li>
<li>只能存储相同类型元素（通过枚举可模拟多种类型）</li>
</ul>
<hr>
<p><strong>创建与更新</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>操作</strong></th>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>示例</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">新建空 vector</td>
<td align="left"><code>Vec::new()</code></td>
<td align="left"><code>let v: Vec&lt;i32&gt; = Vec::new();</code></td>
<td align="left">需类型注解（无初始值）</td>
</tr>
<tr>
<td align="left">带初始值创建</td>
<td align="left"><code>vec!</code> 宏</td>
<td align="left"><code>let v = vec![1, 2, 3];</code></td>
<td align="left">自动推断类型（推荐方式）</td>
</tr>
<tr>
<td align="left">添加元素</td>
<td align="left"><code>push()</code></td>
<td align="left"><code>v.push(4);</code></td>
<td align="left">需 <code>mut</code> 声明</td>
</tr>
</tbody></table>
<p>在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。</p>
<hr>
<p><strong>访问元素</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>返回值</strong></th>
<th align="left"><strong>越界行为</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">索引 <code>[]</code></td>
<td align="left"><code>&amp;T</code></td>
<td align="left">Panic（崩溃）</td>
<td align="left"><code>let third = &amp;v[2];</code></td>
</tr>
<tr>
<td align="left"><code>get()</code></td>
<td align="left"><code>Option&lt;&amp;T&gt;</code></td>
<td align="left">返回 <code>None</code></td>
<td align="left"><code>let third = v.get(2);</code></td>
</tr>
</tbody></table>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全访问索引3</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = &amp;v[<span class="number">3</span>];  <span class="comment">// 返回 &amp;i32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element_option</span> = v.<span class="title function_ invoke__">get</span>(<span class="number">3</span>);  <span class="comment">// 返回 Option&lt;&amp;i32&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Element: &#123;&#125;&quot;</span>, element);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正确处理Option</span></span><br><span class="line">    <span class="keyword">match</span> element_option &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Option value: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Element does not exist&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250618085001458.png" alt="image-20250618085001458"></p>
<blockquote>
<p><strong>索引选择原则</strong>：</p>
<ul>
<li>期望崩溃时用 <code>[]</code></li>
<li>需安全处理越界用 <code>get()</code></li>
</ul>
</blockquote>
<hr>
<p><strong>遍历与修改</strong></p>
<ol>
<li><p><strong>不可变遍历</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;i&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可变遍历（需修改值）</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>; <span class="comment">// 解引用修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>存储多种类型</strong></p>
<p>通过枚举实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="string">&quot;blue&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>限制</strong>：需提前知道所有可能类型（未知类型需用 trait 对象）</p>
</blockquote>
<hr>
<p><strong>所有权与生命周期</strong></p>
<ol>
<li><p><strong>作用域规则</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 创建</span></span><br><span class="line">    <span class="comment">// 使用 v...</span></span><br><span class="line">&#125; <span class="comment">// v 离开作用域，内存自动释放</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>借用冲突</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];   <span class="comment">// 不可变借用</span></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);           <span class="comment">// ❌ 可变借用冲突</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;first&#125;&quot;</span>); <span class="comment">// 不可变借用再次使用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原因：<code>push</code> 可能导致内存重分配，使原有引用失效</li>
</ul>
</li>
</ol>
<hr>
<p><strong>关键特性总结</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">动态大小</td>
<td align="left">运行时自动扩容</td>
</tr>
<tr>
<td align="left">栈+堆存储</td>
<td align="left">元数据在栈，元素在堆</td>
</tr>
<tr>
<td align="left">类型安全</td>
<td align="left">编译时检查元素类型一致性</td>
</tr>
<tr>
<td align="left">边界安全检查</td>
<td align="left">提供安全访问方法（<code>get()</code>）</td>
</tr>
<tr>
<td align="left">自动内存管理</td>
<td align="left">离开作用域自动释放内存</td>
</tr>
</tbody></table>
<p><strong>常用方法补充</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>功能</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>pop()</code></td>
<td align="left">移除并返回最后一个元素</td>
<td align="left"><code>v.pop()</code> → <code>Option&lt;T&gt;</code></td>
</tr>
<tr>
<td align="left"><code>len()</code></td>
<td align="left">获取元素数量</td>
<td align="left"><code>v.len()</code></td>
</tr>
<tr>
<td align="left"><code>is_empty()</code></td>
<td align="left">检查是否为空</td>
<td align="left"><code>v.is_empty()</code></td>
</tr>
</tbody></table>
<blockquote>
<p>Vector 是 Rust 最常用的集合类型，适用于需要动态数组的场景，结合枚举可灵活处理多种数据类型。</p>
</blockquote>
<hr>
<h3 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a><strong>字符串</strong>（<em>string</em>）</h3><p><strong>核心概念</strong></p>
<p><strong>字符串本质</strong>：</p>
<ul>
<li><code>String</code>：可增长、可变、拥有所有权的 UTF-8 字符串</li>
<li><code>&amp;str</code>：不可变字符串切片（常见形式）</li>
<li>所有字符串均为 <strong>UTF-8 编码</strong>，支持全球字符</li>
</ul>
<hr>
<p><strong>字符串创建</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>示例</strong></th>
<th align="left"><strong>使用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>String::new()</code></td>
<td align="left"><code>let s = String::new();</code></td>
<td align="left">创建空字符串</td>
</tr>
<tr>
<td align="left"><code>to_string()</code></td>
<td align="left"><code>&quot;hello&quot;.to_string();</code></td>
<td align="left">从字面值转换</td>
</tr>
<tr>
<td align="left"><code>String::from()</code></td>
<td align="left"><code>String::from(&quot;你好&quot;);</code></td>
<td align="left">显式创建（推荐方式）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>多语言支持</strong>：Rust 原生支持任意 Unicode 字符</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">greetings</span> = [</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>),     <span class="comment">// 中文</span></span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;こんにちは&quot;</span>), <span class="comment">// 日文</span></span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;안녕하세요&quot;</span>)  <span class="comment">// 韩文</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<p><strong>字符串更新</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>示例</strong></th>
<th align="left"><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>push_str()</code></td>
<td align="left"><code>s.push_str(&quot; world&quot;);</code></td>
<td align="left">追加字符串切片（不获取所有权）</td>
</tr>
<tr>
<td align="left"><code>push()</code></td>
<td align="left"><code>s.push(&#39;!&#39;);</code></td>
<td align="left">追加单个字符</td>
</tr>
<tr>
<td align="left"><code>+</code> 运算符</td>
<td align="left"><code>s1 + &amp;s2</code></td>
<td align="left">移动左侧所有权，右侧用引用</td>
</tr>
<tr>
<td align="left"><code>format!</code> 宏</td>
<td align="left"><code>format!(&quot;&#123;s1&#125;-&#123;s2&#125;&quot;)</code></td>
<td align="left">无所有权转移（推荐拼接方式）</td>
</tr>
</tbody></table>
<p><strong>重要区别</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：s1 所有权被移动（后续不可用）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = s1 + <span class="string">&quot;-&quot;</span> + &amp;s2;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;,&#123;s2&#125;,&#123;s3&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：无所有权转移（推荐）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s1&#125;-&#123;s2&#125;&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;,&#123;s2&#125;,&#123;s4&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>方式一：</p>
<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250618091006833.png" alt="image-20250618091006833"></p>
<hr>
<p><strong>字符串索引限制</strong></p>
<p><strong>禁止直接索引</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = s[<span class="number">0</span>]; <span class="comment">// ❌ 编译错误！</span></span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：</p>
<ol>
<li>UTF-8 字符占用 1-4 字节（变长存储）<ul>
<li>英文 “H”：1 字节</li>
<li>俄文 “З”：2 字节</li>
<li>印地语 “न”：3 字节</li>
</ul>
</li>
<li>索引字节可能落在字符中间</li>
<li>索引操作要求 O(1) 时间复杂度（字符串无法保证）</li>
</ol>
<p><strong>安全替代方案</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>需求</strong></th>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取子串</td>
<td align="left">字符串切片（谨慎）</td>
<td align="left"><code>&amp;hello[0..4]</code> &#x2F;&#x2F; “Зд”</td>
</tr>
<tr>
<td align="left">遍历字符</td>
<td align="left"><code>.chars()</code></td>
<td align="left"><code>for c in &quot;नमस्ते&quot;.chars()</code></td>
</tr>
<tr>
<td align="left">访问字节</td>
<td align="left"><code>.bytes()</code></td>
<td align="left"><code>for b in &quot;hello&quot;.bytes()</code></td>
</tr>
<tr>
<td align="left">获取第n个字符</td>
<td align="left"><code>.chars().nth(n)</code></td>
<td align="left"><code>&quot;hello&quot;.chars().nth(1)</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>切片风险</strong>：必须对齐字符边界</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="string">&quot;Здравствуйте&quot;</span>[<span class="number">0</span>..<span class="number">1</span>] <span class="comment">// ❌ 运行时 panic！</span></span><br></pre></td></tr></table></figure></blockquote>
<hr>
<p><strong>内部存储原理</strong></p>
<p><strong>字符串内存布局</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> &#123;</span><br><span class="line">    vec: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        len: <span class="number">24</span>,          <span class="comment">// &quot;Здравствуйте&quot; 的字节长度</span></span><br><span class="line">        capacity: <span class="number">24</span>,</span><br><span class="line">        ptr: ► [<span class="number">208</span>, <span class="number">151</span>, <span class="number">208</span>, ...] <span class="comment">// UTF-8 字节序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三种视角</strong>：</p>
<ol>
<li>字节（Bytes）：<code>[224, 164, 168, ...]</code></li>
<li>标量值（Unicode Scalars）：<code>[&#39;न&#39;, &#39;म&#39;, &#39;स&#39;, &#39;्&#39;, ...]</code></li>
<li>字形簇（Grapheme Clusters）：<code>[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]</code>（需第三方库）</li>
</ol>
<hr>
<p><strong>最佳实践总结</strong></p>
<ol>
<li><strong>创建选择</strong>：优先使用 <code>String::from()</code></li>
<li><strong>拼接选择</strong>：多段拼接用 <code>format!</code> 宏</li>
<li><strong>遍历选择</strong>：<ul>
<li>字符级操作：<code>for c in s.chars()</code></li>
<li>字节级操作：<code>for b in s.bytes()</code></li>
</ul>
</li>
<li><strong>索引替代</strong>：<ul>
<li>切片：确保范围在字符边界内</li>
<li>迭代器：<code>.chars().nth()</code> 或 <code>.bytes().nth()</code></li>
</ul>
</li>
<li><strong>多语言处理</strong>：<ul>
<li>使用 <code>.chars()</code> 获取 Unicode 字符</li>
<li>需要字形簇时使用 <code>unicode-segmentation</code> 库</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>核心原则</strong>：Rust 通过编译时限制避免了字符串操作的常见错误（如无效 Unicode 处理），换取更安全的运行时行为。</p>
</blockquote>
<hr>
<h3 id="哈希-map（hash-map）"><a href="#哈希-map（hash-map）" class="headerlink" title="哈希 map（hash map）"></a><strong>哈希 map</strong>（<em>hash map</em>）</h3><p><strong>核心概念</strong></p>
<p><strong>HashMap&lt;K, V&gt;</strong>：键值对集合，通过哈希函数快速查找</p>
<ul>
<li>键唯一，值可重复</li>
<li>无序存储（遍历顺序不确定）</li>
<li>堆内存存储数据</li>
</ul>
<hr>
<p><strong>基本操作</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>操作</strong></th>
<th align="left"><strong>方法&#x2F;代码</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">创建</td>
<td align="left"><code>HashMap::new()</code></td>
<td align="left"><code>let mut scores = HashMap::new();</code></td>
</tr>
<tr>
<td align="left">插入键值对</td>
<td align="left"><code>insert()</code></td>
<td align="left"><code>scores.insert(&quot;Blue&quot;, 10);</code><br /><code>scores.insert(String::from(&quot;Blue&quot;), 10);</code></td>
</tr>
<tr>
<td align="left">获取值</td>
<td align="left"><code>get()</code></td>
<td align="left"><code>scores.get(&quot;Blue&quot;)</code> → <code>Option&lt;&amp;V&gt;</code></td>
</tr>
<tr>
<td align="left">安全获取值</td>
<td align="left"><code>get().copied().unwrap_or()</code></td>
<td align="left"><code>scores.get(&quot;Red&quot;).copied().unwrap_or(0)</code></td>
</tr>
<tr>
<td align="left">遍历</td>
<td align="left"><code>for (k, v) in &amp;map</code></td>
<td align="left"><code>for (team, score) in &amp;scores &#123;...&#125;</code></td>
</tr>
</tbody></table>
<blockquote>
<p>注意：需先引入 <code>use std::collections::HashMap;</code></p>
<p>安全获取值：<code>get</code> 方法返回 <code>Option&lt;&amp;V&gt;</code>，如果某个键在哈希 map 中没有对应的值，<code>get</code> 会返回 <code>None</code>。程序中通过调用 <code>copied</code> 方法来获取一个 <code>Option&lt;i32&gt;</code> 而不是 <code>Option&lt;&amp;i32&gt;</code>，接着调用 <code>unwrap_or</code> 在 <code>scores</code> 中没有该键所对应的项时将其设置为零。</p>
</blockquote>
<hr>
<p><strong>所有权处理</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>值类型</strong></th>
<th align="left"><strong>插入后行为</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Copy</code>类型（i32等）</td>
<td align="left">复制值</td>
<td align="left"><code>map.insert(1, 10);</code> &#x2F;&#x2F; 原值仍可用</td>
</tr>
<tr>
<td align="left">非<code>Copy</code>类型（String）</td>
<td align="left">转移所有权（原变量失效）</td>
<td align="left"><code>map.insert(s1, s2);</code> &#x2F;&#x2F; s1,s2失效</td>
</tr>
<tr>
<td align="left">引用类型</td>
<td align="left">保留原所有权（注意生命周期）</td>
<td align="left"><code>map.insert(&amp;key, &amp;value);</code></td>
</tr>
</tbody></table>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Color&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(key, value);  <span class="comment">// key和value所有权转移</span></span><br><span class="line">    <span class="comment">// 此后不能再使用key和value</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;key&#125;,&#123;value&#125;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/06/11/Rust/image-20250618092322631.png" alt="image-20250618092322631"></p>
<hr>
<p><strong>高级更新技巧</strong></p>
<ol>
<li><p><strong>覆盖更新</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Blue&quot;</span>, <span class="number">25</span>); <span class="comment">// 直接覆盖旧值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>条件插入</strong>（键不存在时插入）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.<span class="title function_ invoke__">entry</span>(<span class="string">&quot;Yellow&quot;</span>).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>基于旧值更新</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">word_count</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = word_count.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>; <span class="comment">// 解引用后更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：&#123;&quot;hello&quot;:2, &quot;world&quot;:1&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><code>entry().or_insert()</code> 返回<code>&amp;mut V</code>可变引用，需解引用修改</p>
</blockquote>
<hr>
<p><strong>性能与安全</strong></p>
<ol>
<li><p><strong>默认哈希器</strong>：SipHash 算法</p>
<ul>
<li>抗DoS攻击</li>
<li>中等性能</li>
</ul>
</li>
<li><p><strong>更换哈希器</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::hash::BuildHasherDefault;</span><br><span class="line"><span class="keyword">use</span> twox_hash::XxHash64; <span class="comment">// 需添加twox-hash依赖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = HashMap::<span class="title function_ invoke__">default</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&quot;fast&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>需要高性能时，可选用第三方哈希器（如<code>xxHash</code>）</p>
</blockquote>
<hr>
<p><strong>典型应用场景</strong></p>
<ol>
<li><p><strong>数据统计</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计单词频率</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">freq</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    *freq.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缓存系统</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cache</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expensive_call</span>(arg: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_cached</span>(arg: <span class="type">i32</span>, cache: &amp;<span class="keyword">mut</span> HashMap&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    *cache.<span class="title function_ invoke__">entry</span>(arg).<span class="title function_ invoke__">or_insert_with</span>(|| <span class="title function_ invoke__">expensive_call</span>(arg))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>替代switch</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">operations</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">operations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;add&quot;</span>, |a, b| a + b);</span><br><span class="line">operations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;mul&quot;</span>, |a, b| a * b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(op) = operations.<span class="title function_ invoke__">get</span>(<span class="string">&quot;add&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">op</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>最佳实践总结</strong></p>
<ol>
<li><strong>键选择</strong>：<ul>
<li>推荐使用不可变类型作键</li>
<li>确保键类型实现<code>Eq</code>和<code>Hash</code> trait</li>
</ul>
</li>
<li><strong>内存管理</strong>：<ul>
<li>大型数据存储引用（注意生命周期）</li>
<li>小型数据直接存储</li>
</ul>
</li>
<li><strong>更新模式</strong>：<ul>
<li>无条件更新 → <code>insert()</code></li>
<li>键不存在时插入 → <code>entry().or_insert()</code></li>
<li>基于旧值更新 → <code>entry().and_modify()</code></li>
</ul>
</li>
<li><strong>错误处理</strong>：<ul>
<li>使用<code>get</code>代替直接索引</li>
<li>用<code>entry</code>API避免缺失键检查</li>
</ul>
</li>
</ol>
<blockquote>
<p>HashMap提供O(1)平均时间复杂度操作，是快速查找的理想选择</p>
</blockquote>
<hr>
<hr>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Rust 将错误分为两大类：</p>
<ul>
<li><strong>可恢复的</strong>（<em>recoverable</em>），如：文件未找到的错误</li>
<li><strong>不可恢复的</strong>（<em>unrecoverable</em>）错误，如：试图访问一个超过数组末端的位置。</li>
</ul>
<p><code>Result&lt;T, E&gt;</code> 类型，用于处理可恢复的错误。</p>
<p><code>panic!</code> 宏，在程序遇到不可恢复的错误时停止执行。</p>
<hr>
<h3 id="panic"><a href="#panic" class="headerlink" title="panic!"></a><code>panic!</code></h3><p><strong>核心概念</strong></p>
<p><strong><code>panic!</code></strong>：处理不可恢复错误的宏</p>
<ul>
<li>两种触发方式：<ol>
<li>代码错误（如数组越界）</li>
<li>显式调用 <code>panic!(&quot;错误信息&quot;)</code></li>
</ol>
</li>
<li>默认行为：<strong>栈展开</strong>（unwinding）<ul>
<li>回溯调用栈</li>
<li>清理每个函数的数据</li>
<li>显示错误信息后退出</li>
</ul>
</li>
</ul>
<hr>
<p><strong>配置 panic 行为</strong></p>
<p>在 <code>Cargo.toml</code> 中配置：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span>  <span class="comment"># 改为终止模式（不清理直接退出）</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>模式</strong></th>
<th align="left"><strong>行为</strong></th>
<th align="left"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">展开 (默认)</td>
<td align="left">清理栈数据后退出</td>
<td align="left">开发环境（便于调试）</td>
</tr>
<tr>
<td align="left">终止</td>
<td align="left">立即退出，不清理</td>
<td align="left">发布环境（减小二进制体积）</td>
</tr>
</tbody></table>
<hr>
<p><strong>典型 panic 场景</strong></p>
<ol>
<li><p><strong>显式调用</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;程序崩溃！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at src/main.rs:2:5:</span><br><span class="line">程序崩溃！</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>隐式触发</strong>（数组越界）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    v[<span class="number">99</span>]; <span class="comment">// 索引越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at src/main.rs:3:5:</span><br><span class="line">index out of bounds: the len is 3 but the index is 99</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>调试技巧：Backtrace</strong>回溯追踪</p>
<p>设置环境变量获取调用堆栈：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUST_BACKTRACE=1 cargo run</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stack backtrace:</span><br><span class="line">   0: rust_begin_unwind</span><br><span class="line">   1: core::panicking::panic_fmt</span><br><span class="line">   2: core::panicking::panic_bounds_check</span><br><span class="line">   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index</span><br><span class="line">   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index</span><br><span class="line">   5: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index</span><br><span class="line">   6: my_crate::main  // ❗ 你的代码位置 ❗</span><br><span class="line">   7: core::ops::function::FnOnce::call_once</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关键步骤</strong>：</p>
<ol>
<li>从底部向上查找</li>
<li>定位第一个属于你代码的文件（如 <code>src/main.rs:6</code>）</li>
<li>忽略 Rust 内部调用（0-5）</li>
</ol>
</blockquote>
<hr>
<p><strong>何时使用 panic？</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>是否 panic</strong></th>
<th align="left"><strong>替代方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">示例&#x2F;原型代码</td>
<td align="left">✅ 适用</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">程序启动配置错误</td>
<td align="left">✅ 适用</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">违反核心不变量的情况</td>
<td align="left">✅ 适用</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">预期的可恢复错误</td>
<td align="left">❌ 避免</td>
<td align="left"><code>Result</code> 返回值</td>
</tr>
<tr>
<td align="left">用户输入错误</td>
<td align="left">❌ 避免</td>
<td align="left">错误提示+重试</td>
</tr>
<tr>
<td align="left">网络请求超时</td>
<td align="left">❌ 避免</td>
<td align="left">重试机制</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>黄金法则</strong>：只有遇到程序无法继续执行的严重错误时才用 <code>panic!</code></p>
</blockquote>
<hr>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>开发阶段</strong>：</p>
<ul>
<li>保留默认栈展开</li>
<li>使用 <code>RUST_BACKTRACE=1</code> 调试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux/macOS</span></span><br><span class="line">RUST_BACKTRACE=1 cargo run</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows PowerShell</span></span><br><span class="line"><span class="variable">$env</span>:RUST_BACKTRACE=1; cargo run</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发布阶段</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span>  <span class="comment"># 减小二进制体积</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理原则</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优于 panic! 的做法</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = vector.<span class="title function_ invoke__">get</span>(index) &#123;</span><br><span class="line">    <span class="comment">// 安全处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;索引 &#123;&#125; 越界&quot;</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>总结</strong></p>
<p><code>panic!</code> 是 Rust 处理不可恢复错误的最后手段：</p>
<ul>
<li>开发环境：利用 backtrace 快速定位问题</li>
<li>生产环境：配置 <code>panic = &#39;abort</code> 优化性能</li>
<li>大多数场景：优先使用 <code>Result</code> 处理可恢复错误</li>
</ul>
<blockquote>
<p>“恐慌不是策略，而是无路可退时的警报。” - Rustacean 箴言</p>
</blockquote>
<hr>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a><code>Result</code></h3><p>用 Result 处理可恢复的错误，例如，如果因为打开一个并不存在的文件而失败，此时我们可能想要创建这个文件，而不是终止进程。</p>
<p><strong>核心概念</strong></p>
<p><strong><code>Result&lt;T, E&gt;</code></strong>：处理可恢复错误的枚举类型</p>
<ul>
<li><code>Ok(T)</code>：操作成功时包含的值</li>
<li><code>Err(E)</code>：操作失败时包含的错误信息</li>
</ul>
<hr>
<p><strong>基础错误处理模式</strong></p>
<ol>
<li><strong>模式匹配处理</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"><span class="keyword">match</span> file_result &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(file) =&gt; <span class="title function_ invoke__">process_file</span>(file),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">        std::io::ErrorKind::NotFound =&gt; <span class="title function_ invoke__">create_file</span>(),</span><br><span class="line">        _ =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;无法打开文件: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>错误类型细化</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;config.cfg&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(f) =&gt; f,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) <span class="keyword">if</span> e.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound =&gt; &#123;</span><br><span class="line">        File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;config.cfg&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;创建文件失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;文件错误: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>实用快捷方法</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方法</strong></th>
<th align="left"><strong>行为描述</strong></th>
<th align="left"><strong>适用场景</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>unwrap()</code></td>
<td align="left">成功返回值，失败则 panic</td>
<td align="left">原型开发&#x2F;快速验证</td>
<td align="left"><code>let f = File::open(&quot;f.txt&quot;).unwrap();</code></td>
</tr>
<tr>
<td align="left"><code>expect(msg)</code></td>
<td align="left">同 unwrap，可自定义错误消息</td>
<td align="left">需要明确错误上下文</td>
<td align="left"><code>File::open(&quot;f.txt&quot;).expect(&quot;配置文件必须存在&quot;);</code></td>
</tr>
<tr>
<td align="left"><code>unwrap_or_else()</code></td>
<td align="left">错误时执行自定义处理函数</td>
<td align="left">生产环境错误处理</td>
<td align="left">见下方完整示例</td>
</tr>
</tbody></table>
<p><strong><code>unwrap_or_else</code> 完整示例</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;config.toml&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">    <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">        <span class="comment">// 文件不存在时创建新文件</span></span><br><span class="line">        File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;config.toml&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|create_error| &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;创建文件失败: &#123;:?&#125;&quot;</span>, create_error);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他错误直接panic</span></span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;无法打开文件: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>选择建议</strong>：</p>
<ul>
<li>原型开发：<code>unwrap</code>&#x2F;<code>expect</code></li>
<li>生产代码：优先使用模式匹配或<code>unwrap_or_else</code></li>
</ul>
</blockquote>
<hr>
<p><strong>错误传播技术</strong></p>
<ol>
<li><strong>手动传播：（显式匹配）</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_config</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 第一层匹配：文件打开</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;config.cfg&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,          <span class="comment">// 成功：返回文件句柄</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),   <span class="comment">// 失败：直接返回错误</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二层匹配：读取内容</span></span><br><span class="line">    <span class="keyword">match</span> file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(contents),     <span class="comment">// 成功：返回内容</span></span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),          <span class="comment">// 失败：返回错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong><code>?</code>运算符（推荐）</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_config</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;config.cfg&quot;</span>)?;  <span class="comment">// 错误时自动返回</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;       <span class="comment">// 错误时自动返回</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>链式调用-自动转换</strong>：<code>?</code>会调用<code>from</code>进行错误类型转换</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_config</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;config.cfg&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>终极简化</strong>：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_config</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;config.cfg&quot;</span>)  <span class="comment">// 单行完成开/读/关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>?</code>运算符使用规则</strong></p>
<ol>
<li><strong>函数返回值约束</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 合法：返回Result</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">valid_func</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;data.txt&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 非法：main默认返回()</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;file.txt&quot;</span>)?; <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>解决方案</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确用法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;data.txt&quot;</span>)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, data);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(()) <span class="comment">// 正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Box&lt;dyn Error&gt;</code>：通用错误类型（可容纳任何错误）</li>
<li>退出码：<code>Ok(())</code> → 0，<code>Err</code> → 非0</li>
</ul>
<ol start="3">
<li><strong>Option中的用法</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_line</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">next</span>()? <span class="comment">// 如果为None则提前返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>错误处理黄金法则</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>错误类型</strong></th>
<th align="left"><strong>处理方式</strong></th>
<th align="left"><strong>典型场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">不可恢复错误</td>
<td align="left"><code>panic!</code></td>
<td align="left">数组越界、违反程序不变性</td>
</tr>
<tr>
<td align="left">可恢复错误</td>
<td align="left"><code>Result&lt;T, E&gt;</code></td>
<td align="left">文件不存在、网络请求失败</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>设计哲学</strong>：当不确定时应优先返回<code>Result</code>，让调用者决定处理方式</p>
</blockquote>
<p><strong>关键总结</strong></p>
<ol>
<li><strong>错误传播</strong>：优先使用<code>?</code>运算符保持代码简洁</li>
<li><strong>错误转换</strong>：利用<code>From</code> trait自动转换错误类型</li>
<li><strong>入口点处理</strong>：<code>main</code>函数可返回<code>Result</code>类型</li>
<li><strong>组合方法</strong>：结合<code>map</code>&#x2F;<code>and_then</code>等组合子构建处理链</li>
</ol>
<p>通过<code>Result</code>和<code>?</code>运算符，Rust实现了既安全又简洁的错误处理机制，使开发者能够清晰地表达错误处理逻辑而不牺牲代码可读性。</p>
<hr>
<h3 id="panic-vs-Result"><a href="#panic-vs-Result" class="headerlink" title="panic! vs Result"></a><code>panic!</code> vs <code>Result</code></h3><p><strong>核心原则</strong></p>
<p><strong>默认选择</strong>：优先返回 <code>Result</code></p>
<ul>
<li>将错误处理权交给调用者</li>
<li>保持代码灵活性和可恢复性</li>
</ul>
<hr>
<p><strong>适合使用 <code>panic!</code> 的场景</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>说明</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>示例&#x2F;原型代码</strong></td>
<td align="left">快速失败以暴露问题</td>
<td align="left"><code>let port: u16 = &quot;8080&quot;.parse().unwrap();</code></td>
</tr>
<tr>
<td align="left"><strong>测试用例</strong></td>
<td align="left">测试失败时应直接终止</td>
<td align="left"><code>assert_eq!(calculate(), 42);</code></td>
</tr>
<tr>
<td align="left"><strong>开发者已知安全</strong></td>
<td align="left">人类判断不会出错（编译器无法推断）</td>
<td align="left"><code>rust&lt;br&gt;let home: IpAddr = &quot;127.0.0.1&quot;&lt;br&gt; .parse()&lt;br&gt; .expect(&quot;有效IP&quot;);</code></td>
</tr>
<tr>
<td align="left"><strong>有害状态 (Bad State)</strong></td>
<td align="left">程序处于不可恢复的无效状态</td>
<td align="left">见下方详细说明</td>
</tr>
<tr>
<td align="left"><strong>外部不可控代码</strong></td>
<td align="left">调用外部代码返回无法处理的无效状态</td>
<td align="left">调用C FFI返回空指针</td>
</tr>
<tr>
<td align="left"><strong>安全漏洞风险</strong></td>
<td align="left">操作可能引发内存安全问题时</td>
<td align="left">数组越界访问</td>
</tr>
</tbody></table>
<hr>
<p><strong>有害状态 (Bad State) 的判断标准</strong></p>
<p>满足以下<strong>所有条件</strong>时适合 <code>panic!</code>：</p>
<ol>
<li><strong>非预期状态</strong>：<ul>
<li>非常规情况（非用户输入错误等预期错误）</li>
<li><em>反例</em>：用户输入格式错误应返回 <code>Result</code></li>
</ul>
</li>
<li><strong>后续依赖此状态</strong>：<ul>
<li>后续代码逻辑依赖当前状态有效性</li>
<li>无法在每个步骤都进行状态检查</li>
</ul>
</li>
<li><strong>无法编码到类型系统</strong>：<ul>
<li>无法通过类型系统保证状态有效性</li>
<li><em>反例</em>：使用 <code>u32</code> 避免负数问题</li>
</ul>
</li>
</ol>
<hr>
<p><strong>自定义类型验证模式（推荐）</strong></p>
<p><strong>问题</strong>：多处重复验证相同逻辑<br><strong>解决方案</strong>：创建封装类型保证有效性</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Percentage</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Percentage</span> &#123;</span><br><span class="line">    <span class="comment">/// 创建新实例（验证范围）</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !(<span class="number">0</span>..=<span class="number">100</span>).<span class="title function_ invoke__">contains</span>(&amp;value) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;百分比必须在0-100之间: &#123;&#125;&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 安全获取值</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用（编译时保证有效性）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Percentage::<span class="title function_ invoke__">new</span>(<span class="number">75</span>);  <span class="comment">// 安全使用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_</span> = Percentage::<span class="title function_ invoke__">new</span>(<span class="number">150</span>); <span class="comment">// 运行时 panic!</span></span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>：</p>
<ol>
<li>集中验证逻辑</li>
<li>通过类型系统保证数据有效性</li>
<li>避免重复检查</li>
</ol>
<hr>
<p><strong>错误处理决策流程图</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[遇到错误] --&gt; B&#123;是否可恢复?&#125;</span><br><span class="line">    B --&gt;|是| C[返回 Result]</span><br><span class="line">    B --&gt;|否| D&#123;是否符合以下任一?&#125;</span><br><span class="line">    D --&gt; E[示例/原型]</span><br><span class="line">    D --&gt; F[测试用例]</span><br><span class="line">    D --&gt; G[有害状态]</span><br><span class="line">    D --&gt; H[安全风险]</span><br><span class="line">    D --&gt; I[外部不可控]</span><br><span class="line">    E --&gt; J[panic!]</span><br><span class="line">    F --&gt; J</span><br><span class="line">    G --&gt; J</span><br><span class="line">    H --&gt; J</span><br><span class="line">    I --&gt; J</span><br><span class="line">    D --&gt;|不符合| C</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>黄金准则总结</strong></p>
<ol>
<li><p><strong>默认路径</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先选择</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">api</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Data, Error&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>panic! 适用场景</strong>：</p>
<ul>
<li>示例&#x2F;原型&#x2F;测试代码</li>
<li>绝对不可能发生的错误（开发者保证）</li>
<li>程序处于有害状态（违反核心不变性）</li>
<li>安全关键操作（内存安全风险）</li>
</ul>
</li>
<li><p><strong>创建验证类型</strong>：</p>
<ul>
<li>对重要约束创建专用类型</li>
<li>在构造时进行一次性验证</li>
<li>通过类型系统保证后续使用安全</li>
</ul>
</li>
</ol>
<blockquote>
<p>遵循 “通过类型系统防止错误，而非运行时检查” 的 Rust 哲学，显著提高代码可靠性</p>
</blockquote>
<hr>
<hr>
<h2 id="泛型、Trait-和生命周期"><a href="#泛型、Trait-和生命周期" class="headerlink" title="泛型、Trait 和生命周期"></a>泛型、Trait 和生命周期</h2><h3 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h3><p><strong><code>&lt;T&gt;</code> 具体类型或其他属性的抽象替代</strong></p>
<p><strong>泛型（Generics）</strong>：创建类型或函数的抽象模板，可处理多种具体类型</p>
<ul>
<li>消除重复代码</li>
<li>提高代码复用性</li>
<li>编译时类型安全</li>
</ul>
<hr>
<p><strong>从具体到泛型的演变</strong></p>
<ol>
<li><strong>具体类型函数</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_i32</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>遇到新需求</strong>（需支持<code>char</code>类型）：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_char</span>(list: &amp;[<span class="type">char</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>泛型解决方案</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关键改进</strong>：</p>
<ul>
<li><code>T</code> 代表任意类型</li>
<li><code>PartialOrd</code> trait 约束确保类型可比较</li>
</ul>
</blockquote>
<hr>
<p><strong>泛型使用场景</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>示例</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">函数定义</td>
<td align="left"><code>fn func&lt;T&gt;(arg: T) -&gt; T</code></td>
<td align="left">参数和返回值泛型化</td>
</tr>
<tr>
<td align="left">结构体定义</td>
<td align="left"><code>struct Point&lt;T&gt; &#123; x: T, y: T &#125;</code></td>
<td align="left">字段类型泛型化</td>
</tr>
<tr>
<td align="left">枚举定义</td>
<td align="left"><code>enum Option&lt;T&gt; &#123; Some(T), None &#125;</code></td>
<td align="left">关联值泛型化</td>
</tr>
<tr>
<td align="left">方法实现</td>
<td align="left"><code>impl&lt;T&gt; Point&lt;T&gt; &#123; ... &#125;</code></td>
<td align="left">为泛型结构体实现方法</td>
</tr>
</tbody></table>
<hr>
<p><strong>函数泛型示例</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明泛型类型T</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123; <span class="comment">// 需要T实现PartialOrd</span></span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型结构体示例</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单泛型参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T, <span class="comment">// x和y必须是相同类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多泛型参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point2</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U, <span class="comment">// x和y可以是不同类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">int_point</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mixed_point</span> = Point2 &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>泛型枚举示例</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">success</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="type">Result</span>::<span class="title function_ invoke__">Ok</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">failure</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="type">Result</span>::<span class="title function_ invoke__">Err</span>(<span class="string">&quot;Error&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>泛型方法实现</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 通用方法（所有Point&lt;T&gt;可用）</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 特定类型方法（仅Point&lt;f32&gt;可用）</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法自有泛型参数</span></span><br><span class="line"><span class="keyword">impl</span>&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;X2, Y2&gt;(<span class="keyword">self</span>, other: Point&lt;X2, Y2&gt;) <span class="punctuation">-&gt;</span> Point&lt;X1, Y2&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>性能说明</strong></p>
<p><strong>零成本抽象</strong>：Rust 泛型在编译时进行单态化（Monomorphization）</p>
<ul>
<li>编译器为每种具体类型生成专用代码</li>
<li>运行时无额外开销</li>
<li>等效于手写多个具体类型版本</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译后生成：</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_i32</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_char</span>(list: &amp;[<span class="type">char</span>]) <span class="punctuation">-&gt;</span> &amp;<span class="type">char</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译时优化</strong>：泛型代码 ⇒ 具体类型代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型定义</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后生成</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>零成本抽象</strong>：运行时效率等同于手写具体类型代码</li>
<li><strong>完全类型安全</strong>：编译时检查所有类型约束</li>
</ul>
<hr>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>命名约定</strong>：</p>
<ul>
<li>使用大写驼峰式命名（如 <code>T</code>, <code>Key</code>, <code>Value</code>）</li>
<li>简单类型常用 <code>T</code>（Type）、<code>E</code>（Error）、<code>K</code>（Key）、<code>V</code>（Value）</li>
</ul>
</li>
<li><p><strong>合理约束</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要比较功能</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要显示功能</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>&lt;T: Display&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;item&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必要约束（如比较操作需PartialOrd）</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">compare</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    a &gt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免过度约束</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>&lt;T&gt;(value: T) &#123; <span class="comment">// 无需约束</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免过度泛化</strong>：</p>
<ul>
<li>只在真正需要复用的地方使用泛型</li>
<li>简单函数不需要强行泛化</li>
</ul>
</li>
<li><p><strong>错误处理：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;; <span class="comment">// ❌ 编译错误：类型不匹配</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案：使用多泛型参数 <code>Point&lt;T, U&gt;</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>泛型是 Rust 类型系统的核心支柱，与 trait 和生命周期共同构建了安全高效的抽象机制。</p>
</blockquote>
<hr>
<h3 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h3><p><strong>核心概念</strong></p>
<p><strong>Trait</strong>：定义类型共享行为的抽象接口</p>
<ul>
<li>声明共享方法签名</li>
<li>可为不同类型实现相同行为</li>
<li>类似其他语言的接口，但有独特特性</li>
</ul>
<hr>
<p><strong>Trait 基本使用</strong></p>
<ol>
<li><strong>定义与实现</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Summary trait</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为NewsArticle实现Summary</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123; <span class="comment">/* 字段 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>默认实现</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="comment">// 默认实现</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认实现</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;&#125;  <span class="comment">// 空impl块</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>依赖其他方法的实现</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;  <span class="comment">// 需要实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用未实现的方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Trait 作为参数（Trait Bound）</strong></p>
<ol>
<li><strong>基础语法</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法糖形式</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;News: &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价trait bound形式</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>多重约束</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求同时实现Summary + Display</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型形式</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Where子句简化</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复杂签名</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用where子句</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>返回实现Trait的类型</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    SocialPost &#123; <span class="comment">// 返回具体类型</span></span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;content&quot;</span>),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>限制</strong>：只能返回单一具体类型，以下代码无效：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：尝试返回两种不同类型</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123; NewsArticle&#123;...&#125; &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; SocialPost&#123;...&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>条件方法实现</strong></p>
<ol>
<li><strong>基于Trait约束的方法</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123; ... &#125; <span class="keyword">else</span> &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Blanket实现（覆盖性实现）</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库示例：为所有实现Display的类型实现ToString</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_string</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="number">3</span>.<span class="title function_ invoke__">to_string</span>();  <span class="comment">// 整数可用</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>孤儿规则（Coherence规则）</strong></p>
<p><strong>关键限制</strong>：只能为当前crate中的类型实现当前crate中的trait</p>
<ul>
<li>避免：为外部类型实现外部trait（被禁止）</li>
<li>允许：为当前类型实现外部trait</li>
<li>允许：为外部类型实现当前trait</li>
</ul>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许：Summary(当前) + Vec&lt;T&gt;(外部)</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Summary <span class="keyword">for</span> <span class="title class_">Vec</span>&lt;T&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止：Display(外部) + Vec&lt;T&gt;(外部)</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Display <span class="keyword">for</span> <span class="title class_">Vec</span>&lt;T&gt; &#123; ... &#125;  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>最佳实践总结</strong></p>
<ol>
<li><strong>定义明确的行为契约</strong>：Trait应聚焦单一职责</li>
<li><strong>合理使用默认实现</strong>：减少重复代码</li>
<li><strong>Trait Bound规范</strong>：<ul>
<li>简单场景用<code>impl Trait</code></li>
<li>复杂约束用<code>where</code>子句</li>
</ul>
</li>
<li><strong>Blanket实现</strong>：为符合条件的所有类型提供通用实现</li>
<li><strong>孤儿规则</strong>：设计crate时注意实现权限</li>
</ol>
<blockquote>
<p>Trait是Rust多态和代码复用的核心机制，与泛型结合形成强大抽象能力</p>
</blockquote>
<hr>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li><p><strong>核心目标</strong><br>确保引用始终指向有效数据，<strong>避免悬垂引用</strong>（Dangling References）。<br>▶ 示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x; <span class="comment">// 错误！`x` 在此处销毁，`r` 成为悬垂引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;r&#125;&quot;</span>); <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>借用检查器（Borrow Checker）</strong></p>
<ul>
<li>在编译期比较引用的<strong>作用域</strong>，验证引用有效性。</li>
<li>通过生命周期注解显式声明引用间的关系。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>生命周期注解语法</strong></p>
<ul>
<li><p><strong>标记规则</strong>：<code>&amp;&#39;a T</code><br>▶ 示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>        <span class="comment">// 显式生命周期的不可变引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">String</span> <span class="comment">// 显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>函数中的生命周期</strong></p>
<ol>
<li><p><strong>问题场景</strong><br>编译器无法推断返回引用的来源时需显式标注：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&#39;a</code> 表示 <strong><code>x</code> 和 <code>y</code> 实际生命周期的最小交集</strong>。</li>
<li>返回值生命周期与输入参数中较短者一致。</li>
</ul>
</li>
<li><p><strong>调用约束</strong><br>▶ 有效调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(s1.<span class="title function_ invoke__">as_str</span>(), s2.<span class="title function_ invoke__">as_str</span>()); <span class="comment">// `result` 生命周期 ≤ `s2`</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;result&#125;&quot;</span>); <span class="comment">// 合法：`result` 在 `s2` 存活期内使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>▶ 无效调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">    result = <span class="title function_ invoke__">longest</span>(s1.<span class="title function_ invoke__">as_str</span>(), s2.<span class="title function_ invoke__">as_str</span>()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;result&#125;&quot;</span>); <span class="comment">// 错误！`result` 可能指向已销毁的 `s2`</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>结构体中的生命周期</strong></p>
<ul>
<li><p>结构体包含引用时，<strong>必须声明生命周期</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Highlight</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    text: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, <span class="comment">// 引用字段需标注生命周期</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">excerpt</span> = Highlight &#123; text: first_sentence &#125;; <span class="comment">// `excerpt` 生命周期 ≤ `novel`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>生命周期省略规则</strong></p>
<p>编译器在以下场景可自动推断生命周期（无需手动标注）：</p>
<ol>
<li><strong>输入生命周期规则</strong>：每个引用参数分配独立生命周期。</li>
<li><strong>输出生命周期规则</strong>：若只有1个输入生命周期，将其赋予所有输出。</li>
<li><strong>方法规则</strong>：若方法含 <code>&amp;self</code>&#x2F;<code>&amp;mut self</code>，所有输出生命周期继承 <code>self</code>。</li>
</ol>
<p>▶ 省略示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123; ... &#125; </span><br><span class="line"><span class="comment">// 编译器自动展开为：fn first_word&lt;&#x27;a&gt;(s: &amp;&#x27;a str) -&gt; &amp;&#x27;a str</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>特殊生命周期：<code>&#39;static</code></strong></p>
<ul>
<li><p><strong>全局存活</strong>：整个程序运行期有效（如字符串字面值）。</p>
</li>
<li><p><strong>慎用场景</strong>：仅当引用确实永久有效时使用，多数错误源于逻辑问题而非需 <code>&#39;static</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;静态字符串&quot;</span>; <span class="comment">// 文本直接嵌入二进制</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>生命周期 + 泛型 + Trait Bound</strong></p>
<p>三者的组合使用场景：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">announce_longest</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    ann: T,          <span class="comment">// 泛型参数</span></span><br><span class="line">) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,      <span class="comment">// Trait Bound</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;公告：&#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关键总结</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>概念</strong></th>
<th align="left"><strong>作用</strong></th>
<th align="left"><strong>典型场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>生命周期注解</strong></td>
<td align="left">声明引用的有效范围关系</td>
<td align="left">函数签名、结构体定义</td>
</tr>
<tr>
<td align="left"><strong>借用检查器</strong></td>
<td align="left">编译期验证引用有效性，阻止悬垂引用</td>
<td align="left">所有引用操作</td>
</tr>
<tr>
<td align="left"><strong>省略规则</strong></td>
<td align="left">编译器自动推断常见模式的生命周期</td>
<td align="left">输入参数单一或含 <code>self</code> 的方法</td>
</tr>
<tr>
<td align="left"><strong><code>&#39;static</code></strong></td>
<td align="left">程序全局有效的引用（谨慎使用）</td>
<td align="left">字符串字面值、全局常量</td>
</tr>
<tr>
<td align="left"><strong>组合使用</strong></td>
<td align="left">生命周期 + 泛型 + Trait Bound &#x3D; 安全且灵活的抽象</td>
<td align="left">复杂函数&#x2F;结构体</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>核心价值</strong>：生命周期在<strong>编译期</strong>通过作用域分析保障内存安全，实现 <strong>“零运行时开销”</strong> 的高效内存管理。结合泛型和 Trait Bound，Rust 在高度抽象的同时保持绝对安全。</p>
</blockquote>
<hr>
<hr>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>Rust 包含了编写自动化软件测试的功能支持。</p>
<h3 id="如何编写测试"><a href="#如何编写测试" class="headerlink" title="如何编写测试"></a>如何编写测试</h3><p><strong>核心概念</strong></p>
<p>Rust 测试函数用于验证代码行为是否符合预期，通常包含三个步骤：</p>
<ol>
<li><strong>设置数据&#x2F;状态</strong></li>
<li><strong>运行被测代码</strong></li>
<li><strong>断言结果</strong></li>
</ol>
<p><strong>基础测试结构</strong></p>
<ol>
<li><p><strong>创建测试函数</strong>：<br>使用 <code>#[test]</code> 属性标记测试函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>); <span class="comment">// 断言</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行测试</strong>：<br>执行 <code>cargo test</code> 命令运行所有测试。</p>
</li>
</ol>
<hr>
<p><strong>断言宏</strong></p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>assert!</code></td>
<td align="left">检查条件是否为 <code>true</code></td>
<td align="left"><code>assert!(result.is_valid())</code></td>
</tr>
<tr>
<td align="left"><code>assert_eq!</code></td>
<td align="left">检查两个值<strong>相等</strong></td>
<td align="left"><code>assert_eq!(result, 4)</code></td>
</tr>
<tr>
<td align="left"><code>assert_ne!</code></td>
<td align="left">检查两个值<strong>不相等</strong></td>
<td align="left"><code>assert_ne!(result, 0)</code></td>
</tr>
</tbody></table>
<p>示例：<strong>矩形包含测试</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span> <span class="comment">// 需实现 PartialEq 和 Debug</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123; width: <span class="type">u32</span>, height: <span class="type">u32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">larger_holds_smaller</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123; width: <span class="number">8</span>, height: <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123; width: <span class="number">5</span>, height: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="built_in">assert!</span>(larger.<span class="title function_ invoke__">can_hold</span>(&amp;smaller)); <span class="comment">// 使用 assert!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">smaller_cannot_hold_larger</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123; width: <span class="number">8</span>, height: <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123; width: <span class="number">5</span>, height: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="built_in">assert!</span>(!smaller.<span class="title function_ invoke__">can_hold</span>(&amp;larger)); <span class="comment">// 取反检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>自定义失败信息</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greeting_contains_name</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">greeting</span>(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(</span><br><span class="line">        result.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;Carol&quot;</span>),</span><br><span class="line">        <span class="string">&quot;输出不包含名字，实际值: `&#123;&#125;`&quot;</span>, <span class="comment">// 自定义错误信息</span></span><br><span class="line">        result</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>失败时输出：<br><code>Greeting did not contain name, value was &#39;Hello!&#39;</code></p>
<hr>
<p><strong>测试 Panic 场景</strong></p>
<p>使用 <code>#[should_panic]</code> 验证代码是否按预期 panic：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123; value: <span class="type">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;值必须在 1-100 之间，输入: &#123;&#125;&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[should_panic(expected = <span class="string">&quot;值必须在 1-100 之间&quot;</span>)]</span> <span class="comment">// 可选：匹配错误信息</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">    Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>); <span class="comment">// 预期触发 panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>使用 <code>Result&lt;T, E&gt;</code> 的测试</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_works</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> result == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;2+2 不等于 4&quot;</span>)) <span class="comment">// 返回错误而非 panic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：此类测试<strong>不能</strong>使用 <code>#[should_panic]</code>。</p>
</blockquote>
<hr>
<p><strong>关键特性总结</strong></p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">语法&#x2F;方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标记测试函数</td>
<td align="left"><code>#[test]</code></td>
</tr>
<tr>
<td align="left">运行测试</td>
<td align="left"><code>cargo test</code></td>
</tr>
<tr>
<td align="left">相等断言</td>
<td align="left"><code>assert_eq!(a, b)</code></td>
</tr>
<tr>
<td align="left">不等断言</td>
<td align="left"><code>assert_ne!(a, b)</code></td>
</tr>
<tr>
<td align="left">条件检查</td>
<td align="left"><code>assert!(condition)</code></td>
</tr>
<tr>
<td align="left">自定义错误信息</td>
<td align="left">在断言后添加格式化字符串</td>
</tr>
<tr>
<td align="left">验证 panic</td>
<td align="left"><code>#[should_panic]</code></td>
</tr>
<tr>
<td align="left">返回错误的测试</td>
<td align="left"><code>fn test() -&gt; Result&lt;(), E&gt;</code></td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li>为自定义类型添加 <code>#[derive(Debug, PartialEq)]</code> 以支持断言</li>
<li>使用 <code>expected</code> 参数精确匹配 panic 信息</li>
<li>在复杂场景中优先使用 <code>Result&lt;T, E&gt;</code> 测试便于错误处理</li>
<li>测试模块应放在 <code>#[cfg(test)]</code> 模块内，避免编译到生产环境</li>
</ol>
<p>通过组合这些工具，您可以构建覆盖各种场景的健壮测试套件，确保 Rust 代码的可靠性和正确性。</p>
<hr>
<h3 id="控制测试"><a href="#控制测试" class="headerlink" title="控制测试"></a>控制测试</h3><p><strong>1. 控制测试并行度</strong></p>
<p>默认并行运行测试，可通过 <code>--test-threads</code> 控制线程数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单线程顺序运行测试</span></span><br><span class="line">$ cargo <span class="built_in">test</span> -- --test-threads=1</span><br></pre></td></tr></table></figure>

<p><strong>2. 显示测试输出</strong></p>
<p>默认隐藏通过测试的输出，使用 <code>--show-output</code> 显示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> -- --show-output</span><br></pre></td></tr></table></figure>

<p><strong>3. 按名称过滤测试</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">运行单个测试</td>
<td align="left"><code>cargo test test_name</code></td>
<td align="left">精确匹配测试名</td>
</tr>
<tr>
<td align="left">运行多个测试</td>
<td align="left"><code>cargo test partial_name</code></td>
<td align="left">匹配包含该字符串的测试</td>
</tr>
<tr>
<td align="left">运行模块测试</td>
<td align="left"><code>cargo test module_name::</code></td>
<td align="left">运行指定模块的所有测试</td>
</tr>
</tbody></table>
<p><strong>4. 处理被忽略的测试</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore = <span class="string">&quot;耗时太长&quot;</span>]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expensive_test</span>() &#123;</span><br><span class="line">    <span class="comment">// 长时间运行的测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cargo test</code></td>
<td align="left">默认跳过被忽略的测试</td>
</tr>
<tr>
<td align="left"><code>cargo test -- --ignored</code></td>
<td align="left">只运行被忽略的测试</td>
</tr>
<tr>
<td align="left"><code>cargo test -- --include-ignored</code></td>
<td align="left">运行所有测试（含被忽略的）</td>
</tr>
</tbody></table>
<p><strong>5. 测试输出示例对比</strong></p>
<p><strong>默认输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">running 2 tests</span><br><span class="line">test fast_test ... ok</span><br><span class="line">test slow_test ... ignored</span><br></pre></td></tr></table></figure>

<p><strong>显示输出</strong> (<code>--show-output</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">running 2 tests</span><br><span class="line">test fast_test ... ok</span><br><span class="line"></span><br><span class="line">stdout:</span><br><span class="line">计算结果: 42</span><br><span class="line"></span><br><span class="line">test slow_test ... ignored</span><br></pre></td></tr></table></figure>

<p><strong>运行被忽略测试</strong> (<code>--ignored</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">running 1 test</span><br><span class="line">test slow_test ... ok</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关键参数总结</strong></p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">命令格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">控制线程数</td>
<td align="left"><code>cargo test -- --test-threads=N</code></td>
<td align="left">设置并行线程数量</td>
</tr>
<tr>
<td align="left">显示输出</td>
<td align="left"><code>cargo test -- --show-output</code></td>
<td align="left">显示通过测试的输出</td>
</tr>
<tr>
<td align="left">精确匹配</td>
<td align="left"><code>cargo test exact_test_name</code></td>
<td align="left">运行单个指定测试</td>
</tr>
<tr>
<td align="left">模糊匹配</td>
<td align="left"><code>cargo test partial_name</code></td>
<td align="left">运行名称包含该字符串的测试</td>
</tr>
<tr>
<td align="left">运行被忽略</td>
<td align="left"><code>cargo test -- --ignored</code></td>
<td align="left">只运行被标记为 ignore 的测试</td>
</tr>
<tr>
<td align="left">包含被忽略</td>
<td align="left"><code>cargo test -- --include-ignored</code></td>
<td align="left">运行所有测试（含被忽略的）</td>
</tr>
</tbody></table>
<hr>
<p><strong>使用技巧</strong></p>
<ol>
<li><p><strong>调试特定测试</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单线程运行特定测试并显示输出</span></span><br><span class="line">$ cargo <span class="built_in">test</span> failing_test -- --test-threads=1 --show-output</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分离长短期测试</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">quick_test</span>() &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[ignore = <span class="string">&quot;需要完整数据库&quot;</span>]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">full_integration_test</span>() &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日常开发：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>完整测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> -- --ignored</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>批量运行相关测试</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行所有数据库相关测试</span></span><br><span class="line">$ cargo <span class="built_in">test</span> db_</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过合理组合这些选项，可以高效控制测试的执行方式，适应不同测试场景的需求。</p>
<hr>
<h3 id="测试的组织结构"><a href="#测试的组织结构" class="headerlink" title="测试的组织结构"></a>测试的组织结构</h3><p><strong>1. 单元测试 (Unit Tests)</strong></p>
<ul>
<li><p><strong>位置</strong>：与源码同文件（<code>src/</code> 目录中）</p>
</li>
<li><p><strong>结构</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span> <span class="comment">// 仅测试时编译</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_case</span>() &#123;</span><br><span class="line">        <span class="comment">// 测试逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>可测试私有函数</li>
<li>快速验证单个模块</li>
<li>使用 <code>cargo test</code> 运行</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">internal_adder</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; a + b &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test_private</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">internal_adder</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="number">4</span>); <span class="comment">// 测试私有函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>2. 集成测试 (Integration Tests)</strong></p>
<ul>
<li><p><strong>位置</strong>：<code>tests/</code> 目录（与 <code>src/</code> 同级）</p>
</li>
<li><p><strong>结构</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tests/integration_test.rs</span></span><br><span class="line"><span class="keyword">use</span> your_crate::public_function; <span class="comment">// 导入公有API</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_integration</span>() &#123;</span><br><span class="line">    <span class="comment">// 跨模块测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>仅测试公有接口</li>
<li>模拟外部用户使用方式</li>
<li>每个文件是独立 crate</li>
</ul>
</li>
<li><p><strong>文件结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src/</span><br><span class="line">│   └── lib.rs</span><br><span class="line">└── tests/</span><br><span class="line">    ├── integration_test.rs</span><br><span class="line">    └── common/</span><br><span class="line">        └── mod.rs  # 辅助模块</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>3. 辅助模块处理</strong></p>
<ul>
<li><p><strong>问题</strong>：避免辅助模块被识别为测试</p>
</li>
<li><p><strong>解决方案</strong>：</p>
<ol>
<li><p>创建 <code>tests/common/mod.rs</code></p>
</li>
<li><p>在测试文件中引入：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> common; <span class="comment">// 不是 use!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_with_helper</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<hr>
<p><strong>4. 二进制 Crate 的特殊性</strong></p>
<ul>
<li><p><strong>问题</strong>：无法直接测试 <code>src/main.rs</code></p>
</li>
<li><p><strong>最佳实践</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs (核心逻辑)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">core_logic</span>() &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main.rs (精简入口)</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    your_crate::<span class="title function_ invoke__">core_logic</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tests/integration_test.rs (测试库)</span></span><br><span class="line"><span class="keyword">use</span> your_crate::core_logic;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>测试输出结构</strong></p>
<p>运行 <code>cargo test</code> 的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Running unittests src/lib.rs    # 单元测试</span><br><span class="line">Running tests/integration.rs    # 集成测试</span><br><span class="line">Doc-tests your_crate            # 文档测试</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>测试类型对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>单元测试</strong></th>
<th align="left"><strong>集成测试</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">位置</td>
<td align="left">源码文件中</td>
<td align="left"><code>tests/</code> 目录</td>
</tr>
<tr>
<td align="left">可见性</td>
<td align="left">可测试私有函数</td>
<td align="left">仅测试公有 API</td>
</tr>
<tr>
<td align="left">编译标记</td>
<td align="left">需要 <code>#[cfg(test)]</code></td>
<td align="left">自动识别</td>
</tr>
<tr>
<td align="left">作用范围</td>
<td align="left">单个模块</td>
<td align="left">跨模块&#x2F;整个 crate</td>
</tr>
<tr>
<td align="left">辅助代码</td>
<td align="left">直接写在测试模块</td>
<td align="left">通过 <code>common/mod.rs</code> 共享</td>
</tr>
<tr>
<td align="left">二进制 crate支持</td>
<td align="left">直接支持</td>
<td align="left">需通过库接口间接测试</td>
</tr>
</tbody></table>
<hr>
<p><strong>关键命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行特定集成测试文件</span></span><br><span class="line">cargo <span class="built_in">test</span> --<span class="built_in">test</span> integration_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行所有测试（含文档测试）</span></span><br><span class="line">cargo <span class="built_in">test</span> --all</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>最佳实践</strong></p>
<ol>
<li><strong>保持单元测试小而专注</strong>：验证单个函数&#x2F;方法</li>
<li><strong>集成测试模拟真实场景</strong>：测试多个模块协作</li>
<li><strong>共享辅助代码</strong>：使用 <code>tests/common/mod.rs</code></li>
<li><strong>核心逻辑放入库</strong>：使二进制和集成测试可复用</li>
<li><strong>合理分配比例</strong>：70% 单元测试 + 30% 集成测试</li>
</ol>
<p>通过这种组织结构，可以确保代码从微观到宏观都得到充分验证，同时保持测试代码的整洁和可维护性。</p>
<hr>
<hr>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p><strong>核心实现步骤</strong></p>
<ol>
<li><p><strong>导入环境模块</strong>：</p>
<p>这个函数返回一个传递给程序的命令行参数的<strong>迭代器</strong>（<em>iterator</em>）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取参数集合</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提取关键参数</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];  <span class="comment">// 搜索字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">file_path</span> = &amp;args[<span class="number">2</span>];  <span class="comment">// 文件路径</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>完整代码示例</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 获取命令行参数集合</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提取搜索词和文件路径</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_path</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印参数信息</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, file_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>参数索引说明</strong></p>
<table>
<thead>
<tr>
<th align="left">索引</th>
<th align="left">值示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>args[0]</code></td>
<td align="left"><code>&quot;target/debug/minigrep&quot;</code></td>
<td align="left">可执行文件路径</td>
</tr>
<tr>
<td align="left"><code>args[1]</code></td>
<td align="left"><code>&quot;searchstring&quot;</code></td>
<td align="left">用户搜索词</td>
</tr>
<tr>
<td align="left"><code>args[2]</code></td>
<td align="left"><code>&quot;example.txt&quot;</code></td>
<td align="left">目标文件路径</td>
</tr>
</tbody></table>
<hr>
<p><strong>运行示例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- <span class="built_in">test</span> sample.txt</span><br><span class="line">   Compiling minigrep v0.1.0</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.41s</span><br><span class="line">     Running `target/debug/minigrep <span class="built_in">test</span> sample.txt`</span><br><span class="line">Searching <span class="keyword">for</span> <span class="built_in">test</span></span><br><span class="line">In file sample.txt</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关键特性说明</strong></p>
<ol>
<li><strong>参数收集</strong>：<ul>
<li><code>env::args()</code> 返回命令行参数的迭代器</li>
<li><code>.collect()</code> 将迭代器转换为 <code>Vec&lt;String&gt;</code></li>
<li>必须显式声明类型 <code>Vec&lt;String&gt;</code></li>
</ul>
</li>
<li><strong>参数处理</strong>：<ul>
<li>索引从 0 开始，0 号位置总是程序路径</li>
<li>用户参数从索引 1 开始</li>
<li>使用字符串引用避免数据拷贝（<code>&amp;args[1]</code>）</li>
</ul>
</li>
<li><strong>特殊参数处理</strong>：<ul>
<li><code>--</code> 分隔符：确保 cargo 不会解析后续参数</li>
<li>参数顺序：程序名 → 搜索词 → 文件路径</li>
</ul>
</li>
</ol>
<hr>
<p><strong>当前限制与改进方向</strong></p>
<ol>
<li><p><strong>问题</strong>：</p>
<ul>
<li>参数不足时 panic</li>
<li>无法处理带空格参数</li>
<li>缺少错误提示</li>
</ul>
</li>
<li><p><strong>后续改进</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进后示例</span></span><br><span class="line"><span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;Usage: minigrep &lt;query&gt; &lt;file-path&gt;&quot;</span>);</span><br><span class="line">    std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>执行流程示意图</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[用户输入] --&gt;|cargo run -- test sample.txt| B[程序启动]</span><br><span class="line">    B --&gt; C[收集参数]</span><br><span class="line">    C --&gt; D[参数向量]</span><br><span class="line">    D --&gt; E[提取查询词]</span><br><span class="line">    D --&gt; F[提取文件路径]</span><br><span class="line">    E --&gt; G[打印查询词]</span><br><span class="line">    F --&gt; H[打印文件路径]</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>重要注意事项</strong></p>
<ol>
<li><p><strong>Unicode 处理</strong>：</p>
<ul>
<li><p>使用 <code>env::args()</code> 要求所有参数是有效 Unicode</p>
</li>
<li><p>如需处理非 Unicode 参数，改用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env::args_os;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;std::ffi::OsString&gt; = <span class="title function_ invoke__">args_os</span>().<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>参数所有权</strong>：</p>
<ul>
<li><p>使用引用 <code>&amp;args[1]</code> 避免复制字符串</p>
</li>
<li><p>需要长期使用时需克隆：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>此实现为后续文件读取和搜索功能奠定了基础，下一步将添加文件读取功能。</p>
<hr>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p><strong>核心实现步骤</strong></p>
<ol>
<li><p><strong>导入文件系统模块</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>读取文件内容</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(file_path)</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法读取文件&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>完整代码示例</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 获取命令行参数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提取参数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_path</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印参数信息</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Searching for &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;In file &#123;&#125;&quot;</span>, file_path);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取文件内容</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(file_path)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法读取文件&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印文件内容</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;&#125;&quot;</span>, contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>文件读取说明</strong></p>
<ol>
<li><strong><code>fs::read_to_string</code> 函数</strong>：<ul>
<li>参数：文件路径（<code>&amp;str</code> 或 <code>String</code>）</li>
<li>返回值：<code>Result&lt;String, std::io::Error&gt;</code></li>
<li>功能：一次性读取整个文件到字符串</li>
</ul>
</li>
<li><strong>错误处理</strong>：<ul>
<li>使用 <code>expect</code> 处理可能的错误</li>
<li>文件不存在或无法读取时程序会 panic</li>
</ul>
</li>
</ol>
<hr>
<p><strong>文件结构示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minigrep/</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── poem.txt       # 测试文件</span><br><span class="line">└── src/</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>

<p><strong>poem.txt 内容</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m nobody! Who are you?</span><br><span class="line">Are you nobody, too?</span><br><span class="line">Then there&#x27;s a pair of us - don&#x27;t tell!</span><br><span class="line">They&#x27;d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>运行示例</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- the poem.txt</span><br><span class="line">   Compiling minigrep v0.1.0</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.41s</span><br><span class="line">     Running `target/debug/minigrep the poem.txt`</span><br><span class="line">Searching <span class="keyword">for</span> the</span><br><span class="line">In file poem.txt</span><br><span class="line">文件内容:</span><br><span class="line">I<span class="string">&#x27;m nobody! Who are you?</span></span><br><span class="line"><span class="string">Are you nobody, too?</span></span><br><span class="line"><span class="string">Then there&#x27;</span>s a pair of us - don<span class="string">&#x27;t tell!</span></span><br><span class="line"><span class="string">They&#x27;</span>d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>当前实现的问题</strong></p>
<ol>
<li><p><strong>单一职责原则</strong>：</p>
<ul>
<li><code>main</code> 函数承担了参数解析、文件读取和内容打印多个职责</li>
</ul>
</li>
<li><p><strong>错误处理不足</strong>：</p>
<ul>
<li>使用 <code>expect</code> 在错误时直接 panic</li>
<li>没有友好的错误提示</li>
</ul>
</li>
<li><p><strong>潜在改进方向</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进后的错误处理</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">contents</span> = <span class="keyword">match</span> fs::<span class="title function_ invoke__">read_to_string</span>(file_path) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(content) =&gt; content,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;读取文件错误: &#123;e&#125;&quot;</span>);</span><br><span class="line">        std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>文件读取特性说明</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>说明</strong></th>
<th align="left"><strong>注意事项</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">一次性读取</td>
<td align="left">整个文件读入内存</td>
<td align="left">不适合大文件</td>
</tr>
<tr>
<td align="left">UTF-8 编码</td>
<td align="left">要求文件为有效 UTF-8</td>
<td align="left">非 UTF-8 文件需用 <code>fs::read</code></td>
</tr>
<tr>
<td align="left">相对路径</td>
<td align="left">相对于当前工作目录</td>
<td align="left">通常为项目根目录</td>
</tr>
<tr>
<td align="left">错误类型</td>
<td align="left">返回 <code>io::Error</code></td>
<td align="left">包含详细错误信息</td>
</tr>
</tbody></table>
<hr>
<p><strong>后续开发方向</strong></p>
<ol>
<li><p><strong>重构代码结构</strong>：</p>
<ul>
<li>分离参数解析逻辑</li>
<li>分离文件读取逻辑</li>
<li>分离搜索逻辑</li>
</ul>
</li>
<li><p><strong>增强错误处理</strong>：</p>
<ul>
<li>自定义错误类型</li>
<li>更友好的错误消息</li>
<li>非 panic 的错误处理</li>
</ul>
</li>
<li><p><strong>实现搜索功能</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    contents.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">contains</span>(query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此步骤完成了文件读取功能，为后续实现搜索功能奠定了基础。当前实现虽然简单，但已经能够验证程序的基本工作流程。</p>
<hr>
<h3 id="重构改进和错误处理"><a href="#重构改进和错误处理" class="headerlink" title="重构改进和错误处理"></a>重构改进和错误处理</h3><p><strong>重构后的代码结构</strong></p>
<p><strong>src&#x2F;main.rs (二进制入口)</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;env, process&#125;;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 获取命令行参数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析配置</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;参数解析错误: &#123;err&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;搜索内容: &#123;&#125;&quot;</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;目标文件: &#123;&#125;&quot;</span>, config.file_path);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行核心逻辑</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;程序执行错误: &#123;e&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;lib.rs (核心逻辑)</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;error::Error, fs&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> file_path: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;参数不足：需要 &lt;查询内容&gt; 和 &lt;文件路径&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query: args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            file_path: args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文件内容:\n&#123;contents&#125;&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关键改进点</strong></p>
<ol>
<li><p><strong>模块化分离</strong>：</p>
<ul>
<li>二进制入口 (<code>main.rs</code>)：参数处理、错误显示</li>
<li>核心逻辑 (<code>lib.rs</code>)：配置解析、文件处理</li>
</ul>
</li>
<li><p><strong>错误处理优化</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置解析错误处理</span></span><br><span class="line">.<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;参数解析错误: &#123;err&#125;&quot;</span>);</span><br><span class="line">    process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件操作错误处理</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;程序执行错误: &#123;e&#125;&quot;</span>);</span><br><span class="line">    process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置结构封装</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> file_path: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 验证和构建逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Result 类型使用</strong>：</p>
<ul>
<li><code>Config::build()</code> 返回 <code>Result&lt;Config, &amp;str&gt;</code></li>
<li><code>run()</code> 返回 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code></li>
</ul>
</li>
</ol>
<hr>
<p><strong>改进前后对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方面</strong></th>
<th align="left"><strong>重构前</strong></th>
<th align="left"><strong>重构后</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>错误处理</strong></td>
<td align="left"><code>expect()</code> 导致 panic</td>
<td align="left">友好错误消息 + 非零退出码</td>
</tr>
<tr>
<td align="left"><strong>参数解析</strong></td>
<td align="left">直接索引访问，无验证</td>
<td align="left">专用 <code>Config</code> 结构体 + 验证</td>
</tr>
<tr>
<td align="left"><strong>代码组织</strong></td>
<td align="left">所有逻辑在 main.rs</td>
<td align="left">分离为 main.rs (入口) 和 lib.rs (核心)</td>
</tr>
<tr>
<td align="left"><strong>错误消息</strong></td>
<td align="left">技术性错误 (index out of bounds)</td>
<td align="left">用户友好提示 (“参数不足”)</td>
</tr>
<tr>
<td align="left"><strong>可测试性</strong></td>
<td align="left">难以测试</td>
<td align="left">核心逻辑可独立测试</td>
</tr>
</tbody></table>
<hr>
<p><strong>错误处理机制</strong></p>
<ol>
<li><p><strong>配置解析错误</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户输入: cargo run</span></span><br><span class="line"><span class="comment">// 输出: 参数解析错误: 参数不足：需要 &lt;查询内容&gt; 和 &lt;文件路径&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件读取错误</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件不存在时输出: </span></span><br><span class="line"><span class="comment">// 程序执行错误: No such file or directory (os error 2)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>统一错误出口</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>); <span class="comment">// 非零退出码表示失败</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>项目结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">minigrep/</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.rs   # 程序入口</span><br><span class="line">│   └── lib.rs    # 核心逻辑</span><br><span class="line">└── poem.txt      # 测试文件</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关键 Rust 特性应用</strong></p>
<ol>
<li><p><strong>Result 类型</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(...) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(...) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>trait 对象</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt; <span class="comment">// 任意错误类型的抽象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误传播</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(...)?; <span class="comment">// 自动错误传播</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>闭包使用</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123; ... &#125;) <span class="comment">// 错误处理闭包</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>后续扩展方向</strong></p>
<ol>
<li><p><strong>添加单元测试</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">config_build_valid</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">args</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="string">&quot;program&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="string">&quot;test&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="string">&quot;poem.txt&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(config.query, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现搜索功能</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    contents.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">contains</span>(query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>环境变量支持</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">mut</span> args: <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        args.<span class="title function_ invoke__">next</span>(); <span class="comment">// 跳过程序名</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;缺少查询参数&quot;</span>)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">file_path</span> = args.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;缺少文件路径&quot;</span>)?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123; query, file_path &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此重构显著提升了代码的健壮性、可维护性和可测试性，为后续功能扩展奠定了坚实基础。</p>
<hr>
<h3 id="采用-TDD-完善搜索功能"><a href="#采用-TDD-完善搜索功能" class="headerlink" title="采用 TDD 完善搜索功能"></a>采用 TDD 完善搜索功能</h3><p><em>测试驱动开发（Test Driven Development, TDD）</em></p>
<p><strong>测试驱动开发步骤</strong></p>
<ol>
<li><strong>编写失败测试</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>最小实现使测试编译</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="built_in">vec!</span>[] <span class="comment">// 返回空向量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>完善搜索逻辑</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>完整实现代码</strong></p>
<p><strong>src&#x2F;lib.rs</strong>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;error::Error, fs&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> file_path: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;参数不足：需要 &lt;查询内容&gt; 和 &lt;文件路径&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query: args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            file_path: args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)?;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;line&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_sensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Duct tape.&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">multiple_results</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;body&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">I&#x27;m nobody! Who are you?</span></span><br><span class="line"><span class="string">Are you nobody, too?</span></span><br><span class="line"><span class="string">How dreary to be somebody!&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;I&#x27;m nobody! Who are you?&quot;</span>, <span class="string">&quot;Are you nobody, too?&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">no_results</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;monomorphization&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">assert!</span>(<span class="title function_ invoke__">search</span>(query, contents).<span class="title function_ invoke__">is_empty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;main.rs</strong>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;env, process&#125;;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;参数解析错误: &#123;err&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;程序执行错误: &#123;e&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="搜索功能说明"><a href="#搜索功能说明" class="headerlink" title="搜索功能说明"></a><strong>搜索功能说明</strong></h4><p><strong>核心搜索逻辑</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关键特性</strong></p>
<ol>
<li><strong>逐行处理</strong>：<ul>
<li><code>contents.lines()</code> 将文本分割为行迭代器</li>
<li>高效处理大文件（无需全部加载到内存）</li>
</ul>
</li>
<li><strong>精确匹配</strong>：<ul>
<li>使用 <code>str::contains</code> 进行子字符串匹配</li>
<li>当前区分大小写</li>
</ul>
</li>
<li><strong>生命周期管理</strong>：<ul>
<li><code>&#39;a</code> 生命周期确保返回引用有效</li>
<li>返回值与输入内容生命周期绑定</li>
</ul>
</li>
</ol>
<hr>
<p><strong>测试用例覆盖</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>测试名称</strong></th>
<th align="left"><strong>查询词</strong></th>
<th align="left"><strong>测试内容</strong></th>
<th align="left"><strong>预期结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>one_result</code></td>
<td align="left">“duct”</td>
<td align="left">包含1个匹配行的文本</td>
<td align="left">返回匹配行</td>
</tr>
<tr>
<td align="left"><code>case_sensitive</code></td>
<td align="left">“duct”</td>
<td align="left">包含大小写变体的文本</td>
<td align="left">只返回精确匹配行</td>
</tr>
<tr>
<td align="left"><code>multiple_results</code></td>
<td align="left">“body”</td>
<td align="left">包含多个匹配行的文本</td>
<td align="left">返回所有匹配行</td>
</tr>
<tr>
<td align="left"><code>no_results</code></td>
<td align="left">“monomorphization”</td>
<td align="left">无匹配文本</td>
<td align="left">返回空向量</td>
</tr>
</tbody></table>
<hr>
<p><strong>运行示例</strong></p>
<ol>
<li><strong>精确匹配</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- frog poem.txt</span><br><span class="line">How public, like a frog</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>多行匹配</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- body poem.txt</span><br><span class="line">I<span class="string">&#x27;m nobody! Who are you?</span></span><br><span class="line"><span class="string">Are you nobody, too?</span></span><br><span class="line"><span class="string">How dreary to be somebody!</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>无匹配结果</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- monomorphization poem.txt</span><br><span class="line"><span class="comment"># 无输出</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>后续优化方向</strong></p>
<ol>
<li><strong>大小写不敏感搜索</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    contents.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>环境变量支持</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)?;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.ignore_case &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;line&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>彩色高亮显示</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> owo_colors::OwoColorize;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line.<span class="title function_ invoke__">replace</span>(query, &amp;query.<span class="title function_ invoke__">red</span>().<span class="title function_ invoke__">to_string</span>()));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>正则表达式支持</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> regex::Regex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_regex</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">re</span> = Regex::<span class="title function_ invoke__">new</span>(query).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    contents.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| re.<span class="title function_ invoke__">is_match</span>(line))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此实现完成了核心搜索功能，遵循了测试驱动开发的最佳实践，并通过全面的测试用例确保了功能可靠性。</p>
<hr>
<h3 id="集成环境变量支持"><a href="#集成环境变量支持" class="headerlink" title="集成环境变量支持"></a>集成环境变量支持</h3><p><strong>完整实现代码</strong></p>
<p><strong>src&#x2F;lib.rs</strong>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;error::Error, fs, env&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> file_path: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> ignore_case: <span class="type">bool</span>, <span class="comment">// 新增环境变量控制字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;参数不足：需要 &lt;查询内容&gt; 和 &lt;文件路径&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query: args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            file_path: args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            ignore_case: env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>).<span class="title function_ invoke__">is_ok</span>(), <span class="comment">// 检查环境变量</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)?;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.ignore_case &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;line&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小写敏感搜索</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小写不敏感搜索</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(</span><br><span class="line">    query: &amp;<span class="type">str</span>,</span><br><span class="line">    contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    contents.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_sensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.</span></span><br><span class="line"><span class="string">Duct tape.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;rUsT&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.</span></span><br><span class="line"><span class="string">Trust me.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;Rust:&quot;</span>, <span class="string">&quot;Trust me.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">config_ignore_case</span>() &#123;</span><br><span class="line">        <span class="comment">// 模拟设置环境变量</span></span><br><span class="line">        env::<span class="title function_ invoke__">set_var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">args</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="string">&quot;program&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="string">&quot;test&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="string">&quot;test.txt&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(config.ignore_case);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清理环境变量</span></span><br><span class="line">        env::<span class="title function_ invoke__">remove_var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">config_case_sensitive</span>() &#123;</span><br><span class="line">        <span class="comment">// 确保未设置环境变量</span></span><br><span class="line">        env::<span class="title function_ invoke__">remove_var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">args</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="string">&quot;program&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="string">&quot;test&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            <span class="string">&quot;test.txt&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(!config.ignore_case);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;main.rs</strong> (保持不变):</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;env, process&#125;;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;参数解析错误: &#123;err&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;程序执行错误: &#123;e&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>环境变量处理详解</strong></p>
<p><strong>1. 环境变量检测</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ignore_case</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>).<span class="title function_ invoke__">is_ok</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>env::var(&quot;IGNORE_CASE&quot;)</code> 尝试获取环境变量值</li>
<li><code>is_ok()</code> 只关心变量是否设置，不关心具体值</li>
<li>变量值可以是任意内容（如 <code>1</code>, <code>true</code>, <code>on</code> 等）</li>
</ul>
<p><strong>2. 搜索模式选择</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.ignore_case &#123;</span><br><span class="line">    <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>3. 大小写不敏感搜索实现</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(</span><br><span class="line">    query: &amp;<span class="type">str</span>,</span><br><span class="line">    contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    contents.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将查询词转换为小写</li>
<li>逐行转换为小写后进行比较</li>
<li>使用迭代器链式操作更简洁</li>
</ul>
<hr>
<h4 id="测试增强"><a href="#测试增强" class="headerlink" title="测试增强"></a><strong>测试增强</strong></h4><p><strong>新增测试用例</strong></p>
<ol>
<li><strong>环境变量检测测试</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">config_ignore_case</span>() &#123;</span><br><span class="line">    env::<span class="title function_ invoke__">set_var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>, <span class="string">&quot;1&quot;</span>); <span class="comment">// 设置环境变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(config.ignore_case);</span><br><span class="line">    env::<span class="title function_ invoke__">remove_var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>); <span class="comment">// 清理环境</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>默认大小写敏感测试</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">config_case_sensitive</span>() &#123;</span><br><span class="line">    env::<span class="title function_ invoke__">remove_var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>); <span class="comment">// 确保未设置</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(!config.ignore_case);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>使用示例</strong></p>
<p><strong>1. 默认大小写敏感模式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- to poem.txt</span><br><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br></pre></td></tr></table></figure>

<p><strong>2. 启用大小写不敏感搜索</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Unix/Linux/macOS</span></span><br><span class="line">$ IGNORE_CASE=1 cargo run -- to poem.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows PowerShell</span></span><br><span class="line">$ <span class="variable">$Env</span>:IGNORE_CASE=1; cargo run -- to poem.txt</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<p><strong>3. 环境变量优先级测试</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时设置环境变量和命令行参数（扩展功能示例）</span></span><br><span class="line">$ IGNORE_CASE=0 cargo run -- --case-sensitive to poem.txt</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="环境变量处理说明"><a href="#环境变量处理说明" class="headerlink" title="环境变量处理说明"></a><strong>环境变量处理说明</strong></h4><table>
<thead>
<tr>
<th align="left"><strong>平台</strong></th>
<th align="left"><strong>设置命令</strong></th>
<th align="left"><strong>取消设置命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Unix&#x2F;Linux&#x2F;macOS</td>
<td align="left"><code>IGNORE_CASE=1 cargo run -- ...</code></td>
<td align="left"><code>unset IGNORE_CASE</code></td>
</tr>
<tr>
<td align="left">Windows CMD</td>
<td align="left"><code>set IGNORE_CASE=1 &amp; cargo run -- ...</code></td>
<td align="left"><code>set IGNORE_CASE=</code></td>
</tr>
<tr>
<td align="left">Windows PowerShell</td>
<td align="left"><code>$Env:IGNORE_CASE=1; cargo run -- ...</code></td>
<td align="left"><code>Remove-Item Env:IGNORE_CASE</code></td>
</tr>
</tbody></table>
<hr>
<p><strong>优先级策略建议</strong></p>
<p>如需实现命令行参数和环境变量共存：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展Config结构</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> file_path: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> ignore_case: <span class="type">Option</span>&lt;<span class="type">bool</span>&gt;, <span class="comment">// None=自动, Some(true)=强制忽略, Some(false)=强制敏感</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先级：命令行参数 &gt; 环境变量 &gt; 默认</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">ignore_case</span> = args.ignore_case</span><br><span class="line">    .<span class="title function_ invoke__">or_else</span>(|| env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>).<span class="title function_ invoke__">map</span>(|_| <span class="literal">true</span>).<span class="title function_ invoke__">ok</span>())</span><br><span class="line">    .<span class="title function_ invoke__">unwrap_or</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>此实现提供了灵活的大小写搜索控制，通过环境变量实现用户偏好设置，同时保持了代码的健壮性和可测试性。</p>
<hr>
<h3 id="错误信息输出优化"><a href="#错误信息输出优化" class="headerlink" title="错误信息输出优化"></a>错误信息输出优化</h3><p><strong>完整实现代码</strong></p>
<p><strong>src&#x2F;main.rs</strong>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;env, process&#125;;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="comment">// 使用 eprintln! 输出到标准错误</span></span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;参数解析错误: &#123;err&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="comment">// 使用 eprintln! 输出到标准错误</span></span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;程序执行错误: &#123;e&#125;&quot;</span>);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>src&#x2F;lib.rs</strong> (保持不变):</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;error::Error, fs, env&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> file_path: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> ignore_case: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;参数不足：需要 &lt;查询内容&gt; 和 &lt;文件路径&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query: args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            file_path: args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            ignore_case: env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;IGNORE_CASE&quot;</span>).<span class="title function_ invoke__">is_ok</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.file_path)?;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.ignore_case &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="comment">// 正常输出使用 println! (标准输出)</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;line&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(</span><br><span class="line">    query: &amp;<span class="type">str</span>,</span><br><span class="line">    contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    contents.<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码保持不变...</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="输出流区分说明"><a href="#输出流区分说明" class="headerlink" title="输出流区分说明"></a><strong>输出流区分说明</strong></h4><table>
<thead>
<tr>
<th align="left"><strong>输出类型</strong></th>
<th align="left"><strong>宏</strong></th>
<th align="left"><strong>流</strong></th>
<th align="left"><strong>用途</strong></th>
<th align="left"><strong>重定向示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">正常输出</td>
<td align="left"><code>println!</code></td>
<td align="left">标准输出(stdout)</td>
<td align="left">程序结果</td>
<td align="left"><code>program &gt; output.txt</code></td>
</tr>
<tr>
<td align="left">错误信息</td>
<td align="left"><code>eprintln!</code></td>
<td align="left">标准错误(stderr)</td>
<td align="left">错误和警告消息</td>
<td align="left"><code>program 2&gt; errors.txt</code></td>
</tr>
<tr>
<td align="left">混合输出</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">同时输出结果和错误</td>
<td align="left"><code>program &amp;&gt; all_output.txt</code></td>
</tr>
</tbody></table>
<hr>
<p><strong>使用示例</strong></p>
<p><strong>1. 正常执行（无重定向）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- the poem.txt</span><br><span class="line">Searching <span class="keyword">for</span> the</span><br><span class="line">In file poem.txt</span><br><span class="line">Then there<span class="string">&#x27;s a pair of us - don&#x27;</span>t tell!</span><br></pre></td></tr></table></figure>

<p><strong>2. 参数错误（输出到stderr）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">参数解析错误: 参数不足：需要 &lt;查询内容&gt; 和 &lt;文件路径&gt;</span><br></pre></td></tr></table></figure>

<p><strong>3. 文件错误（输出到stderr）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -- <span class="built_in">test</span> missing.txt</span><br><span class="line">程序执行错误: No such file or directory (os error 2)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="重定向场景测试"><a href="#重定向场景测试" class="headerlink" title="重定向场景测试"></a><strong>重定向场景测试</strong></h4><p><strong>场景1: 仅重定向标准输出</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误信息显示在终端，正常输出保存到文件</span></span><br><span class="line">$ cargo run -- the poem.txt &gt; output.txt</span><br><span class="line">$ <span class="built_in">cat</span> output.txt</span><br><span class="line">Then there<span class="string">&#x27;s a pair of us - don&#x27;</span>t tell!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误情况</span></span><br><span class="line">$ cargo run &gt; output.txt</span><br><span class="line">参数解析错误: 参数不足：需要 &lt;查询内容&gt; 和 &lt;文件路径&gt;</span><br><span class="line">$ <span class="built_in">cat</span> output.txt  <span class="comment"># 输出文件为空</span></span><br></pre></td></tr></table></figure>

<p><strong>场景2: 仅重定向标准错误</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正常输出显示在终端，错误信息保存到文件</span></span><br><span class="line">$ cargo run -- <span class="built_in">test</span> missing.txt 2&gt; errors.txt</span><br><span class="line">$ <span class="built_in">cat</span> errors.txt</span><br><span class="line">程序执行错误: No such file or directory (os error 2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成功执行时错误文件为空</span></span><br><span class="line">$ cargo run -- the poem.txt 2&gt; errors.txt</span><br><span class="line">Then there<span class="string">&#x27;s a pair of us - don&#x27;</span>t tell!</span><br><span class="line">$ <span class="built_in">cat</span> errors.txt  <span class="comment"># 空文件</span></span><br></pre></td></tr></table></figure>

<p><strong>场景3: 同时重定向两个流</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有输出重定向到同一个文件</span></span><br><span class="line">$ cargo run -- the poem.txt &amp;&gt; all_output.txt</span><br><span class="line">$ <span class="built_in">cat</span> all_output.txt</span><br><span class="line">Then there<span class="string">&#x27;s a pair of us - don&#x27;</span>t tell!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误情况</span></span><br><span class="line">$ cargo run &amp;&gt; all_output.txt</span><br><span class="line">$ <span class="built_in">cat</span> all_output.txt</span><br><span class="line">参数解析错误: 参数不足：需要 &lt;查询内容&gt; 和 &lt;文件路径&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="输出分离的优势"><a href="#输出分离的优势" class="headerlink" title="输出分离的优势"></a><strong>输出分离的优势</strong></h4><ol>
<li><p><strong>自动化脚本友好</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只处理成功结果，忽略错误</span></span><br><span class="line">results=$(cargo run -- query file.txt 2&gt;/dev/null)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>日志分离</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正常日志和错误日志分开存储</span></span><br><span class="line">$ cargo run -- query file.txt &gt; app.log 2&gt; error.log</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实时监控</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端实时查看错误，同时保存结果</span></span><br><span class="line">$ cargo run -- query file.txt 2&gt;&amp;1 | <span class="built_in">tee</span> output.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>最佳实践总结</strong></p>
<ol>
<li><p><strong>始终区分输出类型</strong>：</p>
<ul>
<li>程序结果 → stdout</li>
<li>错误和诊断信息 → stderr</li>
</ul>
</li>
<li><p><strong>错误信息应自包含</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的错误信息</span></span><br><span class="line"><span class="built_in">eprintln!</span>(<span class="string">&quot;无法打开文件: &#123;&#125; - &#123;&#125;&quot;</span>, file_path, e);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的错误信息</span></span><br><span class="line"><span class="built_in">eprintln!</span>(<span class="string">&quot;错误发生&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>考虑使用专业日志库</strong>（如 <code>log</code> + <code>env_logger</code>）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> log::&#123;error, info&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    env_logger::<span class="title function_ invoke__">init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        error!(<span class="string">&quot;程序执行错误: &#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提供静默模式选项</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !config.silent &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;line&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此优化确保程序符合Unix哲学，能够与其他命令行工具良好集成，并提供了更专业的用户体验。</p>
<hr>
<hr>
<h2 id="迭代器与闭包"><a href="#迭代器与闭包" class="headerlink" title="迭代器与闭包"></a>迭代器与闭包</h2><ul>
<li><strong>闭包</strong>（<em>Closures</em>），一个可以储存在变量里的类似函数的结构</li>
<li><strong>迭代器</strong>（<em>Iterators</em>），一种处理元素序列的方式</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>Rust 闭包精要总结</strong></p>
<p><strong>1. 闭包的核心特性</strong></p>
<ul>
<li><strong>匿名函数</strong>：无函数名，可存储在变量中或作为参数传递</li>
<li><strong>捕获环境</strong>：能访问定义时作用域中的值（函数无法做到）</li>
<li><strong>灵活调用</strong>：在创建后不同上下文中执行</li>
</ul>
<p><strong>2. 基本语法</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础形式</span></span><br><span class="line">|参数<span class="number">1</span>, 参数<span class="number">2</span>| &#123; 表达式 &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化形式（单表达式可省略花括号）</span></span><br><span class="line">|x| x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型注解（通常可省略）</span></span><br><span class="line">|x: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; x * <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 捕获环境的三种方式</strong></p>
<table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">特点</th>
<th align="left">关键字</th>
<th align="left">实现 trait</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>不可变借用</strong></td>
<td align="left">只读访问环境值</td>
<td align="left">自动</td>
<td align="left"><code>Fn</code></td>
</tr>
<tr>
<td align="left"><strong>可变借用</strong></td>
<td align="left">可修改环境值</td>
<td align="left">自动</td>
<td align="left"><code>FnMut</code></td>
</tr>
<tr>
<td align="left"><strong>获取所有权</strong></td>
<td align="left">移动环境值到闭包内（跨线程常用）</td>
<td align="left"><code>move</code></td>
<td align="left"><code>FnOnce</code></td>
</tr>
</tbody></table>
<p><strong>示例对比</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不可变借用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">print</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list); <span class="comment">// ✅ 多次调用OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 可变借用</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">add</span> = || list.<span class="title function_ invoke__">push</span>(<span class="number">4</span>); <span class="comment">// ✅ 调用后仍可访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取所有权（跨线程必需）</span></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;        <span class="comment">// ✅ 安全传递所有权</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Moved: &#123;:?&#125;&quot;</span>, list)</span><br><span class="line">&#125;).<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p><strong>4. 类型推断规则</strong></p>
<ul>
<li><p><strong>参数&#x2F;返回值类型</strong>：编译器自动推断（通常不需注解）</p>
</li>
<li><p><strong>重要限制</strong>：闭包<strong>首次调用后锁定类型</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = |x| x;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">closure</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 推断为 &amp;str 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">closure</span>(<span class="number">5</span>);       <span class="comment">// ❌ 错误！类型已锁定</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>5. 闭包 Trait 系统</strong></p>
<p>闭包自动实现以下 trait 之一：</p>
<table>
<thead>
<tr>
<th align="left">Trait</th>
<th align="left">调用次数</th>
<th align="left">能否修改环境</th>
<th align="left">能否移出值</th>
<th align="left">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FnOnce</code></td>
<td align="left">仅1次</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">消耗环境值的操作（如移动）</td>
</tr>
<tr>
<td align="left"><code>FnMut</code></td>
<td align="left">多次</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">迭代修改（如排序）</td>
</tr>
<tr>
<td align="left"><code>Fn</code></td>
<td align="left">多次</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">并发操作&#x2F;纯函数</td>
</tr>
</tbody></table>
<p><strong>标准库应用</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option::unwrap_or_else：接受 FnOnce()</span></span><br><span class="line">func.<span class="title function_ invoke__">unwrap_or_else</span>(|| <span class="keyword">self</span>.<span class="title function_ invoke__">fallback</span>()) </span><br><span class="line"></span><br><span class="line"><span class="comment">// slice::sort_by_key：要求 FnMut</span></span><br><span class="line">list.<span class="title function_ invoke__">sort_by_key</span>(|item| item.<span class="title function_ invoke__">key</span>()); </span><br></pre></td></tr></table></figure>

<p><strong>6. 关键实践技巧</strong></p>
<ul>
<li><p><strong>优先让编译器推断类型</strong>，除非必要不添加类型注解</p>
</li>
<li><p><strong>跨线程传递数据</strong>时显式使用 <code>move</code> 关键字</p>
</li>
<li><p><strong>避免意外移动值</strong>：确保闭包体不转移值的所有权</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：尝试在 sort_by_key 中移动值</span></span><br><span class="line">list.<span class="title function_ invoke__">sort_by_key</span>(|r| &#123;</span><br><span class="line">    operations.<span class="title function_ invoke__">push</span>(value); <span class="comment">// ❌ value 被移出</span></span><br><span class="line">    r.width</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改计数器</strong>代替移动值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">list.<span class="title function_ invoke__">sort_by_key</span>(|r| &#123;</span><br><span class="line">    count += <span class="number">1</span>; <span class="comment">// ✅ 修改而不移动</span></span><br><span class="line">    r.width</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>7. 典型应用场景</strong></p>
<ol>
<li><strong>延迟计算</strong>：包装昂贵操作，按需执行</li>
<li><strong>回调函数</strong>：事件处理&#x2F;异步操作</li>
<li><strong>迭代器适配</strong>：与 <code>map</code>&#x2F;<code>filter</code> 等组合使用</li>
<li><strong>定制行为</strong>：如示例中的 T 恤赠送逻辑</li>
<li><strong>线程间数据传输</strong>：通过 <code>move</code> 安全传递所有权</li>
</ol>
<p><strong>核心思维导图</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">闭包核心特性</span><br><span class="line">├─ 匿名函数：无名称、可存储/传递</span><br><span class="line">├─ 环境捕获：访问定义作用域的值</span><br><span class="line">├─ 三种捕获方式</span><br><span class="line">│  ├─ 不可变借用（Fn）</span><br><span class="line">│  ├─ 可变借用（FnMut）</span><br><span class="line">│  └─ 获取所有权（move + FnOnce）</span><br><span class="line">└─ 类型系统</span><br><span class="line">   ├─ 自动类型推断（首次调用锁定）</span><br><span class="line">   ├─ FnOnce：一次性操作（消耗值）</span><br><span class="line">   ├─ FnMut：多次调用（可修改环境）</span><br><span class="line">   └─ Fn：多次调用（只读访问）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过闭包，Rust 在保证内存安全的前提下，实现了比函数更灵活的上下文感知能力。理解其捕获机制和 trait 系统是高效使用的关键，尤其在迭代器和并发编程中不可或缺。</p>
</blockquote>
<hr>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><strong>1. 迭代器核心概念</strong></p>
<ul>
<li><strong>惰性求值</strong>：迭代器在被消费前不会执行任何操作（如 <code>map</code> 不会立即计算）</li>
<li><strong>通用接口</strong>：统一方式处理各种序列（Vec、数组、字符串、自定义集合等）</li>
<li><strong>零成本抽象</strong>：编译后优化效率通常与手写循环相当</li>
</ul>
<p><strong>2. 迭代器创建方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">所有权</th>
<th align="left">元素类型</th>
<th align="left">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.iter()</code></td>
<td align="left">不可变借用</td>
<td align="left"><code>&amp;T</code></td>
<td align="left">只读访问元素</td>
</tr>
<tr>
<td align="left"><code>.iter_mut()</code></td>
<td align="left">可变借用</td>
<td align="left"><code>&amp;mut T</code></td>
<td align="left">修改元素</td>
</tr>
<tr>
<td align="left"><code>.into_iter()</code></td>
<td align="left">获取所有权</td>
<td align="left"><code>T</code></td>
<td align="left">转换所有权（如消费集合）</td>
</tr>
</tbody></table>
<p><strong>3. 核心 Trait：Iterator</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;  <span class="comment">// 关联类型</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;  <span class="comment">// 必须实现的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认实现方法（超过50个）</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">size_hint</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (<span class="type">usize</span>, <span class="type">Option</span>&lt;<span class="type">usize</span>&gt;) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">count</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123; ... &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 迭代器消费方法（消耗迭代器）</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.sum()</code></td>
<td align="left">数值求和</td>
<td align="left"><code>let total: i32 = iter.sum()</code></td>
</tr>
<tr>
<td align="left"><code>.collect()</code></td>
<td align="left">收集到集合</td>
<td align="left"><code>let v: Vec&lt;_&gt; = iter.collect()</code></td>
</tr>
<tr>
<td align="left"><code>.count()</code></td>
<td align="left">统计元素数量</td>
<td align="left"><code>let n = iter.count()</code></td>
</tr>
<tr>
<td align="left"><code>.last()</code></td>
<td align="left">获取最后一个元素</td>
<td align="left"><code>iter.last()</code></td>
</tr>
<tr>
<td align="left"><code>.for_each()</code></td>
<td align="left">对每个元素执行操作</td>
<td align="left"><code>iter.for_each(xprint!(&quot;&#123;x&#125;&quot;))</code></td>
</tr>
</tbody></table>
<blockquote>
<p>⚠️ 调用消费方法后迭代器不可再用</p>
</blockquote>
<p><strong>5. 迭代器适配器（返回新迭代器）</strong></p>
<table>
<thead>
<tr>
<th align="left">适配器</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.map()</code></td>
<td align="left">元素转换</td>
<td align="left"><code>iter.map(x * 2)</code></td>
</tr>
<tr>
<td align="left"><code>.filter()</code></td>
<td align="left">条件过滤</td>
<td align="left"><code>iter.filter(x % 2 == 0)</code></td>
</tr>
<tr>
<td align="left"><code>.zip()</code></td>
<td align="left">双迭代器并行</td>
<td align="left"><code>a.iter().zip(b.iter())</code></td>
</tr>
<tr>
<td align="left"><code>.enumerate()</code></td>
<td align="left">添加索引</td>
<td align="left"><code>iter.enumerate()</code></td>
</tr>
<tr>
<td align="left"><code>.skip(n)</code></td>
<td align="left">跳过前 n 项</td>
<td align="left"><code>iter.skip(3)</code></td>
</tr>
<tr>
<td align="left"><code>.take(n)</code></td>
<td align="left">取前 n 项</td>
<td align="left"><code>iter.take(5)</code></td>
</tr>
<tr>
<td align="left"><code>.chain()</code></td>
<td align="left">连接两个迭代器</td>
<td align="left"><code>iter1.chain(iter2)</code></td>
</tr>
<tr>
<td align="left"><code>.rev()</code></td>
<td align="left">反向迭代（需双端迭代器）</td>
<td align="left"><code>iter.rev()</code></td>
</tr>
</tbody></table>
<blockquote>
<p>特点：</p>
<ol>
<li>惰性：不立即执行</li>
<li>可链式调用：<code>iter.map().filter().take()...</code></li>
<li>需消费方法获取结果</li>
</ol>
</blockquote>
<p><strong>6. 闭包与迭代器的结合</strong></p>
<p>典型场景：<code>filter</code> + 环境捕获</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">filter_shoes</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|s| s.size == size)  <span class="comment">// 捕获 size 参数</span></span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()  <span class="comment">// 必须消费</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. 性能关键点</strong></p>
<ol>
<li><strong>零成本抽象</strong>：迭代器编译优化后通常与手写循环效率相同</li>
<li><strong>循环融合</strong>：编译器可能合并多个适配器操作</li>
<li><strong>短路操作</strong>：<code>find()</code>&#x2F;<code>any()</code> 等在满足条件时提前终止</li>
</ol>
<p><strong>8. 迭代器使用模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建迭代器</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">nums</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = nums.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 手动迭代（需可变）</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 自动消费（推荐）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">doubled</span>: <span class="type">Vec</span>&lt;_&gt; = nums.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|x| x * <span class="number">2</span>)       <span class="comment">// 适配器：元素加倍</span></span><br><span class="line">    .<span class="title function_ invoke__">filter</span>(|&amp;x| x &gt; <span class="number">3</span>)   <span class="comment">// 适配器：过滤</span></span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();           <span class="comment">// 消费方法：收集到Vec</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(doubled, <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>9. 常见陷阱与解决方案</strong></p>
<table>
<thead>
<tr>
<th align="left">问题类型</th>
<th align="left">错误示例</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未消费迭代器</td>
<td align="left"><code>iter.map(x+1);</code></td>
<td align="left">添加 <code>.collect()</code> 等消费方法</td>
</tr>
<tr>
<td align="left">多次使用已消费迭代器</td>
<td align="left"><code>let sum = iter.sum(); iter.next();</code></td>
<td align="left">重新创建迭代器</td>
</tr>
<tr>
<td align="left">所有权冲突</td>
<td align="left">在 <code>.into_iter()</code> 后访问原集合</td>
<td align="left">需要时克隆元素</td>
</tr>
</tbody></table>
<p><strong>迭代器思维导图</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Rust 迭代器</span><br><span class="line">├─ 核心特性</span><br><span class="line">│  ├─ 惰性求值</span><br><span class="line">│  ├─ 零成本抽象</span><br><span class="line">│  └─ 统一接口</span><br><span class="line">├─ 创建方式</span><br><span class="line">│  ├─ iter() → &amp;T</span><br><span class="line">│  ├─ iter_mut() → &amp;mut T</span><br><span class="line">│  └─ into_iter() → T</span><br><span class="line">├─ 核心方法</span><br><span class="line">│  ├─ next() → Option&lt;Item&gt;</span><br><span class="line">│  ├─ 消费方法 (sum/collect/count)</span><br><span class="line">│  └─ 适配器 (map/filter/zip)</span><br><span class="line">├─ 闭包结合</span><br><span class="line">│  └─ 捕获环境 (如 filter)</span><br><span class="line">└─ 使用模式</span><br><span class="line">   ├─ 链式调用: iter.map().filter().collect()</span><br><span class="line">   └─ 延迟执行直到消费</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过迭代器，Rust 在保证内存安全和性能的前提下，提供了比传统循环更声明式、更组合的数据处理方式，是函数式编程风格的重要支撑。</p>
</blockquote>
<hr>
<h3 id="I-O-项目迭代器改进"><a href="#I-O-项目迭代器改进" class="headerlink" title="I&#x2F;O 项目迭代器改进"></a>I&#x2F;O 项目迭代器改进</h3><p><strong>1. Config::build 函数改进</strong></p>
<p><strong>原始问题</strong>：使用切片索引导致不必要的 <code>clone()</code> 操作<br><strong>改进方法</strong>：直接接受迭代器作为参数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进前：使用切片需克隆字符串</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_path</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进后：直接使用迭代器避免克隆</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(<span class="keyword">mut</span> args: <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    args.<span class="title function_ invoke__">next</span>(); <span class="comment">// 跳过程序名</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = args.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;缺少查询字符串&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_path</span> = args.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;缺少文件路径&quot;</span>)?;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键改进点</strong>：</p>
<ul>
<li>参数类型改为 <code>impl Iterator&lt;Item = String&gt;</code></li>
<li>使用 <code>next()</code> 替代索引访问</li>
<li>使用 <code>ok_or</code> 简化错误处理</li>
<li>完全消除 <code>clone()</code> 调用</li>
</ul>
<p><strong>2. main 函数适配</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进前：收集到Vec再传递切片</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(&amp;args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进后：直接传递迭代器</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">build</span>(env::<span class="title function_ invoke__">args</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>：避免创建临时 vector，减少内存分配</p>
<p><strong>3. search 函数改进</strong></p>
<p><strong>原始问题</strong>：显式循环和可变 vector<br><strong>改进方法</strong>：使用迭代器适配器</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进前：显式循环</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进后：迭代器链</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    contents</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">contains</span>(query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键改进点</strong>：</p>
<ul>
<li>消除可变状态 (<code>mut results</code>)</li>
<li>使用 <code>filter</code> 替代显式条件检查</li>
<li>链式调用提高可读性</li>
<li>更函数式编程风格</li>
</ul>
<p><strong>4. search_case_insensitive 同步改进</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进前</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进后</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    </span><br><span class="line">    contents</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 性能考量</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">内存使用</th>
<th align="left">可读性</th>
<th align="left">函数式纯度</th>
<th align="left">并行潜力</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>原始循环</strong></td>
<td align="left">中间可变状态</td>
<td align="left">较低</td>
<td align="left">低</td>
<td align="left">受限</td>
</tr>
<tr>
<td align="left"><strong>迭代器</strong></td>
<td align="left">无中间状态</td>
<td align="left">较高</td>
<td align="left">高</td>
<td align="left">更优</td>
</tr>
</tbody></table>
<p><strong>结论</strong>：迭代器版本通常性能相当或更优，因为：</p>
<ol>
<li>零成本抽象优化</li>
<li>循环融合（Loop fusion）技术</li>
<li>减少内存分配操作</li>
</ol>
<p><strong>6. 迭代器选择原则</strong></p>
<ol>
<li><strong>简单转换</strong>：优先使用 <code>map</code>&#x2F;<code>filter</code></li>
<li><strong>状态累积</strong>：使用 <code>fold</code> 或 <code>reduce</code></li>
<li><strong>搜索匹配</strong>：使用 <code>find</code>&#x2F;<code>any</code>&#x2F;<code>all</code></li>
<li><strong>集合构建</strong>：使用 <code>collect</code> 指定类型</li>
<li><strong>错误处理</strong>：结合 <code>Result</code> 使用 <code>?</code> 操作符</li>
</ol>
<p><strong>改进核心思想</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[原始实现] --&gt; B[问题分析]</span><br><span class="line">    B --&gt; C&#123;改进方案&#125;</span><br><span class="line">    C --&gt; D[Config构建]</span><br><span class="line">    C --&gt; E[搜索功能]</span><br><span class="line">    D --&gt; F[使用迭代器参数]</span><br><span class="line">    D --&gt; G[消除clone]</span><br><span class="line">    E --&gt; H[迭代器适配器]</span><br><span class="line">    E --&gt; I[消除可变状态]</span><br><span class="line">    F --&gt; J[直接处理env::args]</span><br><span class="line">    G --&gt; K[所有权转移]</span><br><span class="line">    H --&gt; L[filter+collect]</span><br><span class="line">    I --&gt; M[纯函数式]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过迭代器改进，I&#x2F;O 项目获得了：</p>
<ol>
<li><strong>更简洁</strong>：代码行数减少30%</li>
<li><strong>更安全</strong>：消除可变状态和显式索引</li>
<li><strong>更高效</strong>：避免不必要的内存分配</li>
<li><strong>更现代</strong>：采用函数式编程范式</li>
</ol>
<p>这展示了 Rust 迭代器在实际项目中提升代码质量和性能的强大能力。</p>
</blockquote>
<hr>
<h3 id="迭代器-vs-循环"><a href="#迭代器-vs-循环" class="headerlink" title="迭代器 vs 循环"></a>迭代器 vs 循环</h3><p><strong>1. 核心发现</strong></p>
<ul>
<li><p><strong>性能等效性</strong>：迭代器与手写循环性能相当</p>
<ul>
<li><p>搜索基准测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)</span><br><span class="line">test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>零成本抽象</strong>：高级迭代器操作编译为高效底层代码</p>
</li>
<li><p><strong>编译器优化</strong>：Rust 编译器消除迭代器抽象开销</p>
</li>
</ul>
<p><strong>2. 关键性能原理</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">循环实现</th>
<th align="left">迭代器实现</th>
<th align="left">优势对比</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>内存访问</strong></td>
<td align="left">显式索引</td>
<td align="left">隐式边界检查</td>
<td align="left">迭代器消除边界检查</td>
</tr>
<tr>
<td align="left"><strong>循环控制</strong></td>
<td align="left">手动管理</td>
<td align="left">编译器优化</td>
<td align="left">迭代器支持循环展开</td>
</tr>
<tr>
<td align="left"><strong>中间状态</strong></td>
<td align="left">通常需要</td>
<td align="left">通常消除</td>
<td align="left">迭代器减少内存访问</td>
</tr>
<tr>
<td align="left"><strong>代码生成</strong></td>
<td align="left">直接对应</td>
<td align="left">高级优化</td>
<td align="left">迭代器支持更多优化机会</td>
</tr>
</tbody></table>
<p><strong>3. 音频解码器案例解析</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">prediction</span> = coefficients.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">zip</span>(&amp;buffer[i - <span class="number">12</span>..i])          <span class="comment">// 创建(value, coefficient)对</span></span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|(&amp;c, &amp;s)| c * s <span class="keyword">as</span> <span class="type">i64</span>)     <span class="comment">// 每对相乘</span></span><br><span class="line">    .sum::&lt;<span class="type">i64</span>&gt;() &gt;&gt; qlp_shift;        <span class="comment">// 求和后位移</span></span><br></pre></td></tr></table></figure>

<p><strong>编译器优化步骤</strong>：</p>
<ol>
<li><strong>循环展开</strong>：已知12次迭代 → 生成12段重复代码</li>
<li><strong>寄存器分配</strong>：系数值存入寄存器 → 消除内存访问</li>
<li><strong>边界检查消除</strong>：静态确定范围 → 移除运行时检查</li>
<li><strong>指令流水</strong>：并行执行乘法操作</li>
</ol>
<p><strong>4. 零成本抽象本质</strong></p>
<blockquote>
<p>“不使用的功能无需为其付出代价；而已经使用的功能，也不可能通过手写代码做得更好”<br>—— Bjarne Stroustrup (C++之父)</p>
</blockquote>
<p>Rust 迭代器实现：</p>
<ul>
<li><strong>零运行时开销</strong>：抽象在编译时消除</li>
<li><strong>最优机器码</strong>：生成与手写汇编同等高效的代码</li>
<li><strong>按需付费</strong>：只为实际使用的功能付出代价</li>
</ul>
<p><strong>5. 性能优化指南</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">推荐方案</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>简单遍历</strong></td>
<td align="left">迭代器</td>
<td align="left">等性能+更高可读性</td>
</tr>
<tr>
<td align="left"><strong>复杂条件逻辑</strong></td>
<td align="left">迭代器链</td>
<td align="left">减少分支预测错误</td>
</tr>
<tr>
<td align="left"><strong>内存敏感操作</strong></td>
<td align="left">迭代器+<code>collect()</code></td>
<td align="left">减少中间分配</td>
</tr>
<tr>
<td align="left"><strong>CPU密集型计算</strong></td>
<td align="left">两者均可</td>
<td align="left">关键在算法而非迭代方式</td>
</tr>
<tr>
<td align="left"><strong>并行处理</strong></td>
<td align="left">并行迭代器</td>
<td align="left">rayon等库提供简单并行化</td>
</tr>
</tbody></table>
<p><strong>6. 实践建议</strong></p>
<ol>
<li><p><strong>默认使用迭代器</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先选择</span></span><br><span class="line">data.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|x| x.<span class="title function_ invoke__">is_valid</span>()).<span class="title function_ invoke__">map</span>(process).<span class="title function_ invoke__">collect</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而非</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> data &#123;</span><br><span class="line">    <span class="keyword">if</span> item.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">        result.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">process</span>(item));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能关键处测量</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo bench <span class="comment"># 使用基准测试验证</span></span><br><span class="line">cargo flamegraph <span class="comment"># 生成火焰图分析</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>利用特定优化</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用大小提示提高效率</span></span><br><span class="line">iter.<span class="title function_ invoke__">size_hint</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择特化方法</span></span><br><span class="line">slice::binary_search 替代手动实现</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>7. 性能思维模型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[源代码] --&gt; B&#123;Rust编译器&#125;</span><br><span class="line">    B --&gt;|循环版本| C[传统汇编指令]</span><br><span class="line">    B --&gt;|迭代器版本| D[优化后机器码]</span><br><span class="line">    C --&gt; E[CPU执行]</span><br><span class="line">    D --&gt; E</span><br><span class="line">    E --&gt; F&#123;性能对比&#125;</span><br><span class="line">    F --&gt;|等效| G[选择可读性更高的]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最终结论：在 Rust 中可<strong>放心使用迭代器</strong><br>它们提供：</p>
<ul>
<li>同等或更优的运行时性能</li>
<li>更简洁的代码表达力</li>
<li>更强的编译器优化潜力</li>
<li>更安全的隐式边界处理</li>
</ul>
<p>性能不是拒绝迭代器的理由，而是拥抱它的契机！</p>
</blockquote>
<hr>
<hr>
<h2 id="Cargo-和-Cates-io-高级"><a href="#Cargo-和-Cates-io-高级" class="headerlink" title="Cargo 和 Cates.io 高级"></a>Cargo 和 Cates.io 高级</h2><ul>
<li>使用发布配置（release profiles）来自定义构建</li>
<li>将库发布到 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a></li>
<li>使用工作空间（workspaces）来组织更大的项目</li>
<li>从 <a target="_blank" rel="noopener" href="https://crates.io/">crates.io</a> 安装二进制文件</li>
<li>使用自定义的命令来扩展 Cargo</li>
</ul>
<h3 id="发布配置自定义构建"><a href="#发布配置自定义构建" class="headerlink" title="发布配置自定义构建"></a>发布配置自定义构建</h3><p><strong>1. 核心概念</strong></p>
<ul>
<li><strong>发布配置</strong>：预定义的构建方案，允许自定义编译选项</li>
<li><strong>独立配置</strong>：每个配置完全独立，互不影响</li>
<li><strong>主要配置</strong>：<ul>
<li><code>dev</code>：开发模式 (<code>cargo build</code>)</li>
<li><code>release</code>：发布模式 (<code>cargo build --release</code>)</li>
</ul>
</li>
</ul>
<p><strong>2. 配置识别</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line">    Finished `release` profile [optimized] target(s) in 0.32s</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dev</code>：未优化 + 包含调试信息</li>
<li><code>release</code>：完全优化（去调试信息）</li>
</ul>
<p><strong>3. 默认配置值</strong></p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left"><code>dev</code> 默认值</th>
<th align="left"><code>release</code> 默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>opt-level</code></td>
<td align="left">0</td>
<td align="left">3</td>
<td align="left">优化级别 (0-3)</td>
</tr>
<tr>
<td align="left"><code>debug</code></td>
<td align="left">true</td>
<td align="left">false</td>
<td align="left">包含调试信息</td>
</tr>
<tr>
<td align="left"><code>debug-assertions</code></td>
<td align="left">true</td>
<td align="left">false</td>
<td align="left">运行时检查</td>
</tr>
<tr>
<td align="left"><code>overflow-checks</code></td>
<td align="left">true</td>
<td align="left">false</td>
<td align="left">整数溢出检查</td>
</tr>
<tr>
<td align="left"><code>lto</code></td>
<td align="left">false</td>
<td align="left">false</td>
<td align="left">链接时优化</td>
</tr>
<tr>
<td align="left"><code>panic</code></td>
<td align="left">‘unwind’</td>
<td align="left">‘unwind’</td>
<td align="left">panic处理方式</td>
</tr>
<tr>
<td align="left"><code>incremental</code></td>
<td align="left">true</td>
<td align="left">false</td>
<td align="left">增量编译</td>
</tr>
</tbody></table>
<p><strong>4. 关键配置：优化级别 (opt-level)</strong></p>
<table>
<thead>
<tr>
<th align="left">级别</th>
<th align="left">编译速度</th>
<th align="left">运行时性能</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">⚡️ 极快</td>
<td align="left">🐢 最慢</td>
<td align="left">快速开发迭代</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">✅ 快</td>
<td align="left">🚶 中等</td>
<td align="left">平衡开发环境</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">⏱ 中等</td>
<td align="left">🚀 良好</td>
<td align="left">预发布测试</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">🐢 最慢</td>
<td align="left">⚡️ 最快</td>
<td align="left">正式生产环境</td>
</tr>
</tbody></table>
<p><strong>设计哲学</strong>：</p>
<ul>
<li>开发模式：快速编译 &gt; 运行性能</li>
<li>发布模式：运行性能 &gt; 编译速度</li>
</ul>
<p><strong>5. 自定义配置方法</strong>**</p>
<p>在 <code>Cargo.toml</code> 中添加配置段：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：提升开发模式优化级别</span></span><br><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">1</span>  <span class="comment"># 默认0 → 改为1级优化</span></span><br><span class="line"><span class="attr">incremental</span> = <span class="literal">true</span>  <span class="comment"># 启用增量编译（默认已开启）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：调整发布模式设置</span></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="string">&#x27;z&#x27;</span>  <span class="comment"># 优化大小而非速度</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">true</span>       <span class="comment"># 启用链接时优化</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span>  <span class="comment"># panic时直接终止进程</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 常用自定义场景</strong></p>
<ol>
<li><p><strong>开发环境加速</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最小化发布体积</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="string">&#x27;z&#x27;</span>  <span class="comment"># 尺寸优化</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">true</span>       <span class="comment"># 链接时优化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>强化安全检查</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">overflow-checks</span> = <span class="literal">true</span>  <span class="comment"># 启用整数溢出检查</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>嵌入式开发</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&quot;abort&quot;</span>  <span class="comment"># 无堆栈展开</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span> <span class="comment"># 单线程编译提升优化</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>7. 配置继承规则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[默认配置] --&gt; B&#123;是否有自定义&#125;</span><br><span class="line">    B --&gt;|无| C[使用默认值]</span><br><span class="line">    B --&gt;|有| D[覆盖指定项]</span><br><span class="line">    D --&gt; E[其他项保持默认]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要</strong>：自定义配置只覆盖显式设置的选项，未提及选项保持默认值</p>
</blockquote>
<p><strong>8. 最佳实践建议</strong></p>
<ol>
<li><p><strong>开发环境</strong>：</p>
<ul>
<li>保持 <code>opt-level=0</code> 除非项目庞大</li>
<li>启用 <code>incremental=true</code>（默认已开启）</li>
</ul>
</li>
<li><p><strong>CI&#x2F;CD 流水线</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.ci]</span>  <span class="comment"># 自定义配置</span></span><br><span class="line"><span class="attr">inherits</span> = <span class="string">&quot;release&quot;</span>  <span class="comment"># 继承release配置</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">2</span>         <span class="comment"># 中等优化加速CI</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能敏感库</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">lto</span> = <span class="string">&quot;thin&quot;</span>  <span class="comment"># 折衷的链接时优化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Windows 发布</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">debug</span> = <span class="literal">true</span>  <span class="comment"># 保留PDB调试符号</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>查看完整配置：<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo Profiles Documentation</a></p>
</blockquote>
<p><strong>配置选择决策树</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">是否需要自定义构建？</span><br><span class="line">├─ 否 → 使用默认dev/release配置</span><br><span class="line">├─ 是 → </span><br><span class="line">   ├─ 目标平台？</span><br><span class="line">   │  ├─ 嵌入式 → panic=&#x27;abort&#x27;, opt-level=&#x27;s&#x27;</span><br><span class="line">   │  ├─ 桌面应用 → opt-level=3, lto=true</span><br><span class="line">   │  └─ 服务器 → opt-level=3, codegen-units=16</span><br><span class="line">   │</span><br><span class="line">   ├─ 特殊需求？</span><br><span class="line">   │  ├─ 最小体积 → opt-level=&#x27;z&#x27;, lto=true</span><br><span class="line">   │  ├─ 强化安全 → overflow-checks=true</span><br><span class="line">   │  └─ 调试符号 → debug=true</span><br><span class="line">   │</span><br><span class="line">   └─ 添加[profile.*]到Cargo.toml</span><br></pre></td></tr></table></figure>

<p>通过合理配置发布配置，您可以在编译速度、运行时性能和二进制大小之间找到最佳平衡点，满足不同场景的需求。</p>
<hr>
<h3 id="Crate-发布与文档编写"><a href="#Crate-发布与文档编写" class="headerlink" title="Crate 发布与文档编写"></a>Crate 发布与文档编写</h3><p><strong>1. 文档注释系统</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">语法</th>
<th align="left">用途</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>项文档</strong></td>
<td align="left"><code>///</code></td>
<td align="left">描述函数&#x2F;模块&#x2F;结构体</td>
<td align="left"><code>/// 计算两数之和</code></td>
</tr>
<tr>
<td align="left"><strong>容器文档</strong></td>
<td align="left"><code>//!</code></td>
<td align="left">描述整个 crate 或模块</td>
<td align="left"><code>//! 数学计算工具库</code></td>
</tr>
</tbody></table>
<p><strong>文档测试特性</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// # 示例</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// assert_eq!(add(2, 2), 4);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 <code>cargo test</code> 自动验证示例代码</li>
<li>确保文档与代码同步</li>
</ul>
<p><strong>2. 文档标准章节</strong></p>
<table>
<thead>
<tr>
<th align="left">章节标题</th>
<th align="left">内容描述</th>
<th align="left">必需性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code># Examples</code></td>
<td align="left">使用示例</td>
<td align="left">推荐</td>
</tr>
<tr>
<td align="left"><code># Panics</code></td>
<td align="left">可能触发 panic 的场景</td>
<td align="left">可选</td>
</tr>
<tr>
<td align="left"><code># Errors</code></td>
<td align="left">返回 Result 时的错误类型</td>
<td align="left">可选</td>
</tr>
<tr>
<td align="left"><code># Safety</code></td>
<td align="left">使用 unsafe 时的安全条件</td>
<td align="left">可选</td>
</tr>
</tbody></table>
<p><strong>3. API 结构优化技巧</strong></p>
<p><strong>问题</strong>：深层模块导致使用不便<br><strong>解决方案</strong>：<code>pub use</code> 重导出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始结构</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> graphics &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> colors &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Rgb</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> graphics::colors::Rgb;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户可简化为</span></span><br><span class="line"><span class="keyword">use</span> my_crate::Rgb;</span><br></pre></td></tr></table></figure>

<p><strong>优化效果</strong>：</p>
<ul>
<li>保持内部组织灵活性</li>
<li>提供扁平化的用户接口</li>
<li>提升 API 易用性</li>
</ul>
<p><strong>4. Crate 发布流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant D as 开发者</span><br><span class="line">    participant C as Crates.io</span><br><span class="line">    D-&gt;&gt;C: 1. 注册账号(GitHub)</span><br><span class="line">    D-&gt;&gt;C: 2. 获取API Token</span><br><span class="line">    D-&gt;&gt;D: 3. cargo login &lt;token&gt;</span><br><span class="line">    D-&gt;&gt;D: 4. 配置Cargo.toml元数据</span><br><span class="line">    D-&gt;&gt;C: 5. cargo publish</span><br></pre></td></tr></table></figure>

<p><strong>5. 必须的元数据字段</strong></p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;unique_name&quot;</span>  <span class="comment"># 全局唯一标识</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;1.0.0&quot;</span>     <span class="comment"># 遵循语义化版本</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;简洁的功能描述&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT OR Apache-2.0&quot;</span>  <span class="comment"># SPDX标识符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选但推荐</span></span><br><span class="line"><span class="attr">repository</span> = <span class="string">&quot;https://github.com/...&quot;</span></span><br><span class="line"><span class="attr">documentation</span> = <span class="string">&quot;https://docs.rs/crate&quot;</span></span><br><span class="line"><span class="attr">keywords</span> = [<span class="string">&quot;math&quot;</span>, <span class="string">&quot;algorithms&quot;</span>]</span><br><span class="line"><span class="attr">categories</span> = [<span class="string">&quot;science&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>6. SPDX 许可证标识符示例</strong></p>
<table>
<thead>
<tr>
<th align="left">许可证类型</th>
<th align="left">SPDX 标识符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MIT</td>
<td align="left"><code>MIT</code></td>
</tr>
<tr>
<td align="left">Apache 2.0</td>
<td align="left"><code>Apache-2.0</code></td>
</tr>
<tr>
<td align="left">BSD 3-Clause</td>
<td align="left"><code>BSD-3-Clause</code></td>
</tr>
<tr>
<td align="left">GPLv3</td>
<td align="left"><code>GPL-3.0-only</code></td>
</tr>
<tr>
<td align="left">双许可证</td>
<td align="left"><code>MIT OR Apache-2.0</code></td>
</tr>
</tbody></table>
<blockquote>
<p>完整列表：<a target="_blank" rel="noopener" href="https://spdx.org/licenses/">https://spdx.org/licenses/</a></p>
</blockquote>
<p><strong>7. 版本管理操作</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">命令</th>
<th align="left">效果说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">发布新版本</td>
<td align="left"><code>cargo publish</code></td>
<td align="left">上传新版本</td>
</tr>
<tr>
<td align="left">撤回版本</td>
<td align="left"><code>cargo yank --vers 1.0.1</code></td>
<td align="left">阻止新项目依赖该版本</td>
</tr>
<tr>
<td align="left">撤销撤回</td>
<td align="left"><code>cargo yank --vers 1.0.1 --undo</code></td>
<td align="left">恢复版本可用性</td>
</tr>
<tr>
<td align="left">查看发布内容</td>
<td align="left"><code>cargo package --list</code></td>
<td align="left">预览将发布的文件</td>
</tr>
</tbody></table>
<p><strong>撤回特性关键点</strong>：</p>
<ul>
<li>不影响现有项目</li>
<li>不可删除已发布版本</li>
<li>用于修复敏感信息泄漏等紧急情况</li>
</ul>
<p><strong>最佳实践清单</strong></p>
<ol>
<li><p><strong>文档规范</strong>：</p>
<ul>
<li>所有公共 API 项必须有文档</li>
<li>包含至少一个使用示例</li>
<li>使用 <code>cargo doc --open</code> 预览效果</li>
</ul>
</li>
<li><p><strong>发布准备</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo check</span><br><span class="line">cargo <span class="built_in">test</span></span><br><span class="line">cargo publish --dry-run</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>版本管理</strong>：</p>
<ul>
<li>遵循语义化版本 (SemVer)</li>
<li>重大变更时递增主版本号</li>
<li>使用 <code>cargo yank</code> 替代删除</li>
</ul>
</li>
<li><p><strong>安全注意事项</strong>：</p>
<ul>
<li>检查是否包含敏感信息</li>
<li>确保许可证信息准确</li>
<li>验证所有依赖的兼容性</li>
</ul>
</li>
</ol>
<blockquote>
<p>通过合理组织 API 结构和编写专业文档，您的 crate 将更容易被社区接受和使用。</p>
</blockquote>
<hr>
<h3 id="Cargo-工作空间"><a href="#Cargo-工作空间" class="headerlink" title="Cargo 工作空间"></a>Cargo 工作空间</h3><p><strong>1. 工作空间核心概念</strong></p>
<ul>
<li><strong>共享环境</strong>：多个 crate 共享同一个 Cargo.lock 和 target 目录</li>
<li><strong>统一管理</strong>：通过顶层 Cargo.toml 配置工作空间</li>
<li><strong>高效编译</strong>：避免重复构建依赖项</li>
<li><strong>版本一致性</strong>：确保所有 crate 使用相同的依赖版本</li>
</ul>
<p><strong>2. 工作空间结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add/                  # 工作空间根目录</span><br><span class="line">├── Cargo.toml        # 工作空间配置</span><br><span class="line">├── Cargo.lock        # 共享依赖锁文件</span><br><span class="line">├── target/           # 共享构建输出</span><br><span class="line">│</span><br><span class="line">├── adder/            # 二进制 crate</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src/</span><br><span class="line">│       └── main.rs</span><br><span class="line">│</span><br><span class="line">└── add_one/          # 库 crate</span><br><span class="line">    ├── Cargo.toml</span><br><span class="line">    └── src/</span><br><span class="line">        └── lib.rs</span><br></pre></td></tr></table></figure>

<p><strong>3. 配置工作空间</strong></p>
<p><strong>文件名：Cargo.toml</strong></p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">resolver</span> = <span class="string">&quot;2&quot;</span>  <span class="comment"># 依赖解析器版本</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;adder&quot;</span>,    <span class="comment"># 二进制 crate</span></span><br><span class="line">    <span class="string">&quot;add_one&quot;</span>,  <span class="comment"># 库 crate</span></span><br><span class="line">    <span class="string">&quot;add_two&quot;</span>   <span class="comment"># 其他库 crate</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>4. 工作空间操作命令</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">构建所有 crate</td>
<td align="left"><code>cargo build</code></td>
<td align="left">在根目录运行</td>
</tr>
<tr>
<td align="left">运行特定二进制</td>
<td align="left"><code>cargo run -p adder</code></td>
<td align="left">运行 adder 二进制</td>
</tr>
<tr>
<td align="left">测试特定 crate</td>
<td align="left"><code>cargo test -p add_one</code></td>
<td align="left">测试 add_one 库</td>
</tr>
<tr>
<td align="left">检查特定 crate</td>
<td align="left"><code>cargo check -p add_two</code></td>
<td align="left">检查 add_two 库</td>
</tr>
<tr>
<td align="left">更新依赖</td>
<td align="left"><code>cargo update</code></td>
<td align="left">更新整个工作空间依赖</td>
</tr>
<tr>
<td align="left">构建发布版本</td>
<td align="left"><code>cargo build --release</code></td>
<td align="left">优化构建所有 crate</td>
</tr>
</tbody></table>
<p><strong>5. Crate 间依赖管理</strong></p>
<p><strong>在 adder&#x2F;Cargo.toml 中添加路径依赖：</strong></p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">add_one</span> = &#123; path = <span class="string">&quot;../add_one&quot;</span> &#125;</span><br><span class="line"><span class="attr">add_two</span> = &#123; path = <span class="string">&quot;../add_two&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>在代码中使用依赖：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adder/src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> add_one::add_one;</span><br><span class="line"><span class="keyword">use</span> add_two::add_two;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;10 + 1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_one</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;10 + 2 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 外部依赖管理</strong></p>
<ul>
<li><strong>共享 Cargo.lock</strong>：所有 crate 使用相同的依赖版本</li>
<li><strong>显式声明</strong>：每个 crate 必须声明自己的依赖</li>
</ul>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add_one/Cargo.toml</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add_two/Cargo.toml (需要则单独声明)</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.8.5&quot;</span>  <span class="comment"># 必须与 add_one 版本相同</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 测试工作空间</strong></p>
<ul>
<li><strong>运行所有测试</strong>：<code>cargo test</code>（根目录）</li>
<li><strong>测试特定 crate</strong>：<code>cargo test -p add_one</code></li>
<li><strong>测试输出</strong>：显示每个 crate 的测试结果</li>
</ul>
<p><strong>8. 发布工作空间中的 crate</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布单个 crate</span></span><br><span class="line">cargo publish -p add_one</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布多个 crate</span></span><br><span class="line">cargo publish -p add_one</span><br><span class="line">cargo publish -p add_two</span><br></pre></td></tr></table></figure>

<p><strong>工作空间优势总结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[工作空间优势] --&gt; B[依赖一致性]</span><br><span class="line">    A --&gt; C[编译效率]</span><br><span class="line">    A --&gt; D[统一管理]</span><br><span class="line">    A --&gt; E[项目结构化]</span><br><span class="line">    B --&gt; F[共享Cargo.lock]</span><br><span class="line">    C --&gt; G[共享target目录]</span><br><span class="line">    D --&gt; H[统一命令操作]</span><br><span class="line">    E --&gt; I[逻辑分离]</span><br></pre></td></tr></table></figure>

<p><strong>9. 最佳实践</strong></p>
<ol>
<li><p><strong>项目组织</strong>：</p>
<ul>
<li>将相关 crate 组织在同一工作空间</li>
<li>按功能模块拆分 crate</li>
<li>保持 crate 小而专注</li>
</ul>
</li>
<li><p><strong>依赖管理</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顶层Cargo.toml定义公共依赖</span></span><br><span class="line"><span class="section">[workspace.dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">tokio</span> = &#123; version = <span class="string">&quot;1.0&quot;</span>, features = [<span class="string">&quot;full&quot;</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员crate引用</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde.workspace</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">tokio.workspace</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>版本控制</strong>：</p>
<ul>
<li>使用语义化版本控制 (SemVer)</li>
<li>同步更新相关 crate 版本</li>
<li>通过 <code>cargo update</code> 统一更新依赖</li>
</ul>
</li>
<li><p><strong>CI&#x2F;CD 集成</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GitHub Actions 示例</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Rust</span> <span class="string">Workspace</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">cargo</span> <span class="string">build</span> <span class="string">--all</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">cargo</span> <span class="string">test</span> <span class="string">--all</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>典型工作场景</strong></p>
<ol>
<li><p><strong>新建工作空间</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-workspace &amp;&amp; <span class="built_in">cd</span> my-workspace</span><br><span class="line"><span class="built_in">touch</span> Cargo.toml</span><br><span class="line"><span class="comment"># 添加 [workspace] 配置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加成员 crate</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo new --bin app</span><br><span class="line">cargo new --lib core</span><br><span class="line">cargo new --lib utils</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置依赖</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/Cargo.toml</span></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">core</span> = &#123; path = <span class="string">&quot;../core&quot;</span> &#125;</span><br><span class="line"><span class="attr">utils</span> = &#123; path = <span class="string">&quot;../utils&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>开发工作流</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在根目录</span></span><br><span class="line">cargo build   <span class="comment"># 构建所有</span></span><br><span class="line">cargo <span class="built_in">test</span>    <span class="comment"># 测试所有</span></span><br><span class="line">cargo run -p app  <span class="comment"># 运行主应用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>通过 Cargo 工作空间，您可以高效管理多 crate 项目，保持依赖一致性，加速编译过程，同时维护清晰的项目结构。</p>
</blockquote>
<hr>
<h3 id="Rust-cargo-install"><a href="#Rust-cargo-install" class="headerlink" title="Rust cargo install"></a>Rust <code>cargo install</code></h3><p><strong>1. 核心概念</strong></p>
<ul>
<li><strong>用途</strong>：安装 Rust 开发者共享的工具（二进制 crate）</li>
<li><strong>定位</strong>：开发者工具安装方式，<strong>非系统级包管理替代</strong></li>
<li><strong>限制</strong>：仅支持包含二进制目标（如 <code>src/main.rs</code>）的 crate</li>
</ul>
<p><strong>2. 安装流程</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo install ripgrep</span><br><span class="line">    Updating crates.io index</span><br><span class="line">  Downloaded ripgrep v14.1.1</span><br><span class="line">  ...</span><br><span class="line">  Installing ~/.cargo/bin/rg</span><br><span class="line">   Installed package `ripgrep v14.1.1` (executable `rg`)</span><br></pre></td></tr></table></figure>

<p><strong>3. 安装位置</strong></p>
<table>
<thead>
<tr>
<th align="left">环境</th>
<th align="left">默认安装路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标准 Rust 安装</td>
<td align="left"><code>$HOME/.cargo/bin</code></td>
</tr>
<tr>
<td align="left">自定义 Rust 安装</td>
<td align="left"><code>&lt;rust-root&gt;/bin</code></td>
</tr>
</tbody></table>
<p><strong>关键配置</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查安装路径</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$CARGO_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加路径到环境变量 (bash/zsh)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p><strong>4. 识别可安装的 crate</strong></p>
<table>
<thead>
<tr>
<th align="left">特征</th>
<th align="left">二进制 crate</th>
<th align="left">库 crate</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>入口文件</strong></td>
<td align="left"><code>src/main.rs</code></td>
<td align="left"><code>src/lib.rs</code></td>
</tr>
<tr>
<td align="left"><strong>Cargo.toml</strong></td>
<td align="left"><code>[[bin]]</code> 部分</td>
<td align="left"><code>[lib]</code> 部分</td>
</tr>
<tr>
<td align="left"><strong>功能说明</strong></td>
<td align="left">README 明确标注</td>
<td align="left">文档说明为库</td>
</tr>
</tbody></table>
<p><strong>5. 常用 Rust 工具推荐</strong></p>
<table>
<thead>
<tr>
<th align="left">工具名称</th>
<th align="left">功能描述</th>
<th align="left">安装命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ripgrep (rg)</code></td>
<td align="left">高效文本搜索</td>
<td align="left"><code>cargo install ripgrep</code></td>
</tr>
<tr>
<td align="left"><code>fd-find</code></td>
<td align="left">现代文件查找</td>
<td align="left"><code>cargo install fd-find</code></td>
</tr>
<tr>
<td align="left"><code>bat</code></td>
<td align="left">带语法高亮的 cat 替代</td>
<td align="left"><code>cargo install bat</code></td>
</tr>
<tr>
<td align="left"><code>exa</code></td>
<td align="left">增强版 ls</td>
<td align="left"><code>cargo install exa</code></td>
</tr>
<tr>
<td align="left"><code>starship</code></td>
<td align="left">强大的终端提示符</td>
<td align="left"><code>cargo install starship</code></td>
</tr>
<tr>
<td align="left"><code>du-dust</code></td>
<td align="left">磁盘使用分析工具</td>
<td align="left"><code>cargo install du-dust</code></td>
</tr>
</tbody></table>
<p><strong>6. 高级用法</strong></p>
<p><strong>安装特定版本</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install ripgrep --version 13.0.0</span><br></pre></td></tr></table></figure>

<p><strong>从 Git 仓库安装</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --git https://github.com/BurntSushi/ripgrep.git</span><br></pre></td></tr></table></figure>

<p><strong>安装功能标志</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install bat --features=<span class="string">&quot;git&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>查看已安装包</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo install --list</span><br><span class="line"><span class="comment"># 示例输出:</span></span><br><span class="line"><span class="comment"># ripgrep v14.1.1:</span></span><br><span class="line"><span class="comment">#     rg</span></span><br><span class="line"><span class="comment"># bat v0.24.0:</span></span><br><span class="line"><span class="comment">#     bat</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 路径配置指南</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[终端命令] --&gt; B&#123;是否在PATH中&#125;</span><br><span class="line">    B --&gt;|是| C[直接执行]</span><br><span class="line">    B --&gt;|否| D[命令未找到]</span><br><span class="line">    D --&gt; E[添加 $HOME/.cargo/bin 到 PATH]</span><br><span class="line">    E --&gt; F[重新加载终端]</span><br><span class="line">    F --&gt; A</span><br></pre></td></tr></table></figure>

<p><strong>各平台配置方法</strong>：</p>
<ul>
<li><p><strong>Linux&#x2F;macOS</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bashrc 或 ~/.zshrc</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/.cargo/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Windows (PowerShell)</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $PROFILE 文件</span></span><br><span class="line"><span class="variable">$env:Path</span> += <span class="string">&quot;;<span class="variable">$env:USERPROFILE</span>\.cargo\bin&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Windows (CMD)</strong>：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setx <span class="built_in">PATH</span> &quot;<span class="variable">%PATH%</span>;<span class="variable">%USERPROFILE%</span>\.cargo\bin&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>8. 管理技巧</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">更新已安装包</td>
<td align="left"><code>cargo install --force &lt;crate&gt;</code></td>
<td align="left">强制重新安装最新版</td>
</tr>
<tr>
<td align="left">卸载包</td>
<td align="left">手动删除 $CARGO_HOME&#x2F;bin 文件</td>
<td align="left">cargo 暂无内置卸载命令</td>
</tr>
<tr>
<td align="left">查看安装信息</td>
<td align="left"><code>cargo install --list</code></td>
<td align="left">列出所有通过 cargo install 安装的包</td>
</tr>
</tbody></table>
<p><strong>9. 最佳实践</strong></p>
<ol>
<li><p><strong>定期更新</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查可更新包</span></span><br><span class="line">cargo install cargo-update</span><br><span class="line">cargo install-update -a</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>空间管理</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看占用空间</span></span><br><span class="line"><span class="built_in">du</span> -sh ~/.cargo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理缓存</span></span><br><span class="line">cargo cache -a</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安全安装</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 crate 来源</span></span><br><span class="line">cargo install --locked &lt;crate&gt; <span class="comment"># 确保使用 Cargo.lock 版本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>替代系统包</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建别名替代系统命令</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cat</span>=<span class="string">&#x27;bat --paging=never&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grep=rg</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>通过 <code>cargo install</code>，Rust 开发者可以轻松获取社区构建的高质量工具链，提升开发效率和生产体验。</p>
</blockquote>
<hr>
<h3 id="Cargo-自定义扩展命令"><a href="#Cargo-自定义扩展命令" class="headerlink" title="Cargo 自定义扩展命令"></a>Cargo 自定义扩展命令</h3><p><strong>1. 扩展机制核心</strong></p>
<ul>
<li><strong>命名约定</strong>：任何名为 <code>cargo-&lt;subcommand&gt;</code> 的二进制文件自动成为 Cargo 子命令</li>
<li><strong>执行方式</strong>：<code>cargo &lt;subcommand&gt;</code> 直接调用对应二进制</li>
<li><strong>自动集成</strong>：通过 <code>cargo --list</code> 显示所有可用命令（包括自定义扩展）</li>
</ul>
<p><strong>2. 创建自定义命令步骤</strong></p>
<ol>
<li><p><strong>创建二进制项目</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new cargo-awesome</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现功能</strong> (<code>src/main.rs</code>)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;🚀 This is my custom cargo command!&quot;</span>);</span><br><span class="line">    <span class="comment">// 添加实际功能逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>本地安装</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install --path ./cargo-awesome</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo awesome</span><br><span class="line"><span class="comment"># 输出: 🚀 This is my custom cargo command!</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>3. 扩展命令示例</strong></p>
<table>
<thead>
<tr>
<th align="left">命令名称</th>
<th align="left">功能描述</th>
<th align="left">实现原理</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>cargo-audit</code></td>
<td align="left">安全漏洞检查</td>
<td align="left">分析依赖关系</td>
</tr>
<tr>
<td align="left"><code>cargo-watch</code></td>
<td align="left">文件变化自动重建</td>
<td align="left">监控文件系统事件</td>
</tr>
<tr>
<td align="left"><code>cargo-edit</code></td>
<td align="left">修改Cargo.toml依赖</td>
<td align="left">直接操作TOML文件</td>
</tr>
<tr>
<td align="left"><code>cargo-tree</code></td>
<td align="left">可视化依赖树</td>
<td align="left">解析Cargo.lock</td>
</tr>
</tbody></table>
<p><strong>4. 高级扩展特性</strong></p>
<ol>
<li><p><strong>访问Cargo环境</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Received &#123;&#125; arguments: &#123;:?&#125;&quot;</span>, args.<span class="title function_ invoke__">len</span>(), args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>与Cargo深度集成</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> cargo_metadata::MetadataCommand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_project_metadata</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">metadata</span> = MetadataCommand::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">exec</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Project packages: &#123;:?&#125;&quot;</span>, metadata.packages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>5. 发布自定义命令</strong></p>
<ol>
<li><p><strong>打包扩展</strong>：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在cargo-awesome/Cargo.toml中</span></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;cargo-awesome&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;My awesome Cargo extension&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT OR Apache-2.0&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发布到crates.io</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo publish -p cargo-awesome</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用户安装</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-awesome</span><br><span class="line">cargo awesome</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>6. 生态系统优势</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Rust开发者] --&gt; B(创建cargo-xxx工具)</span><br><span class="line">    B --&gt; C[crates.io发布]</span><br><span class="line">    C --&gt; D[其他开发者安装]</span><br><span class="line">    D --&gt; E[增强工作流]</span><br><span class="line">    E --&gt; A</span><br></pre></td></tr></table></figure>

<p><strong>良性循环效应</strong>：</p>
<ol>
<li>开发者创建实用工具</li>
<li>社区共享解决方案</li>
<li>整个生态系统效率提升</li>
<li>吸引更多开发者参与</li>
</ol>
<p><strong>7. 最佳实践</strong></p>
<ol>
<li><p><strong>命名规范</strong>：</p>
<ul>
<li>前缀必须是 <code>cargo-</code></li>
<li>使用kebab-case（短横线分隔）</li>
<li>明确描述功能（如 <code>cargo-audit</code>）</li>
</ul>
</li>
<li><p><strong>用户体验</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现help输出</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_help</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Usage: cargo awesome [OPTIONS]&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Options:&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;  --help       Show this help&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;  --version    Show version&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> anyhow::&#123;Context, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = <span class="title function_ invoke__">load_config</span>().<span class="title function_ invoke__">context</span>(<span class="string">&quot;Failed to load config&quot;</span>)?;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>测试集成</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试自定义命令</span></span><br><span class="line">cargo <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 测试作为cargo子命令的行为</span></span><br><span class="line">cargo awesome --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>Rust 生态协作总结</strong></p>
<ol>
<li><p><strong>标准化工具链</strong>：</p>
<ul>
<li>Cargo 提供统一工作流</li>
<li>跨平台一致体验</li>
</ul>
</li>
<li><p><strong>分层架构优势</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">    A[应用层] --&gt; B[自定义 cargo-* 工具]</span><br><span class="line">    B --&gt; C[Cargo 核心]</span><br><span class="line">    C --&gt; D[Rust 标准库]</span><br><span class="line">    D --&gt; E[系统接口]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生态增长引擎</strong>：</p>
<ul>
<li>2023年crates.io统计：<ul>
<li>10万+ 可用crate</li>
<li>每日新增150+ crate</li>
<li>自定义命令类工具增长最快</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>行动号召</strong>：</p>
<ul>
<li>将实用工具发布至crates.io</li>
<li>使用<code>cargo install</code>探索社区工具</li>
<li>参与开源Rust工具开发</li>
</ul>
</li>
</ol>
<blockquote>
<p>Rust的成功在于：标准库保持精简稳定，而通过Cargo和crates.io建立的共享机制，让生态系统能够以惊人的速度创新和发展。每个开发者既是工具的使用者，也是生态的贡献者！</p>
</blockquote>
<hr>
<hr>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ol>
<li><strong>智能指针核心概念</strong></li>
</ol>
<ul>
<li><strong>本质</strong>：包含额外元数据和功能的结构体</li>
<li><strong>与普通指针区别</strong>：<ul>
<li>拥有数据所有权（而非常规指针的借用）</li>
<li>提供额外功能（生命周期管理、线程安全等）</li>
</ul>
</li>
<li><strong>关键特征</strong>：实现 <code>Deref</code> 和 <code>Drop</code> trait</li>
</ul>
<p><strong>2. 标准库智能指针对比</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">所有权</th>
<th align="left">线程安全</th>
<th align="left">使用场景</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Box&lt;T&gt;</code></td>
<td align="left">单一</td>
<td align="left">✅</td>
<td align="left">堆分配、动态大小类型</td>
<td align="left">最轻量级</td>
</tr>
<tr>
<td align="left"><code>Rc&lt;T&gt;</code></td>
<td align="left">共享</td>
<td align="left">❌</td>
<td align="left">单线程引用计数</td>
<td align="left">多所有者只读访问</td>
</tr>
<tr>
<td align="left"><code>Arc&lt;T&gt;</code></td>
<td align="left">共享</td>
<td align="left">✅</td>
<td align="left">跨线程引用计数</td>
<td align="left">线程安全的引用计数</td>
</tr>
<tr>
<td align="left"><code>RefCell&lt;T&gt;</code></td>
<td align="left">可变借用</td>
<td align="left">❌</td>
<td align="left">内部可变性（单线程）</td>
<td align="left">运行时借用检查</td>
</tr>
<tr>
<td align="left"><code>Mutex&lt;T&gt;</code>&#x2F;<code>RwLock&lt;T&gt;</code></td>
<td align="left">共享</td>
<td align="left">✅</td>
<td align="left">跨线程内部可变性</td>
<td align="left">提供并发安全</td>
</tr>
</tbody></table>
<ol start="3">
<li><strong>核心智能指针详解</strong></li>
</ol>
<p><strong>3.1 <code>Box&lt;T&gt;</code> - 堆分配指针</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);  <span class="comment">// 在堆上分配整数</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b); <span class="comment">// 自动解引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：<ul>
<li>编译时已知大小</li>
<li>离开作用域自动释放内存</li>
<li>解引用开销为零</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li>递归类型（如链表）</li>
<li>大型数据结构转移所有权</li>
<li>trait对象（<code>Box&lt;dyn Trait&gt;</code>）</li>
</ul>
</li>
</ul>
<p><strong>3.2 <code>Rc&lt;T&gt;</code> - 引用计数指针</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rc1</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">rc2</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;rc1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Count: &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;rc1)); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：<ul>
<li>单线程引用计数</li>
<li>只读共享数据（无法修改内容）</li>
<li>计数归零自动清理</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li>数据结构共享（如图节点）</li>
<li>只读配置数据共享</li>
</ul>
</li>
</ul>
<p><strong>3.3 <code>RefCell&lt;T&gt;</code> - 内部可变性容器</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">cell</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">42</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = cell.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    *num += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, cell); <span class="comment">// 输出 RefCell &#123; value: 52 &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：<ul>
<li>运行时借用检查（而非编译时）</li>
<li>实现”内部可变性”模式</li>
<li>panic! 当违反借用规则时</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li>修改不可变结构内部数据</li>
<li>实现mock测试对象</li>
<li>配合Rc实现多所有者可变数据</li>
</ul>
</li>
</ul>
<p><strong>4. 组合使用模式</strong></p>
<p><strong>4.1 共享可变数据 (<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>)</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">    children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">    value: <span class="number">5</span>,</span><br><span class="line">    children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>4.2 线程安全共享 (<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>)</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = c.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num += <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br></pre></td></tr></table></figure>

<p><strong>5. 关键 Trait 机制</strong></p>
<p><strong>5.1 <code>Deref</code> Trait - 解引用转换</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动解引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = <span class="title function_ invoke__">MyBox</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *m); <span class="comment">// 输出 &quot;Rust&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>5.2 <code>Drop</code> Trait - 资源清理</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dropping &#123;&#125;&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;resource&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 作用域结束自动调用 drop</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 &quot;Dropping resource&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 内存安全机制对比</strong></p>
<table>
<thead>
<tr>
<th align="left">机制</th>
<th align="left">检查时机</th>
<th align="left">开销</th>
<th align="left">错误处理</th>
</tr>
</thead>
<tbody><tr>
<td align="left">引用</td>
<td align="left">编译时</td>
<td align="left">无</td>
<td align="left">编译错误</td>
</tr>
<tr>
<td align="left"><code>RefCell&lt;T&gt;</code></td>
<td align="left">运行时</td>
<td align="left">中等</td>
<td align="left">panic</td>
</tr>
<tr>
<td align="left"><code>Mutex&lt;T&gt;</code></td>
<td align="left">运行时</td>
<td align="left">高</td>
<td align="left">返回LockResult</td>
</tr>
</tbody></table>
<p><strong>7. 避免引用循环</strong></p>
<p><strong>问题代码：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,    <span class="comment">// 弱引用避免循环</span></span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：</strong></p>
<ol>
<li>使用 <code>Weak&lt;T&gt;</code> 代替 <code>Rc&lt;T&gt;</code> 持有父节点</li>
<li>调用 <code>Rc::downgrade</code> 创建弱引用</li>
<li>使用 <code>upgrade()</code> 尝试获取强引用</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">    parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">    children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">    value: <span class="number">5</span>,</span><br><span class="line">    parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">    children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">*leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br></pre></td></tr></table></figure>

<p><strong>8. 智能指针选用指南</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[需要智能指针?] --&gt; B&#123;所有权模型&#125;</span><br><span class="line">    B --&gt;|单一所有者| C[Box&lt;T&gt;]</span><br><span class="line">    B --&gt;|多所有者| D&#123;线程需求&#125;</span><br><span class="line">    D --&gt;|单线程| E[Rc&lt;T&gt;]</span><br><span class="line">    D --&gt;|多线程| F[Arc&lt;T&gt;]</span><br><span class="line">    E --&gt; G&#123;需要可变?&#125;</span><br><span class="line">    G --&gt;|是| H[Rc&lt;RefCell&lt;T&gt;&gt;]</span><br><span class="line">    G --&gt;|否| I[纯Rc&lt;T&gt;]</span><br><span class="line">    F --&gt; J&#123;需要可变?&#125;</span><br><span class="line">    J --&gt;|是| K[Arc&lt;Mutex&lt;T&gt;&gt;]</span><br><span class="line">    J --&gt;|否| L[纯Arc&lt;T&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过合理选择智能指针组合，可在保证内存安全的前提下实现灵活的数据管理模型，满足从简单堆分配到复杂跨线程共享等各种场景需求。</p>
</blockquote>
<hr>
<h3 id="Rust-Box"><a href="#Rust-Box" class="headerlink" title="Rust Box&lt;T&gt;"></a>Rust <code>Box&lt;T&gt;</code></h3><p><strong>1. 核心功能</strong></p>
<ul>
<li><strong>堆分配</strong>：将值从栈移动到堆存储</li>
<li><strong>固定大小指针</strong>：无论指向数据大小，<code>Box</code> 本身大小固定（通常为一个机器字长）</li>
<li><strong>所有权管理</strong>：拥有堆数据的所有权，离开作用域自动释放内存</li>
</ul>
<p><strong>2. 三大使用场景</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>递归类型</strong></td>
<td align="left">定义大小未知的类型（如链表）</td>
<td align="left"><code>Cons(i32, Box&lt;List&gt;)</code></td>
</tr>
<tr>
<td align="left"><strong>大数据转移</strong></td>
<td align="left">避免栈拷贝大体积数据</td>
<td align="left"><code>let big_data = Box::new([0u8; 10_000_000]);</code></td>
</tr>
<tr>
<td align="left"><strong>trait对象</strong></td>
<td align="left">实现不同类型统一接口</td>
<td align="left"><code>Box&lt;dyn Draw&gt;</code></td>
</tr>
</tbody></table>
<p><strong>3. 递归类型实现（Cons List）</strong></p>
<p><strong>问题</strong>：直接定义递归枚举会导致无限大小</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例 ❌</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, List), <span class="comment">// 递归包含自身，大小无限</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：使用<code>Box</code>间接存储</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确定义 ✅</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;), <span class="comment">// Box有固定大小（指针）</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">list</span> = List::<span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, </span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, </span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(List::<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, </span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(List::Nil)))));</span><br></pre></td></tr></table></figure>

<p><strong>内存布局</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">栈上list变量:</span><br><span class="line">  Cons变体:</span><br><span class="line">    - i32值 (4字节)</span><br><span class="line">    - Box指针 (8字节) → 指向堆上的下一个List</span><br><span class="line"></span><br><span class="line">堆内存块1:</span><br><span class="line">  Cons变体:</span><br><span class="line">    - i32值 (4字节)</span><br><span class="line">    - Box指针 (8字节) → 指向堆上的下一个List</span><br><span class="line"></span><br><span class="line">堆内存块2:</span><br><span class="line">  Nil变体 (0字节)</span><br></pre></td></tr></table></figure>

<p><strong>4. 性能特征</strong></p>
<ul>
<li><strong>分配开销</strong>：每次<code>Box::new</code>触发一次堆分配</li>
<li><strong>访问成本</strong>：指针解引用（通常被编译器优化）</li>
<li><strong>对比转移</strong>：转移所有权时仅复制指针（高效），而非整个数据</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大数据转移效率对比</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">huge_data</span> = <span class="built_in">vec!</span>[<span class="number">0u8</span>; <span class="number">10_000_000</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 低效：复制整个vec ❌</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">copy</span> = huge_data; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效：仅复制指针 ✅</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">boxed</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(huge_data);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">moved_box</span> = boxed;</span><br></pre></td></tr></table></figure>

<p><strong>5. 基础操作</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">heap_int</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解引用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, *heap_int); <span class="comment">// 显式解引用</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, heap_int);  <span class="comment">// 自动解引用（Deref trait）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模式匹配</span></span><br><span class="line"><span class="keyword">match</span> *heap_int &#123;</span><br><span class="line">    <span class="number">42</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The answer!&quot;</span>),</span><br><span class="line">    _ =&gt; (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转移所有权</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">moved_box</span> = heap_int; <span class="comment">// 原变量失效</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 与普通指针区别</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Box&lt;T&gt;</code></th>
<th align="left">裸指针 (<code>*const T</code>&#x2F;<code>*mut T</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">所有权</td>
<td align="left">拥有所有权</td>
<td align="left">无所有权</td>
</tr>
<tr>
<td align="left">生命周期</td>
<td align="left">编译器验证</td>
<td align="left">手动管理</td>
</tr>
<tr>
<td align="left">内存安全</td>
<td align="left">自动释放</td>
<td align="left">需手动释放</td>
</tr>
<tr>
<td align="left">空指针</td>
<td align="left">不可能</td>
<td align="left">可能</td>
</tr>
</tbody></table>
<p><strong>7. 实现机制</strong></p>
<p><strong>Deref Trait</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;**<span class="keyword">self</span> <span class="comment">// 双重解引用：先解Box，再解引用内部数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>允许：</p>
<ul>
<li>自动解引用：<code>let x = *boxed_value;</code></li>
<li>方法调用：<code>boxed_value.method()</code></li>
</ul>
<p><strong>Drop Trait</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 伪代码：释放堆内存</span></span><br><span class="line">        <span class="title function_ invoke__">deallocate</span>(<span class="keyword">self</span>.ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保证：</p>
<ul>
<li>离开作用域自动调用</li>
<li>释放顺序与创建顺序相反（后进先出）</li>
</ul>
<p><strong>8. 实际应用场景</strong></p>
<p><strong>构建树结构</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    left: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;TreeNode&gt;&gt;,  <span class="comment">// 左子树</span></span><br><span class="line">    right: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;TreeNode&gt;&gt;, <span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回复杂类型</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_complex</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Iterator</span>&lt;Item=<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>((<span class="number">0</span>..<span class="number">10</span>).<span class="title function_ invoke__">flat_map</span>(|x| <span class="built_in">vec!</span>[x, x*<span class="number">2</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9. 注意事项</strong></p>
<ul>
<li><strong>不用于性能优化</strong>：仅当需要解决所有权&#x2F;大小时使用</li>
<li><strong>避免深层嵌套</strong>：多层Box导致内存碎片</li>
<li><strong>替代方案</strong>：考虑<code>Rc</code>&#x2F;<code>Arc</code>等共享所有权类型</li>
</ul>
<blockquote>
<p><code>Box&lt;T&gt;</code> 是 Rust 内存安全模型的基石，通过编译期保证和运行时零开销，完美平衡安全与效率。</p>
</blockquote>
<hr>
<h3 id="Rust-Deref-Trait"><a href="#Rust-Deref-Trait" class="headerlink" title="Rust Deref Trait"></a>Rust <code>Deref</code> Trait</h3><p><strong>1. 核心概念</strong></p>
<ul>
<li><strong>解引用运算符 <code>\*</code></strong>：允许访问指针指向的值</li>
<li><strong><code>Deref</code> trait</strong>：自定义类型在 <code>*</code> 运算符下的行为</li>
<li><strong>强制转换机制</strong>：自动将智能指针转换为底层引用</li>
</ul>
<ol start="2">
<li><strong>基本实现模式</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;  <span class="comment">// 定义解引用后的目标类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span>  <span class="comment">// 返回内部数据的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 解引用过程解析</strong></p>
<p>当执行 <code>*y</code> 时（<code>y: MyBox&lt;T&gt;</code>），Rust 底层实际执行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(y.<span class="title function_ invoke__">deref</span>())</span><br></pre></td></tr></table></figure>

<ol>
<li>调用 <code>deref()</code> 方法获取 <code>&amp;T</code></li>
<li>对返回的引用进行普通解引用</li>
</ol>
<p><strong>4. Deref 强制转换规则</strong></p>
<table>
<thead>
<tr>
<th align="left">转换方向</th>
<th align="left">条件</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&amp;T</code> → <code>&amp;U</code></td>
<td align="left"><code>T: Deref&lt;Target=U&gt;</code></td>
<td align="left"><code>&amp;MyBox&lt;String&gt;</code> → <code>&amp;String</code> → <code>&amp;str</code></td>
</tr>
<tr>
<td align="left"><code>&amp;mut T</code> → <code>&amp;mut U</code></td>
<td align="left"><code>T: DerefMut&lt;Target=U&gt;</code></td>
<td align="left"><code>&amp;mut MyVec</code> → <code>&amp;mut [T]</code></td>
</tr>
<tr>
<td align="left"><code>&amp;mut T</code> → <code>&amp;U</code></td>
<td align="left"><code>T: Deref&lt;Target=U&gt;</code></td>
<td align="left"><code>&amp;mut String</code> → <code>&amp;str</code></td>
</tr>
</tbody></table>
<p><strong>注意</strong>：不可变引用<strong>不能</strong>强制转换为可变引用（违反借用规则）</p>
<p><strong>5. Deref 强制转换实战</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;name&#125;!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);  <span class="comment">// 发生两次 Deref 强制转换：</span></span><br><span class="line">                <span class="comment">// 1. &amp;MyBox&lt;String&gt; -&gt; &amp;String</span></span><br><span class="line">                <span class="comment">// 2. &amp;String -&gt; &amp;str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 手动转换对比</strong></p>
<p>无 Deref 强制转换时需要显式转换：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">hello</span>(&amp;(*m)[..]);  <span class="comment">// 等价于：</span></span><br><span class="line">                   <span class="comment">// 1. *m: MyBox&lt;String&gt; -&gt; String</span></span><br><span class="line">                   <span class="comment">// 2. &amp;(*m): String -&gt; &amp;String</span></span><br><span class="line">                   <span class="comment">// 3. &amp;(*m)[..]: &amp;String -&gt; &amp;str</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 设计哲学</strong></p>
<ol>
<li><p><strong>统一接口</strong>：函数可同时接受智能指针和普通引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下调用都有效：</span></span><br><span class="line"><span class="title function_ invoke__">hello</span>(<span class="string">&quot;Rust&quot;</span>);                   <span class="comment">// &amp;str</span></span><br><span class="line"><span class="title function_ invoke__">hello</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));    <span class="comment">// &amp;String 转 &amp;str</span></span><br><span class="line"><span class="title function_ invoke__">hello</span>(&amp;MyBox::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Rust&quot;</span>.<span class="title function_ invoke__">into</span>())); <span class="comment">// &amp;MyBox 转 &amp;str</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>零成本抽象</strong>：所有转换在编译时完成</p>
</li>
<li><p><strong>类型安全</strong>：编译器保证转换的有效性</p>
</li>
</ol>
<p><strong>8. 可变解引用 (DerefMut)</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> T &#123;</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>允许通过 <code>*</code> 获取可变引用</li>
<li>启用可变版本的 Deref 强制转换</li>
</ul>
<p><strong>9. 强制转换过程图解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[&amp;MyBox&lt;String&gt;] --&gt;|Deref| B[&amp;String]</span><br><span class="line">    B --&gt;|Deref| C[&amp;str]</span><br><span class="line">    C --&gt; D[hello 函数]</span><br></pre></td></tr></table></figure>

<p><strong>10. 使用注意事项</strong></p>
<ol>
<li><p><strong>避免过度转换</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反模式：不必要的多层包装</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Box</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = <span class="type">str</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span>  <span class="comment">// Box&lt;String&gt; 自动解引用为 &amp;str</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>保持预期行为</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确实现：符合用户预期</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不可变优先</strong>：设计类型时优先考虑不可变解引用</p>
</li>
</ol>
<p><strong>智能指针生态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[智能指针] --&gt; B[Box&lt;T&gt;]</span><br><span class="line">    A --&gt; C[Rc&lt;T&gt;]</span><br><span class="line">    A --&gt; D[RefCell&lt;T&gt;]</span><br><span class="line">    B --&gt; E[实现 Deref]</span><br><span class="line">    C --&gt; E</span><br><span class="line">    D --&gt; F[内部可变性]</span><br><span class="line">    E --&gt; G[统一引用接口]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Deref</code> trait 是 Rust 智能指针生态的核心枢纽，通过标准化解引用行为，实现了：</p>
<ul>
<li>引用与智能指针的无缝互操作</li>
<li>类型安全的自动类型转换</li>
<li>零成本的抽象能力</li>
</ul>
<p>这使得 Rust 在保持内存安全的同时，提供了灵活高效的类型系统。</p>
</blockquote>
<hr>
<h3 id="Rust-Drop-Trait"><a href="#Rust-Drop-Trait" class="headerlink" title="Rust Drop Trait"></a>Rust <code>Drop</code> Trait</h3><p><strong>1. 核心概念</strong></p>
<ul>
<li><strong>资源清理</strong>：在值离开作用域时自动执行清理代码</li>
<li><strong>确定性析构</strong>：精确控制资源释放时机</li>
<li><strong>RAII模式</strong>：资源获取即初始化（Resource Acquisition Is Initialization）</li>
</ul>
<p><strong>2. 基本实现</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomResource</span> &#123;</span><br><span class="line">    id: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomResource</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;释放资源 #&#123;&#125;&quot;</span>, <span class="keyword">self</span>.id);</span><br><span class="line">        <span class="comment">// 实际清理操作：关闭文件、释放锁、网络连接等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 关键特性</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>自动调用</strong></td>
<td align="left">离开作用域时由 Rust 自动调用</td>
</tr>
<tr>
<td align="left"><strong>顺序保证</strong></td>
<td align="left">后进先出（LIFO）顺序释放</td>
</tr>
<tr>
<td align="left"><strong>不可手动调用</strong></td>
<td align="left">禁止直接调用 <code>drop()</code> 方法</td>
</tr>
<tr>
<td align="left"><strong>提前释放</strong></td>
<td align="left">使用 <code>std::mem::drop</code> 函数强制释放</td>
</tr>
</tbody></table>
<p><strong>4. 释放顺序验证</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = CustomResource &#123; id: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = CustomResource &#123; id: <span class="number">2</span> &#125;;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = CustomResource &#123; id: <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;内部作用域结束&quot;</span>);</span><br><span class="line">    &#125; <span class="comment">// c 在此释放</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;主作用域结束&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 先释放 b (id:2)，再释放 a (id:1)</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内部作用域结束</span><br><span class="line">释放资源 #3</span><br><span class="line">主作用域结束</span><br><span class="line">释放资源 #2</span><br><span class="line">释放资源 #1</span><br></pre></td></tr></table></figure>

<p><strong>5. 提前释放机制</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::drop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">resource</span> = CustomResource &#123; id: <span class="number">100</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;资源创建完成&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(resource); <span class="comment">// 手动提前释放</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;资源已被手动释放&quot;</span>);</span><br><span class="line">    <span class="comment">// 后续不能再使用 resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">资源创建完成</span><br><span class="line">释放资源 #100</span><br><span class="line">资源已被手动释放</span><br></pre></td></tr></table></figure>

<p><strong>6. 实际应用场景</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">实现方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>文件处理</strong></td>
<td align="left">自动关闭文件句柄</td>
</tr>
<tr>
<td align="left"><strong>网络连接</strong></td>
<td align="left">自动断开连接</td>
</tr>
<tr>
<td align="left"><strong>锁管理</strong></td>
<td align="left">自动释放互斥锁</td>
</tr>
<tr>
<td align="left"><strong>内存管理</strong></td>
<td align="left">释放堆内存（如 <code>Box</code>）</td>
</tr>
<tr>
<td align="left"><strong>数据库连接</strong></td>
<td align="left">自动归还连接池</td>
</tr>
</tbody></table>
<p><strong>文件处理示例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">    <span class="comment">// 内部包含文件句柄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">FileHandler</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;关闭文件: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.filename);</span><br><span class="line">        <span class="comment">// 实际关闭文件操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. 设计原则</strong></p>
<ol>
<li><p><strong>资源对称性</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;建立数据库连接&quot;</span>);</span><br><span class="line">        <span class="comment">// 连接逻辑</span></span><br><span class="line">        DatabaseConnection &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;关闭数据库连接&quot;</span>);</span><br><span class="line">        <span class="comment">// 清理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常安全</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">process_data</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock</span> = MutexLock::<span class="title function_ invoke__">acquire</span>(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="comment">// 可能panic的操作</span></span><br><span class="line">&#125; <span class="comment">// 即使发生panic，锁也能保证释放</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复杂资源管理</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CompositeResource</span> &#123;</span><br><span class="line">    file: FileHandler,</span><br><span class="line">    connection: DatabaseConnection,</span><br><span class="line">    buffer: HeapBuffer,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CompositeResource</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 按特定顺序释放子资源</span></span><br><span class="line">        <span class="title function_ invoke__">drop</span>(<span class="keyword">self</span>.buffer);</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(<span class="keyword">self</span>.connection);</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(<span class="keyword">self</span>.file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>8. 与C++对比</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Rust</th>
<th align="left">C++</th>
</tr>
</thead>
<tbody><tr>
<td align="left">确定性析构</td>
<td align="left">✅ 保证</td>
<td align="left">✅ 保证</td>
</tr>
<tr>
<td align="left">异常安全</td>
<td align="left">✅ 强保证</td>
<td align="left">❌ 可能泄漏</td>
</tr>
<tr>
<td align="left">手动释放</td>
<td align="left">通过 <code>std::mem::drop</code></td>
<td align="left"><code>delete</code>&#x2F;<code>delete[]</code></td>
</tr>
<tr>
<td align="left">作用域控制</td>
<td align="left">基于词法作用域</td>
<td align="left">基于块作用域</td>
</tr>
<tr>
<td align="left">移动语义</td>
<td align="left">移动后原对象立即失效</td>
<td align="left">移动后可能残留状态</td>
</tr>
</tbody></table>
<p><strong>9. 高级应用技巧</strong></p>
<p><strong>延迟初始化资源</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LazyResource</span> &#123;</span><br><span class="line">    resource: <span class="type">Option</span>&lt;ExpensiveResource&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">LazyResource</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> ExpensiveResource &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.resource.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.resource = <span class="title function_ invoke__">Some</span>(ExpensiveResource::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.resource.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">LazyResource</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(res) = <span class="keyword">self</span>.resource.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">            res.<span class="title function_ invoke__">cleanup</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>10. 内存安全机制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[创建资源] --&gt; B[使用资源]</span><br><span class="line">    B --&gt; C&#123;离开作用域&#125;</span><br><span class="line">    C --&gt;|正常| D[调用drop清理]</span><br><span class="line">    C --&gt;|panic| D[调用drop清理]</span><br><span class="line">    D --&gt; E[资源安全释放]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Drop</code> trait 是 Rust 内存安全的基石，通过：</p>
<ol>
<li><strong>自动资源管理</strong>：消除忘记释放的风险</li>
<li><strong>异常安全保障</strong>：即使发生 panic 也能正确清理</li>
<li><strong>可预测的行为</strong>：严格的 LIFO 释放顺序</li>
</ol>
<p>实现了比垃圾回收更高效、比手动管理更安全的资源管理模式。</p>
</blockquote>
<hr>
<h3 id="Rust-Rc-引用计数智能指针"><a href="#Rust-Rc-引用计数智能指针" class="headerlink" title="Rust Rc&lt;T&gt; 引用计数智能指针"></a>Rust <code>Rc&lt;T&gt;</code> 引用计数智能指针</h3><p><strong>1. 核心概念</strong></p>
<ul>
<li><strong>多所有权</strong>：允许单个值被多个所有者共享</li>
<li><strong>引用计数</strong>：跟踪值的活跃引用数量</li>
<li><strong>自动清理</strong>：当计数归零时自动释放资源</li>
<li><strong>单线程专用</strong>：仅适用于单线程场景（多线程使用 <code>Arc&lt;T&gt;</code>）</li>
</ul>
<p><strong>2. 基本使用模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建初始列表 (计数=1)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 克隆共享 (计数=2)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再次克隆共享 (计数=3)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">&#125; <span class="comment">// 自动释放，计数归零</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 引用计数管理</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">方法</th>
<th align="left">计数变化</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">创建</td>
<td align="left"><code>Rc::new()</code></td>
<td align="left">+1</td>
<td align="left">初始引用</td>
</tr>
<tr>
<td align="left">克隆</td>
<td align="left"><code>Rc::clone()</code></td>
<td align="left">+1</td>
<td align="left">增加共享所有者</td>
</tr>
<tr>
<td align="left">离开作用域</td>
<td align="left">自动</td>
<td align="left">-1</td>
<td align="left">释放所有者</td>
</tr>
<tr>
<td align="left">获取计数</td>
<td align="left"><code>Rc::strong_count()</code></td>
<td align="left">-</td>
<td align="left">查看当前计数</td>
</tr>
</tbody></table>
<p><strong>计数生命周期示例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);                  <span class="comment">// 计数=1</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;初始计数: &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);           <span class="comment">// 计数=2</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b创建后: &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);       <span class="comment">// 计数=3</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;c创建后: &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;                                <span class="comment">// c离开，计数=2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c离开后: &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;                                   <span class="comment">// b离开，计数=1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;b离开后: &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a)); <span class="comment">// a离开，计数=0=&gt;释放</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 内存布局解析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[栈变量 a] --&gt; B[Rc 结构]</span><br><span class="line">    C[栈变量 b] --&gt; B</span><br><span class="line">    D[栈变量 c] --&gt; B</span><br><span class="line">    </span><br><span class="line">    B --&gt; E[堆数据]</span><br><span class="line">    </span><br><span class="line">    B[ Rc 结构 ] --&gt; F[strong_count: 3]</span><br><span class="line">    B --&gt; G[weak_count: 0]</span><br><span class="line">    B --&gt; H[指向堆数据]</span><br></pre></td></tr></table></figure>

<p><strong>5. 与 <code>Box&lt;T&gt;</code> 的关键区别</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Box&lt;T&gt;</code></th>
<th align="left"><code>Rc&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">所有权</td>
<td align="left">单一</td>
<td align="left">多重</td>
</tr>
<tr>
<td align="left">克隆行为</td>
<td align="left">深拷贝</td>
<td align="left">仅增加计数</td>
</tr>
<tr>
<td align="left">可变性</td>
<td align="left">允许修改</td>
<td align="left">默认不可变</td>
</tr>
<tr>
<td align="left">性能开销</td>
<td align="left">无额外开销</td>
<td align="left">计数管理开销</td>
</tr>
<tr>
<td align="left">使用场景</td>
<td align="left">独占所有权</td>
<td align="left">共享所有权</td>
</tr>
</tbody></table>
<p><strong>6. 最佳实践</strong></p>
<ol>
<li><p><strong>优先使用 <code>Rc::clone</code></strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐 ✅</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">shared</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;original);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐 ❌</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">shared</span> = original.<span class="title function_ invoke__">clone</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免深层嵌套</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能导致计数管理复杂化</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">deep</span> = Rc::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(<span class="number">42</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结合 <code>RefCell</code> 实现内部可变性</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">shared_mut</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">42</span>));</span><br><span class="line">*shared_mut.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">1</span>; <span class="comment">// 修改共享数据</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>7. 使用场景示例</strong></p>
<p><strong>树形结构节点共享</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    children: <span class="type">Vec</span>&lt;Rc&lt;TreeNode&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(TreeNode &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">    children: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(TreeNode &#123;</span><br><span class="line">    value: <span class="number">5</span>,</span><br><span class="line">    children: <span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>配置数据共享</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    timeout: <span class="type">u32</span>,</span><br><span class="line">    retries: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">config</span> = Rc::<span class="title function_ invoke__">new</span>(AppConfig &#123;</span><br><span class="line">    timeout: <span class="number">30</span>,</span><br><span class="line">    retries: <span class="number">3</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">processor1</span> = Processor::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;config));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">processor2</span> = Processor::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;config));</span><br></pre></td></tr></table></figure>

<p><strong>8. 限制与注意事项</strong></p>
<ol>
<li><p><strong>不可变限制</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// *data = 50; // 错误！不能直接修改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>循环引用风险</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    next: <span class="type">Option</span>&lt;Rc&lt;Node&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">node1</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123; next: <span class="literal">None</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">node2</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123; next: <span class="title function_ invoke__">Some</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;node1)) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险：可能创建循环引用</span></span><br><span class="line"><span class="comment">// node1.next = Some(Rc::clone(&amp;node2)); // 内存泄漏！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程限制</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误！Rc不能跨线程</span></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>9. 循环引用解决方案</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,    <span class="comment">// 弱引用避免循环</span></span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">    value: <span class="number">3</span>,</span><br><span class="line">    parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">    children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">    value: <span class="number">5</span>,</span><br><span class="line">    parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">    children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">*leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch); <span class="comment">// 弱引用赋值</span></span><br></pre></td></tr></table></figure>

<p><strong>10. 性能特征</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">时间复杂度</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Rc::new()</code></td>
<td align="left">O(1)</td>
<td align="left">堆分配+初始化计数</td>
</tr>
<tr>
<td align="left"><code>Rc::clone()</code></td>
<td align="left">O(1)</td>
<td align="left">原子计数增加</td>
</tr>
<tr>
<td align="left">离开作用域</td>
<td align="left">O(1)</td>
<td align="left">原子计数减少</td>
</tr>
<tr>
<td align="left">计数归零</td>
<td align="left">O(n)</td>
<td align="left">递归释放资源</td>
</tr>
<tr>
<td align="left"><code>Rc::downgrade()</code></td>
<td align="left">O(1)</td>
<td align="left">创建弱引用</td>
</tr>
</tbody></table>
<blockquote>
<p><code>Rc&lt;T&gt;</code> 是 Rust 共享所有权模型的基石，通过：</p>
<ol>
<li><strong>安全的多所有者机制</strong>：避免悬挂指针</li>
<li><strong>自动内存管理</strong>：计数归零自动释放</li>
<li><strong>编译时+运行时检查</strong>：结合所有权和引用计数</li>
</ol>
<p>实现了复杂数据结构的灵活共享，同时保持内存安全。</p>
</blockquote>
<hr>
<h3 id="RefCell-与内部可变性模式"><a href="#RefCell-与内部可变性模式" class="headerlink" title="RefCell&lt;T&gt; 与内部可变性模式"></a><code>RefCell&lt;T&gt;</code> 与内部可变性模式</h3><p><strong>核心概念</strong></p>
<ol>
<li><strong>内部可变性 (Interior Mutability)</strong>：<ul>
<li>允许在拥有不可变引用时修改数据</li>
<li>绕过编译时借用检查，在运行时强制执行规则</li>
<li>使用 <code>unsafe</code> 代码实现，但通过安全 API 封装</li>
</ul>
</li>
<li><strong><code>RefCell&lt;T&gt;</code> 特性</strong>：<ul>
<li>单一所有权（区别于 <code>Rc&lt;T&gt;</code> 的多所有权）</li>
<li><strong>运行时</strong>检查借用规则（区别于编译时检查）</li>
<li>违反规则时触发 <code>panic!</code> 而非编译错误</li>
<li>仅适用于单线程环境</li>
</ul>
</li>
</ol>
<p><strong>关键操作</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">返回类型</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>borrow()</code></td>
<td align="left"><code>Ref&lt;T&gt;</code></td>
<td align="left">获取不可变引用</td>
</tr>
<tr>
<td align="left"><code>borrow_mut()</code></td>
<td align="left"><code>RefMut&lt;T&gt;</code></td>
<td align="left">获取可变引用</td>
</tr>
<tr>
<td align="left"><code>try_borrow()</code></td>
<td align="left"><code>Result&lt;...&gt;</code></td>
<td align="left">安全获取不可变引用</td>
</tr>
<tr>
<td align="left"><code>try_borrow_mut()</code></td>
<td align="left"><code>Result&lt;...&gt;</code></td>
<td align="left">安全获取可变引用</td>
</tr>
</tbody></table>
<p><strong>使用场景</strong></p>
<ol>
<li><p><strong>Mock 对象测试</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">    sent_messages: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="comment">// 在不可变方法中修改数据</span></span><br><span class="line">        <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(msg.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>递归数据结构</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改共享数据</span></span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>选择时机</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">所有权</th>
<th align="left">检查时机</th>
<th align="left">可变性</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Box&lt;T&gt;</code></td>
<td align="left">单一</td>
<td align="left">编译时</td>
<td align="left">可变&#x2F;不可变</td>
<td align="left">普通单所有者场景</td>
</tr>
<tr>
<td align="left"><code>Rc&lt;T&gt;</code></td>
<td align="left">多个</td>
<td align="left">编译时</td>
<td align="left"><strong>仅不可变</strong></td>
<td align="left">共享数据的只读场景</td>
</tr>
<tr>
<td align="left"><code>RefCell&lt;T&gt;</code></td>
<td align="left">单一</td>
<td align="left"><strong>运行时</strong></td>
<td align="left">可变&#x2F;不可变</td>
<td align="left">需要内部可变性的场景</td>
</tr>
<tr>
<td align="left"><code>Rc&lt;RefCell&lt;T&gt;&gt;</code></td>
<td align="left">多个</td>
<td align="left">运行时</td>
<td align="left">可变&#x2F;不可变</td>
<td align="left">需要共享且可修改的数据</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>优先使用编译时检查</strong>：默认使用 <code>Box&lt;T&gt;</code> 或 <code>Rc&lt;T&gt;</code>，确保安全</p>
</li>
<li><p><strong>谨慎使用内部可变性</strong>：</p>
<ul>
<li>确保运行时不会违反借用规则</li>
<li>注意 <code>borrow_mut()</code> 可能触发 <code>panic!</code></li>
</ul>
</li>
<li><p><strong>组合使用模式</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享可变数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">shared_data</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 克隆智能指针</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">clone1</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;shared_data);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">clone2</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;shared_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">*clone1.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line">*clone2.<span class="title function_ invoke__">borrow_mut</span>() *= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>典型错误</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发 panic!（运行时检测到双重可变借用）</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">cell</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r1</span> = cell.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">r2</span> = cell.<span class="title function_ invoke__">borrow_mut</span>(); <span class="comment">// panic: already mutably borrowed</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：多线程场景中使用 <code>Mutex&lt;T&gt;</code>（线程安全的 <code>RefCell&lt;T&gt;</code>）</p>
</blockquote>
<p>通过此指南，你可快速掌握 <code>RefCell&lt;T&gt;</code> 的核心概念和实用模式，在需要内部可变性时安全地绕过 Rust 的编译时限制，同时保持运行时安全保证。</p>
<hr>
<h3 id="引用循环与内存泄漏"><a href="#引用循环与内存泄漏" class="headerlink" title="引用循环与内存泄漏"></a>引用循环与内存泄漏</h3><p><strong>核心问题</strong></p>
<ol>
<li><strong>引用循环</strong>：<ul>
<li>当使用 <code>Rc&lt;T&gt;</code> + <code>RefCell&lt;T&gt;</code> 时可能创建相互引用的循环</li>
<li>导致引用计数永远不为 0，内存无法释放</li>
<li>Rust 允许内存泄漏（认为内存安全），但需避免</li>
</ul>
</li>
<li><strong>典型场景</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),  <span class="comment">// 可变的引用指针</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建循环引用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line">* a.<span class="title function_ invoke__">tail</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);  <span class="comment">// 相互指向</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案：<code>Weak&lt;T&gt;</code></strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Rc&lt;T&gt;</code> (强引用)</th>
<th align="left"><code>Weak&lt;T&gt;</code> (弱引用)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">所有权</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">影响内存释放</td>
<td align="left">✓ (计数归零时释放)</td>
<td align="left">✗</td>
</tr>
<tr>
<td align="left">创建方式</td>
<td align="left"><code>Rc::clone()</code></td>
<td align="left"><code>Rc::downgrade()</code></td>
</tr>
<tr>
<td align="left">访问值</td>
<td align="left">直接解引用</td>
<td align="left"><code>upgrade()</code> → <code>Option&lt;Rc&lt;T&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">计数类型</td>
<td align="left"><code>strong_count</code></td>
<td align="left"><code>weak_count</code></td>
</tr>
</tbody></table>
<p><strong>树形结构实践（父子节点）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,    <span class="comment">// 父节点：弱引用</span></span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;, <span class="comment">// 子节点：强引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建叶子节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建分支节点</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]), <span class="comment">// 强引用子节点</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立反向引用（弱引用）</span></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用计数观察</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建叶子节点后</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;leaf: strong=&#123;&#125;, weak=&#123;&#125;&quot;</span>, </span><br><span class="line">    Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),  <span class="comment">// 1</span></span><br><span class="line">    Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)     <span class="comment">// 0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(...);</span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;branch: strong=&#123;&#125;, weak=&#123;&#125;&quot;</span>, </span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch),  <span class="comment">// 1</span></span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch)     <span class="comment">// 1 (来自leaf.parent)</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf: strong=&#123;&#125;, weak=&#123;&#125;&quot;</span>, </span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),   <span class="comment">// 2 (branch.children + 原始leaf)</span></span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)      <span class="comment">// 0</span></span><br><span class="line">    );</span><br><span class="line">&#125; <span class="comment">// branch离开作用域，强引用归零</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后访问父节点</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;leaf parent: &#123;:?&#125;&quot;</span>, </span><br><span class="line">    leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>()  <span class="comment">// None（已安全释放）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>关键总结</strong></p>
<ol>
<li><strong>循环引用预防</strong>：<ul>
<li>在需要双向引用时，使用 <strong>强引用 + 弱引用</strong> 组合</li>
<li>父子关系：父→子用 <code>Rc&lt;T&gt;</code>，子→父用 <code>Weak&lt;T&gt;</code></li>
</ul>
</li>
<li><strong>安全访问</strong>：<ul>
<li>始终通过 <code>upgrade()</code> 检查弱引用有效性</li>
<li>返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code> 避免悬垂指针</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>树形&#x2F;图数据结构</li>
<li>缓存系统</li>
<li>任何需要打破所有权循环的场景</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>注意</strong>：多线程环境使用 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> + <code>Arc::downgrade()</code> 实现线程安全版本</p>
</blockquote>
<hr>
<hr>
<h2 id="Rust-无畏并发"><a href="#Rust-无畏并发" class="headerlink" title="Rust 无畏并发"></a>Rust 无畏并发</h2><h3 id="开始-1"><a href="#开始-1" class="headerlink" title="开始"></a>开始</h3><p><strong>核心原则</strong></p>
<ol>
<li><strong>编译时保障</strong>：<ul>
<li>所有权系统在编译时捕获并发错误</li>
<li>类型系统防止数据竞争（data races）</li>
<li>“无畏并发” &#x3D; 安全重构 + 避免运行时诡异 bug</li>
</ul>
</li>
</ol>
<p><strong>并发工具集</strong></p>
<table>
<thead>
<tr>
<th align="left">工具</th>
<th align="left">适用场景</th>
<th align="left">关键特性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>线程 (Threads)</strong></td>
<td align="left">CPU 密集型任务</td>
<td align="left"><code>std::thread::spawn()</code> + <code>join()</code></td>
</tr>
<tr>
<td align="left"><strong>消息传递</strong></td>
<td align="left">分布式任务处理</td>
<td align="left">通道 (<code>mpsc</code>) + 所有权转移</td>
</tr>
<tr>
<td align="left"><strong>共享状态</strong></td>
<td align="left">需要高效共享数据的场景</td>
<td align="left"><code>Mutex&lt;T&gt;</code> + <code>Arc&lt;T&gt;</code> 组合</td>
</tr>
<tr>
<td align="left"><strong>Sync&#x2F;Send</strong></td>
<td align="left">自定义并发类型</td>
<td align="left">编译器自动检查并发安全</td>
</tr>
</tbody></table>
<hr>
<p><strong>1. 线程管理</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;线程: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程工作</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;主线程: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待子线程完成</span></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li><code>spawn</code> 返回 <code>JoinHandle</code></li>
<li><code>join()</code> 阻塞当前线程</li>
<li>线程间无自动数据共享</li>
</ul>
<hr>
<p><strong>2. 消息传递（通道）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;  <span class="comment">// 多生产者，单消费者</span></span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[<span class="string">&quot;消息1&quot;</span>, <span class="string">&quot;消息2&quot;</span>, <span class="string">&quot;消息3&quot;</span>];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程作为消费者</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;收到: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>所有权通过 <code>send()</code> 转移</li>
<li>通道自动处理同步</li>
<li><code>try_recv()</code> 非阻塞接收</li>
</ul>
<hr>
<p><strong>3. 共享状态并发</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>黄金组合</strong>：</p>
<ol>
<li><code>Arc&lt;T&gt;</code>：原子引用计数（线程安全版 <code>Rc&lt;T&gt;</code>）</li>
<li><code>Mutex&lt;T&gt;</code>：互斥锁（<code>lock()</code> 获取守卫）</li>
<li>守卫自动释放锁（RAII 模式）</li>
</ol>
<hr>
<p><strong>4. Sync 与 Send Trait</strong></p>
<table>
<thead>
<tr>
<th align="left">Trait</th>
<th align="left">作用</th>
<th align="left">自动实现条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Send</strong></td>
<td align="left">允许所有权跨线程转移</td>
<td align="left">所有成员都实现 Send</td>
</tr>
<tr>
<td align="left"><strong>Sync</strong></td>
<td align="left">允许不可变引用跨线程安全共享</td>
<td align="left">所有成员都实现 Sync</td>
</tr>
</tbody></table>
<p><strong>手动实现示例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyConcurrentType</span> &#123;</span><br><span class="line">    data: Mutex&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并发安全</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Send</span> <span class="keyword">for</span> <span class="title class_">MyConcurrentType</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Sync</span> <span class="keyword">for</span> <span class="title class_">MyConcurrentType</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>并发模式对比</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>消息传递</strong></td>
<td align="left">避免数据竞争</td>
<td align="left">数据复制开销</td>
<td align="left">任务管道&#x2F;工作队列</td>
</tr>
<tr>
<td align="left"><strong>共享状态</strong></td>
<td align="left">高效访问共享资源</td>
<td align="left">死锁风险</td>
<td align="left">缓存&#x2F;计数器&#x2F;状态机</td>
</tr>
<tr>
<td align="left"><strong>无锁结构</strong></td>
<td align="left">极致性能</td>
<td align="left">实现复杂度高</td>
<td align="left">高性能核心组件</td>
</tr>
</tbody></table>
<hr>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>优先选择消息传递</strong>：更符合 Rust 所有权哲学</p>
</li>
<li><p><strong>锁的粒度控制</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：锁范围过大</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">lock</span> = data.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="title function_ invoke__">process1</span>(&amp;lock);</span><br><span class="line"><span class="title function_ invoke__">process2</span>(&amp;lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：最小化锁范围</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock</span> = data.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="title function_ invoke__">process1</span>(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock</span> = data.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="title function_ invoke__">process2</span>(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>死锁预防</strong>：</p>
<ul>
<li>固定锁获取顺序</li>
<li>使用 <code>try_lock()</code> 替代阻塞锁</li>
<li>设置锁超时 (<code>parking_lot</code> crate)</li>
</ul>
</li>
<li><p><strong>工具链支持</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-audit  # 安全审计</span><br><span class="line">cargo install cargo-geiger # 检测unsafe代码</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>通过编译时保障 + 灵活的工具选择，Rust 使你能<strong>无畏</strong>地构建高并发系统，无需在安全性和性能间妥协。</p>
</blockquote>
<hr>
<h3 id="Rust-线程使用"><a href="#Rust-线程使用" class="headerlink" title="Rust 线程使用"></a>Rust 线程使用</h3><p><strong>1. 创建线程</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用 spawn 创建新线程</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;子线程: &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程工作</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;主线程: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>:</p>
<ul>
<li><code>thread::spawn</code> 接受闭包作为线程执行体</li>
<li>主线程结束时所有子线程会被强制终止</li>
<li>线程执行顺序不确定（由操作系统调度）</li>
</ul>
<p><strong>2. 使用 join 控制线程生命周期</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程工作</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;主线程: &#123;&#125;&quot;</span>, i);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待子线程完成</span></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p><strong>join 位置的影响</strong>:</p>
<table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">效果</th>
<th align="left">输出顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主循环后</td>
<td align="left">主线程等待子线程完成</td>
<td align="left">主&#x2F;子线程交替输出</td>
</tr>
<tr>
<td align="left">主循环前</td>
<td align="left">子线程完成后再执行主循环</td>
<td align="left">先子线程后主线程</td>
</tr>
</tbody></table>
<p><strong>3. move 闭包：所有权转移</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 move 强制获取所有权</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;转移的vec: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    <span class="comment">// v 在这里被销毁</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处不能再使用 v（所有权已转移）</span></span><br><span class="line"><span class="comment">// println!(&quot;&#123;:?&#125;&quot;, v); // 编译错误！</span></span><br><span class="line"></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p><strong>所有权规则</strong>:</p>
<ol>
<li>线程闭包默认尝试借用环境变量</li>
<li><code>move</code> 关键字强制获取所有权</li>
<li>所有权转移后原上下文无法再使用该变量</li>
</ol>
<p><strong>4. 线程安全生命周期</strong></p>
<p><strong>错误示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let v = vec![1, 2, 3];</span><br><span class="line">let handle = thread::spawn(|| &#123;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, v); // 可能引用无效内存</span><br><span class="line">&#125;);</span><br><span class="line">drop(v); // 提前释放</span><br><span class="line">handle.join().unwrap();</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123; <span class="comment">// 所有权转移</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 不能在此处 drop(v)，所有权已转移</span></span><br><span class="line">handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p><strong>线程使用要点</strong></p>
<ol>
<li><strong>线程隔离</strong>：每个线程有独立栈空间</li>
<li><strong>数据共享</strong>：需通过通道(Channel)或原子类型(Atomic)</li>
<li><strong>错误处理</strong>：<code>join()</code> 返回 <code>Result&lt;(), Box&lt;dyn Any + Send&gt;&gt;</code></li>
<li><strong>线程局部存储</strong>：使用 <code>thread_local!</code> 宏定义线程私有数据</li>
</ol>
<blockquote>
<p>Rust 的线程模型保证：通过所有权系统和编译时检查，<strong>防止数据竞争和悬垂指针</strong>，实现安全并发。</p>
</blockquote>
<hr>
<h3 id="Rust-消息传递并发"><a href="#Rust-消息传递并发" class="headerlink" title="Rust 消息传递并发"></a>Rust 消息传递并发</h3><p><strong>1. 信道基础</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;  <span class="comment">// 多生产者单消费者</span></span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建信道 (发送端tx, 接收端rx)</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    </span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(msg).<span class="title function_ invoke__">unwrap</span>();  <span class="comment">// 发送消息，所有权转移</span></span><br><span class="line">        <span class="comment">// 此处不能再使用msg!</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 阻塞接收消息</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;收到: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li><code>mpsc</code> &#x3D; 多生产者单消费者</li>
<li><code>send()</code> 转移所有权</li>
<li><code>recv()</code> 阻塞等待消息</li>
</ul>
<p><strong>2. 非阻塞接收</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> rx.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(msg) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;新消息: &#123;&#125;&quot;</span>, msg),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(mpsc::TryRecvError::Empty) =&gt; &#123;&#125;,  <span class="comment">// 无消息</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(mpsc::TryRecvError::Disconnected) =&gt; <span class="keyword">break</span>,  <span class="comment">// 信道关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 流式接收（迭代器模式）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[<span class="string">&quot;消息1&quot;</span>, <span class="string">&quot;消息2&quot;</span>, <span class="string">&quot;消息3&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));  <span class="comment">// 模拟处理时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动迭代直到信道关闭</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;收到: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 多生产者实现</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tx1</span> = tx.<span class="title function_ invoke__">clone</span>();  <span class="comment">// 克隆发送端</span></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    tx1.<span class="title function_ invoke__">send</span>(<span class="string">&quot;线程1的消息&quot;</span>.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者2</span></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(<span class="string">&quot;线程2的消息&quot;</span>.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收所有消息</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所有权规则实践</strong></p>
<p><strong>错误示例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;敏感数据&quot;</span>);</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(data).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, data);  <span class="comment">// 编译错误！所有权已转移</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>正确做法</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 克隆数据发送副本</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">data_clone</span> = data.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">tx.<span class="title function_ invoke__">send</span>(data_clone).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或发送后不再使用原数据</span></span><br><span class="line">tx.<span class="title function_ invoke__">send</span>(data).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// 此处不能使用data</span></span><br></pre></td></tr></table></figure>

<p><strong>信道关闭机制</strong></p>
<ol>
<li><strong>自动关闭</strong>：<ul>
<li>当所有发送端被丢弃时</li>
<li>接收端迭代器自动终止</li>
</ul>
</li>
<li><strong>手动关闭</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">drop</span>(tx);  <span class="comment">// 显式关闭发送端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端会收到Disconnected错误</span></span><br></pre></td></tr></table></figure>

<p><strong>性能优化技巧</strong></p>
<ol>
<li><strong>批处理发送</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tx.<span class="title function_ invoke__">send_batch</span>(<span class="built_in">vec!</span>[msg1, msg2, msg3]).<span class="title function_ invoke__">unwrap</span>();  <span class="comment">// 减少锁竞争</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>有界信道</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">100</span>);  <span class="comment">// 容量100的缓冲信道</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>选择接收</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">select!</span> &#123;</span><br><span class="line">    msg = rx1.<span class="title function_ invoke__">recv</span>() =&gt; &#123; <span class="comment">/* 处理消息1 */</span> &#125;,</span><br><span class="line">    msg = rx2.<span class="title function_ invoke__">recv</span>() =&gt; &#123; <span class="comment">/* 处理消息2 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>核心原则</strong>：<br><strong>“不要通过共享内存来通讯；而要通过通讯来共享内存”</strong><br>Rust的信道机制在编译期保证：</p>
<ol>
<li>数据竞争安全</li>
<li>所有权明确转移</li>
<li>线程间解耦</li>
</ol>
</blockquote>
<hr>
<h3 id="Rust-共享状态并发"><a href="#Rust-共享状态并发" class="headerlink" title="Rust 共享状态并发"></a>Rust 共享状态并发</h3><p><strong>1. 互斥器 (Mutex) 基础</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>); <span class="comment">// 创建互斥器</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取锁（阻塞直到可用）</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>; <span class="comment">// 修改受保护数据</span></span><br><span class="line">    &#125; <span class="comment">// 锁自动释放 (RAII)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m); <span class="comment">// 输出: Mutex &#123; data: 6 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li><code>lock()</code> 返回 <code>MutexGuard</code> 智能指针</li>
<li>自动实现 <code>Deref</code> 和 <code>Drop</code></li>
<li>作用域结束自动释放锁</li>
<li>线程 panic 时自动释放锁（<code>PoisonError</code> 处理）</li>
</ul>
<p><strong>2. 多线程共享解决方案：Arc + Mutex</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>)); <span class="comment">// 原子引用计数 + 互斥器</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter); <span class="comment">// 增加引用计数</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>; <span class="comment">// 安全修改共享数据</span></span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// 输出: 结果: 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>黄金组合</strong>：</p>
<ul>
<li><code>Arc&lt;T&gt;</code>：线程安全的引用计数（原子操作）</li>
<li><code>Mutex&lt;T&gt;</code>：提供内部可变性 + 互斥访问</li>
<li>组合后实现多线程安全共享</li>
</ul>
<p><strong>3. 与 Rc&#x2F;RefCell 的对比</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">单线程</th>
<th align="left">多线程</th>
</tr>
</thead>
<tbody><tr>
<td align="left">引用计数</td>
<td align="left"><code>Rc&lt;T&gt;</code></td>
<td align="left"><code>Arc&lt;T&gt;</code></td>
</tr>
<tr>
<td align="left">内部可变性</td>
<td align="left"><code>RefCell&lt;T&gt;</code></td>
<td align="left"><code>Mutex&lt;T&gt;</code></td>
</tr>
<tr>
<td align="left">运行时检查</td>
<td align="left">借用规则</td>
<td align="left">锁机制</td>
</tr>
<tr>
<td align="left">线程安全</td>
<td align="left">❌</td>
<td align="left">✅</td>
</tr>
</tbody></table>
<p><strong>4. 原子类型优化（简单计数器场景）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicI32, Ordering&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">counter</span> = AtomicI32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::SeqCst); <span class="comment">// 原子操作，无锁</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 死锁预防模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险：交叉锁定</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">lock_a</span> = mutex_a.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">lock_b</span> = mutex_b.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 可能死锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案1：固定锁顺序</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">lock1</span> = <span class="title function_ invoke__">min</span>(mutex_a, mutex_b).<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">lock2</span> = <span class="title function_ invoke__">max</span>(mutex_a, mutex_b).<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案2：尝试锁</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(lock_a) = mutex_a.<span class="title function_ invoke__">try_lock</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(lock_b) = mutex_b.<span class="title function_ invoke__">try_lock</span>() &#123;</span><br><span class="line">        <span class="comment">// 成功获取双锁</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 回退策略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案3：使用 crate (如 parking_lot)</span></span><br><span class="line"><span class="keyword">use</span> parking_lot::&#123;Mutex, const_mutex&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = const_mutex!(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = const_mutex!(<span class="number">2</span>);</span><br><span class="line">parking_lot::<span class="title function_ invoke__">lock</span>(&amp;a, &amp;b); <span class="comment">// 死锁安全实现</span></span><br></pre></td></tr></table></figure>

<p><strong>共享状态 vs 消息传递</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">共享状态</th>
<th align="left">消息传递 (Channel)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数据位置</td>
<td align="left">集中存储</td>
<td align="left">分散在生产者&#x2F;消费者间</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">高频访问共享资源</td>
<td align="left">任务解耦&#x2F;流水线处理</td>
</tr>
<tr>
<td align="left">复杂度</td>
<td align="left">需要管理锁</td>
<td align="left">无需显式锁</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">通常更高（无数据移动）</td>
<td align="left">可能有序列化开销</td>
</tr>
<tr>
<td align="left">内存安全</td>
<td align="left">依赖正确使用锁</td>
<td align="left">所有权转移保证安全</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>最小化锁范围</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确：快速释放锁</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// 关键区操作</span></span><br><span class="line">&#125; <span class="comment">// 立即释放锁</span></span><br><span class="line"><span class="comment">// 非关键区操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免锁嵌套</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险：可能死锁</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">lock1</span> = mutex1.<span class="title function_ invoke__">lock</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">lock2</span> = mutex2.<span class="title function_ invoke__">lock</span>(); <span class="comment">// 如果其他线程以相反顺序获取，则死锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 RwLock 优化读多写少</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::RwLock;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">lock</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = lock.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 多个读取者</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = lock.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = lock.<span class="title function_ invoke__">write</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 独占写入者</span></span><br><span class="line">    *w += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>核心原则</strong>：<br>Rust 通过类型系统保证：</p>
<ul>
<li>共享数据的线程安全访问（<code>Sync</code> trait）</li>
<li>锁的生命周期管理（<code>MutexGuard</code> 的 <code>Drop</code> 实现）</li>
<li>引用计数的原子操作（<code>Arc</code> 代替 <code>Rc</code>）</li>
</ul>
</blockquote>
<p>通过 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 模式，Rust 在编译期就确保了共享内存访问的安全性，消除了数据竞争和大部分死锁风险。</p>
<hr>
<h3 id="Send-与-Sync-Trait"><a href="#Send-与-Sync-Trait" class="headerlink" title="Send 与 Sync Trait"></a><code>Send</code> 与 <code>Sync</code> Trait</h3><p><strong>1. 核心概念</strong></p>
<table>
<thead>
<tr>
<th align="left">Trait</th>
<th align="left">作用</th>
<th align="left">自动实现条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Send</code></strong></td>
<td align="left">允许类型的所有权在线程间<strong>安全转移</strong></td>
<td align="left">所有成员都实现 <code>Send</code></td>
</tr>
<tr>
<td align="left"><strong><code>Sync</code></strong></td>
<td align="left">允许类型的<strong>不可变引用</strong>(&amp;T)在线程间<strong>安全共享</strong></td>
<td align="left">所有成员都实现 <code>Sync</code></td>
</tr>
</tbody></table>
<p><strong>2. 标准类型实现分析</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">Send</th>
<th align="left">Sync</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基本类型 (i32, bool等)</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">自然满足线程安全要求</td>
</tr>
<tr>
<td align="left"><code>Rc&lt;T&gt;</code></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">非原子引用计数，线程不安全</td>
</tr>
<tr>
<td align="left"><code>Arc&lt;T&gt;</code></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">原子引用计数，线程安全</td>
</tr>
<tr>
<td align="left"><code>Mutex&lt;T&gt;</code></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">提供线程安全的内部可变性</td>
</tr>
<tr>
<td align="left"><code>RwLock&lt;T&gt;</code></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">读写锁，线程安全</td>
</tr>
<tr>
<td align="left"><code>Cell&lt;T&gt;</code></td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">线程内部可变性，但跨线程不安全</td>
</tr>
<tr>
<td align="left"><code>RefCell&lt;T&gt;</code></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">非线程安全的运行时借用检查</td>
</tr>
<tr>
<td align="left">裸指针 (<code>*const T</code>等)</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">需要手动管理安全</td>
</tr>
</tbody></table>
<p><strong>3. 自动实现机制</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动实现 Send/Sync 的复合类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SafeType</span> &#123;</span><br><span class="line">    a: <span class="type">i32</span>,       <span class="comment">// Send + Sync</span></span><br><span class="line">    b: Arc&lt;Mutex&lt;<span class="type">String</span>&gt;&gt;, <span class="comment">// Send + Sync</span></span><br><span class="line">&#125; <span class="comment">// 自动获得 Send + Sync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非安全类型示例</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnsafeType</span> &#123;</span><br><span class="line">    rc: Rc&lt;<span class="type">i32</span>&gt;,  <span class="comment">// !Send + !Sync</span></span><br><span class="line">&#125; <span class="comment">// 自动获得 !Send + !Sync</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 自定义类型实现规则</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动实现（需要 unsafe 代码）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span>(<span class="comment">/* 字段 */</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Send</span> <span class="keyword">for</span> <span class="title class_">MyType</span> &#123;&#125;   <span class="comment">// 保证跨线程转移安全</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Sync</span> <span class="keyword">for</span> <span class="title class_">MyType</span> &#123;&#125;   <span class="comment">// 保证共享引用安全</span></span><br></pre></td></tr></table></figure>

<p><strong>必须遵守的保证</strong>：</p>
<ol>
<li><strong>Send 保证</strong>：转移后原线程不再访问</li>
<li><strong>Sync 保证</strong>：多个线程同时读取不会引发数据竞争</li>
</ol>
<p><strong>5. 并发错误示例分析</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：尝试在线程间传递 Rc&lt;T&gt;</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">share_rc</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rc</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">42</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rc); <span class="comment">// 编译错误: `Rc&lt;i32&gt;` cannot be sent between threads</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器错误</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rc&lt;i32&gt;` cannot be sent between threads safely</span><br></pre></td></tr></table></figure>

<p><strong>6. 并发安全模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确模式：Arc + Mutex</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">safe_shared_state</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_clone</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;data);</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = data_clone.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *guard += <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. 并发扩展生态</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">推荐 crate</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">异步运行时</td>
<td align="left">tokio, async-std</td>
<td align="left">高性能异步I&#x2F;O</td>
</tr>
<tr>
<td align="left">无锁数据结构</td>
<td align="left">crossbeam, flurry</td>
<td align="left">无锁队列、哈希表等</td>
</tr>
<tr>
<td align="left">工作窃取调度</td>
<td align="left">rayon</td>
<td align="left">并行迭代器</td>
</tr>
<tr>
<td align="left">原子操作扩展</td>
<td align="left">atomic-float, ordered-float</td>
<td align="left">浮点数的原子操作</td>
</tr>
</tbody></table>
<p><strong>关键总结</strong></p>
<ol>
<li><p><strong>编译期保证</strong>：Rust 在编译时通过 <code>Send</code>&#x2F;<code>Sync</code> 阻止线程不安全操作</p>
</li>
<li><p><strong>安全边界</strong>：</p>
<ul>
<li>99% 的情况应依赖自动实现</li>
<li>手动实现需要深入理解内存模型（见第20章）</li>
</ul>
</li>
<li><p><strong>设计哲学</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准库的智慧体现</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Mutex</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Mutex</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Mutex&lt;T&gt;</code> 自动获得 <code>Send</code>&#x2F;<code>Sync</code> 当且仅当 <code>T</code> 是 <code>Send</code></li>
<li>这种设计确保锁保护的数据满足线程安全要求</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>无畏并发</strong>：<br>Rust 的并发模型独特之处在于：</p>
<ul>
<li>线程安全不是运行时特性，而是<strong>类型属性</strong></li>
<li>通过 <code>Send</code>&#x2F;<code>Sync</code> 在编译期排除数据竞争</li>
<li>标准库提供基础，生态提供扩展，实现从系统编程到Web服务的全覆盖安全并发</li>
</ul>
</blockquote>
<hr>
<hr>
<h2 id="Rust-异步编程"><a href="#Rust-异步编程" class="headerlink" title="Rust 异步编程"></a>Rust 异步编程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>1. 核心概念</strong></p>
<table>
<thead>
<tr>
<th align="left">术语</th>
<th align="left">定义</th>
<th align="left">Rust 实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Async</strong></td>
<td align="left">声明异步函数，返回 <code>Future</code></td>
<td align="left"><code>async fn</code></td>
</tr>
<tr>
<td align="left"><strong>Await</strong></td>
<td align="left">暂停执行直到 <code>Future</code> 完成</td>
<td align="left"><code>.await</code></td>
</tr>
<tr>
<td align="left"><strong>Future</strong></td>
<td align="left">表示异步计算的值（惰性，需要执行器驱动）</td>
<td align="left"><code>impl Future</code></td>
</tr>
<tr>
<td align="left"><strong>Executor</strong></td>
<td align="left">调度和执行异步任务的运行时系统</td>
<td align="left">Tokio, async-std 等</td>
</tr>
</tbody></table>
<p><strong>2. 基础语法</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">fetch_data</span>(url: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">    reqwest::<span class="title function_ invoke__">get</span>(url).<span class="keyword">await</span>?.<span class="title function_ invoke__">text</span>().<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">process</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">fetch_data</span>(<span class="string">&quot;https://example.com&quot;</span>).<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(data) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Received: &#123;&#125;&quot;</span>, data),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 执行模型</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span>  <span class="comment">// 使用Tokio运行时</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task1</span> = <span class="title function_ invoke__">process_data</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task2</span> = <span class="title function_ invoke__">process_data</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并发执行任务</span></span><br><span class="line">    <span class="keyword">let</span> (res1, res2) = tokio::join!(task1, task2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 并发模式对比</strong></p>
<table>
<thead>
<tr>
<th align="left">模型</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>多线程</strong></td>
<td align="left">利用多核CPU</td>
<td align="left">上下文切换开销大</td>
<td align="left">CPU密集型任务</td>
</tr>
<tr>
<td align="left"><strong>异步</strong></td>
<td align="left">高并发I&#x2F;O，资源占用低</td>
<td align="left">单线程执行计算任务</td>
<td align="left">I&#x2F;O密集型任务</td>
</tr>
<tr>
<td align="left"><strong>混合</strong></td>
<td align="left">兼顾计算和I&#x2F;O</td>
<td align="left">复杂度高</td>
<td align="left">综合型应用</td>
</tr>
</tbody></table>
<p><strong>5. 关键组件</strong></p>
<ol>
<li><p><strong>Future 状态机</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FetchFuture</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Start</span>(Url),</span><br><span class="line">    <span class="title function_ invoke__">WaitingFirstByte</span>(ResponseFuture),</span><br><span class="line">    <span class="title function_ invoke__">WaitingBody</span>(TextFuture),</span><br><span class="line">    Done,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译器将 <code>async fn</code> 转换为状态机</li>
<li>每个 <code>.await</code> 是状态切换点</li>
</ul>
</li>
<li><p><strong>Waker 唤醒机制</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SocketRead</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    socket: &amp;<span class="symbol">&#x27;a</span> Socket,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">SocketRead</span>&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.socket.<span class="title function_ invoke__">has_data</span>() &#123;</span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(<span class="keyword">self</span>.socket.<span class="title function_ invoke__">read_buf</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 数据到达时唤醒任务</span></span><br><span class="line">            <span class="keyword">self</span>.socket.<span class="title function_ invoke__">register_waker</span>(cx.<span class="title function_ invoke__">waker</span>());</span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>6. 最佳实践</strong></p>
<ol>
<li><p><strong>避免阻塞</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：阻塞执行器线程</span></span><br><span class="line">std::thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：异步等待</span></span><br><span class="line">tokio::time::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>任务拆分</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU密集型任务使用独立线程池</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = tokio::task::<span class="title function_ invoke__">spawn_blocking</span>(|| &#123;</span><br><span class="line">    <span class="title function_ invoke__">heavy_computation</span>() <span class="comment">// 长时间计算</span></span><br><span class="line">&#125;).<span class="keyword">await</span>?;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>并发控制</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::stream::FuturesUnordered;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tasks</span> = FuturesUnordered::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">url</span> <span class="keyword">in</span> urls &#123;</span><br><span class="line">    tasks.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">fetch_data</span>(url));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(result) = tasks.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="comment">// 处理完成的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>7. 错误处理</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">fallible_task</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="title function_ invoke__">fetch_data</span>().<span class="keyword">await</span>?; <span class="comment">// 传播错误</span></span><br><span class="line">    <span class="title function_ invoke__">process</span>(data).<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一错误处理</span></span><br><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">fallible_task</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;成功&quot;</span>),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(MyError::<span class="title function_ invoke__">Io</span>(e)) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;IO错误: &#123;e&#125;&quot;</span>),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(MyError::<span class="title function_ invoke__">Parse</span>(e)) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;解析错误: &#123;e&#125;&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8. 生态系统</strong></p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">推荐库</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">运行时</td>
<td align="left">Tokio, async-std</td>
<td align="left">异步任务执行</td>
</tr>
<tr>
<td align="left">HTTP客户端</td>
<td align="left">reqwest, hyper</td>
<td align="left">网络请求</td>
</tr>
<tr>
<td align="left">数据库</td>
<td align="left">sqlx, sea-orm</td>
<td align="left">异步数据库访问</td>
</tr>
<tr>
<td align="left">Web框架</td>
<td align="left">axum, actix-web</td>
<td align="left">异步Web服务</td>
</tr>
<tr>
<td align="left">工具集</td>
<td align="left">futures, tokio-stream</td>
<td align="left">流处理和组合器</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>核心优势</strong>：</p>
<ol>
<li><strong>零成本抽象</strong>：异步代码编译为高效状态机</li>
<li><strong>无畏并发</strong>：借用检查器保证异步代码内存安全</li>
<li><strong>无缝集成</strong>：<code>.await</code> 语法类似同步代码</li>
<li><strong>高扩展性</strong>：单线程可处理数万并发连接</li>
</ol>
</blockquote>
<p>通过 <code>async/await</code>，Rust 提供了：</p>
<ul>
<li>类似同步代码的直观编写方式</li>
<li>接近手写状态机的运行时性能</li>
<li>编译期保障的线程安全</li>
<li>适用于从嵌入式系统到Web服务的全场景</li>
</ul>
<hr>
<h3 id="Rust-异步编程与-Futures"><a href="#Rust-异步编程与-Futures" class="headerlink" title="Rust 异步编程与 Futures"></a>Rust 异步编程与 Futures</h3><p><strong>1. 核心概念</strong></p>
<table>
<thead>
<tr>
<th align="left">术语</th>
<th align="left">定义</th>
<th align="left">关键特性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Future</code></strong></td>
<td align="left">表示异步计算的值（惰性执行）</td>
<td align="left"><code>trait Future &#123; type Output; &#125;</code></td>
</tr>
<tr>
<td align="left"><strong><code>async</code></strong></td>
<td align="left">标记异步代码块或函数</td>
<td align="left">编译为状态机</td>
</tr>
<tr>
<td align="left"><strong><code>.await</code></strong></td>
<td align="left">暂停执行直到 <code>Future</code> 完成</td>
<td align="left">后缀关键字</td>
</tr>
<tr>
<td align="left"><strong><code>Executor</code></strong></td>
<td align="left">调度和执行异步任务的运行时</td>
<td align="left">驱动 <code>Future</code> 完成</td>
</tr>
</tbody></table>
<p><strong>2. 异步函数原理</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户编写的异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">fetch_data</span>(url: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">get</span>(url).<span class="keyword">await</span>;</span><br><span class="line">    response.<span class="title function_ invoke__">text</span>().<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器生成的等价代码</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FetchDataFuture</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    state: State&lt;<span class="symbol">&#x27;a</span>&gt;,</span><br><span class="line">    url: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    Start,</span><br><span class="line">    <span class="title function_ invoke__">AwaitingGet</span>(GetFuture),</span><br><span class="line">    <span class="title function_ invoke__">AwaitingText</span>(TextFuture),</span><br><span class="line">    Done,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">FetchDataFuture</span>&lt;<span class="symbol">&#x27;_</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="type">String</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">            State::Start =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">fut</span> = <span class="title function_ invoke__">get</span>(<span class="keyword">self</span>.url);</span><br><span class="line">                <span class="keyword">self</span>.state = State::<span class="title function_ invoke__">AwaitingGet</span>(fut);</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">poll</span>(cx) <span class="comment">// 立即再次轮询</span></span><br><span class="line">            &#125;</span><br><span class="line">            State::<span class="title function_ invoke__">AwaitingGet</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> fut) =&gt; &#123;</span><br><span class="line">                <span class="keyword">match</span> fut.<span class="title function_ invoke__">poll</span>(cx) &#123;</span><br><span class="line">                    Poll::<span class="title function_ invoke__">Ready</span>(response) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">let</span> <span class="variable">text_fut</span> = response.<span class="title function_ invoke__">text</span>();</span><br><span class="line">                        <span class="keyword">self</span>.state = State::<span class="title function_ invoke__">AwaitingText</span>(text_fut);</span><br><span class="line">                        <span class="keyword">self</span>.<span class="title function_ invoke__">poll</span>(cx)</span><br><span class="line">                    &#125;</span><br><span class="line">                    Poll::Pending =&gt; Poll::Pending,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            State::<span class="title function_ invoke__">AwaitingText</span>(<span class="keyword">ref</span> <span class="keyword">mut</span> fut) =&gt; &#123;</span><br><span class="line">                fut.<span class="title function_ invoke__">poll</span>(cx).<span class="title function_ invoke__">map</span>(|text| &#123;</span><br><span class="line">                    <span class="keyword">self</span>.state = State::Done;</span><br><span class="line">                    text</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            State::Done =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Future polled after completion&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 关键特性解析</strong></p>
<ol>
<li><p><strong>惰性执行</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">fut</span> = <span class="title function_ invoke__">fetch_data</span>(<span class="string">&quot;https://example.com&quot;</span>); <span class="comment">// 未开始执行</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = fut.<span class="keyword">await</span>; <span class="comment">// 实际开始执行并等待完成</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>零成本抽象</strong>：</p>
<ul>
<li>无堆分配（除非明确要求）</li>
<li>无动态分发</li>
<li>编译器生成最优状态机</li>
</ul>
</li>
<li><p><strong><code>Pin</code> 机制</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保证Future在内存中位置固定</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>4. 并发模式实践</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::future::&#123;join, race, select&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行执行（等待所有完成）</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">parallel</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (res1, res2) = <span class="title function_ invoke__">join</span>(<span class="title function_ invoke__">task1</span>(), <span class="title function_ invoke__">task2</span>()).<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 竞速执行（获取首个结果）</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">race</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">race</span>(<span class="title function_ invoke__">task1</span>(), <span class="title function_ invoke__">task2</span>()).<span class="keyword">await</span> &#123;</span><br><span class="line">        Either::<span class="title function_ invoke__">Left</span>(res) =&gt; <span class="comment">/* 任务1胜出 */</span>,</span><br><span class="line">        Either::<span class="title function_ invoke__">Right</span>(res) =&gt; <span class="comment">/* 任务2胜出 */</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择性等待</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">selective</span>() &#123;</span><br><span class="line">    <span class="built_in">select!</span> &#123;</span><br><span class="line">        res1 = <span class="title function_ invoke__">task1</span>().<span class="title function_ invoke__">fuse</span>() =&gt; <span class="comment">/* 任务1完成 */</span>,</span><br><span class="line">        res2 = <span class="title function_ invoke__">task2</span>().<span class="title function_ invoke__">fuse</span>() =&gt; <span class="comment">/* 任务2完成 */</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 网页爬虫优化实现</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> trpl::&#123;Either, Html, race&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">urls</span>: <span class="type">Vec</span>&lt;_&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建所有任务的future</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tasks</span>: <span class="type">Vec</span>&lt;_&gt; = urls.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|url| <span class="title function_ invoke__">page_title</span>(url))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 竞速执行所有任务</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">winner</span> = <span class="title function_ invoke__">race_all</span>(tasks).<span class="keyword">await</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">match</span> winner &#123;</span><br><span class="line">        (url, <span class="title function_ invoke__">Some</span>(title)) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;🏆 &#123;url&#125;\n标题: &#123;title&#125;&quot;</span>),</span><br><span class="line">        (url, <span class="literal">None</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;🏆 &#123;url&#125;\n(无标题)&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 竞速执行多个任务</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">race_all</span>&lt;T&gt;(futures: <span class="type">Vec</span>&lt;<span class="keyword">impl</span> <span class="title class_">Future</span>&lt;Output = T&gt;&gt;) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> (result, _, remaining) = futures::future::<span class="title function_ invoke__">select_all</span>(futures).<span class="keyword">await</span>;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页面标题</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">page_title</span>(url: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="type">str</span>, <span class="type">Option</span>&lt;<span class="type">String</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = trpl::<span class="title function_ invoke__">get</span>(url).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = response.<span class="title function_ invoke__">text</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">title</span> = Html::<span class="title function_ invoke__">parse</span>(&amp;text)</span><br><span class="line">        .<span class="title function_ invoke__">select_first</span>(<span class="string">&quot;title&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|el| el.<span class="title function_ invoke__">inner_html</span>());</span><br><span class="line">    (url, title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 最佳实践</strong></p>
<ol>
<li><p><strong>最小化 <code>.await</code> 范围</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 不佳：持有锁跨await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">process</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="title function_ invoke__">io_operation</span>().<span class="keyword">await</span>; <span class="comment">// 危险！持有锁等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：限制锁范围</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">process</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = mutex.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        lock.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">io_operation</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">fallible</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="title function_ invoke__">fetch_data</span>().<span class="keyword">await</span>?; <span class="comment">// 传播错误</span></span><br><span class="line">    <span class="title function_ invoke__">process</span>(data).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>资源清理</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ResourceGuard</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">ResourceGuard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;资源已释放&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">use_resource</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_guard</span> = ResourceGuard;</span><br><span class="line">    <span class="title function_ invoke__">async_op</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125; <span class="comment">// guard自动drop</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>7. 生态工具</strong></p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">推荐库</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">异步运行时</td>
<td align="left">Tokio, async-std</td>
<td align="left">任务执行与调度</td>
</tr>
<tr>
<td align="left">Future工具集</td>
<td align="left">futures, futures-lite</td>
<td align="left">组合器与工具函数</td>
</tr>
<tr>
<td align="left">异步I&#x2F;O</td>
<td align="left">tokio::net, async-net</td>
<td align="left">TCP&#x2F;UDP&#x2F;Unix域套接字</td>
</tr>
<tr>
<td align="left">定时器</td>
<td align="left">tokio::time</td>
<td align="left">延时与超时</td>
</tr>
<tr>
<td align="left">同步原语</td>
<td align="left">tokio::sync</td>
<td align="left">异步互斥锁、信号量等</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>核心优势总结</strong>：</p>
<ol>
<li><strong>零成本抽象</strong>：编译为高效状态机，无运行时开销</li>
<li><strong>无畏并发</strong>：借用检查器保证内存安全</li>
<li><strong>无缝集成</strong>：<code>async</code>&#x2F;<code>.await</code> 语法类似同步代码</li>
<li><strong>精细控制</strong>：可选择最适合的运行时（嵌入式到服务器）</li>
<li><strong>生态系统</strong>：成熟工具链支持各种应用场景</li>
</ol>
</blockquote>
<p>通过掌握 <code>Future</code> 和 <code>async/await</code>，你可以在 Rust 中构建高性能、安全的异步应用，从嵌入式系统到分布式服务都能胜任。</p>
<hr>
<h3 id="Rust-异步并发编程"><a href="#Rust-异步并发编程" class="headerlink" title="Rust 异步并发编程"></a>Rust 异步并发编程</h3><p><strong>1. 异步任务基础</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并运行异步任务</span></span><br><span class="line">trpl::<span class="title function_ invoke__">run</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 启动新任务</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = trpl::<span class="title function_ invoke__">spawn_task</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;任务1: &#123;i&#125;&quot;</span>);</span><br><span class="line">            trpl::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>)).<span class="keyword">await</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主任务</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;主任务: &#123;i&#125;&quot;</span>);</span><br><span class="line">        trpl::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>)).<span class="keyword">await</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务完成</span></span><br><span class="line">    handle.<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>2. 并发执行模式</strong></p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">实现方式</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>顺序执行</strong></td>
<td align="left">直接<code>.await</code></td>
<td align="left">无并发，顺序执行</td>
</tr>
<tr>
<td align="left"><strong>任务分离</strong></td>
<td align="left"><code>spawn_task</code> + <code>handle.await</code></td>
<td align="left">后台执行，可等待结果</td>
</tr>
<tr>
<td align="left"><strong>公平并发</strong></td>
<td align="left"><code>trpl::join!</code></td>
<td align="left">任务交替执行（公平调度）</td>
</tr>
<tr>
<td align="left"><strong>竞速执行</strong></td>
<td align="left"><code>trpl::race!</code></td>
<td align="left">返回最先完成的结果</td>
</tr>
</tbody></table>
<p><strong>3. 异步消息传递</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx) = trpl::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送任务 (必须move所有权!)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">sender</span> = <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">msg</span> <span class="keyword">in</span> [<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;from&quot;</span>, <span class="string">&quot;async&quot;</span>] &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(msg).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        trpl::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>)).<span class="keyword">await</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收任务</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">receiver</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(msg) = rx.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;收到: &#123;msg&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发执行</span></span><br><span class="line">trpl::join!(sender, receiver).<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4. 多生产者模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (tx, <span class="keyword">mut</span> rx) = trpl::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">producer1</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="string">&quot;生产者1&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        trpl::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">300</span>)).<span class="keyword">await</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者2</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">producer2</span> = <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(<span class="string">&quot;生产者2&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    trpl::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">500</span>)).<span class="keyword">await</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">consumer</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(msg) = rx.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;消费: &#123;msg&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理多个任务</span></span><br><span class="line">trpl::join!(producer1, producer2, consumer).<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>

<p><strong>5. 关键注意事项</strong></p>
<ol>
<li><p><strong>所有权移动</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确：使用move转移所有权</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(data).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// tx被移动进闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>信道关闭</strong>：</p>
<ul>
<li>当所有发送端被<strong>丢弃</strong>时接收端自动关闭</li>
<li>使用<code>while let Some(value) = rx.recv().await</code>处理关闭</li>
</ul>
</li>
<li><p><strong>任务退出</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保任务能正常退出</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">task</span> = <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">    <span class="comment">// ...工作...</span></span><br><span class="line">&#125;; <span class="comment">// 任务结束时tx自动丢弃</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多任务管理</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用join宏处理任意数量任务</span></span><br><span class="line">trpl::join!(</span><br><span class="line">    <span class="title function_ invoke__">task1</span>(),</span><br><span class="line">    <span class="title function_ invoke__">task2</span>(),</span><br><span class="line">    <span class="title function_ invoke__">task3</span>()</span><br><span class="line">).<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>6. 线程与异步对比</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">线程</th>
<th align="left">异步任务</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>创建开销</strong></td>
<td align="left">高（MB级）</td>
<td align="left">极低（KB级）</td>
</tr>
<tr>
<td align="left"><strong>切换成本</strong></td>
<td align="left">高（微秒级）</td>
<td align="left">低（纳秒级）</td>
</tr>
<tr>
<td align="left"><strong>调度方式</strong></td>
<td align="left">抢占式</td>
<td align="left">协作式</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">固定栈大小</td>
<td align="left">动态增长</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">CPU密集型</td>
<td align="left">I&#x2F;O密集型</td>
</tr>
<tr>
<td align="left"><strong>并发数量</strong></td>
<td align="left">数百~数千</td>
<td align="left">数万~百万</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>最小化阻塞</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 避免在异步代码中使用同步阻塞</span></span><br><span class="line">std::thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 使用异步睡眠</span></span><br><span class="line">trpl::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>任务拆分</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将长任务分解为多个await点</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">long_task</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">part1</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="title function_ invoke__">part2</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="title function_ invoke__">part3</span>().<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用?传播错误</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">fallible_task</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="title function_ invoke__">fetch_data</span>().<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">process</span>(data).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>核心要点</strong>：</p>
<ol>
<li>异步任务通过<strong>状态机</strong>实现，开销远低于线程</li>
<li>使用<code>async move</code>确保资源的正确释放</li>
<li><code>join!</code>宏是管理多个并发任务的首选工具</li>
<li>消息传递是任务间通信的安全模式</li>
<li>Rust的异步模型特别适合高并发I&#x2F;O应用</li>
</ol>
</blockquote>
<hr>
<h3 id="Rust-异步-Future-管理"><a href="#Rust-异步-Future-管理" class="headerlink" title="Rust 异步 Future 管理"></a>Rust 异步 Future 管理</h3><p><strong>1. 管理任意数量 Futures</strong></p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">解决方案</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>固定数量异构 Futures</strong></td>
<td align="left"><code>join!</code> 宏</td>
<td align="left">编译时已知数量，类型可不同</td>
</tr>
<tr>
<td align="left"><strong>动态数量同构 Futures</strong></td>
<td align="left"><code>join_all</code> + <code>Vec&lt;Future&gt;</code></td>
<td align="left">运行时动态数量，类型必须相同</td>
</tr>
<tr>
<td align="left"><strong>动态数量异构 Futures</strong></td>
<td align="left"><code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code></td>
<td align="left">需要堆分配，支持不同类型</td>
</tr>
</tbody></table>
<p><strong>2. 实现动态数量异构 Futures</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> futures::future::&#123;join_all, Future&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1: Box + Pin (堆分配)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">futures</span>: <span class="type">Vec</span>&lt;Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Future&lt;Output = ()&gt;&gt;&gt;&gt; = <span class="built_in">vec!</span>[</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="title function_ invoke__">task1</span>()),</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="title function_ invoke__">task2</span>()),</span><br><span class="line">];</span><br><span class="line"><span class="title function_ invoke__">join_all</span>(futures).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2: pin! 宏 (栈分配)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">task1</span> = pin!(<span class="keyword">async</span> &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">task2</span> = pin!(<span class="keyword">async</span> &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">futures</span>: <span class="type">Vec</span>&lt;Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> Future&lt;Output = ()&gt;&gt;&gt; = <span class="built_in">vec!</span>[task1, task2];</span><br><span class="line"><span class="title function_ invoke__">join_all</span>(futures).<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3. Future 竞速模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 race 获取首个完成结果</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = trpl::<span class="title function_ invoke__">race</span>(<span class="title function_ invoke__">slow_task</span>(), <span class="title function_ invoke__">fast_task</span>()).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 select! 处理多个竞速任务</span></span><br><span class="line">tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">    res = task1 =&gt; <span class="title function_ invoke__">handle1</span>(res),</span><br><span class="line">    res = task2 =&gt; <span class="title function_ invoke__">handle2</span>(res),</span><br><span class="line">    _ = tokio::time::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>)) =&gt; <span class="title function_ invoke__">timeout</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 协作式调度关键点</strong></p>
<ol>
<li><p><strong>主动让出控制权</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">cpu_intensive</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">part1</span>(); <span class="comment">// 无await计算</span></span><br><span class="line">    tokio::task::<span class="title function_ invoke__">yield_now</span>().<span class="keyword">await</span>; <span class="comment">// 主动让出</span></span><br><span class="line">    <span class="title function_ invoke__">part2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能对比</strong>：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">适用场景</th>
<th align="left">性能开销</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>yield_now()</code></td>
<td align="left">细粒度控制</td>
<td align="left">极低 (纳秒级)</td>
</tr>
<tr>
<td align="left"><code>sleep(1ms)</code></td>
<td align="left">定时让出</td>
<td align="left">较高 (毫秒级)</td>
</tr>
</tbody></table>
</li>
</ol>
<p><strong>5. 构建超时抽象</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">timeout</span>&lt;F: Future&gt;(</span><br><span class="line">    future: F,</span><br><span class="line">    duration: Duration,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;F::Output, Duration&gt; &#123;</span><br><span class="line">    tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">        res = future =&gt; <span class="title function_ invoke__">Ok</span>(res),</span><br><span class="line">        _ = tokio::time::<span class="title function_ invoke__">sleep</span>(duration) =&gt; <span class="title function_ invoke__">Err</span>(duration),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">timeout</span>(<span class="title function_ invoke__">slow_operation</span>(), Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>)).<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(result) =&gt; <span class="comment">/* 成功 */</span>,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="comment">/* 超时处理 */</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 高级 Future 处理</strong></p>
<ol>
<li><p><strong>顺序执行 Futures</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">for</span> <span class="variable">fut</span> <span class="keyword">in</span> futures &#123;</span><br><span class="line">    results.<span class="title function_ invoke__">push</span>(fut.<span class="keyword">await</span>); <span class="comment">// 顺序执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FuturesUnordered</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> futures::stream::FuturesUnordered;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">set</span> = FuturesUnordered::<span class="title function_ invoke__">new</span>();</span><br><span class="line">set.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">task1</span>());</span><br><span class="line">set.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">task2</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(res) = set.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="comment">// 处理完成的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>类型选择原则</strong>：</p>
<ul>
<li>固定数量 → <code>join!</code></li>
<li>同类型动态集 → <code>join_all</code></li>
<li>混合类型动态集 → <code>FuturesUnordered</code> + trait 对象</li>
</ul>
</li>
<li><p><strong>协作式调度</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在长循环中定期让出</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100_000</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span> &#123;</span><br><span class="line">        tokio::task::<span class="title function_ invoke__">yield_now</span>().<span class="keyword">await</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>超时集成</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合重试逻辑</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">with_retries</span>&lt;F, T&gt;(<span class="keyword">mut</span> op: F, max_retries: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;T, Error&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnMut</span>() <span class="punctuation">-&gt;</span> Future&lt;Output = <span class="type">Result</span>&lt;T, Error&gt;&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..max_retries &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="title function_ invoke__">timeout</span>(<span class="title function_ invoke__">op</span>(), Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>)).<span class="keyword">await</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Ok</span>(result)) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(result),</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Err</span>(e)) =&gt; <span class="title function_ invoke__">log_error</span>(e),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="title function_ invoke__">log_timeout</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(Error::MaxRetriesExceeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>核心洞察</strong>：</p>
<ol>
<li>Rust 异步模型基于<strong>协作式调度</strong>，需要开发者主动添加 yield 点</li>
<li><code>Pin</code> 机制确保 Future 内存安全，是处理异构 Future 集合的基础</li>
<li>组合简单 Future 可以构建强大抽象（如超时、重试）</li>
<li>根据场景选择合适并发结构（<code>join_all</code> vs <code>FuturesUnordered</code>）</li>
</ol>
</blockquote>
<hr>
<h3 id="流（Streams）快速入门"><a href="#流（Streams）快速入门" class="headerlink" title="流（Streams）快速入门"></a>流（Streams）快速入门</h3><p>流（Streams）是异步编程中处理<strong>顺序产生的值序列</strong>的核心工具，类似于同步编程中的迭代器（Iterator）。以下是关键概念和用法：</p>
<p><strong>核心概念</strong></p>
<ol>
<li><strong>流 vs 迭代器</strong>：<ul>
<li>迭代器：同步产生值（<code>next()</code> 阻塞）</li>
<li>流：异步产生值（<code>next().await</code> 非阻塞）</li>
</ul>
</li>
<li><strong>核心 Trait</strong>：<ul>
<li><code>Stream</code>：基础 trait（定义异步行为）</li>
<li><code>StreamExt</code>：扩展方法（提供 <code>next()</code>, <code>filter()</code>, <code>map()</code> 等实用功能）</li>
</ul>
</li>
</ol>
<p><strong>基础用法</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> trpl::StreamExt; <span class="comment">// 必须引入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从同步迭代器创建流</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">values</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stream</span> = trpl::<span class="title function_ invoke__">stream_from_iter</span>(values.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|n| n * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = stream.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Value: &#123;&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Value: 2, Value: 4, Value: 6</span></span><br></pre></td></tr></table></figure>

<p><strong>流操作示例</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤流</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">filtered</span> = stream.<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射流</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">mapped</span> = stream.<span class="title function_ invoke__">map</span>(|x| <span class="built_in">format!</span>(<span class="string">&quot;ID-&#123;x&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并流 (交叉输出)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">merged</span> = stream1.<span class="title function_ invoke__">merge</span>(stream2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限流 (控制频率)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">throttled</span> = stream.<span class="title function_ invoke__">throttle</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时处理</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">with_timeout</span> = stream.<span class="title function_ invoke__">timeout</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p><strong>实战模式</strong></p>
<p><strong>场景：合并消息流 + 间隔计数器</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> trpl::StreamExt;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">messages</span> = <span class="title function_ invoke__">get_message_stream</span>();       <span class="comment">// 自定义消息流</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">intervals</span> = <span class="title function_ invoke__">get_interval_stream</span>()     <span class="comment">// 每毫秒计数</span></span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|count| <span class="built_in">format!</span>(<span class="string">&quot;Interval &#123;count&#125;&quot;</span>))</span><br><span class="line">    .<span class="title function_ invoke__">throttle</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>)); <span class="comment">// 限流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">merged</span> = messages</span><br><span class="line">    .<span class="title function_ invoke__">timeout</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">200</span>))  <span class="comment">// 消息超时</span></span><br><span class="line">    .<span class="title function_ invoke__">merge</span>(intervals)                     <span class="comment">// 合并流</span></span><br><span class="line">    .<span class="title function_ invoke__">take</span>(<span class="number">10</span>);                            <span class="comment">// 限制10个元素</span></span><br><span class="line"></span><br><span class="line">pin!(merged); <span class="comment">// 固定流到内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = merged.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> item &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(msg) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;msg&#125;&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;Timeout!&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键技巧</strong></p>
<ol>
<li><p><strong>错误处理</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端处理错误</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = tx.<span class="title function_ invoke__">send</span>(<span class="string">&quot;data&quot;</span>).<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;Send failed: &#123;e&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>资源清理</strong>：</p>
<ul>
<li>无限流需包含退出条件</li>
<li>使用 <code>take(n)</code> 限制元素数量</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>使用 <code>throttle</code> 避免过度轮询</li>
<li>优先选择有界（bounded）信道</li>
</ul>
</li>
</ol>
<p><strong>常见陷阱解决方案</strong></p>
<table>
<thead>
<tr>
<th align="left">问题</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">缺少 <code>next()</code> 方法</td>
<td align="left">引入 <code>use trpl::StreamExt</code></td>
</tr>
<tr>
<td align="left">流未固定（pin）</td>
<td align="left">使用 <code>pin!(stream)</code> 宏</td>
</tr>
<tr>
<td align="left">任务阻塞主线程</td>
<td align="left">用 <code>spawn_task</code> 生成后台任务</td>
</tr>
<tr>
<td align="left">流元素类型不匹配</td>
<td align="left">用 <code>map</code> 统一类型</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>最佳实践</strong>：流适用于</p>
<ul>
<li>实时消息处理（聊天&#x2F;通知）</li>
<li>大文件分块读取</li>
<li>传感器数据流</li>
<li>限速API请求</li>
</ul>
</blockquote>
<p>通过组合 <code>filter</code>, <code>map</code>, <code>merge</code>, <code>timeout</code> 等操作，可以构建高效的异步数据处理管道，兼顾响应性与资源效率。</p>
<hr>
<h3 id="深入理解-Async-Traits-核心概念"><a href="#深入理解-Async-Traits-核心概念" class="headerlink" title="深入理解 Async Traits 核心概念"></a>深入理解 Async Traits 核心概念</h3><p>以下是异步编程关键 traits 的精炼总结，帮助您快速掌握核心机制：</p>
<p><strong>1. Future Trait 核心机制</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Poll</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ready</span>(T),</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>核心原理</strong>：<ul>
<li><code>await</code> 编译为对 <code>poll()</code> 的调用</li>
<li>运行时轮询 future：<ul>
<li><code>Ready</code> → 执行后续操作</li>
<li><code>Pending</code> → 挂起任务，稍后重试</li>
</ul>
</li>
</ul>
</li>
<li><strong>状态机</strong>：异步代码块编译为包含多个状态的状态机</li>
<li><strong>运行时角色</strong>：协调任务调度，避免忙等待</li>
</ul>
<p><strong>2. Pin&#x2F;Unpin 内存安全机制</strong></p>
<ul>
<li><p><strong>问题根源</strong>：自引用类型（常见于异步状态机）</p>
</li>
<li><p><strong>解决方案</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">fut</span> = <span class="keyword">async</span> &#123; <span class="comment">/* 自引用结构 */</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pinned</span> = pin!(fut); <span class="comment">// 固定内存位置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>关键区别</strong>：</p>
<table>
<thead>
<tr>
<th align="left">Trait</th>
<th align="left">安全移动</th>
<th align="left">典型用例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Unpin</code></td>
<td align="left">✅</td>
<td align="left">基本类型、标准集合</td>
</tr>
<tr>
<td align="left"><code>!Unpin</code></td>
<td align="left">❌</td>
<td align="left">编译器生成的异步 future</td>
</tr>
</tbody></table>
</li>
<li><p><strong>实践要点</strong>：</p>
<ul>
<li>遇到 “cannot be unpinned” 错误时：<ol>
<li>使用 <code>pin!()</code> 宏固定栈上 future</li>
<li>或使用 <code>Box::pin()</code> 固定堆上 future</li>
</ol>
</li>
<li><code>poll()</code> 要求 <code>Pin&lt;&amp;mut Self&gt;</code> 参数确保安全</li>
</ul>
</li>
</ul>
<p><strong>3. Stream Trait 异步序列</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Stream</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll_next</span>(</span><br><span class="line">        <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, </span><br><span class="line">        cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> Poll&lt;<span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>双重特性</strong>：</p>
<ul>
<li>序列性（类似 <code>Iterator</code>）</li>
<li>异步性（类似 <code>Future</code>）</li>
</ul>
</li>
<li><p><strong>生态实践</strong>：</p>
<ul>
<li><p>基础 trait：定义核心行为</p>
</li>
<li><p><code>StreamExt</code>：提供高级 API</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须引入作用域</span></span><br><span class="line"><span class="keyword">use</span> futures::stream::StreamExt; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = stream.<span class="title function_ invoke__">next</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="comment">// 处理项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>关键实践指南</strong></p>
<ol>
<li><p><strong>Future 处理原则</strong>：</p>
<ul>
<li>直接 <code>await</code> 时自动处理 pinning</li>
<li>存储或传递 future 时需显式固定</li>
<li>避免在 <code>Ready</code> 后再次轮询</li>
</ul>
</li>
<li><p><strong>Stream 组合模式</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">messages</span><br><span class="line">    .<span class="title function_ invoke__">timeout</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">200</span>))  <span class="comment">// 超时控制</span></span><br><span class="line">    .<span class="title function_ invoke__">merge</span>(intervals.<span class="title function_ invoke__">throttle</span>(<span class="number">100</span>.<span class="title function_ invoke__">millis</span>())) <span class="comment">// 合并+限流</span></span><br><span class="line">    .<span class="title function_ invoke__">take</span>(<span class="number">20</span>) <span class="comment">// 数量限制</span></span><br><span class="line">    .for_each(|item| <span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> item &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(msg) =&gt; <span class="title function_ invoke__">process</span>(msg),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="title function_ invoke__">log_timeout</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">await</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理要点</strong>：</p>
<ul>
<li><p>信道操作需处理 <code>SendError</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = tx.<span class="title function_ invoke__">send</span>(data).<span class="keyword">await</span> &#123;</span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;Send failed: &#123;e&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>超时操作返回 <code>Result</code></p>
</li>
</ul>
</li>
</ol>
<p><strong>常见问题速查表</strong></p>
<table>
<thead>
<tr>
<th align="left">问题现象</th>
<th align="left">解决方案</th>
<th align="left">根本原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left">缺少 <code>next()</code> 方法</td>
<td align="left">引入 <code>StreamExt</code></td>
<td align="left">Trait 未在作用域</td>
</tr>
<tr>
<td align="left">“cannot be unpinned”</td>
<td align="left">使用 <code>pin!()</code> 或 <code>Box::pin()</code></td>
<td align="left">自引用 future 需固定</td>
</tr>
<tr>
<td align="left">流合并类型错误</td>
<td align="left">用 <code>map()</code> 统一元素类型</td>
<td align="left">流元素类型不兼容</td>
</tr>
<tr>
<td align="left">任务阻塞主线程</td>
<td align="left">使用 <code>spawn_task</code></td>
<td align="left">未正确生成后台任务</td>
</tr>
</tbody></table>
<p><strong>进阶理解提示</strong></p>
<ol>
<li><p><strong>运行时机制</strong>：</p>
<ul>
<li><code>Context</code> 参数携带 <code>Waker</code> 用于唤醒任务</li>
<li>高效调度是运行时的核心职责</li>
</ul>
</li>
<li><p><strong>状态机优化</strong>：</p>
<ul>
<li>编译器生成最优状态转移逻辑</li>
<li>每个 <code>await</code> 点对应状态机的一个状态</li>
</ul>
</li>
<li><p><strong>Pin 本质</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Pin</span>&lt;P&gt; &#123;</span><br><span class="line">    pointer: P, <span class="comment">// 必须是 Deref 目标不可移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不是智能指针，而是约束指针使用的保证器</li>
<li>通过类型系统保证内存稳定性</li>
</ul>
</li>
</ol>
<p>掌握这些核心概念后，您将能：</p>
<ul>
<li>高效诊断异步编程中的编译错误</li>
<li>理解运行时底层工作机制</li>
<li>安全构建复杂的异步工作流</li>
<li>合理选择流处理组合模式</li>
</ul>
<hr>
<h3 id="线程、任务与-Future-协同"><a href="#线程、任务与-Future-协同" class="headerlink" title="线程、任务与 Future 协同"></a>线程、任务与 Future 协同</h3><p><strong>核心模型对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>系统线程</strong></th>
<th align="left"><strong>异步任务</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">创建开销</td>
<td align="left">高 (MB级内存)</td>
<td align="left">极低 (KB级内存)</td>
</tr>
<tr>
<td align="left">切换成本</td>
<td align="left">高 (内核切换)</td>
<td align="left">低 (用户态切换)</td>
</tr>
<tr>
<td align="left">并发粒度</td>
<td align="left">线程级</td>
<td align="left">Future级</td>
</tr>
<tr>
<td align="left">取消支持</td>
<td align="left">无原生机制</td>
<td align="left">通过Drop清理</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">CPU密集型计算</td>
<td align="left">I&#x2F;O密集型高并发</td>
</tr>
</tbody></table>
<p><strong>最佳实践组合</strong></p>
<ol>
<li><strong>分层架构模式</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU密集型任务 → 线程</span></span><br><span class="line">std::thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">cpu_intensive_work</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结果传递给异步系统</span></span><br><span class="line">    async_channel.<span class="title function_ invoke__">send</span>(result).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// I/O密集型任务 → 异步</span></span><br><span class="line">trpl::<span class="title function_ invoke__">run</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(data) = async_channel.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_io</span>(data).<span class="keyword">await</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>阻塞操作专用接口</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将阻塞调用封装为异步接口</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">async_blocking_call</span>() <span class="punctuation">-&gt;</span> Data &#123;</span><br><span class="line">    trpl::<span class="title function_ invoke__">spawn_blocking</span>(|| <span class="title function_ invoke__">blocking_io</span>()).<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择策略</strong></p>
<ul>
<li><strong>优先选择线程</strong>：<ul>
<li>视频编码&#x2F;解码</li>
<li>科学计算</li>
<li>密码学操作</li>
</ul>
</li>
<li><strong>优先选择异步任务</strong>：<ul>
<li>Web服务器</li>
<li>实时消息系统</li>
<li>高频I&#x2F;O操作</li>
</ul>
</li>
</ul>
<p><strong>混合架构优势</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[网络请求] --&gt; B(异步前端)</span><br><span class="line">B --&gt; C&#123;任务类型&#125;</span><br><span class="line">C --&gt;|CPU密集型| D[线程池]</span><br><span class="line">C --&gt;|I/O密集型| E[任务调度器]</span><br><span class="line">D --&gt; F[结果聚合]</span><br><span class="line">E --&gt; F</span><br><span class="line">F --&gt; G[响应客户端]</span><br></pre></td></tr></table></figure>

<p><strong>性能陷阱规避</strong></p>
<ol>
<li><strong>绝对避免</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误！阻塞异步运行时</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">deadlock</span>() &#123;</span><br><span class="line">    std::thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>正确替代</strong>：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步休眠（释放线程）</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">proper_delay</span>() &#123;</span><br><span class="line">    trpl::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或转移至阻塞池</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">blocking_work</span>() &#123;</span><br><span class="line">    trpl::<span class="title function_ invoke__">spawn_blocking</span>(|| &#123;</span><br><span class="line">        std::thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;).<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>黄金法则</strong></p>
<blockquote>
<p>“线程处理计算重量，任务处理并发流量”</p>
<ul>
<li>CPU瓶颈 → 扩展线程池</li>
<li>I&#x2F;O瓶颈 → 优化任务调度</li>
<li>混合负载 → 线程处理CPU + 任务管理I&#x2F;O</li>
</ul>
</blockquote>
<hr>
<hr>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="Rust-面向对象特征"><a href="#Rust-面向对象特征" class="headerlink" title="Rust 面向对象特征"></a>Rust 面向对象特征</h3><p><strong>1. 对象：数据与行为的结合</strong></p>
<ul>
<li><p><strong>Rust 实现</strong>：结构体&#x2F;枚举（数据） + <code>impl</code> 块（方法）</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AveragedCollection</span> &#123;</span><br><span class="line">    list: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;,        <span class="comment">// 私有数据</span></span><br><span class="line">    average: <span class="type">f64</span>,          <span class="comment">// 私有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">AveragedCollection</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">i32</span>) &#123; <span class="comment">// 公有方法</span></span><br><span class="line">        <span class="keyword">self</span>.list.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">update_average</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update_average</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;     <span class="comment">// 私有方法</span></span><br><span class="line">        <span class="comment">// 实现细节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 封装：隐藏实现细节</strong></p>
<ul>
<li><strong>访问控制</strong>：<ul>
<li><code>pub</code>：公有接口</li>
<li>默认私有（模块级可见性）</li>
</ul>
</li>
<li><strong>优势</strong>：<ul>
<li>修改内部实现不影响外部代码</li>
<li>强制通过定义良好的接口交互</li>
</ul>
</li>
</ul>
<p><strong>3. 继承的替代方案</strong></p>
<table>
<thead>
<tr>
<th align="left">继承目的</th>
<th align="left">Rust 解决方案</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">代码复用</td>
<td align="left">Trait 默认方法</td>
<td align="left"><code>trait Summary &#123; fn summarize(&amp;self) -&gt; String &#123; String::from(&quot;(Read more...)&quot;) &#125; &#125;</code></td>
</tr>
<tr>
<td align="left">多态（类型替换）</td>
<td align="left">Trait 对象 &#x2F; 泛型约束</td>
<td align="left"><code>fn notify(item: &amp;impl Summary)</code></td>
</tr>
</tbody></table>
<p><strong>4. 多态实现对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>机制</strong></th>
<th align="left"><strong>特点</strong></th>
<th align="left"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">泛型 + Trait约束</td>
<td align="left">编译时多态，零运行时开销</td>
<td align="left">性能关键代码</td>
</tr>
<tr>
<td align="left">Trait 对象</td>
<td align="left">运行时多态，动态分发</td>
<td align="left">异构集合处理</td>
</tr>
</tbody></table>
<p><strong>Rust 面向对象设计原则</strong></p>
<ol>
<li><p><strong>组合优于继承</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Engine</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    engine: Engine,  <span class="comment">// 组合而非继承</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显式接口契约</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>权责分离</strong>：</p>
<ul>
<li>数据存储 → 结构体&#x2F;枚举</li>
<li>行为定义 → Trait + impl 块</li>
</ul>
</li>
</ol>
<p><strong>与传统 OOP 语言关键区别</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left">Java&#x2F;C#</th>
<th align="left">Rust</th>
</tr>
</thead>
<tbody><tr>
<td align="left">继承</td>
<td align="left">类继承</td>
<td align="left">Trait 实现</td>
</tr>
<tr>
<td align="left">多态</td>
<td align="left">父类引用</td>
<td align="left">Trait 对象&#x2F;泛型</td>
</tr>
<tr>
<td align="left">封装</td>
<td align="left">private 修饰符</td>
<td align="left">模块系统 + pub 控制</td>
</tr>
<tr>
<td align="left">构造函数</td>
<td align="left">特殊方法</td>
<td align="left">关联函数 <code>new()</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>核心结论</strong>：Rust 通过独特方式满足面向对象核心需求（封装、多态），同时避免传统继承的缺陷，提供更灵活的代码复用机制。</p>
</blockquote>
<hr>
<h3 id="Rust-Trait-对象"><a href="#Rust-Trait-对象" class="headerlink" title="Rust Trait 对象"></a>Rust Trait 对象</h3><p><strong>核心概念</strong></p>
<ol>
<li><p><strong>问题场景</strong>：处理不同类型值的集合（如 GUI 组件）</p>
</li>
<li><p><strong>解决方案</strong>：Trait 对象 (<code>dyn Trait</code>)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;, <span class="comment">// 存储任意实现 Draw 的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>关键机制</strong></p>
<ol>
<li><p><strong>动态分发</strong>：</p>
<ul>
<li>运行时通过虚表(vtable)查找方法</li>
<li>允许处理编译时未知的类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> &amp;<span class="keyword">self</span>.components &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>(); <span class="comment">// 动态调用具体实现</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型安全保证</strong>：</p>
<ul>
<li>编译器验证所有类型实现目标 trait</li>
<li>无效类型导致编译错误：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `String: Draw` is not satisfied</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>实现示例</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义公共接口</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按钮组件</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123; <span class="comment">/* 按钮绘制逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户自定义组件</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    options: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123; <span class="comment">/* 选择框绘制逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">screen</span> = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(SelectBox &#123; <span class="comment">/* 配置 */</span> &#125;),</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Button &#123; <span class="comment">/* 配置 */</span> &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line">    screen.<span class="title function_ invoke__">run</span>(); <span class="comment">// 统一调用所有组件的 draw()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能特点</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>静态分发 (泛型)</strong></th>
<th align="left"><strong>动态分发 (Trait对象)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">编译时成本</td>
<td align="left">高 (单态化生成多份代码)</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">运行时性能</td>
<td align="left">高 (无额外开销)</td>
<td align="left">中 (虚表查找)</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">大</td>
<td align="left">小</td>
</tr>
<tr>
<td align="left">扩展性</td>
<td align="left">有限 (需编译时已知类型)</td>
<td align="left">强 (运行时添加新类型)</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>处理异构集合</li>
<li>需要运行时扩展类型系统</li>
<li>插件化架构</li>
</ul>
</li>
<li><p><strong>替代方案选择</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同质集合使用泛型 (性能优先)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span>&lt;T: Draw&gt; &#123;</span><br><span class="line">    components: <span class="type">Vec</span>&lt;T&gt;, <span class="comment">// 所有元素同类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>核心价值</strong>：Trait对象在保持类型安全的前提下，提供类似动态语言的鸭子类型(duck typing)能力，实现”关注行为而非具体类型”的设计哲学。</p>
</blockquote>
<hr>
<h3 id="Rust-状态模式实现精要"><a href="#Rust-状态模式实现精要" class="headerlink" title="Rust 状态模式实现精要"></a>Rust 状态模式实现精要</h3><p><strong>方法一：经典状态模式（面向对象风格）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    state: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;&gt;,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">content</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, post: &amp;<span class="symbol">&#x27;a</span> Post) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123; <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态实现</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Draft</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">Draft</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123; </span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PendingReview) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// approve() 保持默认</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PendingReview</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">PendingReview</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123; </span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Published) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// request_review() 保持默认</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Published</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">Published</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">content</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, post: &amp;<span class="symbol">&#x27;a</span> Post) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        &amp;post.content</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转换方法保持默认</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post 方法实现</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Post &#123; state: <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Draft)), content: <span class="type">String</span>::<span class="title function_ invoke__">new</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_text</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, text: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">push_str</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">request_review</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="title function_ invoke__">Some</span>(s.<span class="title function_ invoke__">request_review</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">content</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.state.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">content</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>使用 <code>Box&lt;dyn State&gt;</code> 存储状态对象</li>
<li>状态转换逻辑封装在各状态实现中</li>
<li>添加新状态需修改现有状态转换代码</li>
<li>运行时状态检查</li>
</ul>
<p><strong>方法二：类型状态模式（Rust特色方案）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 草稿状态</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">DraftPost</span> &#123; content: <span class="type">String</span> &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">DraftPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_text</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, text: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">push_str</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> PendingReviewPost &#123;</span><br><span class="line">        PendingReviewPost &#123; content: <span class="keyword">self</span>.content &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 审核状态</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PendingReviewPost</span> &#123; content: <span class="type">String</span> &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PendingReviewPost</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Post &#123;</span><br><span class="line">        Post &#123; content: <span class="keyword">self</span>.content &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布状态</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123; content: <span class="type">String</span> &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> DraftPost &#123;</span><br><span class="line">        DraftPost &#123; content: <span class="type">String</span>::<span class="title function_ invoke__">new</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">content</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>状态编码为不同类型</li>
<li>编译时保证状态转换有效性</li>
<li>无效操作导致编译错误</li>
<li>状态转换消费原实例返回新类型</li>
<li>添加新状态无需修改现有代码</li>
</ul>
<p><strong>两种方案对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left">经典状态模式</th>
<th align="left">类型状态模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">状态表示</td>
<td align="left">Trait对象</td>
<td align="left">结构体类型</td>
</tr>
<tr>
<td align="left">状态转换检查</td>
<td align="left">运行时</td>
<td align="left">编译时</td>
</tr>
<tr>
<td align="left">无效操作处理</td>
<td align="left">运行时逻辑控制</td>
<td align="left">编译错误</td>
</tr>
<tr>
<td align="left">扩展性</td>
<td align="left">修改现有状态</td>
<td align="left">添加新类型</td>
</tr>
<tr>
<td align="left">代码重复</td>
<td align="left">状态转换方法有重复</td>
<td align="left">无重复</td>
</tr>
<tr>
<td align="left">Rust特色利用</td>
<td align="left">较少</td>
<td align="left">充分（类型系统&#x2F;所有权）</td>
</tr>
</tbody></table>
<p><strong>使用示例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型状态模式用法</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">draft</span> = Post::<span class="title function_ invoke__">new</span>();</span><br><span class="line">draft.<span class="title function_ invoke__">add_text</span>(<span class="string">&quot;Hello Rust&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pending</span> = draft.<span class="title function_ invoke__">request_review</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">published</span> = pending.<span class="title function_ invoke__">approve</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, published.<span class="title function_ invoke__">content</span>());</span><br></pre></td></tr></table></figure>

<p><strong>优势总结</strong>：</p>
<ul>
<li>类型状态模式将工作流编码进类型系统</li>
<li>完全消除无效状态转换可能性</li>
<li>获得编译时安全保障</li>
<li>更符合Rust所有权哲学</li>
</ul>
<blockquote>
<p>类型状态模式通过编译时保证取代运行时检查，使无效状态成为不可能，是Rust中状态管理的推荐实践。</p>
</blockquote>
<hr>
<hr>
<h2 id="模式与模式匹配"><a href="#模式与模式匹配" class="headerlink" title="模式与模式匹配"></a>模式与模式匹配</h2><p><strong>模式</strong>（<em>Patterns</em>）是 Rust 中一种特殊的语法，它用来匹配类型的结构，无论类型是简单还是复杂。结合使用模式和 <code>match</code> 表达式以及其他结构可以提供更多对程序控制流的支配权。模式由如下一些内容组合而成：</p>
<ul>
<li>字面值</li>
<li>已解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
<hr>
<h3 id="Rust-模式匹配位置精要"><a href="#Rust-模式匹配位置精要" class="headerlink" title="Rust 模式匹配位置精要"></a>Rust 模式匹配位置精要</h3><p><strong>核心使用场景</strong></p>
<ol>
<li><p><strong><code>match</code> 分支</strong>：</p>
<ul>
<li><p>必须穷尽所有可能值</p>
</li>
<li><p>基本结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> value &#123;</span><br><span class="line">    Pattern1 =&gt; expr1,</span><br><span class="line">    Pattern2 =&gt; expr2,</span><br><span class="line">    _ =&gt; default_expr,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>if let</code> 表达式</strong>：</p>
<ul>
<li><p>单分支匹配的简洁语法</p>
</li>
<li><p>可链式组合：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Pattern1</span> = value &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Pattern2</span> = value &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>while let</code> 循环</strong>：</p>
<ul>
<li><p>持续执行直到模式不匹配</p>
</li>
<li><p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(value) = receiver.<span class="title function_ invoke__">recv</span>() &#123;</span><br><span class="line">    <span class="comment">// 处理value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>for</code> 循环</strong>：</p>
<ul>
<li><p>迭代时解构元素：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用index和value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>let</code> 绑定</strong>：</p>
<ul>
<li><p>本质是模式匹配：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y, z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 元组解构</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">Point</span> &#123; x, y &#125; = point; <span class="comment">// 结构体解构</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>函数参数</strong>：</p>
<ul>
<li><p>参数本身是模式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_coords</span>(&amp;(x, y): &amp;(<span class="type">i32</span>, <span class="type">i32</span>)) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;(&#123;x&#125;, &#123;y&#125;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>模式特性对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>上下文</strong></th>
<th align="left">必须不可反驳</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>let</code> 绑定</td>
<td align="left">✓</td>
<td align="left"><code>let x = 5;</code></td>
</tr>
<tr>
<td align="left">函数参数</td>
<td align="left">✓</td>
<td align="left"><code>fn foo(x: i32)</code></td>
</tr>
<tr>
<td align="left"><code>for</code> 循环</td>
<td align="left">✓</td>
<td align="left"><code>for pat in iter</code></td>
</tr>
<tr>
<td align="left"><code>if let</code></td>
<td align="left">✗ (可反驳)</td>
<td align="left"><code>if let Some(x)=val</code></td>
</tr>
<tr>
<td align="left"><code>while let</code></td>
<td align="left">✗ (可反驳)</td>
<td align="left"><code>while let Ok(x)=res</code></td>
</tr>
<tr>
<td align="left"><code>match</code> 分支</td>
<td align="left">✗ (可反驳)</td>
<td align="left"><code>Some(x) =&gt; ...</code></td>
</tr>
</tbody></table>
<p><strong>关键概念</strong></p>
<ol>
<li><strong>不可反驳模式</strong>：<ul>
<li>总是匹配成功的模式（如变量绑定）</li>
<li>用于<code>let</code>、函数参数等位置</li>
</ul>
</li>
<li><strong>可反驳模式</strong>：<ul>
<li>可能匹配失败的模式（如<code>Some(x)</code>）</li>
<li>用于条件判断上下文</li>
</ul>
</li>
</ol>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>优先选择<code>match</code></strong>：</p>
<ul>
<li>当需要穷尽性检查时</li>
<li>处理多个可能状态</li>
</ul>
</li>
<li><p><strong>简洁场景用<code>if let</code></strong>：</p>
<ul>
<li>只关心单一模式匹配时</li>
<li>替代单分支<code>match</code></li>
</ul>
</li>
<li><p><strong>解构复杂数据</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数解构</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_point</span>(Point &#123; x, y &#125;: Point) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;x&#125;, y: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let绑定解构</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">Point</span> &#123; x: a, y: b &#125; = Point &#123; x: <span class="number">3</span>, y: <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>模式匹配的本质</strong>：Rust中几乎所有绑定操作都是模式匹配，这是语言的核心抽象机制，提供了强大的值解构和条件处理能力。</p>
</blockquote>
<hr>
<h3 id="Rust-模式可反驳性精要"><a href="#Rust-模式可反驳性精要" class="headerlink" title="Rust 模式可反驳性精要"></a>Rust 模式可反驳性精要</h3><p><strong>核心概念</strong></p>
<ol>
<li><p><strong>不可反驳模式</strong>：</p>
<ul>
<li><p>总是匹配成功</p>
</li>
<li><p>用于必须成功的上下文：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;            <span class="comment">// ✓</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(y: <span class="type">i32</span>) &#123;&#125;     <span class="comment">// ✓</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">z</span> <span class="keyword">in</span> iter &#123;&#125;      <span class="comment">// ✓</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>可反驳模式</strong>：</p>
<ul>
<li><p>可能匹配失败</p>
</li>
<li><p>用于条件处理：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = val &#123;&#125;  <span class="comment">// ✓</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Ok</span>(x) = res &#123;&#125; <span class="comment">// ✓</span></span><br><span class="line"><span class="keyword">match</span> opt &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) =&gt; ...,    <span class="comment">// ✓</span></span><br><span class="line">    <span class="literal">None</span> =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>错误场景与修复</strong></p>
<ol>
<li><p><strong>错误：在<code>let</code>中使用可反驳模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option; <span class="comment">// ❌ 编译错误</span></span><br></pre></td></tr></table></figure>

<p><strong>修复方案</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option &#123;  <span class="comment">// ✓</span></span><br><span class="line">    <span class="comment">// 处理Some情况</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理None情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>警告：在<code>if let</code>中使用不可反驳模式</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span> &#123;  <span class="comment">// ⚠️ 编译器警告</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修复方案</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;      <span class="comment">// ✓ 直接绑定</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>规则总结</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>上下文</strong></th>
<th align="left">要求模式类型</th>
<th align="left">错误示例</th>
<th align="left">正确用法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>let</code>绑定</td>
<td align="left">不可反驳</td>
<td align="left"><code>let Some(x)=opt;</code></td>
<td align="left"><code>if let Some(x)=opt</code></td>
</tr>
<tr>
<td align="left">函数参数</td>
<td align="left">不可反驳</td>
<td align="left"><code>fn f(Some(x):Option)</code></td>
<td align="left">使用<code>match</code>内部处理</td>
</tr>
<tr>
<td align="left"><code>for</code>循环</td>
<td align="left">不可反驳</td>
<td align="left"><code>for Some(x) in iter</code></td>
<td align="left">迭代后使用<code>if let</code></td>
</tr>
<tr>
<td align="left"><code>if let</code>&#x2F;<code>while let</code></td>
<td align="left">可反驳</td>
<td align="left"><code>if let x=5 &#123;&#125;</code></td>
<td align="left"><code>let x=5;</code></td>
</tr>
<tr>
<td align="left"><code>match</code>分支</td>
<td align="left">可反驳*</td>
<td align="left">-</td>
<td align="left">最后分支用不可反驳模式</td>
</tr>
</tbody></table>
<blockquote>
<p>* <code>match</code>的最后一个分支通常使用不可反驳模式（如<code>_</code>）确保穷尽匹配</p>
</blockquote>
<p><strong>设计意义</strong></p>
<ol>
<li><strong>安全性</strong>：防止在保证成功的上下文中出现匹配失败</li>
<li><strong>意图清晰</strong>：<ul>
<li>不可反驳模式：确定性的值绑定</li>
<li>可反驳模式：条件性逻辑处理</li>
</ul>
</li>
<li><strong>编译器辅助</strong>：通过错误&#x2F;警告引导正确模式使用</li>
</ol>
<blockquote>
<p><strong>关键原则</strong>：当需要绝对成功时用不可反驳模式，处理可能失败时用可反驳模式，编译器会严格检查确保正确性。</p>
</blockquote>
<hr>
<h3 id="Rust-模式语法精要"><a href="#Rust-模式语法精要" class="headerlink" title="Rust 模式语法精要"></a>Rust 模式语法精要</h3><p><strong>基础匹配模式</strong></p>
<ol>
<li><p><strong>字面值匹配</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="string">&quot;one&quot;</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="string">&quot;two&quot;</span>,</span><br><span class="line">    _ =&gt; <span class="string">&quot;other&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命名变量匹配</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;ID: &#123;id&#125;&quot;</span>),</span><br><span class="line">    <span class="comment">// 注意变量遮蔽问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多模式匹配</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="string">&quot;one or two&quot;</span>,</span><br><span class="line">    <span class="number">3</span>..=<span class="number">5</span> =&gt; <span class="string">&quot;three to five&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>解构复杂类型</strong></p>
<ol>
<li><p><strong>结构体解构</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">Point</span> &#123; x, y &#125; = point;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>枚举解构</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Quit =&gt; <span class="comment">/*...*/</span>,</span><br><span class="line">    Message::Move &#123; x, y &#125; =&gt; <span class="comment">/*...*/</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>嵌套解构</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; <span class="comment">/*...*/</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>忽略值技巧</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>语法</strong></th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>_</code></td>
<td align="left">忽略单个值</td>
<td align="left"><code>let (x, _, z) = (1, 2, 3);</code></td>
</tr>
<tr>
<td align="left"><code>_var</code></td>
<td align="left">忽略未使用变量</td>
<td align="left"><code>let _unused = 5;</code></td>
</tr>
<tr>
<td align="left"><code>..</code></td>
<td align="left">忽略多个值</td>
<td align="left"><code>let (first, .., last) = tuple;</code></td>
</tr>
<tr>
<td align="left">字段级 <code>_</code></td>
<td align="left">解构时忽略特定字段</td>
<td align="left"><code>Point &#123; x, .. &#125; = point;</code></td>
</tr>
</tbody></table>
<p><strong>高级匹配特性</strong></p>
<ol>
<li><p><strong>匹配守卫</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> num &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &gt; <span class="number">10</span> =&gt; <span class="string">&quot;&gt;10&quot;</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="string">&quot;&lt;=10&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@绑定</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> msg &#123;</span><br><span class="line">    Message::Hello &#123; id: id_var @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;ID: &#123;id_var&#125;&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>模式使用规则</strong></p>
<ol>
<li><p><strong>可反驳性规则</strong>：</p>
<ul>
<li><code>let</code>&#x2F;函数参数：必须不可反驳</li>
<li><code>if let</code>&#x2F;<code>while let</code>：可接受可反驳模式</li>
</ul>
</li>
<li><p><strong>穷尽性检查</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> value &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(_) =&gt; <span class="comment">/*...*/</span>,</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="comment">/*...*/</span>,    <span class="comment">// 必须覆盖所有情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>实战技巧</strong></p>
<ol>
<li><p><strong>解构时重命名</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">Point</span> &#123; x: coord_x, y: coord_y &#125; = point;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>匹配守卫优先级</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> x &#123;</span><br><span class="line">    <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> <span class="keyword">if</span> y =&gt; <span class="comment">/*...*/</span>,  <span class="comment">// 等价于 (4|5|6) if y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元组解构</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ((feet, inches), Point &#123; x, y &#125;) = ((<span class="number">3</span>, <span class="number">10</span>), Point &#123; x: <span class="number">3</span>, y: -<span class="number">10</span> &#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>模式匹配本质</strong>：Rust的模式系统是强大的解构工具，结合编译时检查，可安全处理各种数据结构。掌握不同场景下的模式语法，能写出更简洁安全的代码。</p>
</blockquote>
<hr>
<hr>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><ul>
<li>不安全 Rust：用于当需要舍弃 Rust 的某些保证并负责手动维持这些保证</li>
<li>高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法（fully qualified syntax），超（父）trait（supertraits）模式 newtype 模式</li>
<li>高级类型：关于 newtype 模式的更多内容，类型别名，never 类型和动态大小类型</li>
<li>高级函数和闭包：函数指针和返回闭包</li>
<li>宏：定义在编译时定义更多代码的方式</li>
</ul>
<hr>
<h3 id="不安全-Rust"><a href="#不安全-Rust" class="headerlink" title="不安全 Rust"></a>不安全 Rust</h3><p><strong>核心概念</strong></p>
<ol>
<li><p><strong>不安全超能力</strong>：</p>
<ul>
<li>解引用裸指针 (<code>*const T</code>&#x2F;<code>*mut T</code>)</li>
<li>调用不安全函数 (<code>unsafe fn</code>)</li>
<li>访问&#x2F;修改可变静态变量 (<code>static mut</code>)</li>
<li>实现不安全 trait (<code>unsafe trait</code>)</li>
<li>访问联合体字段 (<code>union</code>)</li>
</ul>
</li>
<li><p><strong>安全抽象原则</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全接口封装不安全操作</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">safe_wrapper</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 不安全操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>关键操作详解</strong></p>
<ol>
<li><p><strong>裸指针操作</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;raw <span class="keyword">const</span> num;  <span class="comment">// 创建不可变裸指针</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;raw <span class="keyword">mut</span> num;    <span class="comment">// 创建可变裸指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *r1);  <span class="comment">// 解引用需要unsafe块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FFI 交互</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用C函数</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出Rust函数</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">rust_function</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可变静态变量</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">    <span class="comment">// SAFETY: 单线程访问保证</span></span><br><span class="line">    COUNTER += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>安全实践</strong></p>
<ol>
<li><p><strong>Miri 检测工具</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustup +nightly component add miri</span><br><span class="line">cargo +nightly miri <span class="built_in">test</span>  <span class="comment"># 检测未定义行为</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安全抽象模式</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全封装split_at_mut</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">safe_split</span>(slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>], mid: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> (&amp;<span class="keyword">mut</span> [<span class="type">i32</span>], &amp;<span class="keyword">mut</span> [<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (</span><br><span class="line">            std::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, mid),</span><br><span class="line">            std::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">add</span>(mid), len - mid),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>使用场景与原则</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>推荐方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">系统编程&#x2F;硬件交互</td>
<td align="left">受限使用裸指针</td>
</tr>
<tr>
<td align="left">C库交互</td>
<td align="left">精心设计FFI接口</td>
</tr>
<tr>
<td align="left">全局状态</td>
<td align="left">优先使用原子类型或Mutex</td>
</tr>
<tr>
<td align="left">高性能算法</td>
<td align="left">局部不安全代码+严格验证</td>
</tr>
<tr>
<td align="left">特殊内存布局</td>
<td align="left">union访问+安全封装</td>
</tr>
</tbody></table>
<p><strong>黄金法则</strong>：</p>
<ol>
<li>保持 <code>unsafe</code> 块最小化</li>
<li>每个不安全操作添加 <code>SAFETY</code> 注释</li>
<li>优先使用安全抽象封装</li>
<li>使用 Miri 验证内存安全</li>
<li>遵循 Rustonomicon 最佳实践</li>
</ol>
<blockquote>
<p>不安全 Rust 是系统编程的必要工具，但需严格遵循安全边界封装原则。通过精心设计的抽象层，可在享受底层控制力的同时保持系统整体安全性。</p>
</blockquote>
<hr>
<h3 id="Rust-高级-Trait"><a href="#Rust-高级-Trait" class="headerlink" title="Rust 高级 Trait"></a>Rust 高级 Trait</h3><p><strong>核心特性</strong></p>
<ol>
<li><p><strong>关联类型</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;  <span class="comment">// 占位类型</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;  <span class="comment">// 实现时指定具体类型</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优势</strong>：避免泛型重复标注，确保一个类型只实现一次trait</li>
</ul>
</li>
<li><p><strong>默认泛型参数</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;Rhs = <span class="keyword">Self</span>&gt; &#123;  <span class="comment">// 默认Rhs为Self</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Rhs) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>应用场景</strong>：运算符重载（如实现<code>+</code>）</li>
</ul>
</li>
</ol>
<p><strong>方法冲突解决</strong></p>
<ol>
<li><p><strong>同名方法调用</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">person.<span class="title function_ invoke__">fly</span>();            <span class="comment">// 默认调用Human自身方法</span></span><br><span class="line">Pilot::<span class="title function_ invoke__">fly</span>(&amp;person);     <span class="comment">// 明确调用trait方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>完全限定语法</strong>（静态方法必需）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Dog <span class="keyword">as</span> Animal&gt;::<span class="title function_ invoke__">baby_name</span>();  <span class="comment">// 明确指定trait实现</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>超trait依赖</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;  <span class="comment">// 要求实现Display</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();  <span class="comment">// 使用Display的方法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Newtype模式</strong></p>
<ul>
<li><p><strong>解决孤儿规则限制</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);  <span class="comment">// 包装外部类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;  <span class="comment">// 为包装类型实现外部trait</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))  <span class="comment">// 访问内部数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>关键技巧对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>解决方案</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义类型占位符</td>
<td align="left">关联类型</td>
<td align="left"><code>type Item;</code></td>
</tr>
<tr>
<td align="left">运算符重载</td>
<td align="left">默认泛型参数</td>
<td align="left"><code>impl Add&lt;Meters&gt; for Millimeters</code></td>
</tr>
<tr>
<td align="left">同名方法冲突</td>
<td align="left">显式指定trait</td>
<td align="left"><code>Pilot::fly(&amp;person)</code></td>
</tr>
<tr>
<td align="left">静态方法冲突</td>
<td align="left">完全限定语法</td>
<td align="left"><code>&lt;Dog as Animal&gt;::baby_name()</code></td>
</tr>
<tr>
<td align="left">绕过孤儿规则</td>
<td align="left">Newtype模式</td>
<td align="left"><code>struct MyVec(Vec&lt;i32&gt;)</code></td>
</tr>
<tr>
<td align="left">Trait依赖</td>
<td align="left">超trait</td>
<td align="left"><code>trait Sub: Super &#123; ... &#125;</code></td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>关联类型选择</strong>：</p>
<ul>
<li>需要单实现时用关联类型</li>
<li>需要多实现时用泛型</li>
</ul>
</li>
<li><p><strong>Newtype优化</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Deref</span> <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现<code>Deref</code>自动获得内部类型方法</li>
</ul>
</li>
<li><p><strong>运算符重载模式</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Point &#123; x: <span class="keyword">self</span>.x + other.x, y: <span class="keyword">self</span>.y + other.y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>高级trait特性使Rust类型系统更具表达力，特别适用于库开发。合理使用这些特性可以创建更符合人体工程学的API，同时保持类型安全。</p>
</blockquote>
<hr>
<h3 id="Rust-高级类型"><a href="#Rust-高级类型" class="headerlink" title="Rust 高级类型"></a>Rust 高级类型</h3><p><strong>1. Newtype 模式</strong></p>
<ul>
<li><p><strong>作用</strong>：创建轻量级封装类型，实现类型安全和抽象</p>
</li>
<li><p><strong>核心优势</strong>：</p>
<ul>
<li><strong>类型安全</strong>：防止值混淆（如区分 <code>Millimeters</code> 和 <code>Meters</code>）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>抽象实现</strong>：暴露与内部类型不同的 API</li>
<li><strong>封装隐藏</strong>：隐藏内部实现细节（如封装 <code>HashMap</code> 为 <code>People</code> 类型）</li>
</ul>
</li>
</ul>
<p><strong>2. 类型别名 (Type Aliases)</strong></p>
<ul>
<li><p><strong>语法</strong>：<code>type Alias = ExistingType;</code></p>
</li>
<li><p><strong>核心用途</strong>：</p>
<ul>
<li><strong>简化复杂类型</strong>：减少重复代码</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Thunk</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: Thunk = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>标准库实践</strong>：<code>std::io::Result&lt;T&gt;</code> 替代 <code>Result&lt;T, std::io::Error&gt;</code></li>
</ul>
</li>
<li><p><strong>注意</strong>：与 newtype 不同，<strong>不创建新类型</strong>（<code>Kilometers</code> 与 <code>i32</code> 完全兼容）</p>
</li>
</ul>
<p><strong>3. Never 类型 (<code>!</code>)</strong></p>
<ul>
<li><p><strong>特征</strong>：表示永不返回的函数（发散函数）</p>
</li>
<li><p><strong>核心场景</strong>：</p>
<ul>
<li>标记无限循环：<code>loop &#123; ... &#125;</code></li>
<li>程序终止：<code>panic!()</code></li>
<li>控制流操作：<code>continue</code> 和 <code>break</code></li>
</ul>
</li>
<li><p><strong>特殊能力</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> input.<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num) =&gt; num,        <span class="comment">// u32</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,    <span class="comment">// ! 可强制转为 u32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><strong>动态大小类型 (Dynamically Sized Types - DST)</strong></li>
</ol>
<ul>
<li><strong>黄金法则</strong>：必须通过指针使用（<code>&amp;str</code>、<code>Box&lt;dyn Trait&gt;</code> 等）</li>
<li><strong>常见 DST</strong>：<ul>
<li><code>str</code>：需通过 <code>&amp;str</code> 使用（携带地址+长度）</li>
<li>trait 对象：<code>dyn Trait</code></li>
</ul>
</li>
<li><strong><code>Sized</code> Trait</strong>：<ul>
<li>默认泛型约束：<code>fn generic&lt;T&gt;(t: T)</code> 隐含 <code>T: Sized</code></li>
<li>支持 DST：<code>fn generic&lt;T: ?Sized&gt;(t: &amp;T)</code></li>
</ul>
</li>
</ul>
<hr>
<p><strong>关键对比表</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">是否创建新类型</th>
<th align="left">典型应用场景</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Newtype</strong></td>
<td align="left">✅</td>
<td align="left">单位转换&#x2F;API 抽象</td>
<td align="left"><code>struct Meters(u32);</code></td>
</tr>
<tr>
<td align="left"><strong>类型别名</strong></td>
<td align="left">❌</td>
<td align="left">简化复杂类型签名</td>
<td align="left"><code>type Result&lt;T&gt; = ...;</code></td>
</tr>
<tr>
<td align="left"><strong><code>!</code> 类型</strong></td>
<td align="left">✅</td>
<td align="left">发散函数&#x2F;控制流</td>
<td align="left"><code>panic!()</code>, <code>continue</code></td>
</tr>
<tr>
<td align="left"><strong>DST</strong></td>
<td align="left">N&#x2F;A</td>
<td align="left">运行时确定大小的类型</td>
<td align="left"><code>&amp;str</code>, <code>Box&lt;dyn Trait&gt;</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>需要类型安全 → <strong>Newtype 模式</strong></li>
<li>减少复杂类型重复 → <strong>类型别名</strong></li>
<li>处理未知大小类型 → <strong>指针 + <code>?Sized</code></strong></li>
<li>标记永不返回 → <strong><code>!</code> 类型</strong></li>
</ul>
</blockquote>
<hr>
<h3 id="高级函数与闭包精要"><a href="#高级函数与闭包精要" class="headerlink" title="高级函数与闭包精要"></a>高级函数与闭包精要</h3><p><strong>1. 函数指针 (<code>fn</code> 类型)</strong></p>
<ul>
<li><p><strong>本质</strong>：指向函数的指针（非闭包 trait）</p>
</li>
<li><p><strong>核心用途</strong>：</p>
<ul>
<li>传递已定义的函数（替代闭包）</li>
<li>与不支持闭包的外部代码交互（如 C 语言）</li>
</ul>
</li>
<li><p><strong>语法示例</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>(f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>, arg: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(arg) + <span class="title function_ invoke__">f</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">answer</span> = <span class="title function_ invoke__">do_twice</span>(add_one, <span class="number">5</span>); <span class="comment">// 传递命名函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>特性</strong>：</p>
<ul>
<li><p>实现所有闭包 trait（<code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>）</p>
</li>
<li><p>可替代闭包用于标准库方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包方式</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|i| i.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针方式</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string);       <span class="comment">// trait 方法</span></span><br><span class="line">(<span class="number">0u32</span>..<span class="number">20</span>).<span class="title function_ invoke__">map</span>(Status::Value);                   <span class="comment">// 枚举构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>2. 返回闭包</strong></p>
<ul>
<li><p><strong>核心问题</strong>：闭包是 trait，不能直接返回具体类型</p>
</li>
<li><p><strong>解决方案</strong>：</p>
<ul>
<li><p><strong>单一种类闭包</strong>：使用 <code>impl Fn</code>（静态分发）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    |x| x + <span class="number">1</span>  <span class="comment">// 直接返回闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多种闭包类型</strong>：使用 <code>Box&lt;dyn Fn&gt;</code>（动态分发）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">custom_closure</span>(y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x + y)  <span class="comment">// 捕获环境变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>关键点</strong>：</p>
<ul>
<li><code>impl Fn</code> 为不同闭包生成<strong>独立的不透明类型</strong>，导致类型不兼容</li>
<li><code>Box&lt;dyn Fn&gt;</code> 通过 trait 对象统一类型（牺牲少量性能）</li>
</ul>
</li>
</ul>
<hr>
<p><strong>关键对比表</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">适用场景</th>
<th align="left">性能</th>
<th align="left">限制</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>函数指针 (<code>fn</code>)</strong></td>
<td align="left">传递已存在函数</td>
<td align="left">零开销</td>
<td align="left">不能捕获环境变量</td>
</tr>
<tr>
<td align="left"><strong><code>impl Fn</code></strong></td>
<td align="left">返回单一种类闭包</td>
<td align="left">静态分发</td>
<td align="left">不同类型不兼容</td>
</tr>
<tr>
<td align="left"><strong><code>Box&lt;dyn Fn&gt;</code></strong></td>
<td align="left">返回多种闭包&#x2F;捕获环境变量</td>
<td align="left">动态分发</td>
<td align="left">额外堆分配</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>优先使用 <code>impl Fn</code> 返回闭包（高效）</li>
<li>需要统一多种闭包类型时 → <code>Box&lt;dyn Fn&gt;</code></li>
<li>与外部代码交互 → 函数指针 (<code>fn</code>)</li>
</ul>
</blockquote>
<hr>
<h3 id="Rust-宏精要"><a href="#Rust-宏精要" class="headerlink" title="Rust 宏精要"></a>Rust 宏精要</h3><p><strong>1. 宏的本质与价值</strong></p>
<ul>
<li><strong>元编程</strong>：生成代码的代码，减少重复（如 <code>println!</code>, <code>vec!</code>）</li>
<li><strong>超越函数的能力</strong>：<ul>
<li>可变参数（如 <code>println!(&quot;&#123;&#125;&quot;, x)</code> 或 <code>println!(&quot;&#123;&#125; &#123;&#125;&quot;, x, y)</code>）</li>
<li>编译时展开（可在类型上实现 trait）</li>
</ul>
</li>
<li><strong>代价</strong>：定义更复杂，需先定义后调用</li>
</ul>
<p><strong>2. 声明宏（<code>macro_rules!</code>）</strong></p>
<ul>
<li><p><strong>模式匹配</strong>：类似 <code>match</code>，匹配代码结构</p>
</li>
<li><p><strong>经典案例</strong>：<code>vec!</code> 宏</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ($($x:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">temp_vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            $(temp_vec.<span class="title function_ invoke__">push</span>($x);)*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>关键语法</strong>：</p>
<ul>
<li><code>$(...),*</code>：重复捕获</li>
<li><code>$x:expr</code>：匹配表达式</li>
<li>展开时 <code>$x</code> 替换为实际值</li>
</ul>
</li>
</ul>
<p><strong>3. 过程宏（需专用 crate）</strong></p>
<ul>
<li><p><strong>三种类型</strong>：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">注解形式</th>
<th align="left">函数签名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">自定义派生宏</td>
<td align="left"><code>#[derive(HelloMacro)]</code></td>
<td align="left"><code>fn(TokenStream) -&gt; TokenStream</code></td>
</tr>
<tr>
<td align="left">类属性宏</td>
<td align="left"><code>#[route(GET, &quot;/&quot;)]</code></td>
<td align="left"><code>fn(TokenStream, TokenStream) -&gt; TokenStream</code></td>
</tr>
<tr>
<td align="left">类函数宏</td>
<td align="left"><code>sql!(SELECT ...)</code></td>
<td align="left"><code>fn(TokenStream) -&gt; TokenStream</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong>核心工具链</strong>：</p>
<ul>
<li><code>proc_macro</code>：Rust 内置（操作 token）</li>
<li><code>syn</code>：解析代码为语法树</li>
<li><code>quote</code>：生成 Rust 代码</li>
</ul>
</li>
</ul>
<p>3.1 <strong>自定义派生宏实战</strong></p>
<ul>
<li><p><strong>步骤</strong>：</p>
<ol>
<li><p>定义 trait（<code>hello_macro::HelloMacro</code>）</p>
</li>
<li><p>创建过程宏 crate（<code>hello_macro_derive</code>）</p>
</li>
<li><p>解析输入 → 生成实现代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ast</span> = syn::<span class="title function_ invoke__">parse</span>(input).<span class="title function_ invoke__">unwrap</span>();  <span class="comment">// 解析为语法树</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;ast.ident;                <span class="comment">// 获取类型名</span></span><br><span class="line">    quote! &#123;                              <span class="comment">// 生成代码</span></span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">HelloMacro</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello_macro</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, Macro! My name is &#123;&#125;!&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p>3.2 <strong>类属性宏 vs 类函数宏</strong></p>
<ul>
<li><p><strong>类属性宏</strong>：</p>
<ul>
<li>操作属性+被标记项</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="string">&quot;/&quot;</span>)]</span>  <span class="comment">// 属性内容: GET, &quot;/&quot;</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">index</span>() &#123;&#125;       <span class="comment">// 被标记项</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类函数宏</strong>：</p>
<ul>
<li>类似函数调用</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sql</span> = sql!(SELECT * FROM posts);  <span class="comment">// 操作括号内所有 token</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>宏类型对比表</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">定义方式</th>
<th align="left">典型用例</th>
<th align="left">灵活性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">声明宏</td>
<td align="left"><code>macro_rules!</code></td>
<td align="left"><code>vec!</code>, <code>println!</code></td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">自定义派生宏</td>
<td align="left"><code>#[proc_macro_derive]</code></td>
<td align="left"><code>#[derive(Serialize)]</code></td>
<td align="left">类型相关</td>
</tr>
<tr>
<td align="left">类属性宏</td>
<td align="left"><code>#[proc_macro_attribute]</code></td>
<td align="left">自定义注解</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">类函数宏</td>
<td align="left"><code>#[proc_macro]</code></td>
<td align="left"><code>sql!</code>, <code>html!</code></td>
<td align="left">极高</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>通用模板代码 → <strong>声明宏</strong></li>
<li>自动 trait 实现 → <strong>自定义派生宏</strong></li>
<li>自定义注解 → <strong>类属性宏</strong></li>
<li>领域特定语言(DSL) → <strong>类函数宏</strong></li>
</ul>
</blockquote>
<hr>
<hr>
<h2 id="构建多线程-web-server"><a href="#构建多线程-web-server" class="headerlink" title="构建多线程 web server"></a>构建多线程 web server</h2><p>实现一个返回 “hello” 的 web server</p>
<p>如下是构建 web server 的计划：</p>
<ol>
<li>学习一些 TCP 与 HTTP 知识</li>
<li>在套接字（socket）上监听 TCP 请求</li>
<li>解析少量的 HTTP 请求</li>
<li>创建一个合适的 HTTP 响应</li>
<li>通过线程池改善 server 的吞吐量</li>
</ol>
<hr>
<h3 id="单线程-Web-Server-精要"><a href="#单线程-Web-Server-精要" class="headerlink" title="单线程 Web Server 精要"></a>单线程 Web Server 精要</h3><p><strong>核心流程</strong></p>
<ol>
<li><p><strong>监听 TCP 连接</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:7878&quot;</span>)?;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stream</span> = stream?;</span><br><span class="line">    <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定本地端口 <code>7878</code>（”rust” 九宫格数字）</li>
<li><code>incoming()</code> 返回连接迭代器</li>
</ul>
</li>
<li><p><strong>处理 HTTP 请求</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">buf_reader</span> = BufReader::<span class="title function_ invoke__">new</span>(&amp;stream);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">request_line</span> = buf_reader.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">next</span>()??;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>路由与响应</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (status_line, filename) = <span class="keyword">match</span> request_line.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">    <span class="string">&quot;GET / HTTP/1.1&quot;</span> =&gt; (<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="string">&quot;hello.html&quot;</span>),</span><br><span class="line">    _ =&gt; (<span class="string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>, <span class="string">&quot;404.html&quot;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发送 HTTP 响应</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename)?;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">response</span> = <span class="built_in">format!</span>(</span><br><span class="line">    <span class="string">&quot;&#123;&#125;\r\nContent-Length: &#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">    status_line,</span><br><span class="line">    contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">    contents</span><br><span class="line">);</span><br><span class="line">stream.<span class="title function_ invoke__">write_all</span>(response.<span class="title function_ invoke__">as_bytes</span>())?;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>关键组件</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>组件</strong></th>
<th align="left"><strong>作用</strong></th>
<th align="left"><strong>核心类型&#x2F;函数</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">TCP 监听器</td>
<td align="left">接收客户端连接</td>
<td align="left"><code>TcpListener::bind()</code></td>
</tr>
<tr>
<td align="left">缓冲读取器</td>
<td align="left">高效读取请求数据</td>
<td align="left"><code>BufReader</code></td>
</tr>
<tr>
<td align="left">HTTP 请求解析</td>
<td align="left">提取请求行和头部</td>
<td align="left"><code>.lines()</code> + <code>take_while()</code></td>
</tr>
<tr>
<td align="left">路由分发</td>
<td align="left">根据路径返回不同响应</td>
<td align="left"><code>match</code> 模式匹配</td>
</tr>
<tr>
<td align="left">文件响应</td>
<td align="left">返回 HTML 内容</td>
<td align="left"><code>fs::read_to_string()</code></td>
</tr>
<tr>
<td align="left">响应格式化</td>
<td align="left">构建符合 HTTP 标准的响应</td>
<td align="left"><code>format!</code> 宏</td>
</tr>
</tbody></table>
<p><strong>文件结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project-root/</span><br><span class="line">├── src/</span><br><span class="line">│   └── main.rs         # 服务器实现</span><br><span class="line">├── hello.html          # 主页HTML</span><br><span class="line">├── 404.html            # 404错误页</span><br><span class="line">└── Cargo.toml</span><br></pre></td></tr></table></figure>

<p><strong>hello.html</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello from Rust!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>404.html</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 - Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>运行与测试</strong></p>
<ol>
<li><p>启动服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试请求：</p>
<ul>
<li>有效请求：<code>http://127.0.0.1:7878/</code></li>
<li>无效请求：<code>http://127.0.0.1:7878/unknown</code></li>
</ul>
</li>
<li><p>终端输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection established!  # 每次连接时打印</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>性能局限</strong></p>
<p>当前实现存在两个关键限制：</p>
<ol>
<li><strong>单线程处理</strong>：一次只能服务一个请求</li>
<li><strong>阻塞I&#x2F;O</strong>：文件读取时无法处理其他连接</li>
</ol>
<blockquote>
<p><strong>下一步优化</strong>：引入线程池实现并发处理（见后续章节）</p>
</blockquote>
<p><strong>核心代码精简版</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    fs,</span><br><span class="line">    io::&#123;BufRead, BufReader, Write&#125;,</span><br><span class="line">    net::&#123;TcpListener, TcpStream&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:7878&quot;</span>)?;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">handle_connection</span>(stream?)?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_connection</span>(<span class="keyword">mut</span> stream: TcpStream) <span class="punctuation">-&gt;</span> std::io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">buf_reader</span> = BufReader::<span class="title function_ invoke__">new</span>(&amp;stream);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">request_line</span> = buf_reader.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>()?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (status_line, filename) = <span class="keyword">match</span> request_line.<span class="title function_ invoke__">as_str</span>() &#123;</span><br><span class="line">        <span class="string">&quot;GET / HTTP/1.1&quot;</span> =&gt; (<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="string">&quot;hello.html&quot;</span>),</span><br><span class="line">        _ =&gt; (<span class="string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>, <span class="string">&quot;404.html&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="built_in">format!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;&#125;\r\nContent-Length: &#123;&#125;\r\n\r\n&#123;&#125;&quot;</span>,</span><br><span class="line">        status_line,</span><br><span class="line">        contents.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">        contents</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    stream.<span class="title function_ invoke__">write_all</span>(response.<span class="title function_ invoke__">as_bytes</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="多线程-Web-Server-：线程池实现"><a href="#多线程-Web-Server-：线程池实现" class="headerlink" title="多线程 Web Server ：线程池实现"></a>多线程 Web Server ：线程池实现</h3><p><strong>核心优化点</strong></p>
<ol>
<li><strong>单线程瓶颈</strong>：慢请求（如 <code>/sleep</code>）会阻塞后续请求</li>
<li><strong>线程池解决方案</strong>：<ul>
<li>固定数量工作线程（避免资源耗尽）</li>
<li>任务队列机制（信道传递任务）</li>
</ul>
</li>
</ol>
<p><strong>线程池架构</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,      <span class="comment">// 工作线程集合</span></span><br><span class="line">    sender: mpsc::Sender&lt;Job&gt;, <span class="comment">// 任务发送端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,                   <span class="comment">// 线程ID</span></span><br><span class="line">    thread: JoinHandle&lt;()&gt;,      <span class="comment">// 线程句柄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;; <span class="comment">// 任务类型（闭包）</span></span><br></pre></td></tr></table></figure>

<p><strong>关键实现步骤</strong></p>
<ol>
<li><p><strong>线程池初始化</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ThreadPool &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver)); <span class="comment">// 共享接收端</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">        workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ThreadPool &#123; workers, sender &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工作线程实现</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">// 获取任务（阻塞直到有任务）</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;id&#125; got a job&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">job</span>(); <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Worker &#123; id, thread &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>任务分发机制</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">    <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 发送任务到队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>主程序集成</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:7878&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(<span class="number">4</span>); <span class="comment">// 4线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        </span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(|| &#123; <span class="comment">// 提交任务到线程池</span></span><br><span class="line">            <span class="title function_ invoke__">handle_connection</span>(stream);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left">单线程Server</th>
<th align="left">多线程Server (线程池)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>请求&#x2F;sleep</strong></td>
<td align="left">后续请求阻塞5秒</td>
<td align="left">其他请求立即响应</td>
</tr>
<tr>
<td align="left"><strong>资源占用</strong></td>
<td align="left">每个请求新建线程</td>
<td align="left">固定4个线程处理所有请求</td>
</tr>
<tr>
<td align="left"><strong>抗压能力</strong></td>
<td align="left">易受DoS攻击</td>
<td align="left">稳定处理高并发</td>
</tr>
</tbody></table>
<p><strong>关键注意事项</strong></p>
<ol>
<li><p><strong>信道同步</strong>：</p>
<ul>
<li>使用 <code>Arc&lt;Mutex&lt;Receiver&gt;&gt;</code> 实现线程安全的任务分发</li>
<li>避免 <code>while let</code> 导致的锁持有时间过长问题</li>
</ul>
</li>
<li><p><strong>任务类型设计</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>FnOnce</code>: 任务只需执行一次</li>
<li><code>Send</code>: 允许跨线程传递</li>
<li><code>&#39;static</code>: 任务不引用短生命周期数据</li>
</ul>
</li>
<li><p><strong>错误处理</strong>：</p>
<ul>
<li><code>lock().unwrap()</code>: 互斥锁污染时panic</li>
<li><code>recv().unwrap()</code>: 发送端关闭时panic</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>生产级优化建议</strong>：</p>
<ul>
<li>使用 <code>thread::Builder</code> 替代 <code>spawn</code> 处理线程创建错误</li>
<li>实现优雅关闭（在第二十三章扩展）</li>
<li>添加任务超时机制</li>
</ul>
</blockquote>
<p><strong>完整线程池实现</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::&#123;mpsc, Arc, Mutex&#125;,</span><br><span class="line">    thread::&#123;<span class="keyword">self</span>, JoinHandle&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: mpsc::Sender&lt;Job&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(size &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">        &#125;</span><br><span class="line">        ThreadPool &#123; workers, sender &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">        <span class="keyword">self</span>.sender.<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: JoinHandle&lt;()&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="title function_ invoke__">job</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        Worker &#123; id, thread &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="优雅停机与清理"><a href="#优雅停机与清理" class="headerlink" title="优雅停机与清理"></a>优雅停机与清理</h3><p><strong>核心实现</strong></p>
<ol>
<li><p><strong>线程池改造</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: <span class="type">Option</span>&lt;mpsc::Sender&lt;Job&gt;&gt;, <span class="comment">// Option包装发送端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: <span class="type">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;, <span class="comment">// Option包装线程句柄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Drop 实现（关键）</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 关闭发送端（触发所有接收端错误）</span></span><br><span class="line">        <span class="title function_ invoke__">drop</span>(<span class="keyword">self</span>.sender.<span class="title function_ invoke__">take</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 等待所有工作线程结束</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">worker</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Shutting down worker &#123;&#125;&quot;</span>, worker.id);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 取出线程句柄并等待结束</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(thread) = worker.thread.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                thread.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工作线程改造</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> Worker &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">message</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">match</span> message &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(job) =&gt; <span class="title function_ invoke__">job</span>(), <span class="comment">// 正常执行任务</span></span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Worker &#123;id&#125; disconnected; shutting down.&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 信道关闭时退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        Worker &#123; id, thread: <span class="title function_ invoke__">Some</span>(thread) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>主程序控制</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:7878&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = ThreadPool::<span class="title function_ invoke__">new</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只处理两个请求后主动关闭</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">stream</span> <span class="keyword">in</span> listener.<span class="title function_ invoke__">incoming</span>().<span class="title function_ invoke__">take</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stream</span> = stream.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        pool.<span class="title function_ invoke__">execute</span>(|| <span class="title function_ invoke__">handle_connection</span>(stream));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Shutting down.&quot;</span>); <span class="comment">// 触发线程池drop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关机流程解析</strong></p>
<ol>
<li><p><strong>信号触发</strong>：</p>
<ul>
<li><code>drop(sender.take())</code> 关闭信道</li>
<li>所有工作线程的 <code>recv()</code> 立即返回 <code>Err</code></li>
</ul>
</li>
<li><p><strong>线程退出</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Worker <span class="number">3</span> disconnected; shutting down.  <span class="comment">// 工作线程收到错误</span></span><br><span class="line">Worker <span class="number">0</span> disconnected; shutting down.</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>等待结束</strong>：</p>
<ul>
<li>主线程调用 <code>thread.join().unwrap()</code> 等待每个工作线程</li>
<li>输出：<code>Shutting down worker 3</code></li>
</ul>
</li>
<li><p><strong>资源清理</strong>：</p>
<ul>
<li>所有线程安全退出</li>
<li>系统资源自动释放</li>
</ul>
</li>
</ol>
<p><strong>关键机制</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>组件</strong></th>
<th align="left"><strong>优雅停机作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Option&lt;T&gt;</code></td>
<td align="left">安全取出所有权（避免移动问题）</td>
</tr>
<tr>
<td align="left"><code>take()</code></td>
<td align="left">转移所有权同时置空原值</td>
</tr>
<tr>
<td align="left">信道关闭</td>
<td align="left">广播停机信号到所有工作线程</td>
</tr>
<tr>
<td align="left"><code>join()</code></td>
<td align="left">阻塞等待线程安全退出</td>
</tr>
<tr>
<td align="left">错误处理匹配</td>
<td align="left">区分正常任务和关机信号</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>生产级优化</strong>：</p>
<ul>
<li>添加超时机制：<code>thread.join().unwrap()</code> → <code>thread.join().unwrap_or_else(|_| log_error())</code></li>
<li>实现强制终止：<code>std::thread::park_timeout</code> 配合原子标志位</li>
<li>添加日志记录：替代 <code>println!</code></li>
</ul>
</blockquote>
<p><strong>完整线程池实现</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::&#123;mpsc, Arc, Mutex&#125;,</span><br><span class="line">    thread::&#123;<span class="keyword">self</span>, JoinHandle&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    workers: <span class="type">Vec</span>&lt;Worker&gt;,</span><br><span class="line">    sender: <span class="type">Option</span>&lt;mpsc::Sender&lt;Job&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Job</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(size: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(receiver));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">workers</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(size);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">id</span> <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">            workers.<span class="title function_ invoke__">push</span>(Worker::<span class="title function_ invoke__">new</span>(id, Arc::<span class="title function_ invoke__">clone</span>(&amp;receiver)));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ThreadPool &#123;</span><br><span class="line">            workers,</span><br><span class="line">            sender: <span class="title function_ invoke__">Some</span>(sender),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">execute</span>&lt;F&gt;(&amp;<span class="keyword">self</span>, f: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="title function_ invoke__">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">&#x27;static</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">job</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(f);</span><br><span class="line">        <span class="keyword">self</span>.sender.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">send</span>(job).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(<span class="keyword">self</span>.sender.<span class="title function_ invoke__">take</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> <span class="variable">worker</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.workers &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(thread) = worker.thread.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                thread.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    id: <span class="type">usize</span>,</span><br><span class="line">    thread: <span class="type">Option</span>&lt;JoinHandle&lt;()&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(id: <span class="type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">job</span> = receiver.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">recv</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">match</span> job &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(job) =&gt; <span class="title function_ invoke__">job</span>(),</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">break</span>, <span class="comment">// 信道关闭时退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        Worker &#123;</span><br><span class="line">            id,</span><br><span class="line">            thread: <span class="title function_ invoke__">Some</span>(thread),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-00.html#%E9%99%84%E5%BD%95">附录</a></h2><h3 id="附录-A：关键字"><a href="#附录-A：关键字" class="headerlink" title="附录 A：关键字"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-01-keywords.html#%E9%99%84%E5%BD%95-a%E5%85%B3%E9%94%AE%E5%AD%97">附录 A：关键字</a></h3><h3 id="附录-B：运算符与符号"><a href="#附录-B：运算符与符号" class="headerlink" title="附录 B：运算符与符号"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-02-operators.html#%E9%99%84%E5%BD%95-b%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%AC%A6%E5%8F%B7">附录 B：运算符与符号</a></h3><h3 id="附录-C：可派生的-trait"><a href="#附录-C：可派生的-trait" class="headerlink" title="附录 C：可派生的 trait"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-03-derivable-traits.html#%E9%99%84%E5%BD%95-c%E5%8F%AF%E6%B4%BE%E7%94%9F%E7%9A%84-trait">附录 C：可派生的 trait</a></h3><h3 id="附录-D：实用开发工具"><a href="#附录-D：实用开发工具" class="headerlink" title="附录 D：实用开发工具"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-04-useful-development-tools.html#%E9%99%84%E5%BD%95-d%E5%AE%9E%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">附录 D：实用开发工具</a></h3><h3 id="附录-E：版本"><a href="#附录-E：版本" class="headerlink" title="附录 E：版本"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-05-editions.html#%E9%99%84%E5%BD%95-e%E7%89%88%E6%9C%AC">附录 E：版本</a></h3><h3 id="附录-F：Rust-是如何开发的与-“Nightly-Rust”"><a href="#附录-F：Rust-是如何开发的与-“Nightly-Rust”" class="headerlink" title="附录 F：Rust 是如何开发的与 “Nightly Rust”"></a><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/appendix-07-nightly-rust.html#%E9%99%84%E5%BD%95-grust-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%8E-nightly-rust">附录 F：Rust 是如何开发的与 “Nightly Rust”</a></h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog2025.github.io/2025/05/29/Python/" rel="prev" title="Python">
                  <i class="fa fa-angle-left"></i> Python
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog2025.github.io/2025/06/26/C++/" rel="next" title="C++">
                  C++ <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    
    <!-- 去除心形图案
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    -->
    <span class="post-meta-divider">|</span>

    <span class="author" itemprop="copyrightHolder">lsdyun</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--隐藏网页底部powered by Hexo 强力驱动-->
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
<script src="/blog2025.github.io/js/comments.js"></script><script src="/blog2025.github.io/js/utils.js"></script><script src="/blog2025.github.io/js/motion.js"></script><script src="/blog2025.github.io/js/sidebar.js"></script><script src="/blog2025.github.io/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/blog2025.github.io/js/third-party/search/local-search.js"></script>




  <script src="/blog2025.github.io/js/third-party/fancybox.js"></script>

  <script src="/blog2025.github.io/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
