<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog2025.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog2025.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog2025.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog2025.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog2025.github.io/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lsdyun.github.io","root":"/blog2025.github.io/","images":"/blog2025.github.io/images","scheme":"Pisces","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog2025.github.io/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog2025.github.io/js/config.js"></script>

    <meta name="description" content="Nginxhttps:&#x2F;&#x2F;www.w3ccoo.com&#x2F;nginx&#x2F;default.html 开始Nignx：Web服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器 特点：占用内存少，并发能力强。">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx">
<meta property="og:url" content="https://lsdyun.github.io/blog2025.github.io/2025/07/31/Nginx/index.html">
<meta property="og:site_name" content="记录博客">
<meta property="og:description" content="Nginxhttps:&#x2F;&#x2F;www.w3ccoo.com&#x2F;nginx&#x2F;default.html 开始Nignx：Web服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器 特点：占用内存少，并发能力强。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200S111013OS.61HVKf9R.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200S11106455A.BaTMB0Iv.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200S1110H41L.vQB5hUaJ.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200S1111252930.DigbyJZf.gif">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/image-20250506101149244.png">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200Z11003131R.BeYZ-E3O.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200Z1142U23T.DRL08zOL.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200Z1143304418.BadwDGA0.gif">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/image-20250506124622632.png">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200Z3125643141.BeWm2lgY.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200Z3125G9523.CHVZkCT6.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200Z3150252264.D8eNiZEc.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z41A3095G.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z41A624934.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z41AK02T.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZG522312I.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200ZG61314U5.BDnD5CUT.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200ZG61340340.Cqb7uLLo.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200ZG61413K9.Bu9LEcNR.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200ZG61434247.BKfceQrh.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200ZG61454432.WUOQQGK0.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200ZG61513411.DT-ym0QX.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200ZGGS0R0.Ezom-1yk.gif">
<meta property="og:image" content="https://nginx.mosong.cc/assets/8-200ZP9350G45.Bu3JUOPM.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZQ13044937.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZQ13109228.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZZ91153130.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZZ91229195.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZZ91244125.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9131Q5338.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9131S43E.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9151011T8.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9150J6392.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9160411W7.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9163540624.gif">
<meta property="og:image" content="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z91F25X32.gif">
<meta property="article:published_time" content="2025-07-31T03:28:48.708Z">
<meta property="article:modified_time" content="2025-05-28T03:20:26.171Z">
<meta property="article:author" content="lsdyun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nginx.mosong.cc/assets/8-200S111013OS.61HVKf9R.gif">


<link rel="canonical" href="https://lsdyun.github.io/blog2025.github.io/2025/07/31/Nginx/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lsdyun.github.io/blog2025.github.io/2025/07/31/Nginx/","path":"2025/07/31/Nginx/","title":"Nginx"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Nginx | 记录博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/blog2025.github.io/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog2025.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">记录博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog2025.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog2025.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/blog2025.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/blog2025.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx"><span class="nav-number">1.</span> <span class="nav-text">Nginx</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B"><span class="nav-number">1.1.</span> <span class="nav-text">开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">架构：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">多进程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">主进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">工作进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%EF%BC%88%E8%BD%AF%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7%EF%BC%89"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">信号（软中断信号）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%91%E9%81%93"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">频道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">进程调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">事件驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.2.1.8.</span> <span class="nav-text">图示流程：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">工作流机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">HTTP 请求处理阶段（应用层）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-UDP-%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">TCP&#x2F;UDP 处理阶段（传输层）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%A4%BA%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">图示流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">1.2.3.</span> <span class="nav-text">模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">加载方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.4.</span> <span class="nav-text">安装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.</span> <span class="nav-text">Nginx配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.3.1.</span> <span class="nav-text">配置文件详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.2.</span> <span class="nav-text">进程配置指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">进程管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E4%BC%98"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">进程调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">进程调试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">事件处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%85%8D%E7%BD%AE%E6%A0%B7%E4%BE%8B"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">指令配置样例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC%EF%BC%88listen%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="nav-number">1.3.3.</span> <span class="nav-text">端口监听（listen指令）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#server-name-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%A7%B0"><span class="nav-number">1.3.4.</span> <span class="nav-text">server_name 配置主机名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82"><span class="nav-number">1.3.5.</span> <span class="nav-text">处理HTTP请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.3.6.</span> <span class="nav-text">路由匹配规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URI-%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">URI 匹配规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">匹配顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%B7%AF%E7%94%B1%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">访问路由指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.3.7.</span> <span class="nav-text">重定向配置详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">标准配置指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">脚本指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#root%E6%8C%87%E4%BB%A4%E6%A0%B9%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.8.</span> <span class="nav-text">root指令根目录配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alias-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.9.</span> <span class="nav-text">alias 访问路径别名指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try-files-%E6%96%87%E4%BB%B6%E5%88%A4%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.10.</span> <span class="nav-text">try_files 文件判断指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sendfile-%E9%9B%B6%E5%A4%8D%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.11.</span> <span class="nav-text">sendfile 零复制指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.12.</span> <span class="nav-text">日志记录配置指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">1.4.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E6%A8%A1%E5%9D%97"><span class="nav-number">1.4.1.</span> <span class="nav-text">镜像模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.4.2.</span> <span class="nav-text">内置配置指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97"><span class="nav-number">1.4.3.</span> <span class="nav-text">请求头控制模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9D%97"><span class="nav-number">1.4.4.</span> <span class="nav-text">IP访问控制模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7cookie%E6%A8%A1%E5%9D%97"><span class="nav-number">1.4.5.</span> <span class="nav-text">用户cookie模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%99%90%E5%88%B6%E6%A8%A1%E5%9D%97"><span class="nav-number">1.4.6.</span> <span class="nav-text">并发连接数限制模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A6%96%E9%A1%B5%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97"><span class="nav-number">1.4.7.</span> <span class="nav-text">首页处理模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%E6%A8%A1%E5%9D%97"><span class="nav-number">1.4.8.</span> <span class="nav-text">请求频率限制模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4%E9%85%8D%E7%BD%AE"><span class="nav-number">1.4.9.</span> <span class="nav-text">页面缓存时间配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E5%8E%8B%E7%BC%A9%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.4.10.</span> <span class="nav-text">开启压缩及相关配置详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web"><span class="nav-number">1.5.</span> <span class="nav-text">Web</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA"><span class="nav-number">1.5.1.</span> <span class="nav-text">静态资源服务器搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA"><span class="nav-number">1.5.2.</span> <span class="nav-text">文件下载服务器搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E5%8A%A8%E6%80%81SSI%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.5.3.</span> <span class="nav-text">伪动态SSI服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">配置指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSI-%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">SSI 命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%A0%B7%E4%BE%8B"><span class="nav-number">1.5.4.</span> <span class="nav-text">配置样例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA"><span class="nav-number">1.5.5.</span> <span class="nav-text">HTTPS服务器搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4-1"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">配置指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">HTTPS 基本配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">HTTPS 密钥交换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E4%BC%9A%E8%AF%9D%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.5.4.</span> <span class="nav-text">HTTPS 会话缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.5.5.</span> <span class="nav-text">HTTPS 双向认证配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E5%90%8A%E9%94%80%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.5.6.</span> <span class="nav-text">HTTPS 吊销证书配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E9%85%8D%E7%BD%AE%E6%A0%B7%E4%BE%8B"><span class="nav-number">1.5.5.7.</span> <span class="nav-text">HTTPS 配置样例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FastCGI%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E7%AE%80%E8%BF%B0"><span class="nav-number">1.5.6.</span> <span class="nav-text">FastCGI模块配置简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EFastCGI%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.5.7.</span> <span class="nav-text">基于FastCGI实现负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CGI%E3%80%81FastCGI%E3%80%81SCGI%E3%80%81WSGI%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="nav-number">1.5.8.</span> <span class="nav-text">CGI、FastCGI、SCGI、WSGI网关接口简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uWSGI%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E7%AE%80%E8%BF%B0"><span class="nav-number">1.5.9.</span> <span class="nav-text">uWSGI模块配置简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA"><span class="nav-number">1.5.10.</span> <span class="nav-text">伪流媒体服务器搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.10.1.</span> <span class="nav-text">模块配置指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%AA%E6%B5%81%E5%AA%92%E4%BD%93%E9%85%8D%E7%BD%AE%E6%A0%B7%E4%BE%8B"><span class="nav-number">1.5.10.2.</span> <span class="nav-text">伪流媒体配置样例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP2%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E7%AE%80%E8%BF%B0"><span class="nav-number">1.5.11.</span> <span class="nav-text">HTTP2模块配置简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebDAV%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E7%AE%80%E8%BF%B0"><span class="nav-number">1.5.12.</span> <span class="nav-text">WebDAV模块配置简述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text">代理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">HTTP代理服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">正向代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">模块指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86-1"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">正向代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">HTTP 的反向代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">HTTPS 的反向代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%AE%A2%E6%88%B7%E7%AB%AF-IP"><span class="nav-number">1.6.1.6.</span> <span class="nav-text">反向代理的真实客户端 IP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stream%E6%A8%A1%E5%9D%97%E7%AE%80%E8%BF%B0"><span class="nav-number">1.6.2.</span> <span class="nav-text">stream模块简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-UDP%E4%BB%A3%E7%90%86%E7%AE%80%E8%BF%B0"><span class="nav-number">1.6.3.</span> <span class="nav-text">TCP&#x2F;UDP代理简述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">核心配置指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E6%A0%B7%E4%BE%8B"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">TCP 反向代理配置样例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86-SSL-TCP"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">代理 SSL TCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">UDP 反向代理配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ESSL%E7%9A%84TCP%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.6.4.</span> <span class="nav-text">基于SSL的TCP代理服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gRPC%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.6.5.</span> <span class="nav-text">gRPC代理服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gRPC-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">gRPC 介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gRPC-%E6%A8%A1%E5%9D%97%E6%8C%87%E4%BB%A4"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">gRPC 模块指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gRPC-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE"><span class="nav-number">1.6.5.3.</span> <span class="nav-text">gRPC 反向代理配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">1.7.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.1.</span> <span class="nav-text">缓存配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">客户端缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">正向代理缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C%EF%BC%88CDN%EF%BC%89"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">内容分发网络（CDN）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">反向代理缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.2.</span> <span class="nav-text">代理缓存配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%8F%8A%E7%8A%B6%E6%80%81"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">缓存处理流程及状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">缓存配置指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">HTTP 范围请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memcached%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97"><span class="nav-number">1.7.3.</span> <span class="nav-text">Memcached缓存模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Memcached-%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">Memcached 缓存应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.4.</span> <span class="nav-text">反向代理缓存服务器配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6"><span class="nav-number">1.7.5.</span> <span class="nav-text">客户端缓存控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E6%95%88%E6%9C%9F%E9%AA%8C%E8%AF%81"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">有效期验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%AA%8C%E8%AF%81"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">服务端验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.8.</span> <span class="nav-text">负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A8%A1%E5%9D%97"><span class="nav-number">1.8.1.</span> <span class="nav-text">负载均衡模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">服务器配置指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E6%8C%87%E4%BB%A4"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">负载均衡策略指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="nav-number">1.8.2.</span> <span class="nav-text">负载均衡策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">轮询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">一致性哈希</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP-%E5%93%88%E5%B8%8C"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">IP 哈希</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%91%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">最少连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%B4%9F%E8%BD%BD%E7%AE%97%E6%B3%95"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">随机负载算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.8.3.</span> <span class="nav-text">长连接负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stream%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.8.4.</span> <span class="nav-text">stream容错机制详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0upstream"><span class="nav-number">1.8.5.</span> <span class="nav-text">动态更新upstream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-TCP-UDP-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.8.6.</span> <span class="nav-text">Stream(TCP&#x2F;UDP)负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-UDP-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">TCP&#x2F;UDP 负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-UDP-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6"><span class="nav-number">1.8.6.2.</span> <span class="nav-text">TCP&#x2F;UDP 负载均衡的容错机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">1.9.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%AE%80%E8%BF%B0"><span class="nav-number">1.9.1.</span> <span class="nav-text">日志分析简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="nav-number">1.9.2.</span> <span class="nav-text">访问日志配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AEerror-log"><span class="nav-number">1.9.3.</span> <span class="nav-text">错误日志配置error_log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%BD%92%E6%A1%A3%E9%85%8D%E7%BD%AE"><span class="nav-number">1.9.4.</span> <span class="nav-text">日志归档配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%88ELK%EF%BC%89%E9%85%8D%E7%BD%AE"><span class="nav-number">1.9.5.</span> <span class="nav-text">日志分析工具（ELK）配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ELK-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">ELK 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ELK-%E5%AE%89%E8%A3%85"><span class="nav-number">1.9.5.2.</span> <span class="nav-text">ELK 安装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE"><span class="nav-number">1.9.6.</span> <span class="nav-text">监控工具配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prometheus%E7%AE%80%E4%BB%8B"><span class="nav-number">1.9.6.1.</span> <span class="nav-text">Prometheus简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Prometheus%E9%83%A8%E7%BD%B2"><span class="nav-number">1.9.6.2.</span> <span class="nav-text">Prometheus部署</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7HTTP%E4%B8%BB%E6%9C%BA%E7%8A%B6%E6%80%81"><span class="nav-number">1.9.6.3.</span> <span class="nav-text">监控HTTP主机状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7TCP-UDP%E4%B8%BB%E6%9C%BA%E7%8A%B6%E6%80%81"><span class="nav-number">1.9.6.4.</span> <span class="nav-text">监控TCP&#x2F;UDP主机状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Prometheus%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6"><span class="nav-number">1.9.6.5.</span> <span class="nav-text">Prometheus监控告警</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4"><span class="nav-number">1.10.</span> <span class="nav-text">集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%99%9A%E6%8B%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">1.10.1.</span> <span class="nav-text">Linux虚拟服务器简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LVS%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">LVS术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LVS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">LVS工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LVS%E8%BD%AC%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">LVS转发模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="nav-number">1.10.1.4.</span> <span class="nav-text">LVS负载均衡算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPVS%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8ipvsadm"><span class="nav-number">1.10.1.5.</span> <span class="nav-text">IPVS的管理器ipvsadm</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keepalived%E9%85%8D%E7%BD%AE%E7%AE%80%E8%BF%B0"><span class="nav-number">1.10.2.</span> <span class="nav-text">Keepalived配置简述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Keepalived%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">Keepalived相关术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Keepalived%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">Keepalived的工作模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%A5%E5%BA%B7%E6%A3%80%E6%B5%8B"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">健康检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.10.2.4.</span> <span class="nav-text">配置关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E8%B4%9F%E8%BD%BD%EF%BC%88%E5%9F%BA%E4%BA%8ELVS%E5%92%8CKeepalived%EF%BC%89%E6%90%AD%E5%BB%BA"><span class="nav-number">1.10.3.</span> <span class="nav-text">集群负载（基于LVS和Keepalived）搭建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E8%A7%84%E5%88%92"><span class="nav-number">1.10.4.</span> <span class="nav-text">集群配置管理规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.10.4.1.</span> <span class="nav-text">配置目录结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%BD%92%E6%A1%A3"><span class="nav-number">1.10.4.2.</span> <span class="nav-text">配置归档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4"><span class="nav-number">1.10.4.3.</span> <span class="nav-text">配置变更</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%91%E5%B8%83"><span class="nav-number">1.10.4.4.</span> <span class="nav-text">配置发布</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GitLab%EF%BC%88%E9%85%8D%E7%BD%AE%E5%BD%92%E6%A1%A3%E5%B7%A5%E5%85%B7%EF%BC%89%E9%85%8D%E7%BD%AE"><span class="nav-number">1.10.5.</span> <span class="nav-text">GitLab（配置归档工具）配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%E5%B7%A5%E5%85%B7Ansible"><span class="nav-number">1.10.6.</span> <span class="nav-text">配置修改工具Ansible</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%80%E8%BF%B0"><span class="nav-number">1.10.7.</span> <span class="nav-text">Jenkins安装与配置简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.10.8.</span> <span class="nav-text">集群配置管理实例</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lsdyun"
      src="/blog2025.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">lsdyun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog2025.github.io/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog2025.github.io/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lsdyun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lsdyun" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lsdyun.github.io/blog2025.github.io/2025/07/31/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog2025.github.io/images/avatar.png">
      <meta itemprop="name" content="lsdyun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Nginx | 记录博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Nginx
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-31 11:28:48" itemprop="dateCreated datePublished" datetime="2025-07-31T11:28:48+08:00">2025-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-28 11:20:26" itemprop="dateModified" datetime="2025-05-28T11:20:26+08:00">2025-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog2025.github.io/categories/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


		<!--  设置置顶图标  -->
		        
		<!--  设置置顶图标  -->
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><a target="_blank" rel="noopener" href="https://nginx.mosong.cc/guide/">Nginx</a></h1><p><strong><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/default.html">https://www.w3ccoo.com/nginx/default.html</a></strong></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>Nignx：Web服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器</p>
<p>特点：占用内存少，并发能力强。</p>
<p>版本：Nginx 开源版、Nginx Plus 商业版</p>
<ul>
<li>国内流行版本：<ul>
<li>Tengine项目（淘宝网）</li>
<li>OpenResty项目</li>
</ul>
</li>
</ul>
<p>功能：访问代理、负载均衡、内容缓冲、访问安全及带宽控制等。</p>
<p>实现目标：将访问入口和 Web 服务器分离，将 Web 服务器和动态脚本解析器分开，将 Web 功能不断拆分、微服务等。</p>
<p>应用特性：</p>
<ul>
<li><p>开源版：</p>
<ul>
<li><p>访问路由</p>
<p>Nginx 可以通过访问路径、URL 关键字、客户端 IP、灰度分流等多种手段实现访问路由分配。</p>
</li>
<li><p><strong>反向代理</strong></p>
<p>Nginx 本身并不产生响应数据，只是应用自身的异步非阻塞<strong>事件驱动</strong>架构，高效、稳定地将请求反向代理给后端的目标应用服务器，并把响应数据返回给客户端。支持大部分协议的反向代理。</p>
</li>
<li><p>负载均衡</p>
<p>Nginx 在反向代理的基础上集合自身的上游（<strong>upstream</strong>）模块支持多种负载均衡算法，使后端服务器可以非常方便地进行横向扩展，从而有效提升应用的处理能力，使整体应用架构可轻松应对高并发的应用场景。</p>
</li>
<li><p>内容缓存</p>
<p>动态处理与<strong>静态内容</strong>分离是应用架构优化的主要手段之一，Nginx 的内容缓存技术不仅可以实现预置静态文件的高速缓存，还可以对应用响应的动态结果实现缓存，为响应结果变化不大的应用提供更高速的响应能力。</p>
</li>
<li><p>可编程</p>
</li>
</ul>
</li>
<li><p>商业版本：</p>
<ul>
<li>负载均衡：<ul>
<li>基于 cookies 的会话保持功能。</li>
<li>基于响应状态码和响应体的主动健康监测。</li>
<li>支持 DNS 动态更新。</li>
</ul>
</li>
<li>动态管理：<ul>
<li>支持通过 API 清除内容缓存。</li>
<li>可通过 API 动态管理上游的后端服务器列表。</li>
</ul>
</li>
<li>安全控制：<ul>
<li>基于 API 和 OpenID 连接协议单点登录（SSO）的 JWT（JSON Web Token）认证支持。</li>
<li>Nginx WAF 动态模块。</li>
</ul>
</li>
<li>状态监控：<ul>
<li>超过 90 个状态指标的扩展状态监控。</li>
<li>内置实时图形监控面板。</li>
<li>集成可用于自定义监控工具的 JSON 和 HTML 输出功能支持。</li>
</ul>
</li>
<li>Kubernetes Ingress Controller：<ul>
<li>支持 Kubernetes 集群 Pod 的会话保持和主动健康监测。</li>
<li>支持 JWT 身份认证。</li>
</ul>
</li>
<li>流媒体：<ul>
<li>支持自适性串流（Adaptive Bitrate Streaming，ABS）媒体技术 HLS（Apple HTTP Live Streaming）和 HDS（Adobe HTTP Dynamic Streaming）。</li>
<li>支持对 MP4 媒体流进行带宽控制。</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://nginx.mosong.cc/guide/nginx_intro.html#_1-%E8%AE%BF%E9%97%AE%E8%B7%AF%E7%94%B1">分支版本 Tengine</a>：双十一</p>
</li>
</ul>
<hr>
<h2 id="架构："><a href="#架构：" class="headerlink" title="架构："></a>架构：</h2><p>以<strong>事件驱动</strong>的<strong>异步非阻塞多进程</strong>请求处理模型，使 Nginx 的工作进程通过异步非阻塞的事件处理机制，实现了高性能的并发处理能力，让每个连接的请求均可在 Nginx 进程中以<strong>工作流</strong>的方式得到快速处理。</p>
<h3 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h3><p>Nginx 采用的是固定数量的多进程模型：</p>
<ul>
<li><strong>主管理进程</strong>负责工作进程的<strong>配置加载、启停</strong>等操作，</li>
<li><strong>工作进程</strong>负责<strong>处理具体请求</strong>。</li>
</ul>
<p><img src="https://nginx.mosong.cc/assets/8-200S111013OS.61HVKf9R.gif" alt="img"></p>
<p>进程间的资源都是独立的，每个工作进程处理多个连接，每个连接由一个工作进程全权处理，不需要进行进程切换，也就不会产生由进程切换引起的资源消耗问题。</p>
<hr>
<h4 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a><strong>主进程</strong></h4><p>负责监听外部控制信号，通过频道机制将相关信号操作传递给工作进程，多个工作进程间通过共享内存来共享数据和信息。</p>
<h4 id="工作进程"><a href="#工作进程" class="headerlink" title="工作进程"></a><strong>工作进程</strong></h4><p>默认配置下，工作进程的数量与主机 CPU 核数相同，充分利用 CPU 和进程的亲缘性（affinity）将工作进程与 CPU 绑定，从而最大限度地发挥多核 CPU 的处理能力。</p>
<ul>
<li>每个工作进程具备<strong>完整</strong>的请求处理能力，包括网络通信、请求解析、响应生成等全流程任务。工作进程基于异步非阻塞<strong>事件驱动</strong>模型，独立处理分配的客户端连接，‌<strong>无需依赖其他进程即可完成常规HTTP请求处理</strong></li>
<li>工作进程内部包含完整的运行时条件：<ul>
<li><strong>事件驱动机制</strong>‌：通过Epoll&#x2F;Kqueue等系统调用实现高并发处理；</li>
<li>‌<strong>内存管理池</strong>‌：独立维护请求处理所需的内存资源；</li>
<li>‌<strong>模块处理链</strong>‌：加载HTTP模块、SSL模块等核心处理单元，支持完整的协议解析与业务逻辑。</li>
</ul>
</li>
</ul>
<h4 id="信号（软中断信号）"><a href="#信号（软中断信号）" class="headerlink" title="信号（软中断信号）"></a><strong>信号</strong>（软中断信号）</h4><p>可通过调用系统命令<code>kill</code>来发送信号实现进程通信。</p>
<p><strong>核心信号类型及作用：</strong></p>
<table>
<thead>
<tr>
<th>信号类型</th>
<th>执行主体</th>
<th>功能特性</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>‌<strong>HUP</strong>‌</td>
<td>主进程</td>
<td>重新加载配置文件，保留现有TCP连接，旧Worker处理完请求后退出</td>
<td>配置热更新</td>
</tr>
<tr>
<td>‌<strong>USR1</strong>‌</td>
<td>主进程</td>
<td>重新打开所有日志文件，支持日志切割而不中断服务</td>
<td>日志文件滚动管理</td>
</tr>
<tr>
<td>‌<strong>USR2</strong>‌</td>
<td>主进程</td>
<td>启动新版本Nginx实例，保留旧进程处理存量请求</td>
<td>二进制文件平滑升级</td>
</tr>
<tr>
<td>‌<strong>WINCH</strong>‌</td>
<td>主进程</td>
<td>优雅关闭旧版本Worker进程，需配合USR2信号使用</td>
<td>版本回滚或服务降级</td>
</tr>
<tr>
<td>‌<strong>QUIT</strong>‌</td>
<td>主进程</td>
<td>优雅关闭服务，等待所有Worker完成当前请求后终止进程</td>
<td>服务维护停机</td>
</tr>
<tr>
<td>‌<strong>TERM&#x2F;INT</strong>‌</td>
<td>主进程</td>
<td>强制立即终止所有进程，中断正在处理的请求</td>
<td>紧急故障处理</td>
</tr>
</tbody></table>
<p><strong>信号处理实现机制：</strong></p>
<ol>
<li>‌<strong>信号注册体系</strong>‌<br>Master进程启动时通过<code>ngx_init_signals()</code>函数注册信号处理器，使用<code>sigaction()</code>系统调用绑定信号与处理函数。信号处理结构体<code>ngx_signal_t</code>定义了信号编号、处理函数指针等关键参数。</li>
<li>‌<strong>进程间通信</strong>‌<br>Master进程通过信号向Worker进程发送指令，例如：<ul>
<li>发送<code>SIGQUIT</code>通知Worker优雅退出</li>
<li>发送<code>SIGTERM</code>强制终止异常Worker</li>
</ul>
</li>
<li>‌<strong>平滑升级流程</strong>‌<ul>
<li>发送<code>USR2</code>信号启动新Master和Worker进程</li>
<li>新进程PID写入<code>nginx.pid.oldbin</code></li>
<li>发送<code>WINCH</code>逐步关闭旧Worker</li>
<li>通过<code>kill -QUIT</code>终止旧Master</li>
</ul>
</li>
</ol>
<p><strong>操作实践示例：</strong></p>
<ol>
<li><p>‌<strong>配置热更新</strong>‌</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP `<span class="built_in">cat</span> /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure>

<p>该操作触发配置校验和新Worker进程生成，旧Worker处理完请求后退出。</p>
</li>
<li><p>‌<strong>日志切割</strong>‌</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> access.log access.log.bak</span><br><span class="line"><span class="built_in">kill</span> -USR1 `<span class="built_in">cat</span> nginx.pid`  <span class="comment"># 自动创建新日志文件</span></span><br></pre></td></tr></table></figure>

<p>适用于日志归档场景，避免进程重启。</p>
</li>
<li><p>‌<strong>版本回滚</strong>‌</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP `<span class="built_in">cat</span> nginx.pid.oldbin`  <span class="comment"># 恢复旧Master</span></span><br><span class="line"><span class="built_in">kill</span> -WINCH `<span class="built_in">cat</span> nginx.pid`       <span class="comment"># 关闭新Worker</span></span><br><span class="line"><span class="built_in">kill</span> -QUIT `<span class="built_in">cat</span> nginx.pid`        <span class="comment"># 终止新Master</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="频道"><a href="#频道" class="headerlink" title="频道"></a>频道</h4><p>频道（channel）是 Nginx 主进程向工作进程传递信号操作的通信方式，用于将控制工作进程的信号操作传递给工作进程。</p>
<p>创建工作进程时会将接收频道消息的套接字（socket）注册到对应的事件引擎（如 <strong>epoll</strong>）中，当事件引擎监听到主进程发送的频道消息时，就会触发回调函数通知工作进程执行响应操作。</p>
<p><strong>主进程发送频道消息，工作进程接收频道消息并执行相应操作</strong></p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>多个进程访问同一个内存地址，一个进程改变了内存中的内容后，其他进程都可以使用变更后的内容。</p>
<p>主进程启动时创建共享内存，工作进程创建（<code>fork</code> 方式）完成后，所有的进程都开始使用共享内存。</p>
<p>用户可以在配置文件中配置共享内存名称和大小，定义不同的共享内存块供 Nginx 不同的功能使用，Nginx 解析完配置文件后，会将定义的共享内存通过 slab 机制进行内部统一划分和管理。</p>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>当工作进程被创建时，每个工作进程都继承了主进程的监听套接字（socket），所以所有工作进程的事件监听列表中会<strong>共享相同的监听套接字</strong>。这就导致了：</p>
<p><font color="red">（<strong>共享资源的互斥访问机制</strong>）</font><strong>多个工作进程间同一时间内只能由一个工作进程接收网络连接</strong>。为使多个工作进程间能够协调工作，Nginx 的工作进程有如下几种调度方式。</p>
<ul>
<li><p>无调度模式</p>
<p>所有工作进程都会在连接事件被触发时争相与客户端建立连接，建立连接成功则开始处理客户端请求。</p>
<p>无调度模式下所有进程都会争抢资源，但最终<strong>只有一个进程</strong>可以与客户端建立连接，对于系统而言这将在瞬间产生大量的资源消耗，这就是所谓的<font color="red"><strong>惊群现象</strong></font>。</p>
<p><strong>但该模式因为少了争抢互斥锁的处理，在高并发场景下可提高系统的响应能力。</strong></p>
</li>
<li><p>互斥锁模式（accept_mutex）（默认是关闭的）</p>
<p>互斥锁是一种声明机制，每个工作进程都会<strong>周期性</strong>地争抢互斥锁，一旦某个工作进程抢到互斥锁，就表示其拥有接收 HTTP 建立连接事件的处理权，并将当前进程的 socket 监听注入事件引擎（如 <strong>epoll</strong>）中，接收外部的连接事件。</p>
<p>其他工作进程只能继续处理已经建立连接的读写事件，并<strong>周期性地轮询</strong>查看互斥锁的状态，只有互斥锁被释放后工作进程才可以抢占互斥锁，获取 HTTP 建立连接事件的处理权。</p>
<p>互斥锁模式有效地避免了<strong>惊群现象</strong>，对于大量 HTTP 的短连接，该机制有效避免了因工作进程争抢事件处理权而产生的资源消耗。但对于大量启用长连接方式的 HTTP 连接，互斥锁模式会将压力集中在少数工作进程上，进而因工作进程负载不均而导致**每秒查询数（QPS 表示服务器每秒能处理的请求数量，是衡量服务端性能的核心指标）**下降。</p>
<p><strong>性能调优参数</strong>‌<br>修改<code>nginx.conf</code>中的<code>accept_mutex</code>参数可调整互斥策略：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>;  <span class="comment"># 默认启用互斥锁</span></span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;  <span class="comment"># 单次事件循环接收多个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>套接字分片（Socket Sharding）</p>
<p>套接字分片是由<strong>内核</strong>提供的一种分配机制，该机制允许每个工作进程都有<strong>一组相同的</strong>监听套接字。当有外部连接请求时，由内核决定哪个工作进程的套接字监听可以接收连接。这有效避免了<strong>惊群现象</strong>的发生，相比互斥锁机制提高了多核系统的性能。该功能需要在配置 listen 指令时启用 reuseport 参数。</p>
<p><strong>该模式是 Linux 内核提供进程的调度机制，所以性能最好。</strong></p>
</li>
</ul>
<h4 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h4><p>事件驱动程序设计（Event-Driven Programming）是一种程序设计模型，这种模型的程序流程是由外部操作或消息交互事件触发的。其代码架构通常是预先设计一个<strong>事件循环方法</strong>，再由这个事件循环方法<strong>不断地检查</strong>当前要处理的信息，并根据相应的信息触发<strong>事件函数</strong>进行事件处理。</p>
<p>通常未被处理的事件会放在事件<strong>队列</strong>中等待处理，而被事件函数处理的事件也会形成一个事件串，因此事件驱动模型的重点就在于事件处理的弹性和异步化。</p>
<p>Linux 系统将用于寻址操作的虚拟存储器分为<strong>内核空间</strong>和<strong>用户空间</strong>，所有硬件设备的操作都是在内核空间中实现的。<br>当应用程序监听的网络接口接收到网络数据时，<strong>内核</strong>会先把数据保存在<strong>内核空间的缓冲区</strong>中，然后再由<strong>应用程序复制到用户空间</strong>进行处理。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#数据传递路径</span><br><span class="line">接口-&gt; 内核（内核空间的缓冲区）-&gt; 用户空间</span><br></pre></td></tr></table></figure>

<p><strong>套接字（socket）</strong>：套接字是应用程序与 TCP&#x2F;IP 协议通信的中间抽象层，也是一种特殊的文件，应用程序以文件描述符的方式对其进行读&#x2F;写（I&#x2F;O）、打开或关闭操作。每次对 socket 进行读操作都需要等待数据准备（数据被读取到内核缓冲区），然后再将数据从内核缓冲区复制到用户空间。</p>
<p>提高 I&#x2F;O 读写操作性能的模型：</p>
<ul>
<li><p>I&#x2F;O 多路复用模型：</p>
<p>一个进程可以监视多个文件描述符，一旦某个文件描述符就绪（数据准备就绪），进程就可以进行相应的读写操作。</p>
<ul>
<li><p><strong>epoll</strong> 引擎：在 1GB 内存下可以监听 10 万个端口。</p>
<p>epoll 模型利用 mmap 映射内存加速与内核空间的消息传递，从而减少复制消耗。</p>
</li>
</ul>
</li>
</ul>
<p>事件驱动的<strong>异步非阻塞机制</strong>：</p>
<p><img src="https://nginx.mosong.cc/assets/8-200S11106455A.BaTMB0Iv.gif" alt="img"></p>
<h4 id="图示流程："><a href="#图示流程：" class="headerlink" title="图示流程："></a>图示流程：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A[主进程Master 启动] --&gt; B[解析配置]</span><br><span class="line">    B --&gt; C[绑定端口]</span><br><span class="line">    C --&gt; D[创建工作进程Fork Workers]</span><br><span class="line">    D --&gt; E&#123;持续监控&#125;</span><br><span class="line">    E --收到reload信号--&gt; F[启动新工作进程Worker]</span><br><span class="line">    E --工作进程Worker崩溃--&gt; G[重启新工作进程Worker]</span><br><span class="line">    E --正常关闭--&gt; H[通知工作进程Worker退出]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">启动</span><br><span class="line">│</span><br><span class="line">├─ 主进程  </span><br><span class="line">│   │  </span><br><span class="line">│   ├─ 解析配置 → 绑定端口 → 初始化共享内存 → 启动 Worker  </span><br><span class="line">│   ├─ 监听信号：  </span><br><span class="line">│   │   ├─ SIGHUP → 热重载  </span><br><span class="line">│   │   ├─ SIGTERM → 关闭所有 Worker  </span><br><span class="line">│   │   └─ SIGUSR1 → 日志重开  </span><br><span class="line">│   └─ 监控 Worker（自动重启崩溃进程）  </span><br><span class="line">│  </span><br><span class="line">└─ Worker 进程（多实例，独立运行）  </span><br><span class="line">    │  </span><br><span class="line">    ├─ 事件循环（epoll_wait）  </span><br><span class="line">    │   ├─ 处理新连接（通过 accept_mutex 竞争）  </span><br><span class="line">    │   ├─ 处理 I/O 事件（非阻塞读写）  </span><br><span class="line">    │   └─ 定时器与异步任务  </span><br><span class="line">    ├─ 访问共享内存（需加锁）  </span><br><span class="line">    └─ 通过 Socket Pair 与主进程通信</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="工作流机制"><a href="#工作流机制" class="headerlink" title="工作流机制"></a>工作流机制</h3><p>Nginx 在处理客户端请求时，<strong>每个连接仅由一个进程进行处理</strong>，<strong>每个请求仅运行在一个工作流中</strong>，工作流被划分为多个阶段（见下图）</p>
<p><img src="https://nginx.mosong.cc/assets/8-200S1110H41L.vQB5hUaJ.gif" alt="img"></p>
<h4 id="HTTP-请求处理阶段（应用层）"><a href="#HTTP-请求处理阶段（应用层）" class="headerlink" title="HTTP 请求处理阶段（应用层）"></a>HTTP 请求处理阶段（应用层）</h4><p>HTTP请求的处理过程被划分为多个阶段，<strong>每个模块专注于特定阶段的处理任务</strong>，最终由不同模块协作<strong>完成整个请求的响应</strong>。</p>
<p>HTTP 请求的处理过程可分为 11 个阶段，HTTP 请求处理阶段如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">阶段标识</th>
<th align="left">阶段说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NGX_HTTP_POST_READ_PHASE</td>
<td align="left">读取请求阶段，会进行 HTTP 请求头的读取和解析处理</td>
</tr>
<tr>
<td align="left">NGX_HTTP_SERVER_REWRITE_PHASE</td>
<td align="left">server 重定向阶段，会在 URI进入location路由前修改 URI 的内容，进行重定向处理</td>
</tr>
<tr>
<td align="left">NGX_HTTP_FIND_CONFIG_PHASE</td>
<td align="left">URI 匹配阶段，URI 进行 location 匹配处理，该阶段不支持外部模块引入</td>
</tr>
<tr>
<td align="left">NGX_HTTP_REWRITE_PHASE</td>
<td align="left">rewrite 重写阶段，对 URI 执行 rewrite 规则修改处理</td>
</tr>
<tr>
<td align="left">NGX_HTTP_POST_REWRITE_PHASE</td>
<td align="left">rewrite 重写结束阶段，对 rewrite 的结果执行跳转操作并进行次数验证，超过 10 次的则认为是死循环，返回 500 错误。该阶段不支持外部模块引入</td>
</tr>
<tr>
<td align="left">NGX_HTTP_PREACCESS_PHASE</td>
<td align="left">访问控制前阶段，进行连接数、单 IP 访问频率等的处理</td>
</tr>
<tr>
<td align="left">NGX_HTTP_ACCESS_PHASE</td>
<td align="left">访问控制阶段，进行用户认证、基于源 IP 的访问控制等处理</td>
</tr>
<tr>
<td align="left">NGX_HTTP_POST_ACCESS_PHASE</td>
<td align="left">访问控制结束阶段，对访问控制的结果进行处理，如向用户发送拒绝访问等响应。该阶段不支持外部模块引入</td>
</tr>
<tr>
<td align="left">NGX_HTTP_PRECONTENT_PHASE</td>
<td align="left">访问内容前阶段，对目标数据进行内容检验等操作。以前的版本称为 NGX_HTTP_TRY_FILES_PHASE，try_files 和 mirror 功能在这个阶段被执行</td>
</tr>
<tr>
<td align="left">NGX_HTTP_CONTENT_PHASE</td>
<td align="left">访问内容阶段，执行读取本地文件，返回响应内容等操作</td>
</tr>
<tr>
<td align="left">NGX_HTTP_LOG_PHASE</td>
<td align="left">日志记录阶段，处理完请求，进行日志记录</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR  </span><br><span class="line">A[POST_READ] --&gt; B[SERVER_REWRITE]  </span><br><span class="line">B --&gt; C[FIND_CONFIG]  </span><br><span class="line">C --&gt; D[REWRITE]  </span><br><span class="line">D --&gt; E[POST_REWRITE]  </span><br><span class="line">E --&gt;|重写URI| C  </span><br><span class="line">E --&gt; F[PREACCESS]  </span><br><span class="line">F --&gt; G[ACCESS]  </span><br><span class="line">G --&gt; H[POST_ACCESS]  </span><br><span class="line">H --&gt; I[PRECONTENT]  </span><br><span class="line">I --&gt; J[CONTENT]  </span><br><span class="line">J --&gt; K[LOG]  </span><br></pre></td></tr></table></figure>

<h4 id="TCP-UDP-处理阶段（传输层）"><a href="#TCP-UDP-处理阶段（传输层）" class="headerlink" title="TCP&#x2F;UDP 处理阶段（传输层）"></a>TCP&#x2F;UDP 处理阶段（传输层）</h4><p>TCP&#x2F;UDP 会话一共会经历 7 个处理阶段，每个 TCP&#x2F;UDP 会话会自上而下地按照7个阶段进行流转处理，每个处理阶段的说明如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">阶段标识</th>
<th align="left">阶段说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Post-accept</td>
<td align="left">接收客户端连接请求后的第一阶段。模块 ngx_stream_realip_module 在这个阶段被调用</td>
</tr>
<tr>
<td align="left">Pre-access</td>
<td align="left">访问处理前阶段。模块 ngx_stream_limit_conn_module 在这个阶段被调用</td>
</tr>
<tr>
<td align="left">Access</td>
<td align="left">访问处理阶段。模块 ngx_stream_access_module 在这个阶段被调用</td>
</tr>
<tr>
<td align="left">SSL</td>
<td align="left">TLS&#x2F;SSL 处理阶段。模块 ngx_stream_ssl_module 在这个阶段被调用</td>
</tr>
<tr>
<td align="left">Preread</td>
<td align="left">数据预读阶段。将 TCP&#x2F;UDP 会话数据的初始字节读入预读缓冲区，以允许 ngx_stream_ssl_preread_module 之类的模块在处理之前分析</td>
</tr>
<tr>
<td align="left">Content</td>
<td align="left">数据数据处理阶段。通常将 TCP&#x2F;UDP 会话数据代理到上游服务器，或将模块 ngx_stream_return_module 指定的值返回给客户端</td>
</tr>
<tr>
<td align="left">Log</td>
<td align="left">记录客户端会话处理结果的最后阶段。模块 ngx_stream_log_module 在这个阶段被调用</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR  </span><br><span class="line">A[客户端连接] --&gt; B[POST_ACCEPT修正IP]  </span><br><span class="line">B --&gt; C[PRE_ACCESS限流]  </span><br><span class="line">C --&gt; D[ACCESS权限校验]  </span><br><span class="line">D --&gt; E[SSL解密]  </span><br><span class="line">E --&gt; F[PREREAD协议分析]  </span><br><span class="line">F --&gt; G[CONTENT代理至上游]  </span><br><span class="line">G --&gt; H[LOG记录结果]  </span><br></pre></td></tr></table></figure>

<h4 id="图示流程"><a href="#图示流程" class="headerlink" title="图示流程"></a>图示流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR  </span><br><span class="line">A[客户端] --&gt; B(TCP三次握手)  </span><br><span class="line">B --&gt; C&#123;TCP/UDP处理阶段&#125;  </span><br><span class="line">C --&gt;|传输层连接建立| D[HTTP请求传输]  </span><br><span class="line">D --&gt; E&#123;HTTP处理阶段&#125;  </span><br><span class="line">E --&gt;|应用层解析与响应| F[返回HTTP结果]  </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>Nginx 一直秉持模块化的理念，其模块化的架构中，除了少量的主流程代码，都是模块。模块化的设计为 Nginx 提供了高度的可配置、可扩展、可定制特性。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p><strong>核心模块</strong>：负责维护进程的运行、内存及事件的管理</p>
<ul>
<li>核心模块（core）</li>
</ul>
<p>  该模块提供了 Nginx 服务运行的基本功能，如 Nginx 的进程管理、CPU 亲缘性、内存管理、配置文件解析、日志等功能。</p>
<ul>
<li><p>事件模块（event）</p>
<p>该模块负责进行连接处理，提供对不同操作系统的 I&#x2F;O 网络模型支持和自动根据系统平台选择最有效 I&#x2F;O 网络模型的方法。</p>
</li>
</ul>
</li>
<li><p><strong>功能模块</strong>：负责具体功能应用的实现，包括路由分配、内容过滤、网络及磁盘数据读写、代理转发、负载均衡等操作。</p>
<ul>
<li><p>HTTP模块（http）</p>
<p>该模块提供 HTTP 处理的核心功能和部分功能模块，HTTP 核心功能维护了 HTTP 多个阶段的工作流，并实现了对各种 HTTP 功能模块的管理和调用。</p>
</li>
<li><p>Mail模块（mail）</p>
<p>该模块实现邮件代理功能，代理 IMAP、POP3、SMTP 协议。</p>
</li>
<li><p>Stream模块（stream）</p>
<p>该模块提供 TCP&#x2F;UDP 会话的代理和负载相关功能。</p>
</li>
<li><p>第三方模块</p>
<p> lua-resty、nginx-module-vts 等</p>
</li>
</ul>
</li>
</ul>
<h4 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h4><ul>
<li><p><strong>静态加载模块</strong></p>
<p>Nginx 早期版本在进行模块编译时，通过编译配置（configure）选项<code>--with_module</code>和<code>--without-module</code>决定要编译哪些模块，被选择的模块代码与 Nginx 核心代码被编译到同一个 Nginx 二进制文件中，Nginx 文件每次启动时都会<strong>重新编译加载所有的模块</strong>。</p>
</li>
<li><p><strong>动态加载模块</strong></p>
<p>Nginx 可以在运行时有选择地加载 Nginx 官方或第三方模块。</p>
<p>为使动态模块更易于使用，Nginx 官方还提供了 <code>pkg-oss</code> 工具，该工具可为任何动态模块创建可安装的动态模块包。</p>
<p>编译工具链‌：需安装 <code>gcc</code>、<code>make</code> 等编译工具，并确保与原有 Nginx 编译环境一致。</p>
<p>在 Nginx 开源版本的代码中，编译配置选项中含有<code>=dynamic</code>选项，表示支持动态模块加载。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200S1111252930.DigbyJZf.gif" alt="img"></p>
</li>
</ul>
<p>**动态加载操作流程：**‌</p>
<ol>
<li><p>‌<strong>获取模块源码</strong>‌</p>
<ul>
<li>下载目标模块源码（需与当前 Nginx 版本兼容），例如第三方模块 <code>ngx_http_lua_module</code>；</li>
</ul>
</li>
<li><p>‌<strong>配置编译参数</strong>‌</p>
<ul>
<li><p>进入本地安装的 Nginx 源码目录，通过 <code>nginx -V</code>获取原有编译参数，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--prefix=/usr/local/nginx-1.19.1 --with-openssl=/usr/local/src/openssl-1.0.2 --with-pcre=/usr/local/src/pcre-8.37 --with-zlib=/usr/local/src/zlib-1.2.8 --with-http_ssl_module</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>./configure</code>命令，需包含原有编译参数并追加新模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure [原有编译参数] --add-dynamic-module=/path/to/module  <span class="comment">#动态添加第三方模块</span></span><br><span class="line"><span class="comment"># 可添加 --with-compat参数解决某些结构字段未被编译到代码中的问题</span></span><br></pre></td></tr></table></figure>

<p>（示例：<code>--add-dynamic-module=/opt/ngx_http_example_module</code>）；</p>
</li>
</ul>
</li>
<li><p>‌<strong>编译生成动态模块</strong>‌</p>
<ul>
<li>执行 <code>make modules</code>，生成模块文件（<code>.so</code> 文件）；</li>
<li>‌<strong>关键注意</strong>‌：避免直接运行 <code>make install</code>，防止覆盖原有主程序；</li>
</ul>
</li>
<li><p>‌<strong>部署模块文件</strong>‌</p>
<ul>
<li>将生成的 <code>.so</code> 文件复制到 Nginx 模块目录（如 <code>/usr/lib/nginx/modules/</code>）；</li>
</ul>
</li>
<li><p>‌<strong>配置加载模块</strong>‌</p>
<ul>
<li><p>在<code>nginx.conf</code>顶部添加加载指令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">load_module</span> modules/模块名.so;  </span><br></pre></td></tr></table></figure>

<p>（示例：<code>load_module modules/ngx_http_example_module.so;</code>）；</p>
</li>
</ul>
</li>
<li><p>‌<strong>重载配置验证</strong>‌</p>
<ul>
<li>执行 <code>nginx -s reload</code> 平滑重载配置；</li>
<li>通过 <code>nginx -T</code> 检查模块是否生效。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a target="_blank" rel="noopener" href="https://nginx.mosong.cc/guide/nginx_install.html">安装</a></h3><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>Nginx 的核心功能就是应对 HTTP 请求的处理。</p>
<p>Nginx 提供了多种配置指令，让用户可以根据实际的软硬件及使用场景进行灵活配置。</p>
<p>分类：</p>
<ul>
<li><p>核心配置指令</p>
<ul>
<li><p>事件核心配置指令：</p>
<p><strong>-</strong> 主要是与 Nginx 自身软件运行管理及 Nginx 事件驱动架构有关的配置指令</p>
</li>
<li><p>HTTP 核心配置指令：</p>
<p><strong>-</strong>  对客户端从发起 HTTP 请求、完成 HTTP 请求处理、返回处理结果，到关闭 HTTP 连接的完整过程中的各个处理方法进行配置的配置指令。</p>
</li>
</ul>
</li>
<li><p>模块配置指令</p>
<p>每个 Nginx 模块中对所在模块的操作方法进行配置的配置指令。</p>
</li>
</ul>
<hr>
<h3 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h3><p>保存位置： <strong>&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf</strong> </p>
<p>主配置文件是 <strong>nginx.conf</strong>（唯一的默认配置入口）</p>
<p><strong>配置文件目录：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">conf/</span><br><span class="line">├── fastcgi.conf</span><br><span class="line">├── fastcgi.conf.default</span><br><span class="line">├── fastcgi_params				</span><br><span class="line">├── fastcgi_params.default</span><br><span class="line">├── koi-utf</span><br><span class="line">├── koi-win</span><br><span class="line">├── mime.types</span><br><span class="line">├── mime.types.default</span><br><span class="line">├── nginx.conf</span><br><span class="line">├── nginx.conf.default</span><br><span class="line">├── scgi_params</span><br><span class="line">├── scgi_params.default</span><br><span class="line">├── uwsgi_params</span><br><span class="line">├── uwsgi_params.default</span><br><span class="line">└── win-utf </span><br><span class="line"><span class="comment"># &quot;.default&quot;为扩展名的文件是 Nginx 配置文件的配置样例文件。</span></span><br></pre></td></tr></table></figure>

<p>Windows 下：</p>
<p><img src="/blog2025.github.io/image-20250506101149244.png" alt="image-20250506101149244"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastcgi_params: </span><br><span class="line"><span class="comment"># Nginx 在配置 FastCGI 代理服务时会根据 fastcgi_params 文件的配置向 FastCGI 服务器传递变量，该配置文件现已由 fastcgi.conf 代替；</span></span><br><span class="line">fastcgi.conf:</span><br><span class="line"><span class="comment"># 为了规范配置指令 SCRIPT_FILENAME 的用法，引入 FastCGI 变量传递配置；</span></span><br><span class="line">mime.types:</span><br><span class="line"><span class="comment"># MIME 类型映射表，Nginx 会根据服务端文件后缀名在映射关系中获取所属文件类型，将文件类型添加到 HTTP 消息头字段&quot;Content-Type&quot;中；</span></span><br><span class="line">nginx.conf:</span><br><span class="line"><span class="comment"># Nginx 默认的配置入口文件； </span></span><br><span class="line">scgi_params:</span><br><span class="line"><span class="comment"># Nginx 在配置 SCGI 代理服务时会根据 scgi_params 文件的配置向 SCGI 服务器传递变量；</span></span><br><span class="line">uwsgi_params:</span><br><span class="line"><span class="comment"># Nginx 在配置 uWSGI 代理服务时会根据 uwsgi_params 文件的配置向 uWSGI 服务器传递变量；</span></span><br><span class="line">koi-utf、koi-win、win-utf</span><br><span class="line"><span class="comment"># :这 3 个文件是 KOI8-R 编码转换的映射文件，因为 Nginx 的作者是俄罗斯人，在 Unicode 流行之前，KOI8-R 是使用最为广泛的俄语编码。</span></span><br></pre></td></tr></table></figure>

<p><strong>配置文件结构：</strong></p>
<ul>
<li><p>配置指令（directive）</p>
<p><strong>约定</strong>的内部固定字符串， Nginx 中功能配置的最基本元素，Nginx 的每个功能配置都是通过多个不同的指令组合来实现的。</p>
</li>
<li><p>配置指令值</p>
<p>每个配置指令都有<strong>对应的内容</strong>来表示该指令的<strong>控制参数</strong>，可以是<strong>字符串、数字或变量等多种类型。</strong></p>
</li>
<li><p>配置指令语句</p>
<p><strong>指令</strong>与<strong>指令值</strong>组合构成指令语句。一条指令语句可以包含多个配置指令值，在 Nginx 配置文件中，每条指令语句都要用**<code>;</code>**作为语句结束的标识符。</p>
</li>
<li><p>配置指令域</p>
<p>由**<code>&#123; &#125;</code>**括起来的指令语句集合，指令域既可以包含多个指令语句，也可以包含多个指令域。</p>
</li>
<li><p>配置全局域</p>
<p>配置文件 nginx.conf 中<strong>上层</strong>没有其他指令域的区域被称为配置全局域，简称全局域。</p>
<p>常见配置指令域：</p>
<table>
<thead>
<tr>
<th align="left">域名称</th>
<th align="left">域类型</th>
<th align="left">域说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">main</td>
<td align="left">全局域</td>
<td align="left">Nginx 的根级别指令区域。该区域的配置指令是全局有效的，该指令名为隐性显示，nginx.conf 的整个文件内容都写在该指令域中</td>
</tr>
<tr>
<td align="left">events</td>
<td align="left">指令域</td>
<td align="left">Nginx 事件驱动相关的配置指令域</td>
</tr>
<tr>
<td align="left">http</td>
<td align="left">指令域</td>
<td align="left">Nginx HTTP 核心配置指令域，包含客户端完整 HTTP 请求过程中每个过程的处理方法的配置指令</td>
</tr>
<tr>
<td align="left">upstream</td>
<td align="left">指令域</td>
<td align="left">用于定义被代理服务器组的指令区域，也称”上游服务器”</td>
</tr>
<tr>
<td align="left">server</td>
<td align="left">指令域</td>
<td align="left">Nginx 用来定义服务 IP、绑定端口及服务相关的指令区域</td>
</tr>
<tr>
<td align="left">location</td>
<td align="left">指令域</td>
<td align="left">对用户 URI 进行访问路由处理的指令区域</td>
</tr>
<tr>
<td align="left">stream</td>
<td align="left">指令域</td>
<td align="left">Nginx 对 TCP 协议实现代理的配置指令域</td>
</tr>
<tr>
<td align="left">types</td>
<td align="left">指令域</td>
<td align="left">定义被请求文件扩展名与 MIME 类型映射表的指令区域</td>
</tr>
<tr>
<td align="left">if</td>
<td align="left">指令域</td>
<td align="left">按照选择条件判断为真时使用的配置指令域</td>
</tr>
</tbody></table>
</li>
</ul>
<p>nginx.conf文件结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line">worker_processes  1;		<span class="comment"># 只启动一个工作进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;	<span class="comment"># 每个工作进程的最大连接为1024</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;	 <span class="comment"># 引入MIME类型映射表文件</span></span><br><span class="line">    default_type  application/octet-stream;	 <span class="comment"># 全局默认映射类型为application/octet-stream</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    sendfile        on;		 <span class="comment"># 启用零复制机制</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    keepalive_timeout  65;		<span class="comment"># 保持连接超时时间为65s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;		<span class="comment"># 监听80端口的网络连接请求</span></span><br><span class="line">        server_name  localhost;		<span class="comment"># 虚拟主机名为localhost</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写 Nginx 配置文件时，为了便于维护，也会把一些指令或指令域写在外部文件中，再通过 include 指令引入 nginx.conf 主配置文件中。</p>
<p><strong>配置文件中的计量单位：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">容量单位可以使用字节、千字节、兆字节或千兆字节，示例如下。</span><br><span class="line">512</span><br><span class="line">1k或1K</span><br><span class="line">10m或10M</span><br><span class="line">1g或10G 2) 时间的最小单位是毫秒，示例如下。</span><br><span class="line">10ms  <span class="comment"># 10毫秒</span></span><br><span class="line">30s     <span class="comment"># 30秒</span></span><br><span class="line">2m      <span class="comment"># 2分钟</span></span><br><span class="line">5h      <span class="comment"># 5小时</span></span><br><span class="line">1h 30m  <span class="comment"># 1小时30分</span></span><br><span class="line">6d      <span class="comment"># 6天</span></span><br><span class="line">3w      <span class="comment"># 3周</span></span><br><span class="line">5M      <span class="comment"># 5个月</span></span><br><span class="line">2y      <span class="comment"># 2年</span></span><br></pre></td></tr></table></figure>

<p><strong>配置文件中的哈希表：</strong></p>
<p>Nginx 使用哈希表加速对 Nginx 配置中常量的处理，如 server 中的主机名、types 中的 MIME 类型映射表、请求头属性字段等数据集合。</p>
<p>哈希表是通过关键码来快速访问常量对应值的数据存储结构，在通过哈希表获取数据的过程中，其内部实现通过相关函数将常量名转换为一个关键码来实现对应值的快速定位和读取。</p>
<h3 id="进程配置指令"><a href="#进程配置指令" class="headerlink" title="进程配置指令"></a>进程配置指令</h3><p>Nginx 的进程配置指令包含在 Nginx 核心代码及事件模块代码中，按配置指令设定的功能可分为进程管理、进程调优、进程调试、事件处理 4 个部分。</p>
<h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a><strong>进程管理</strong></h4><table>
<thead>
<tr>
<th>指令</th>
<th>默认值</th>
<th>指令说明</th>
</tr>
</thead>
<tbody><tr>
<td>daemon</td>
<td>on</td>
<td>用于设定 Nginx 进程是否以守护进程的方式在后台运行，on 为启用，off 为不启用</td>
</tr>
<tr>
<td>pid</td>
<td>logs&#x2F;nginx.pid</td>
<td>设定保存 Nginx 主进程 ID 的文件路径</td>
</tr>
<tr>
<td>user</td>
<td>nobody nobody</td>
<td>用于设定 Nginx 启动后，主进程唤起的工作进程运行的用户及用户组</td>
</tr>
<tr>
<td>load_module</td>
<td>–</td>
<td>加载动态模块的指令</td>
</tr>
<tr>
<td>include</td>
<td>–</td>
<td>加载外部配置文件</td>
</tr>
<tr>
<td>error_log</td>
<td>logs&#x2F;error.log error</td>
<td>指定错误日志文件路径及文件名</td>
</tr>
<tr>
<td>pcre_jit</td>
<td>off</td>
<td>用于设定在配置文件中的正则表达式是否使用 pcre_jit 技术，off 为不使用，on 为使用。<br />需要 Nginx 在配置编译时加上<code>--with-pcre-jit</code> 参数；</td>
</tr>
<tr>
<td>ssl_engine</td>
<td>–</td>
<td>指定使用的 OpenSSL 加速引擎名称</td>
</tr>
</tbody></table>
<h4 id="进程调优"><a href="#进程调优" class="headerlink" title="进程调优"></a>进程调优</h4><p>Nginx 是按照<strong>事件</strong>驱动架构设计的。每个外部请求都以<strong>事件</strong>的形式被工作进程（Worker Process）响应，并发完成各种功能的操作处理。</p>
<ul>
<li><strong>线程池指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>线程池指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>thread_pool（提升文件操作性能）</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>thread_pool default threads&#x3D;32 max_queue&#x3D;65536;</td>
</tr>
<tr>
<td>指令说明</td>
<td>线程池配置指令，允许调整默认线程池或创建新的线程池，用于读取和发送文件的场景中。在线程池中所有线程都繁忙时，新的请求任务将在队列中等待，默认情况下，等待队列中的最大任务数是 65536，使用线程池机制时，通过配置该指令，可以在因读取和发送文件引发阻塞的场景中提升 Nginx 读取和发送文件的处理性能</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread_pool pool_1 threads=16; 具体参数说明如下。</span><br><span class="line"></span><br><span class="line">thread_pool 也可以编写在 http 指令域中；</span><br><span class="line">threads=</span><br><span class="line"><span class="comment"># 参数定义了线程池的线程数；</span></span><br><span class="line">max_queue= </span><br><span class="line"><span class="comment"># 参数指定了等待队列中的最大任务数，在线程池中所有线程都处于繁忙状态时，新任务将进入等待队列。等待队列中的最大任务数为 65536；</span></span><br><span class="line">线程池指令需要在编译配置时增加 --with-threads 参数。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>定时器方案指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>定时器方案指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>timer_resolution</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>Nginx 中的处理事件超时管理方案有两种，一种是设定一个定时器，每过一段时间就对所有超时事件进行一次扫描；另一种是先计算出距离当前时间最近的将要发生超时事件的时间，然后等待这个时间之后再去进行一次超时检测。默认配置下使用第二种超时检测方案，该方案是依据事件超时时间与当前时间的时间差进行检测的，所以每次事件返回都需要进行新的检测时间计算，在 I&#x2F;O 事件比较多的场景下，这会导致频繁地调用时间函数 gettimeofday 进行计算并更新下次检测的时间，资源消耗相对较高。而设置一个指定的时间值启用第一种方案时，Nginx 内置的事件超时检测定时器会在指定时间周期内进行事件超时检测，无须调用时间函数 gettimeofday 更新时间，资源消耗相对较低</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer_resolution 100ms; </span><br><span class="line"><span class="comment"># 在因频繁调用时间函数引发的资源消耗不大的场景中可不设定该指令。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工作进程优先级指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>工作进程优先级指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>worker_priority</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>0</td>
</tr>
<tr>
<td>指令说明</td>
<td>工作进程优先级设定指令，可以通过该指令设定工作进程在 Linux 系统中的优先级（nice 值）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_priority -5; </span><br><span class="line"><span class="comment"># worker_priority 指令值的取值范围是 -20～19，数值越小，优先级越高，获得的 CPU 时间就越多。</span></span><br></pre></td></tr></table></figure>

<p>配置生效后可以通过如下命令查看，输出结果如下图所示。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200Z11003131R.BeYZ-E3O.gif" alt="img"></p>
<ul>
<li><strong>工作进程数指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>工作进程数指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>worker_processes</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>1</td>
</tr>
<tr>
<td>可配置选项</td>
<td>number 或 auto</td>
</tr>
<tr>
<td>指令说明</td>
<td>依据 Nginx 架构可知，工作进程数量的最佳配置是小于或等于 CPU 内核的数量。通过该指令可以手动设置工作进程的数量，该指令也支持 auto 指令值，由 Nginx 进行自动分配</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes auto; </span><br><span class="line"><span class="comment"># 工作进程数指令的指令值有两种类型，分别为数字和 auto。指令值为 auto 时，Nginx 会根据 CPU 的内核数生成等数量的工作进程。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>工作进程 CPU 绑定指令</li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>工作进程 CPU 绑定指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>worker_cpu_affinity</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>可配置选项</td>
<td>cpumark 或 auto</td>
</tr>
<tr>
<td>指令说明</td>
<td>Nginx 工作进程处于高效的工作状态是因为充分利用了进程与 CPU 的亲缘性，使每个工作进程均可固定在一个 CPU 上运行。该指令可以手动进行工作进程与 CPU 的绑定，当然也可以通过设定指令值 auto 交由 Nginx 自动分配</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 8;</span><br><span class="line"></span><br><span class="line">worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000; 指令值是用 CPU 掩码来表示的，使用与 CPU 数量相等位数的二进制值来表示。单个 CPU 用单个二进制值表示，多个 CPU 组合可用二进制值相加来表示。如配置样例所示，CPU 有 8 个核，分别表示绑定了从第 0 核到第 7 核的 CPU。CPU 核数是从 0 开始计数的。</span><br><span class="line"></span><br><span class="line">指令值除了可以是 CPU 掩码外，还可以是 auto。当指令值为 auto 时，Nginx 会自动进行 CPU 绑定。</span><br><span class="line"></span><br><span class="line">配置样例如下:</span><br><span class="line"></span><br><span class="line">worker_processes auto;</span><br><span class="line"></span><br><span class="line">worker_cpu_affinity auto; 工作进程与 CPU 核数也可以是多种对应组合，指令语句如下: worker_processes 4;</span><br><span class="line"></span><br><span class="line">worker_cpu_affinity 01 10 01 10; <span class="comment"># 表示把第1、3工作进程绑定在2核CPU的第0核，第2、4工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程绑定在2核CPU的第1核</span></span><br><span class="line"><span class="comment"># worker_processes 2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># worker_cpu_affinity 0101 1010;   # 表示把第1工作进程绑定在CPU的第0核和第2核，第2工作进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定在CPU的第1核和第3核</span></span><br><span class="line"><span class="comment"># 工作进程 CPU 绑定指令仅适合于 FreeBSD 和 Linux 操作系统。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工作进程开文件数指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>工作进程开文件数指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>worker_rlimit_nofile</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置 Nginx 所有工作进程同时打开文件的最大数量，默认为操作系统的文件打开数</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 65535;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工作进程关闭等待时间指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>工作进程关闭等待时间指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>worker_shutdown_timeout</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置 Nginx 正常关闭工作进程的超时时间，当超过设定的时间时，Nginx 主进程将强制关闭所有已经打开的连接，以便关闭工作进程</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_shutdown_timeout 10s;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>设置互斥锁文件指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>设置互斥锁文件指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>lock_file</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>logs&#x2F;nginx.lock;</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置互斥锁文件指令，在开启 accept mutex 进程调度模式或使用共享内存的场景下，需要用到互斥锁机制。在一些支持原子操作的操作系统中，可使用共享内存实现互斥锁。在不支持原子操作的系统环境下，需要通过该指令指定一个互斥锁文件</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock_file logs/nginx.lock;</span><br></pre></td></tr></table></figure>

<h4 id="进程调试"><a href="#进程调试" class="headerlink" title="进程调试"></a>进程调试</h4><p>Nginx 调整配置或运行发生异常时，为了及时获知工作进程在事件处理过程中发生的问题，可通过获取内存中各状态机、变量等数据的内容进行调试。</p>
<p>Nginx 为用户提供了一些调试用的配置指令，方便用户进行进程调试。</p>
<ul>
<li><strong>主进程指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>主进程指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>master_process</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>可配置选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>Nginx 默认是以一个主进程管理多个工作进程的工作方式，设定指令值为 off 时，Nginx 将只运行一个主进程来处理所有请求</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_process off; 当只由主进程处理请求时，调试进程会更加方便。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>调试点控制指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>调试点控制指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>debug_points</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>可配置选项</td>
<td>stop 或 abort</td>
</tr>
<tr>
<td>指令说明</td>
<td>该指令用于进行调试点的控制，当指令值为 stop 时，Nginx 在执行到内部调试点时就会发出 SIGSTOP 信号，方便用户进行调试；当指令值为 abort 时则会停止进程并创建 corefile</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug_points stop;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>工作目录指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>工作目录指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>working_directory</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>在 Linux 操作系统中，当进程执行出错或收到终止信号时，操作系统会将执行进程过程中，内存中的内容存储到一个文件中，该文件被称为崩溃文件（corefile），当 Nginx 进程发生这种状况时也会生成一个崩溃文件，该崩溃文件中包含当时的堆栈及寄存器等信息，方便用户排查问题产生的原因。该指令用于设定工作进程保存崩溃文件的目录，在 Nginx 程序崩溃时向该目录中写入崩溃文件，Nginx 进程需要被设定有目录的写权限</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">working_directory logs 可以使用工具 objdump、GDB 进行文件分析。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>调试文件大小指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>调试文件大小指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>worker_rlimit_core</td>
</tr>
<tr>
<td>作用域</td>
<td>main</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>该指令是崩溃文件大小的设置指令。因为崩溃文件会存储非常详细的信息，数据量很大，很容易把磁盘空间占满，因此需要合理限制崩溃文件的文件大小</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_core 800m;</span><br></pre></td></tr></table></figure>

<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>Nginx 是采用事件驱动式架构处理外部请求的，这一架构使得 Nginx 在现有硬件架构下可以处理数以万计的并发请求。</p>
<p>通过事件处理指令的配置可以让 Nginx 与实际运行的硬件及系统进行有效的适配，从而发挥更加高效的并发处理能力。</p>
<ul>
<li><strong>工作进程并发数指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>工作进程并发数指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>worker_connections</td>
</tr>
<tr>
<td>作用域</td>
<td>events</td>
</tr>
<tr>
<td>默认值</td>
<td>512</td>
</tr>
<tr>
<td>指令说明</td>
<td>每个 Nginx 工作进程可处理并发连接的最大数</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">	worker_connections 65535;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">#Linux 系统下，因为每个网络连接都将打开一个文件描述符，Nginx 可处理的并发连接数受限于操作系统的最大打开文件数，同时所有工作进程的并发数也受 worker_rlimit_nofile 指令值的限制。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>事件处理机制选择指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名 称</th>
<th>事件处理机制选择指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>use</td>
</tr>
<tr>
<td>作用域</td>
<td>events</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>Nginx 内部有多种事件处理机制模型，以下简称事件模型。默认情况下，Nginx 会自动选择一种高效的事件模型，用户可以通过该指令自行选择事件模型进行事件处理</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">	use epoll;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment"># Nginx 支持的事件模型有 select、poll、kqueue、epoll、/dev/poll、eventport。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>互斥锁指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>互斥锁指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>accept_mutex</td>
</tr>
<tr>
<td>作用域</td>
<td>events</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>可配置选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置是否启用互斥锁模式的进程调度</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">	accept_mutex on;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment"># 在 Nginx 1.11.3 版本之前，互斥锁指令是默认开启的。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>互斥锁等待时间指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>互斥锁等待时间指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>accept_mutex_delay</td>
</tr>
<tr>
<td>作用域</td>
<td>events</td>
</tr>
<tr>
<td>默认值</td>
<td>500ms</td>
</tr>
<tr>
<td>指令说明</td>
<td>Nginx 工作进程在互斥锁模式下需要不断地争抢互斥锁，没有互斥锁的工作进程如果争抢不到互斥锁，会在等待时间结束后执行下一轮争抢。通过该指令可以将抢锁等待时间设置为一个较短的时间，以提高进程争抢互斥锁的频率</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">	accept_mutex_delay 300ms;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>多请求支持指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>多请求支持指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>multi_accept</td>
</tr>
<tr>
<td>作用域</td>
<td>events</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>可配置选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>默认情况下，每个工作进程一次只接收一个新连接。如果开启该指令，则每个工作进程将接收所有的新连接</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">	multi_accept on;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>未完成异步操作最大数指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>未完成异步操作最大数指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>worker_aio_requests</td>
</tr>
<tr>
<td>作用域</td>
<td>events</td>
</tr>
<tr>
<td>默认值</td>
<td>32</td>
</tr>
<tr>
<td>指令说明</td>
<td>用于设置当在 epoll 事件模型下使用 AIO 时，单个工作进程未完成异步 I&#x2F;O 操作的最大数</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">	worker_aio_requests 128;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>调试指定连接指令</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>调试指定连接指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>debug_connection</td>
</tr>
<tr>
<td>作用域</td>
<td>events</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>可配置选项</td>
<td>address 或 CIDR 或 unix:</td>
</tr>
<tr>
<td>指令说明</td>
<td>对指定的客户端连接开启调试日志</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">    debug_connection 127.0.0.1;</span><br><span class="line"></span><br><span class="line">    debug_connection localhost;</span><br><span class="line"></span><br><span class="line">    debug_connection 192.0.2.0/24;</span><br><span class="line"></span><br><span class="line">    debug_connection ::1;</span><br><span class="line"></span><br><span class="line">    debug_connection 2001:0db8::/32;</span><br><span class="line"></span><br><span class="line">    debug_connection unix:;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment"># 该指令需要 Nginx 在编译时通过--with-debug参数开启。</span></span><br></pre></td></tr></table></figure>

<h4 id="指令配置样例"><a href="#指令配置样例" class="headerlink" title="指令配置样例"></a>指令配置样例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">daemon on;                                              <span class="comment"># 以守护进程的方式运行Nginx</span></span><br><span class="line"></span><br><span class="line">pid  logs/nginx.pid;                                    <span class="comment"># 主进程ID记录在logs/nginx.pid中</span></span><br><span class="line"></span><br><span class="line">user nobody nobody;                                     <span class="comment"># 工作进程运行用户为nobody</span></span><br><span class="line"></span><br><span class="line">load_module <span class="string">&quot;modules/ngx_http_xslt_filter_module.so&quot;</span>;   <span class="comment"># 加载动态模块ngx_http_xslt_</span></span><br></pre></td></tr></table></figure>

<p><strong>filter_module.so</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error_log  logs/error.log debug;                        <span class="comment"># 错误日志输出级别为debug</span></span><br><span class="line"></span><br><span class="line">pcre_jit on;                                            <span class="comment"># 启用pcre_jit技术</span></span><br><span class="line"></span><br><span class="line">thread_pool default threads=32 max_queue=65536;         <span class="comment"># 线程池的线程数为32，等待队列中的最大</span></span><br></pre></td></tr></table></figure>

<p><strong>任务数为65536</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">timer_resolution 100ms;                                 <span class="comment"># 定时器周期为100毫秒</span></span><br><span class="line"></span><br><span class="line">worker_priority -5;                                     <span class="comment"># 工作进程系统优先级为-5</span></span><br><span class="line"></span><br><span class="line">worker_processes auto;                                  <span class="comment"># 工作进程数由Nginx自动调整</span></span><br><span class="line"></span><br><span class="line">worker_cpu_affinity auto;                               <span class="comment"># 工作进程的CPU绑定由Nginx自动调整</span></span><br><span class="line"></span><br><span class="line">worker_rlimit_nofile 65535;                             <span class="comment"># 所有工作进程的最大连接数是65535</span></span><br><span class="line"></span><br><span class="line">worker_shutdown_timeout 10s;                            <span class="comment"># 工作进程关闭等待时间是10秒</span></span><br><span class="line"></span><br><span class="line">lock_file logs/nginx.lock;                              <span class="comment"># 互斥锁文件的位置是logs/nginx.lock</span></span><br><span class="line"></span><br><span class="line">working_directory logs                                  <span class="comment"># 工作进程工作目录是logs</span></span><br><span class="line"></span><br><span class="line">debug_points stop;                                      <span class="comment"># 调试点模式为stop</span></span><br><span class="line"></span><br><span class="line">worker_rlimit_core 800m;                                <span class="comment"># 崩溃文件大小为800MB</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">	worker_connections 65535;                           <span class="comment"># 每个工作进程的最大连接数是65535</span></span><br><span class="line"></span><br><span class="line">	use epoll;                                          <span class="comment"># 指定事件模型为epoll</span></span><br><span class="line"></span><br><span class="line">	accept_mutex on;                                    <span class="comment"># 启用互斥锁模式的进程调度</span></span><br><span class="line"></span><br><span class="line">	accept_mutex_delay 300ms;                           <span class="comment"># 互斥锁模式下进程等待时间为300毫秒</span></span><br><span class="line"></span><br><span class="line">	multi_accept on;                                    <span class="comment"># 启用支持多连接</span></span><br><span class="line"></span><br><span class="line">	worker_aio_requests 128;                            <span class="comment"># 完成异步操作最大数为128</span></span><br><span class="line"></span><br><span class="line">	debug_connection 192.0.2.0/24;                       <span class="comment"># 调试指定连接的IP地址和端口是	192.0.2.0/24</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="端口监听（listen指令）"><a href="#端口监听（listen指令）" class="headerlink" title="端口监听（listen指令）"></a>端口监听（listen指令）</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">端口监听指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">listen</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">server</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">listen*:80 或 *:8000</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">服务监听端口、绑定 IP、监听方式的配置</td>
</tr>
</tbody></table>
<p>Nginx 服务通过 listen 指令的指令值监听网络请求，可以是 IP 协议的形式，也可以是 UNIX 域套接字。</p>
<p>如果不设置 listen 指令，Nginx 在以超级用户运行时则监听 80 端口，以非超级用户运行时则监听 8000 端口。</p>
<p><strong>参数：</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">默认值</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">address</td>
<td align="left">–</td>
<td align="left">若为 IP 协议，该参数值为指定绑定监听端口的 IP 或主机名；若为 UNIX 域套接字，则该参数值为 sock 文件路径</td>
</tr>
<tr>
<td align="left">port</td>
<td align="left">80</td>
<td align="left">IP 协议监听的端口</td>
</tr>
<tr>
<td align="left">bind</td>
<td align="left">address:port</td>
<td align="left">指定 IP 及端口</td>
</tr>
<tr>
<td align="left">ipv6only</td>
<td align="left">on</td>
<td align="left">只接收 IPv6 连接或接收 IPv6 和 IPv4 连接</td>
</tr>
<tr>
<td align="left">default_server</td>
<td align="left">–</td>
<td align="left">当 http 指令域中包含多个虚拟主机时，该参数用于指定哪个虚拟主机是默认服务，默认将第一个顺序的 server 设为默认服务。默认服务可以用来处理没有 server_name 匹配成功的请求</td>
</tr>
<tr>
<td align="left">http2</td>
<td align="left">–</td>
<td align="left">HTTP&#x2F;2 协议支持</td>
</tr>
<tr>
<td align="left">spdy</td>
<td align="left">–</td>
<td align="left">SDPY 协议支持，与 HTTP&#x2F;2 协议不能同时存在</td>
</tr>
<tr>
<td align="left">ssl</td>
<td align="left">–</td>
<td align="left">SSL 支持</td>
</tr>
<tr>
<td align="left">proxy_protocol</td>
<td align="left">–</td>
<td align="left">在指定监听端口上启用 proxy_protocol 协议支持</td>
</tr>
<tr>
<td align="left">fastopen</td>
<td align="left">number</td>
<td align="left">HTTP 处于保持连接（keepalive）状态时，允许不经过三次握手的 TCP 连接的队列的最大数</td>
</tr>
<tr>
<td align="left">deferred</td>
<td align="left">–</td>
<td align="left">添加该参数后，在 TCP 三次握手的过程中，检测到客户端有数据时才将 TCP 状态置为 ESTABLISHED 状态，没有数据则直接丢弃</td>
</tr>
<tr>
<td align="left">reuseport</td>
<td align="left">–</td>
<td align="left">默认情况下，所有的工作进程会共享一个 socket 去监听同一 IP 和端口的组合。该参数启用后，允许每个工作进程有独立的 socket 去监听同一 IP 和端口的组合，内核会对传人的连接进行负载均衡。适用于 Linux 3.9+，DragonFly BSD 和 FreeBSD 12+</td>
</tr>
<tr>
<td align="left">so_keepalive</td>
<td align="left">off</td>
<td align="left">配置是否在监听的端口启用”TCP keepalive”机制。当设置为 on 时，默认等同于 so_keepalive&#x3D;30m::10，表示 30 分钟无数据传输时发送探测包，发送 10 次，发送间隔使用系统内核参数 tcp_keepalive_intvl 的设定值</td>
</tr>
<tr>
<td align="left">backlog</td>
<td align="left">-1&#x2F;511</td>
<td align="left">当阻塞时，设置挂起连接队列的最大长度，在 FreeBSD，DragonFly BSD 和 MacOS 操作系统上，默认值为 -1，其他平台上值为 511</td>
</tr>
<tr>
<td align="left">rcvbuf</td>
<td align="left">–</td>
<td align="left">socket 接收缓冲的大小，默认为 8k 字节，在接收数据比较大的场景中可以适当调整</td>
</tr>
<tr>
<td align="left">sndbuf</td>
<td align="left">–</td>
<td align="left">socket 发送缓冲的大小，默认为 8k 字节，在发送数据较大的场景中可以适当调整</td>
</tr>
<tr>
<td align="left">setfib</td>
<td align="left">number</td>
<td align="left">为监听套接字设置关联路由表，仅在 FreeBSD 系统上有效</td>
</tr>
<tr>
<td align="left">accept_filter</td>
<td align="left">filter</td>
<td align="left">为监听套接字设置过滤器，仅支持 FreeBSD 和 NetBSD 5.0+ 系统</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        listen 127.0.0.1:8000;           <span class="comment"># 监听127.0.0.1的8000端口</span></span><br><span class="line"></span><br><span class="line">        listen 127.0.0.1;                    <span class="comment"># 监听127.0.0.1的默认80端口（root权限）</span></span><br><span class="line"></span><br><span class="line">        listen 8000;                          <span class="comment"># 监听本机所有IP的8000端口</span></span><br><span class="line"></span><br><span class="line">        listen *:8000;                        <span class="comment"># 监听本机所有IP的8000端口</span></span><br><span class="line"></span><br><span class="line">        listen localhost:8000;           <span class="comment"># 监听locahost的8000端口</span></span><br><span class="line"></span><br><span class="line">        listen [::]:8000;                      <span class="comment"># 监听IPv6的8000端口</span></span><br><span class="line"></span><br><span class="line">        listen [::1];                             <span class="comment"># 监听IPv6的回环IP的默认80端口(root权限)</span></span><br><span class="line"></span><br><span class="line">        listen unix:/var/run/nginx.sock; <span class="comment"># 监听域套接字文件</span></span><br><span class="line"></span><br><span class="line">        listen *:8000 \                     <span class="comment"># 监听本机的8000端口</span></span><br><span class="line"></span><br><span class="line">        default_server \          <span class="comment"># 当前服务是http指令域的主服务</span></span><br><span class="line"></span><br><span class="line">        fastopen=30 \            <span class="comment"># 开启fastopen功能并限定最大队列数为30</span></span><br><span class="line"></span><br><span class="line">        deferred \                   <span class="comment"># 拒绝空数据连接</span></span><br><span class="line"></span><br><span class="line">        reuseport \                 <span class="comment"># 工作进程共享socket这个监听端口</span></span><br><span class="line"></span><br><span class="line">        backlog=1024 \          <span class="comment"># 请求阻塞时挂起队列数是1024个</span></span><br><span class="line"></span><br><span class="line">        so_keepalive=on;        <span class="comment"># 当socket为保持连接时，开启状态检测功能</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="server-name-配置主机名称"><a href="#server-name-配置主机名称" class="headerlink" title="server_name 配置主机名称"></a>server_name 配置主机名称</h3><p>Nginx 中的 server_name 指令主要用于配置基于名称的虚拟主机，</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">主机名指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">server_name</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">server</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设定所在 server 指令域的主机名</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com .example.com; <span class="comment"># 泛域名的使用</span></span><br><span class="line">        server_name www.example.;             <span class="comment"># 多个后缀域名的使用server_name</span></span><br><span class="line">        www.example.com ~^www.example.com$;   <span class="comment"># 正则表达式匹配</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 正则匹配变量的场景</span></span><br><span class="line">        server_name ~^(www\.)?(.+)$;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /sites/<span class="variable">$2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 正则匹配为变量的场景</span></span><br><span class="line">        server_name ~^(www\.)?(?&lt;domain&gt;.+)$;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /sites/<span class="variable">$domain</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 server_name 指令值中有多个主机名时，第一个主机名为首主机名。</p>
<hr>
<h3 id="处理HTTP请求"><a href="#处理HTTP请求" class="headerlink" title="处理HTTP请求"></a>处理HTTP请求</h3><p>标准的 HTTP 请求从开始到结束包括<strong>请求报文</strong>和<strong>响应报文</strong>。</p>
<p><strong>请求报文：</strong></p>
<ul>
<li><p>客户端向服务端发起请求时告知服务端请求的方式、相关属性和请求内容的数据包，由请求行、请求头、请求体组成。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200Z1142U23T.DRL08zOL.gif" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请求行：</span></span><br><span class="line">GET 		https://www.baidu.com/ 		HTTP/1.1</span><br><span class="line">请求方法			请求的URL地址		请求的协议及版本号</span><br><span class="line"><span class="comment"># 请求头：</span></span><br><span class="line">除第一行外剩下的内容</span><br><span class="line"><span class="comment"># 请求体：</span></span><br><span class="line">一般为&#123;JSON&#125;格式 <span class="comment"># 本例请求方法为 GET ，没有请求体。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常见的请求头属性如下表所示</p>
<table>
<thead>
<tr>
<th align="left">属性名称</th>
<th align="left">属性值样例</th>
<th align="left">属性说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Host</td>
<td align="left"><a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></td>
<td align="left">记录用户请求的目标主机名，常用于服务端虚拟主机的区分，对应 Nginx 的 server_name 指令的配置</td>
</tr>
<tr>
<td align="left">Accept</td>
<td align="left">text&#x2F;html, application&#x2F;xhtml+xml</td>
<td align="left">描述客户端能够接收服务端返回的数据类型，Nginx 会通过 types 指令域中的内容做匹配</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">BD_HOME&#x3D;1; sugstore&#x3D;1</td>
<td align="left">客户端当前连接的所有 cookie</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a></td>
<td align="left">表示当前连接的上一个来源 URI</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">no-cache</td>
<td align="left">当前客户端缓存机制的控制，可通过更多的属性值参数进行缓存控制</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">keep-alive</td>
<td align="left">表示是否需要启用保持连接机制，HTTP&#x2F;1.1 默认启用保持连接</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">W&#x2F; “50b1c1d4f775c61:df3”</td>
<td align="left">与页面响应头中 etag 的属性值配合使用，将 etag 的内容提交给服务端，用以判断请求内容是否已经被修改，若未被修改，则返回状态码 304，客户端使用本地缓存</td>
</tr>
<tr>
<td align="left">if_modified_since</td>
<td align="left">–</td>
<td align="left">当前请求 URI 页面本地缓存的最后修改时间。服务器会将实际文件的修改时间与该参数值进行比较，若一致，则返回 304，客户端读取本地缓存；若不一致，则返回服务端文件的内容</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>响应报文：</strong></p>
<ul>
<li><p>服务端处理客户端请求后返回客户端的数据，数据包括<strong>响应行、响应头、响应体</strong> 3 个部分。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200Z1143304418.BadwDGA0.gif" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 响应行：</span></span><br><span class="line">HTTP/1.1 			200 			OK</span><br><span class="line">报文协议及版本号	响应状态码		响应状态描述</span><br><span class="line"><span class="comment"># 响应头：</span></span><br><span class="line">包含服务端处理完请求后响应设定的若干属性字段，如 set-cookie 信息等。</span><br><span class="line"><span class="comment"># 响应体：</span></span><br><span class="line">返回的处理结果，本次请求的响应体是 HTML 页面数据。</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应状态码类别：</p>
<ul>
<li>1××（消息）:表示服务端已经接收到请求，正在进行处理；</li>
<li>2××（处理成功）:表示服务端已经正确处理完客户端的 HTTP 请求；</li>
<li>3××（重定向）:服务端接收到 HTTP 请求，并将其 HTTP 请求重定向到客户本地或其他服务器进行处理；</li>
<li>4××（客户端请求有误）:客户端提交的请求不符合规范或未被授权、禁止访问等；</li>
<li>5××（服务端处理出错）:服务端无法正常完成请求操作，如超时等。</li>
</ul>
</li>
<li><p>常见的响应头属性如下表所示</p>
<table>
<thead>
<tr>
<th align="left">属性名称</th>
<th align="left">属性值样例</th>
<th align="left">属性说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Content-Type</td>
<td align="left">text&#x2F;html; charset&#x3D;utf-8</td>
<td align="left">告知客户端返回数据的类型</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">keep-alive</td>
<td align="left">告知客户端是否启用保持连接机制</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">no-cache</td>
<td align="left">告知客户端对缓存机制的控制</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">“50b1c 1d4f775c61:df3”</td>
<td align="left">当前响应数据的实体标签值，用于在客户端与服务端提交相同请求时判断请求内容是否有修改</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left"><code>https://map.baidu.com/</code></td>
<td align="left">告知客户端跳转到指定的 URI</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">username&#x3D;john.wang</td>
<td align="left">通知客户端修改本地 cookie 内容</td>
</tr>
</tbody></table>
</li>
<li><p>当 Nginx 接收 HTTP 请求后，处理相关的配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">作用域</th>
<th align="left">默认值</th>
<th align="left">指令值选项</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ignore_invalid_headers</td>
<td align="left">http, server</td>
<td align="left">on</td>
<td align="left">on 或 off</td>
<td align="left">忽略请求头中的无效属性字段，请求头属性字段中，属性名称默认由英文字符、数字和连接符组成，不符合此标准的属性名均为无效属性名。当指令值为on时，不对无效的属性名称进行过滤</td>
</tr>
<tr>
<td align="left">underscores_in_headers</td>
<td align="left">http, server</td>
<td align="left">off</td>
<td align="left">on 或 off</td>
<td align="left">请求头中属性名称的定义中”<em>“是无效连接符，启用该指令后，”</em>“将被认为是有效的连接符。如果该指令值为 off，则按照 ignore_invalid_headers 指令的配置进行处理</td>
</tr>
<tr>
<td align="left">client_header_buffer_size</td>
<td align="left">http, server</td>
<td align="left">1k</td>
<td align="left">–</td>
<td align="left">设置存放读取客户端请求头的缓冲区的大小，默认值为1K，当请求头的数据因cookie过长等其他原因超过所设定的大小时，会按照large-client header buffers的指令配置进行处理</td>
</tr>
<tr>
<td align="left">large_client_header_buffers</td>
<td align="left">http, server</td>
<td align="left">48k</td>
<td align="left">–</td>
<td align="left">当客户请求头的大小超过 client_header_buffer_size 指令设置的值时，会将超出的部分转移到该缓冲区中。在默认配置下，超大请求头第一次可分配到一个 8KB 的缓冲区块，请求行的大小不能超过该缓冲区块的大小，否则将返回 414 错误。超出 8KB 的请求头会被循环转移到新的缓冲区块中，最多转移 4 次，当超过该值时，则会返回 400 错误</td>
</tr>
<tr>
<td align="left">client_header_timeout</td>
<td align="left">http, server</td>
<td align="left">60s</td>
<td align="left">–</td>
<td align="left">读取客户端请求头的最大超时时间</td>
</tr>
<tr>
<td align="left">request_pool_size</td>
<td align="left">http, server</td>
<td align="left">4k</td>
<td align="left">–</td>
<td align="left">Nginx 开始处理请求时，会为每个请求分配一个 4KB 大小的内存池，以减少内核对小块内存的分配次数，HTTP 请求结束后会回收为其分配的内存池</td>
</tr>
<tr>
<td align="left">client_max_body_size</td>
<td align="left">http, server, Location</td>
<td align="left">1m</td>
<td align="left">–</td>
<td align="left">HTTP 请求时，请求体的最大值。当请求头中属性 Content-Length 的大小超过指令配置时，返回状态码 408</td>
</tr>
<tr>
<td align="left">client_body_buffer_size</td>
<td align="left">http, server, location</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">设置读取客户请求体的缓冲区大小，当请求体的大小超过该设定值后，会按照 client_body_in_single_buffer 指令的配置选择部分或全部写入 client_body_temp_path 指令设定的文件中。默认配置下，32 位系统下缓冲区的大小是 8KB，64 位系统下缓冲区的大小是 16KB</td>
</tr>
<tr>
<td align="left">client_body_in_file_only</td>
<td align="left">http, server, location</td>
<td align="left">off</td>
<td align="left">off 或 clean 或 on</td>
<td align="left">默认情况下是优先使用缓存，在请求体超出请求体缓冲区的大小时再写入文件。启用该指令后将禁用缓冲区，请求体会被直接写入 client_body_temp_path 指令设定的文件中</td>
</tr>
<tr>
<td align="left">client_body_temp_path</td>
<td align="left">http, server, location</td>
<td align="left">client_body_temp_path_client_body_temp</td>
<td align="left">–</td>
<td align="left">请求体被写入文件的临时目录</td>
</tr>
<tr>
<td align="left">client_body_timeout</td>
<td align="left">http, server, location</td>
<td align="left">60s</td>
<td align="left">–</td>
<td align="left">当 HTTP 请求建立连接后，客户端在超过设定时间后仍未发送请求体内容到服务端，则 Nginx 认为请求体超时，将返回响应状态码 408</td>
</tr>
<tr>
<td align="left">if_modified_since</td>
<td align="left">http, server, location</td>
<td align="left">exact</td>
<td align="left">off 或 exact 或 before</td>
<td align="left">在请求头中存在属性if modified since时，关闭或设置客户端缓存文件修改时间的服务端校验功能</td>
</tr>
<tr>
<td align="left">etag</td>
<td align="left">http, server, location</td>
<td align="left">on</td>
<td align="left">on 或 off</td>
<td align="left">etag（Entity Tag），用于在响应头中返回文件实体标签，与同一文件的下一次请求头中 If-None-Match 属性值组合检查文件是否被修改，未修改则返回响应状态码 304，否则返回最新的文件内容</td>
</tr>
<tr>
<td align="left">max_ranges</td>
<td align="left">http, server, location</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">默认为不限制大小，当客户端以 byte-range 方式获取数据请求时，该指令限定了允许的最大值。当指令值为 0 时，则关闭以 byte-range 方式获取数据的功能</td>
</tr>
<tr>
<td align="left">types</td>
<td align="left">http, server, location</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">被请求文件扩展名与 MIME 类型映射表</td>
</tr>
<tr>
<td align="left">types_hash_max_size</td>
<td align="left">http, server, location</td>
<td align="left">1024</td>
<td align="left">–</td>
<td align="left">设定 MIME 类型哈希表的大小</td>
</tr>
<tr>
<td align="left">types_hash_bucket_size</td>
<td align="left">http, server, location</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">设定 MIME 类型哈希桶的大小，默认值与 CPU 缓存行的大小一致，有 32、64、128（单位:字节）3 个值</td>
</tr>
<tr>
<td align="left">error_page</td>
<td align="left">http, server, location</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">当 HTTP 请求发生错误时，可以根据响应状态码定义一个返回的页面或执行跳转</td>
</tr>
<tr>
<td align="left">recursive_error_pages</td>
<td align="left">http, server, location</td>
<td align="left">off</td>
<td align="left">off 或 on</td>
<td align="left">当使用 error_pages 设定多层内部访问时，仍可处理上一层级返回的响应状态码</td>
</tr>
<tr>
<td align="left">server_tokens</td>
<td align="left">http, server, location</td>
<td align="left">on</td>
<td align="left">on 或 off</td>
<td align="left">默认在错误信息响应头中增加属性字段”Server”以标识 Nginx 的版本号</td>
</tr>
<tr>
<td align="left">msie_padding</td>
<td align="left">http, server, location</td>
<td align="left">on</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    ignore_invalid_headers off;</span><br><span class="line"></span><br><span class="line">    underscores_in_headers on;</span><br><span class="line"></span><br><span class="line">    client_header_buffer_size 2k;</span><br><span class="line"></span><br><span class="line">    large_client_header_buffers 10 8k;</span><br><span class="line"></span><br><span class="line">    client_header_timeout 180s;</span><br><span class="line"></span><br><span class="line">    request_pool_size 4k;</span><br><span class="line"></span><br><span class="line">    client_max_body_size 100m;</span><br><span class="line"></span><br><span class="line">    client_body_in_file_only on;</span><br><span class="line"></span><br><span class="line">    client_body_temp_path /tmp/nginx/client_temp 1 2;</span><br><span class="line"></span><br><span class="line">    client_body_timeout 120s;</span><br><span class="line"></span><br><span class="line">    if_modified_since before;</span><br><span class="line"></span><br><span class="line">    etag off;</span><br><span class="line"></span><br><span class="line">    max_ranges 1024 ;</span><br><span class="line"></span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    types_hash_bucket_size 64;</span><br><span class="line"></span><br><span class="line">    error_page 404             /404.html;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line"></span><br><span class="line">    error_page 404 = @fallback;</span><br><span class="line"></span><br><span class="line">    location @fallback &#123;</span><br><span class="line"></span><br><span class="line">    	proxy_pass http://backend;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 =200 /empty.gif;</span><br><span class="line"></span><br><span class="line">    location /download/ &#123;</span><br><span class="line"></span><br><span class="line">    	types &#123;</span><br><span class="line"></span><br><span class="line">    		application/octet-stream yaml;</span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">   		default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxy_intercept_errors on;          <span class="comment"># 当上游服务器返回非200状态码时，返回代理服务器处理</span></span><br><span class="line"></span><br><span class="line">    recursive_error_pages on;           <span class="comment"># 启用多级错误跳转功能</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">    	error_page 404 = @fallback;     <span class="comment"># 当前URL请求为404时执行内部请求@fallback</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @fallback &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://backend;      <span class="comment"># 当前所有请求代理到上游服务器backend</span></span><br><span class="line"></span><br><span class="line">        error_page 502 = @upfallback;   <span class="comment"># 当上游服务器返回502状态码时，执行内部请求@upfallback</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @upfallback &#123;</span><br><span class="line"></span><br><span class="line">    	proxy_pass http://newbackend;   <span class="comment"># 当前的所有请求代理到上游服务器newbackend</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server_tokens off;</span><br><span class="line"></span><br><span class="line">    msie_padding off;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="路由匹配规则"><a href="#路由匹配规则" class="headerlink" title="路由匹配规则"></a><strong>路由匹配规则</strong></h3><p>URI 即统一标识资源符，通用的 URI 语法格式如下:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]</span><br></pre></td></tr></table></figure>

<ul>
<li>在 Nginx 的应用场景中，URL 与 URI 并无明确区别。URI 标准（RFC3986）中约定，URL 是 URI 的一个子集；</li>
<li>scheme 是 URI 请求时遵守的协议，常见的有 <strong>HTTP、HTTPS、FTP</strong>；</li>
<li>host[:port] 是主机名与端口号，HTTP 协议的默认端口是 <strong>80</strong>，HTTPS 协议的默认端口是 <strong>443</strong>；</li>
<li>[&#x2F;path] 是<strong>访问路径与访问文件名</strong>；</li>
<li>[?query] 是<strong>访问参数</strong>，访问参数以**”?”<strong>开始作标识，由多个以</strong>“&amp;”**连接的 <strong>key&#x3D;value</strong> 形式的字符串组成。</li>
</ul>
<h4 id="URI-匹配规则"><a href="#URI-匹配规则" class="headerlink" title="URI 匹配规则"></a>URI 匹配规则</h4><p>location 是 Nginx 对 HTTP 请求中的 URI 进行匹配处理的指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~|@] pattern &#123; ... &#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>[=|~*|^~|@]</code></strong>：修饰语（Modifier），修饰语定义了与 URI 的匹配方式。</p>
</li>
<li><p><strong>pattern</strong>：匹配项，可以是字符串或正则表达式。</p>
<ul>
<li><p>无修饰语：pattern只能是字符串（完全匹配URL中除了参数之外的内容）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">	root /data/web;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰语为**<code>=</code>**，Linux 系统下会区分大小写，Windows 系统下则不会。（完全匹配URL中除了参数之外的内容）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /images &#123;</span><br><span class="line">	root /data/web;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰语为**<code>~</code>**，Linux 系统下会区分大小写，Windows 系统下则会无效。匹配项的内容必须是正则表达式。（完全匹配URL中除了参数之外的内容）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ /images/.*.(gif|jpg|png)$ &#123;</span><br><span class="line">	root /data/web;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰语为**<code>~*</code>**，不区分大小写。匹配项的内容必须是正则表达式。（完全匹配URL中除了参数之外的内容）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* .(gif|jpg|png)$ &#123;</span><br><span class="line">	root /data/web;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰语为**<code>^~</code>**，匹配项的内容如果不是正则表达式，则不再进行正则表达式测试。（完全匹配URL中除了参数之外的内容）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /images &#123;</span><br><span class="line">	root /data/web;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰语为**<code>@</code>**，定义一个只能内部访问的 location 区域，可以被其他内部跳转指令使用，如 try_files 或 error_page。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location @images &#123;</span><br><span class="line">	proxy_pass http://images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="匹配顺序"><a href="#匹配顺序" class="headerlink" title="匹配顺序"></a>匹配顺序</h4><ol>
<li>先检测匹配项的内容为非正则表达式修饰语的 location，然后再检测匹配项的内容为正则表达式修饰语的 location。</li>
<li>匹配项的内容为正则与非正则都匹配的 location，按照匹配项的内容为正则匹配的 location 执行。</li>
<li>所有匹配项的内容均为非正则表达式的 location，按照匹配项的内容完全匹配的内容长短进行匹配，即匹配内容多的 location 被执行。</li>
<li>所有匹配项的内容均为正则表达式的 location，按照书写的先后顺序进行匹配，匹配后就执行，不再做后续检测。</li>
</ol>
<p>当 location 为正则匹配且内部有 proxy_pass 指令时，proxy_pass 的指令值中不能包含无变量的字符串。修饰语”^~”不受该规则限制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ /images &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8080;                                 <span class="comment"># 正确的指令值</span></span><br><span class="line">    proxy_pass http://127.0.0.1:8080<span class="variable">$request_uri</span>;             <span class="comment"># 正确的指令值</span></span><br><span class="line">    proxy_pass http://127.0.0.1:8080/image<span class="variable">$request_uri</span>; <span class="comment"># 正确的指令值</span></span><br><span class="line">    proxy_pass http://127.0.0.1:8080/;                               <span class="comment"># 错误的指令值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问路由指令"><a href="#访问路由指令" class="headerlink" title="访问路由指令"></a>访问路由指令</h4><ul>
<li><p><strong>合并空斜线指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>合并空斜线指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>merge_slashes</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令值选项</td>
<td>off 或 on</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	merge_slashes off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跳转主机名指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>跳转主机名指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>server_name_in_redirect</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>指令说明</td>
<td>默认情况下，Nginx 重定向时，会用当前 server 指令域中主机的 IP 与 path 拼接成完整的 URL 进行重定向。开启该参数后，Nginx 会先查看当前指令域中 server_name 的第一个主机名，如果没有，则会查找请求头中 host 字段的内容，如果再没有则会用 IP 与 path 进行拼接</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	server_name_in_redirect on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跳转端口指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>跳转端口指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>port_in_redirect</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令说明</td>
<td>Nginx 重定向时，会用当前 server 指令域的监听端口与主机拼接成完整的URL进行重定向。当指令值为 off 时，则默认用 80 端口</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	port_in_redirect on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子请求输出缓冲区大小指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>子请求输出缓冲区大小指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>subrequest_output_buffer_size</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>4k 或 8k</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置用于存储子请求响应报文的缓冲区大小，默认值与操作系统的内存页大小一致</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	subrequest_output_buffer_size 64K;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>绝对跳转指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>绝对跳转指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>absolute_redirect</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令值选项</td>
<td>off 或 on</td>
</tr>
<tr>
<td>指令说明</td>
<td>Nginx 发起的重定向使用绝对路径做跳转，即用主机名和端口及访问路径的方式，如果关闭的话，则跳转为默认相对当前请求的主机名和端口的访问路径</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	absolute_redirect off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>响应刷新指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>响应刷新指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>msie_refresh</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令值选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>Nginx 处理页面跳转或刷新的方式通常是以向客户端返回 3xx 状态码来实现。该指令是当客户端为 msie 时，在返回 HTML 头部添加”&lt;meta http-equiv&#x3D;&quot;Refresh&quot; content&#x3D;&quot;0;&quot; url&#x3D;*&gt;”</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	msie_refresh off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="重定向配置详解"><a href="#重定向配置详解" class="headerlink" title="重定向配置详解"></a>重定向配置详解</h3><p>访问重写 <strong>rewrite</strong> 是 Nginx HTTP 请求处理过程中的一个重要功能，它是以模块的形式存在于代码中的，其功能是对用户请求的 URI 进行 PCRE 正则<strong>重写</strong>，然后返回 <strong>30×</strong> 重定向跳转或按条件执行相关配置。</p>
<p>rewrite 模块内置了类似脚本语言的 set、if、break、return 配置指令，通过这些指令，用户可以在 HTTP 请求处理过程中对 URI 进行更灵活的操作控制。</p>
<p>rewrite 模块提供的指令可以分两类：</p>
<ul>
<li><p>标准配置指令</p>
<p>对指定的操作进行相应的操作控制。</p>
</li>
<li><p>脚本指令</p>
<p>可以在 HTTP 指令域内以类似脚本编程的形式进行编写。</p>
</li>
</ul>
<h4 id="标准配置指令"><a href="#标准配置指令" class="headerlink" title="标准配置指令"></a>标准配置指令</h4><ul>
<li><p><strong>rewrite 日志记录指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>rewrite 日志记录指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>rewrite_log</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>指令值选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>当指令值为 on 时，rewrite 的执行结果会以 notice 级别记录到 Nginx 的 error 日志文件中</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	rewrite_log off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>未初始化变量告警日志记录指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>未初始化变量告警日志记录指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>uninitialized_variable_warn</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令值选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>指令值为 on 时，会将未初始化的变量告警记录到日志中</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	uninitialized_variable_warn off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>rewrite 指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>rewrite 指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>rewrite</td>
</tr>
<tr>
<td>作用域</td>
<td>server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令值选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>对用户的 URI 用正则表达式的方式进行重写，并跳转到新的 URI</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	rewrite ^/users/(.*)$ /show?user=<span class="variable">$1</span> last;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>rewrite 访问重写是通过 rewrite 指令实现的，rewrite 指令的语法格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite regex replacement [flag];</span><br></pre></td></tr></table></figure>

<ul>
<li>regex 是 PCRE 语法格式的正则表达式。</li>
<li>replacement 是重写 URI 的改写规则。当改写规则以”http:&#x2F;&#x2F;“”https:&#x2F;&#x2F;“或”$scheme”开头时，Nginx 重写该语句后将停止执行后续任务，并将改写后的 URI 跳转返回客户端。</li>
<li>flag 是执行该条重写指令后的操作控制符。操作控制符有如下 4 种:<ul>
<li>ast:执行完当前重写规则跳转到新的 URI 后继续执行后续操作；</li>
<li>break:执行完当前重写规则跳转到新的 URI 后不再执行后续操作。不影响用户浏览器 URI 显示；</li>
<li>redirect:返回响应状态码 302 的临时重定向，返回内容是重定向 URI 的内容，但浏览器网址仍为请求时的 URI；</li>
<li>permanent:返回响应状态码 301 的永久重定向，返回内容是重定向 URI 的内容，浏览器网址变为重定向的 URI。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="脚本指令"><a href="#脚本指令" class="headerlink" title="脚本指令"></a>脚本指令</h4><ul>
<li><p><strong>设置变量指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>设置变量指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>set</td>
</tr>
<tr>
<td>作用域</td>
<td>server, location, if</td>
</tr>
<tr>
<td>指令说明</td>
<td>set 指令，可以用来定义变量</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server&#123;</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$test</span> <span class="string">&quot;check&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">    server &#123;</span><br><span class="line">    	listen 8080;</span><br><span class="line">        location /foo &#123;</span><br><span class="line">            <span class="built_in">set</span> <span class="variable">$a</span> hello;</span><br><span class="line">            rewrite ^ /bar;</span><br><span class="line">        &#125;</span><br><span class="line">        location /bar &#123;</span><br><span class="line">            如果这个请求来自<span class="string">&quot;/foo&quot;</span>,<span class="variable">$a</span>的值是<span class="string">&quot;hello&quot;</span>。如果直接访问<span class="string">&quot;/bar&quot;</span>，<span class="variable">$a</span>的值为空</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;a = [<span class="variable">$a</span>]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>用 set 指令创建变量后，变量名是 Nginx 配置全局域可用的，但变量值只在有该变量赋值操作的 HTTP 处理流程中可用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080;</span><br><span class="line">        location /foo &#123;</span><br><span class="line">            <span class="built_in">set</span> <span class="variable">$a</span> hello;</span><br><span class="line">            rewrite ^ /bar;</span><br><span class="line">        &#125;</span><br><span class="line">        location /bar &#123;</span><br><span class="line">            如果这个请求来自<span class="string">&quot;/foo&quot;</span>,<span class="variable">$a</span>的值是<span class="string">&quot;hello&quot;</span>。如果直接访问<span class="string">&quot;/bar&quot;</span>，<span class="variable">$a</span>的值为空</span><br><span class="line">            <span class="keyword">if</span> ( <span class="variable">$a</span> = <span class="string">&quot;hello&quot;</span> )&#123;</span><br><span class="line">            	rewrite ^ /newbar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当 set 指令后只有变量名时，系统会自动创建该变量，变量值为空。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server&#123;</span><br><span class="line">    	<span class="built_in">set</span> <span class="variable">$test</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">#变量插值如下:</span></span><br><span class="line">http &#123;</span><br><span class="line">    server&#123;</span><br><span class="line">        <span class="built_in">set</span> <span class="variable">$test</span> <span class="string">&quot;check &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="string">&quot;<span class="variable">$&#123;test&#125;</span>nginx&quot;</span> = <span class="string">&quot;nginx&quot;</span> )&#123; </span><br><span class="line">            <span class="comment">#$&#123;test&#125;nginx的值为&quot;check nginx&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>条件判断指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>条件判断指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>if</td>
</tr>
<tr>
<td>作用域</td>
<td>server, location</td>
</tr>
<tr>
<td>指令说明</td>
<td>条件判断指</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$http_cookie</span> ~* <span class="string">&quot;id=([^;]+)(?:;|$)&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">set</span> <span class="variable">$id</span> <span class="variable">$1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>当判断条件为一个变量时，变量值为空或以 0 开头的字符串都被判断为 false。</p>
</li>
<li><p>变量内容字符串比较操作运算符为”&#x3D;”或”!&#x3D;”。</p>
</li>
<li><p>进行正则表达式比较时，有以下 4 个操作运算符:</p>
<ul>
<li><p>“~”:区分大小写匹配；</p>
</li>
<li><p>“~*”:不区分大小写匹配；</p>
</li>
<li><p>“!~”:区分大小写不匹配；</p>
</li>
<li><p>“!~*”:不区分大小写不匹配。</p>
</li>
</ul>
</li>
<li><p>进行文件或目录比较时，有以下 4 个操作运算符:</p>
<ul>
<li><p>“-f”:判断文件是否存在，可在运算符前加”!”表示反向判断。</p>
</li>
<li><p>“-d”:判断目录是否存在，可在运算符前加”!”表示反向判断。</p>
</li>
<li><p>“-e”:判断文件、目录或链接符号是否存在，可在运算符前加”!”表示反向判断。</p>
</li>
<li><p>“-x”:判断文件是否为可执行文件，可在运算符前加”!”表示反向判断。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>终止指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>终止指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>break</td>
</tr>
<tr>
<td>作用域</td>
<td>server, location, if</td>
</tr>
<tr>
<td>指令说明</td>
<td>终止后续指令的执行</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$slow</span>) &#123;</span><br><span class="line">            limit_rate 10k;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跳转指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>跳转指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>return</td>
</tr>
<tr>
<td>作用域</td>
<td>server, location, if</td>
</tr>
<tr>
<td>指令说明</td>
<td>向客户端返回响应状态码或执行跳转</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$request_method</span> = POST) &#123;</span><br><span class="line">        	<span class="built_in">return</span> 405;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>return 的指令值有以下 4 种方式。</p>
<ul>
<li><p>return code:向客户端返回指定 code 的状态码，当返回非标准的状态码 444 时，Nginx 直接关闭连接，不发送响应头信息。</p>
</li>
<li><p>return code text:向客户端发送带有指定 code 状态码和 text 内容的响应信息。因要在客户端显示 text 内容，所以 code 不能是 30×。</p>
</li>
<li><p>return code URL:这里的 URL 可以是内部跳转或变量 $uri，也可以是有完整 scheme 标识的 URL，将直接返回给客户端执行跳转，code 只能是 30×。</p>
</li>
<li><p>return URL:此时默认 code 为 302，URL 必须是有完整 scheme 标识的 URL。</p>
</li>
</ul>
</li>
<li><p>return 也可以用来调试输出 Nginx 的变量。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="root指令根目录配置"><a href="#root指令根目录配置" class="headerlink" title="root指令根目录配置"></a>root指令根目录配置</h3><p>用户请求的最终结果是要返回数据，当响应文件在 Nginx 服务器本地时，需要进行本地文件位置、读或写、返回执行结果的操作。</p>
<p>Nginx 中的 root 指令可以设定请求 URL 的本地文件根目录，如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">根目录指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">root</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">on</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设定请求 URL 的本地文件根目录</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /flv/ &#123;</span><br><span class="line">	root /data/web;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当 root 指令在 location 指令域时，root 设置的是 location 匹配访问路径的上一层目录，样例中被请求文件的实际本地路径为 &#x2F;data&#x2F;web&#x2F;flv&#x2F;。</p>
<p>location 中的路径是否带”&#x2F;“，对本地路径的访问无任何影响。</p>
<hr>
<h3 id="alias-访问路径别名指令"><a href="#alias-访问路径别名指令" class="headerlink" title="alias 访问路径别名指令"></a>alias 访问路径别名指令</h3><p>Nginx 中想要配置虚拟目录可以使用 alias 指令，该指令的介绍如下表所示:</p>
<table>
<thead>
<tr>
<th align="left">名 称</th>
<th align="left">访问路径别名指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">alias</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">location</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">默认情况下，本地文件的路径是 root 指令设定根目录的相对路径，通过 alias 指令可以将匹配的访问路径重新指定为新定义的文件路径。</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name www.nginxtest.org;</span><br><span class="line">    root /opt/nginx-web/www;</span><br><span class="line">    location /flv/ &#123;</span><br><span class="line">    <span class="built_in">alias</span> /opt/nginx-web/flv/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /js &#123;</span><br><span class="line">	<span class="built_in">alias</span> /opt/nginx-web/js;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /img &#123;</span><br><span class="line">	<span class="built_in">alias</span> /opt/nginx-web/img/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/flv/</span><br><span class="line"></span><br><span class="line">curl -L http://127.0.0.1:8080/js</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:8080/js/</span><br><span class="line"></span><br><span class="line">curl -L http://127.0.0.1:8080/img</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:8080/img/ </span><br></pre></td></tr></table></figure>

<p>alias 指定的目录是 location 路径的实际目录，其所在 location 的 rewrite 指令不能使用 break 参数。</p>
<hr>
<h3 id="try-files-文件判断指令"><a href="#try-files-文件判断指令" class="headerlink" title="try_files 文件判断指令"></a>try_files 文件判断指令</h3><p>可以按顺序检查文件是否存在，并返回第一个找到的文件，如果未找到任何文件，则会调用最后一个参数进行内部重定向，如下表所示:</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">文件判断指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">try_files</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">server、location</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">用于顺序检查指定文件是否存在，如果不存在，则按照最后一个指定 URI 做内部跳转</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    <span class="variable">$uri</span>存在则执行代理的上游服务器操作，否则跳转到default.gif的location</span><br><span class="line">    try_files <span class="variable">$uri</span> /images/default.gif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /images/default.gif &#123;</span><br><span class="line">	expires 30s;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳转的目标也可以是一个location区域，脚本如下:</span></span><br><span class="line">http&#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	try_files /system/maintenance.html <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html <span class="variable">$uri</span>.html @mongrel;</span><br><span class="line">    &#125;</span><br><span class="line">    location @mongrel &#123;</span><br><span class="line">        proxy_pass http://mongrel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="sendfile-零复制指令"><a href="#sendfile-零复制指令" class="headerlink" title="sendfile 零复制指令"></a>sendfile 零复制指令</h3><p>sendfile 配置项用来在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为<strong>零拷贝</strong>，如下表所示:</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">零复制指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">sendfile</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">http、server、location</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">off</td>
</tr>
<tr>
<td align="left">指令值选项</td>
<td align="left">on 或 off</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">启用零复制（sendfile）。零复制（也称零拷贝）是读取本地文件后向网络接口发送文件内容的文件传输机制</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;	</span><br><span class="line">	sendfile on;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>默认配置下，Nginx 读取本地文件后，在进行网络传输时会先将硬盘文件从硬盘中读取到 Nginx 的文件缓冲区中。<br><strong>操作流程为：硬盘 → 内核文件缓冲区 → 应用缓冲区。</strong></p>
<p>然后将 Nginx 文件缓冲区的数据写入网络接口。<br><strong>操作流程：应用缓冲区 → 内核网络缓冲区 → 网络接口。</strong></p>
<p>为了提高文件的传输效率，内核提供了零复制技术，该技术支持文件在内核缓冲区内直接交换打开的文件句柄，无须重复复制文件内容到缓冲区。</p>
<p><strong>操作流程变为：硬盘 → 内核文件缓冲区 → 内核网络缓冲区 → 网络接口。</strong></p>
<p>零复制技术减少了文件的读写次数，提升了本地文件的网络传输速度。内核缓冲区的默认大小为 4096B。</p>
<hr>
<h3 id="日志记录配置指令"><a href="#日志记录配置指令" class="headerlink" title="日志记录配置指令"></a>日志记录配置指令</h3><ul>
<li><p><strong>不存在文件日志指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>不存在文件日志指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>log_not_found</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令值选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>用于设定如果文件不存在错误是否写入日志</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	log_not_found on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子请求访问日志指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>子请求访问日志指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>log_subrequest</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令值选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>用于设定子请求的访问记录是否写入日志</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	log_subrequest on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="镜像模块"><a href="#镜像模块" class="headerlink" title="镜像模块"></a>镜像模块</h3><p><strong>ngx_http_mirror_module</strong></p>
<p>Nginx 中镜像模块的功能是将用户的访问请求镜像<strong>复制到指定的 URI</strong>，通过 location 的 URI 匹配将流量发送到指定的服务器。</p>
<p>用户请求的实际请求响应通过 Nginx 返回客户端，镜像服务器的请求响应则会被 Nginx 服务器丢弃。</p>
<p>镜像请求与实际请求是异步处理的，对实际请求无影响。</p>
<h3 id="内置配置指令"><a href="#内置配置指令" class="headerlink" title="内置配置指令"></a>内置配置指令</h3><ul>
<li><p><strong>访问镜像指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>访问镜像指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>mirror</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>指令说明</td>
<td>将用户的访问请求镜像到指定的 URI，同级支持多个 URI</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /opt/nginx-web/www;</span><br><span class="line">    location / &#123;</span><br><span class="line">        mirror /benchmark;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    location = /benchmark &#123;</span><br><span class="line">    	internal;</span><br><span class="line">    	proxy_pass http://192.168.2.145<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>镜像请求体指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>镜像请求体指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>mirror_request_body</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>将用户的访问请求体同步镜像到指定的 URI，当启用该指令时，创建镜像子请求前会优先读取并缓存客户端的请求体内容，同时 proxy_request_buffering、fastcgi_request_buffering、scgi_request_buffering 和 uwsgi_request_buffering 等指令的不缓存设置将被关闭</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    root /opt/nginx-web/www;</span><br><span class="line">    mirror_request_body off;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">        mirror /accesslog;</span><br><span class="line">    &#125;</span><br><span class="line">    location = /accesslog &#123;</span><br><span class="line">        internal;</span><br><span class="line">        proxy_pass http://192.168.2.145/accesslog/<span class="variable">$&#123;server_name&#125;</span>_$server_port<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果该指令值为 off 则不同步请求体。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /opt/nginx-web/www;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        mirror /benchmark; <span class="comment"># 镜像用户请求</span></span><br><span class="line">        mirror /benchmark; <span class="comment"># 镜像用户请求</span></span><br><span class="line">        mirror /benchmark; <span class="comment"># 镜像用户请求</span></span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    location = /benchmark &#123;</span><br><span class="line">        internal;</span><br><span class="line">        proxy_pass http://192.168.2.145<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>访问镜像模块可以将用户请求同步镜像到指定的服务器，同时还可以对用户的流量进行放大，通常可以在镜像线上流量后进行压力测试或预生产环境验证。</p>
</li>
</ul>
<hr>
<h3 id="请求头控制模块"><a href="#请求头控制模块" class="headerlink" title="请求头控制模块"></a>请求头控制模块</h3><p><strong>referer</strong> 请求头控制模块可以通过设置请求头中的属性字段 Referer 的值<strong>控制访问的拒绝与允许。</strong></p>
<p>Referer 字段用来表示<strong>当前请求的跳转来源</strong>，由于该字段可能会涉及隐私权问题，部分浏览器允许用户不发送该属性字段，因此也会存在浏览器正常的请求头中无 Referer 字段的情况。</p>
<p>有些代理服务器或防火墙也会把 Referer 字段<strong>过滤掉</strong>。</p>
<p>虽然通过 Referer 字段进行来源控制<strong>并不十分可靠</strong>，但用在防盗链的场景中还是基本可以满足需求的。该模块的内置配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">作用域</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">referer_hash_max_size</td>
<td align="left">server, location</td>
<td align="left">2048</td>
<td align="left">referer 指令中，存储变量的哈希表的大小</td>
</tr>
<tr>
<td align="left">referer_hash_bucket_size</td>
<td align="left">server, location</td>
<td align="left">64</td>
<td align="left">referer 指令中，存储变量的哈希桶的大小</td>
</tr>
<tr>
<td align="left">valid_referers</td>
<td align="left">server, location</td>
<td align="left">–</td>
<td align="left">当用户的 HTTP 头的属性字段 Referer 的值符合指令值的检测时，设置变量 $invalid_referer 为空</td>
</tr>
</tbody></table>
<p>referer 指令值参数如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">Referer 的值为空</td>
</tr>
<tr>
<td align="left">blocked</td>
<td align="left">代理服务器或防火墙过滤后的 Referer 值，这些值都不以 http:&#x2F;&#x2F; 或 https:&#x2F;&#x2F; 开头</td>
</tr>
<tr>
<td align="left">server_names</td>
<td align="left">Referer 的值中包含一个服务器名</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name nginxtest.org;</span><br><span class="line">    root /opt/nginx-web/www;</span><br><span class="line">    valid_referers none blocked *.nginxtest.org;</span><br><span class="line"></span><br><span class="line"><span class="comment">#当Referer为空或内容不包含&quot;http://&quot;或以&quot;https://&quot;开头的主机名为&quot;*.nginxtest.org&quot;时允许访问</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">    	<span class="built_in">return</span> 403;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>指令值为字符串时，既可以是包含前缀或后缀的主机名，也可以是包含主机名的 URI。</p>
<p>指令值为正则表达式时，必须以<code>~</code>开头，Nginx 将从”http:&#x2F;&#x2F;“或”https:&#x2F;&#x2F;“之后的字符串开始匹配。</p>
<p>默认变量 $invalid_referer 的值为 1，当 Referer 的值与指令值的内容匹配时，$invalid_referer 的值为空。</p>
<hr>
<h3 id="IP访问控制模块"><a href="#IP访问控制模块" class="headerlink" title="IP访问控制模块"></a>IP访问控制模块</h3><p>Nginx 中IP访问控制模块名称为 <strong>ngx_http_access_module</strong>，该模块可以对<strong>客户端的源 IP 地址</strong>进行<strong>允许或拒绝</strong>访问控制。该模块的内置配置指令如下面表格中所示。</p>
<ul>
<li><p><strong>allow 允许访问指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>允许访问指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>allow</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location、limit_except</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>允许指定源 IP 的客户端请求访问</td>
</tr>
</tbody></table>
</li>
<li><p><strong>deny 拒绝访问指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>拒绝访问指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>deny</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location、limit_except</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>拒绝指定源 IP 的客户端请求访问</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    deny  192.168.1.1;          <span class="comment"># 禁止192.168.1.1</span></span><br><span class="line">    allow 192.168.0.0/24;       <span class="comment"># 允许192.168.0.0/24的IP访问</span></span><br><span class="line">    allow 10.1.1.0/16;          <span class="comment"># 允许10.1.1.0/16的IP访问</span></span><br><span class="line">    allow 2001:0db8::/32;</span><br><span class="line">    deny  all;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Nginx 会按照自上而下的顺序进行匹配。</p>
<hr>
<h3 id="用户cookie模块"><a href="#用户cookie模块" class="headerlink" title="用户cookie模块"></a>用户cookie模块</h3><p>用户 cookie 模块（<strong>ngx_http_userid_module</strong>）的作用是为客户端设置 cookie 以标识不同的访问用户。</p>
<p>可以通过内部变量 <strong>$uid_got</strong> 和 <strong>$uid_set</strong> 记录已接收和设置的 cookie。</p>
<ul>
<li><p><strong>用户cookie指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用户 cookie 指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>userid</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>on、off、v1 或 log</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置关闭或启用用户 cookie 及启用的方式</td>
</tr>
</tbody></table>
<ul>
<li>当指令值为 off 时，关闭用户 cookie 接收和记录功能。</li>
<li>当指令值为 on 时，启用用户 cookie 接收和记录功能，默认为 v2 版本设置 cookie。设置 cookie 的响应头标识为 Set-Cookie2。</li>
<li>当指令值为 v1 时，使用 v1 版本设置 cookie，设置 cookie 的响应头标识为 Set-Cookie。</li>
<li>当指令值为 log 时，不设置用户 cookie，但对接收到的 cookie 进行记录。</li>
</ul>
</li>
<li><p><strong>用户 cookie 域指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用户 cookie 域指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>userid_domain</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>none</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置用户 cookie 中的域名，none 表示禁用 cookie 的域设置</td>
</tr>
</tbody></table>
</li>
<li><p><strong>用户 cookie 过期指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用户 cookie 过期指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>userid_expires</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>time 或 max 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置用户 cookie 的过期时间，time 表示客户端保存 cookie 的时间，max 表示 cookie 的过期时间，默认为会话结束即过期</td>
</tr>
</tbody></table>
</li>
<li><p><strong>用户 cookie 标识指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用户 cookie 标识指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>userid_mark</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>letter 或 digit 或 &#x3D; 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置用户 cookie 的标识机制并设置用作标记的字符。该标识机制用于在保存客户标识符的同时添加或修改 userid_p3p 及 cookie 的过期时间</td>
</tr>
</tbody></table>
<p>用作标记的指令值可以是<strong>任意英文字母（区分大小写）、数字或”&#x3D;”</strong>。</p>
<p>userid_mark 设置完成后，将与用户 cookie 中传送的 Base64 格式的标识的第一个字符进行比较，如果不匹配，则重新发送用户标识、userid_p3p 及 cookie 的过期时间。</p>
</li>
<li><p><strong>用户 cookie 名称指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用户 cookie 名称指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>userid_name</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>uid</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置 cookie 名称</td>
</tr>
</tbody></table>
</li>
<li><p><strong>用户 p3p 指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用户 p3p 指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>userid_p3p</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>none</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置是否将 p3p 头属性字段同 cookie 一同发送</td>
</tr>
</tbody></table>
<p>P3P 是 W3C 推荐的隐私保护标准，P3P 头属性字段通常用于解决与支持 P3P 协议的浏览器的跨域访问问题。</p>
</li>
<li><p><strong>用户 cookie 路径指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用户 cookie 路径指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>userid_path</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置 cookie 路径</td>
</tr>
</tbody></table>
</li>
<li><p><strong>用户 cookie 源服务器指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用户 cookie 源服务器指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>userid_service</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置 cookie 的发布服务器。当 cookie 标识符由多个服务器发出时，为确保用户标识的唯一性，则应为每个服务器分配编号，cookie 版本 1 时默认为 0，cookie 版本 2 时默认为服务器 IP 地址的最后 4 个八位字节组成的数字</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8083;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    auth_request /auth;</span><br><span class="line">    userid         on;</span><br><span class="line">    userid_name    uid;</span><br><span class="line">    userid_domain  example.com;</span><br><span class="line">    userid_path    /;</span><br><span class="line">    userid_expires 1d;</span><br><span class="line">    userid_p3p     <span class="string">&#x27;policyref=&quot;/w3c/p3p.xml&quot;, CP=&quot;CUR ADM OUR NOR STA NID&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        add_header    Set-Cookie <span class="string">&quot;username=<span class="variable">$remote_user</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /auth &#123;</span><br><span class="line">        proxy_pass_request_body off;</span><br><span class="line">        proxy_set_header Content-Length <span class="string">&quot;&quot;</span>;</span><br><span class="line">        proxy_set_header X-Original-URI <span class="variable">$request_uri</span></span><br><span class="line">        proxy_pass http://192.168.2.145:8080/HttpBasicAuth.php;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="并发连接数限制模块"><a href="#并发连接数限制模块" class="headerlink" title="并发连接数限制模块"></a>并发连接数限制模块</h3><p>Nginx 中的并发连接数限制模块（<strong>ngx_http_limit_conn_module</strong>）能够对访问连接中含有指定变量且变量值相同的连接进行计数，指定的变量可以是客户端 IP 地址或请求的主机名等。</p>
<p>当计数值达到 limit_conn 指令设定的值时，将会对超出并发连接数的连接请求返回指定的响应状态码（默认状态码为 503）</p>
<p>该模块只会对请求头已经完全读取完毕的请求进行计数统计。</p>
<p>由于 Nginx 采用的是多进程的架构，该模块通过共享内存存储计数状态以实现多个进程间的计数状态共享。该模块的内置配置指令如下面表格中所示。</p>
<ul>
<li><p><strong>计数存储区指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>计数存储区指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>limit_conn_zone</td>
</tr>
<tr>
<td>作用域</td>
<td>http</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>设定用于存储指定变量计数的共享内存区域</td>
</tr>
</tbody></table>
</li>
<li><p><strong>连接数设置指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>连接数设置指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>limit_conn</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置指定变量的最大并发连接数</td>
</tr>
</tbody></table>
</li>
<li><p><strong>连接数日志级别指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>连接数日志级别指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>limit_conn_log_level</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>error</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>info、notice、warn、error</td>
</tr>
<tr>
<td>指令说明</td>
<td>当指定变量的并发连接数达到最大值时，输出日志的级别</td>
</tr>
</tbody></table>
</li>
<li><p><strong>连接数状态指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>连接数状态指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>limit_conn_status</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>503</td>
</tr>
<tr>
<td>指令说明</td>
<td>当指定变量的并发连接数达到最大值时，请求返回的状态码</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone <span class="variable">$binary_remote_addr</span> zone=addr:10m;  <span class="comment"># 对用户IP进行并发计数，将计数内存区命名为addr，设置计数内存区大小为10MB</span></span><br><span class="line">server &#123;</span><br><span class="line">    location /web1/ &#123;</span><br><span class="line">    limit_conn addr 1;                                                      <span class="comment"># 限制用户的并发连接数为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>limit_conn_zone 的格式为 limit_conn_zone key zone&#x3D;name:size。</p>
</li>
<li><p>limit_conn_zone 的 key 可以是文本、变量或文本与变量的组合。</p>
</li>
<li><p>$binary_remote_addr 为 IPv4 时占用 4B，为 IPv6 时占用 16B。</p>
</li>
<li><p>limit_conn_zone 中 1MB 的内存空间可以存储 32 000 个 32B 或 16 000 个 64B 的变量计数状态。</p>
</li>
<li><p>变量计数状态在 32 位系统平台占用 32B 或 64B，在 64 位系统平台占用 64B。</p>
</li>
</ul>
<p>并发连接数同样支持多个变量的同时统计，配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone <span class="variable">$binary_remote_addr</span> zone=perip:10m;</span><br><span class="line">limit_conn_zone <span class="variable">$server_name</span> zone=perserver:10m;</span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    limit_conn perip 10;</span><br><span class="line">    limit_conn perserver 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="首页处理模块"><a href="#首页处理模块" class="headerlink" title="首页处理模块"></a>首页处理模块</h3><p>HTTP 请求经过一系列的请求流程处理后，最终将读取数据并把数据内容返回给用户。</p>
<p>当用户请求没有明确指定请求的文件名称时，Nginx 会根据设定返回默认数据。</p>
<p>实现这一功能包含 <strong>ngx_http_index_module</strong>、<strong>ngx_http_random_index_module</strong>、<strong>ngx_http_autoindex_module</strong> 这 3 个模块。</p>
<ul>
<li><p><strong>首页指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>首页指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>index</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>index index.html</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置 HTTP 服务器的默认首页</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">	index index.<span class="variable">$geo</span>.html index.html;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment"># 指令值为多个文件时，会按照从左到右的顺序依次查找，找到对应文件后将结束查找。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>随机首页指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>随机首页指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>random_index</td>
</tr>
<tr>
<td>作用域</td>
<td>location</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>随机读取文件目录下的文件内容为首页内容</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root /opt/nginx-web/html;</span><br><span class="line">location / &#123;</span><br><span class="line">	random_index on;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment"># 该指令的执行优先级高于 index 指令，文件目录中的隐藏文件将被忽略。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自动首页指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>自动首页指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>autoindex</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>自动创建目录文件列表为目录首页</td>
</tr>
</tbody></table>
</li>
<li><p><strong>自动首页格式指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>自动首页格式指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>autoindex_format</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>html</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>html 或 xml 或 json 或 jsonp</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置 HTTP 服务器的自动首页文件格式</td>
</tr>
</tbody></table>
</li>
<li><p><strong>自动首页文件大小指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>自动首页文件大小指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>autoindex_exact_size</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>on</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>设置 HTTP 服务器的自动首页显示文件大小。默认文件大小单位为 Byte，当指令值为 off 时，将根据文件大小自动换算为 KB 或者 MB 或者 GB 的单位大小</td>
</tr>
</tbody></table>
</li>
<li><p><strong>自动首页时间指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>自动首页时间指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>autoindex_localtime</td>
</tr>
<tr>
<td>作用域</td>
<td>http、server、location</td>
</tr>
<tr>
<td>默认值</td>
<td>off</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>on 或 off</td>
</tr>
<tr>
<td>指令说明</td>
<td>按照服务器时间显示文件时间。默认显示的文件时间为 GMT 时间。当指令值为 on 时，显示的文件时间为服务器时间</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    autoindex on;</span><br><span class="line">    autoindex_format html;</span><br><span class="line">    autoindex_exact_size off;</span><br><span class="line">    autoindex_localtime on;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="请求频率限制模块"><a href="#请求频率限制模块" class="headerlink" title="请求频率限制模块"></a>请求频率限制模块</h3><p>Nginx 的请求频率限制模块（<strong>ngx_http_limit_req_module</strong>）会对指定变量的请求次数进行计数。</p>
<p>当该变量在单位时间内的请求次数超过设定的数值时，后续请求会被延时处理，当被延时处理的请求数超过指定的队列数时，将返回指定的状态码（默认状态码为 503）。</p>
<p>通常该模块被用于限定同一 IP 客户端单位时间内请求的次数。</p>
<p>该模块通过共享内存存储计数状态以实现多个工作进程间的同一变量计数状态的共享。</p>
<ul>
<li><p><strong>计数存储区指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>计数存储区指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>limit_req_zone</td>
</tr>
<tr>
<td>作用域</td>
<td>http</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>设定用于存储指定变量请求计数的共享内存区域</td>
</tr>
</tbody></table>
</li>
<li><p><strong>请求限制设置指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>请求限制设置指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>limit_req</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>–</td>
</tr>
<tr>
<td>指令说明</td>
<td>启用请求限制并进行请求限制的相关配置</td>
</tr>
</tbody></table>
</li>
<li><p><strong>请求限制日志级别指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>请求限制日志级别指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>limit_req_log_level</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>error</td>
</tr>
<tr>
<td>指令值可选项</td>
<td>info, notice, warn, error</td>
</tr>
<tr>
<td>指令说明</td>
<td>当指定变量的并发连接数达到最大值时，输出日志的级别</td>
</tr>
</tbody></table>
</li>
<li><p><strong>请求限制状态指令</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>请求限制状态指令</th>
</tr>
</thead>
<tbody><tr>
<td>指令</td>
<td>limit_req_status</td>
</tr>
<tr>
<td>作用域</td>
<td>http, server, location</td>
</tr>
<tr>
<td>默认值</td>
<td>503</td>
</tr>
<tr>
<td>指令说明</td>
<td>当指定变量的并发连接数达到最大值时，请求返回的状态码</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_req_zone <span class="variable">$server_name</span> zone=addr:10m rate=1r/s;</span><br><span class="line"><span class="comment"># 限制访问当前站点的请求数，对站点请求计数，将计数内存区命名为addr，设置计数内存区大小为10MB，请求限制为1秒1次</span></span><br><span class="line">    server &#123;</span><br><span class="line">        location /search/ &#123;</span><br><span class="line">            limit_req zone=one;</span><br><span class="line"><span class="comment"># 同一秒只接收一个请求，其余的立即返回状态码503，直到第2秒才接收新的请求</span></span><br><span class="line">            limit_req zone=one burst=5;</span><br><span class="line"><span class="comment"># 同一秒接收6个请求，其余的返回状态码503，只处理一个请求，其余5个请求进入队列，每秒向Nginx释放一个请求进行处理，同时允许接收一个新的请求进入队列</span></span><br><span class="line">            limit_req zone=one burst=5 nodelay;</span><br><span class="line"><span class="comment"># 同一秒接收6个请求，其余的返回状态码503，同时处理6个请求，6秒后再接收新的请求</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>limit_req_zone 的 rate 参数的作用是对请求频率进行限制，有 r&#x2F;s（每秒的请求次数）和 r&#x2F;m（每分钟的请求次数）两个频率单位，也可根据每秒的次数换算成毫秒单位的次数。1MB 内存大小大约可以存储 16000 个 IP 地址的状态信息。</li>
<li>imit_req 的 burst 参数相当于一个缓冲容器，该容器内可容纳 burst 所设置的数量的请求，没有 nodelay 参数时，将匀速向 Nginx 释放需要处理的请求。未进入 burst 容器队列的请求将被返回状态码 503 或由 limit_req_status 指令指定的状态码。</li>
<li>limit_req 的 nodelay 参数是指对请求队列中的请求不进行延时等待，而是立即处理。</li>
</ul>
<p>请求频率同样支持多个变量的同时计数及叠加，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone <span class="variable">$binary_remote_addr</span> zone=perip:10m rate=1r/s;</span><br><span class="line">limit_req_zone <span class="variable">$server_name</span> zone=perserver:10m rate=10r/s;</span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    limit_req zone=perip burst=5 nodelay;</span><br><span class="line">    limit_req zone=perserver burst=10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="页面缓存时间配置"><a href="#页面缓存时间配置" class="headerlink" title="页面缓存时间配置"></a>页面缓存时间配置</h3><p>Nginx 缓存的设置可以<strong>提高网站性能</strong>，对于网站的图片，尤其是新闻网站，图片一旦发布，改动的可能是非常小的，为了减小对服务器请求的压力，提高用户浏览速度，我们可以通过设置 Nginx 中的 <strong>expires 指令</strong>，让用户访问一次后，将图片缓存在用户的浏览器中。</p>
<p>需要注意的是，这种缓存方式只能在用户<strong>不对浏览器强制刷新</strong>的情况下生效，如果用户通过 url 来进行访问，是可以访问到缓存的。</p>
<p><strong>expires 指令</strong>的介绍如下表所示:</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">缓存时间指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">expires</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">http、server、location、if in location</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">off</td>
</tr>
<tr>
<td align="left">指令值可选项</td>
<td align="left">时间或 epoch 或 max 或 off</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">当响应状态码为 200、201、204、206、301、302、303、304、307 或 308 时，对响应头中的属性字段”Expires”和”Cache-Control”进行添加或编辑操作</td>
</tr>
</tbody></table>
<p>当指令值为时间时，既可以是正值也可以是负值。</p>
<p>Expires 的值为当前时间与指令值的时间之和。</p>
<ul>
<li>当指令值的时间为正或 0 时，Cache-Control 的值为指令值的时间。</li>
<li>当指令值的时间为负时，Cache-Control 的值为 no-cache。</li>
<li>当指令值为时间时，可用前缀<code>@</code>指定一个绝对时间，表示在当天的指定时间失效。</li>
<li>当指令值为 epoch 时，Expires 的值为 Thu,01 Jan 1970 00:00:01 GMT，Cache-Control 的值为 no-cache。</li>
<li>当指令值为 max 时，Expires 的值为 Thu,31 Dec 2037 23:55:55 GMT，Cache-Control 的值为 10 年。</li>
<li>当指令值为 off 时，不对响应头中的属性字段 Expires 和 Cache-Control 进行任何操作。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$content_type</span> <span class="variable">$expires</span> &#123;     <span class="comment"># 根据$content_type的值，对变量$expires进行赋值</span></span><br><span class="line">    default         off;         <span class="comment"># 默认不修改Expires和Cache-Control的值</span></span><br><span class="line">    application/pdf 42d;         <span class="comment"># application/pdf类型为42天</span></span><br><span class="line">    ~image/         max;         <span class="comment"># 图片类型为max</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    expires    24h;              <span class="comment"># 设置Expires的值为当前时间之后的24小时，</span></span><br><span class="line">    Cache-Control的值为24小时</span><br><span class="line">    expires    modified +24h;    <span class="comment"># 编辑Expires的值增加24小时，Cache-Control的值增加24小时</span></span><br><span class="line">    expires    @15h;             <span class="comment"># 设置Expires的值为当前日的15点，Cache-Control的值为当前时间到当前日15点的时间差</span></span><br><span class="line">    expires    <span class="variable">$expires</span>;         <span class="comment"># 根据变量$expires的内容设置缓存时间</span></span><br><span class="line">    add_header Cache-Control no-cache;</span><br><span class="line">    add_trailer  X-Always <span class="variable">$host</span> always;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="开启压缩及相关配置详解"><a href="#开启压缩及相关配置详解" class="headerlink" title="开启压缩及相关配置详解"></a>开启压缩及相关配置详解</h3><p><strong>gzip</strong></p>
<p>为提高用户<strong>获取响应数据的速度</strong>，Nginx 服务器可以将<strong>响应数据进行 gzip 压缩</strong>，在减小响应数据的大小后再发送给用户端浏览器，相对于使用户浏览 Web 页面，上述方式显示速度更快。</p>
<p>要想启用响应数据 gzip 压缩（<strong>ngx_http_gzip_module</strong> 模块）功能，需要用户浏览器也支持 gzip 解压功能，目前大多数浏览器都支持 gzip 压缩数据的显示。</p>
<p>Nginx 服务器接收客户端浏览器发送的请求后，通过请求头中的属性字段 <strong>Accept-Encoding</strong> 判断浏览器是否支持 gzip 压缩，对支持 gzip 压缩的浏览器将发送 gzip 压缩的响应数据。</p>
<p><img src="/blog2025.github.io/image-20250506124622632.png" alt="image-20250506124622632"></p>
<p>ngx_http_gzip_module 模块的内置配置参数如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">作用域</th>
<th align="left">默认值</th>
<th align="left">指令值可选项</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gzip</td>
<td align="left">http、server、location、if in location</td>
<td align="left">off</td>
<td align="left">on 或 off</td>
<td align="left">启用 gzip 功能</td>
</tr>
<tr>
<td align="left">gzip_buffers</td>
<td align="left">http、server、location</td>
<td align="left">32 4k 或 16 8k</td>
<td align="left">–</td>
<td align="left">设置 gzip 压缩缓冲区</td>
</tr>
<tr>
<td align="left">gzip_comp_level</td>
<td align="left">http、server、location</td>
<td align="left">1</td>
<td align="left">–</td>
<td align="left">设置 gzip 压缩级别，取值范围为 1~9，该指令值越大，压缩程度越高</td>
</tr>
<tr>
<td align="left">gzip_disable</td>
<td align="left">http、server、location</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">当请求头中的属性字段 User-Agent 的内容与指令值正则匹配时关闭 gzip 压缩功能</td>
</tr>
<tr>
<td align="left">gzip_http_version</td>
<td align="left">http、server、location</td>
<td align="left">1.1</td>
<td align="left">1.0 或 1.1</td>
<td align="left">设置压缩请求的最早 HTTP 协议版本</td>
</tr>
<tr>
<td align="left">gzip_min_length</td>
<td align="left">http、server、location</td>
<td align="left">20</td>
<td align="left">–</td>
<td align="left">设置启用 gzip 压缩的响应数据的最小长度，判断依据为响应头中 Content-Length 的值。如果 Content-Length 不存在，则该指令无效；如果指令值为 0，则表示全部压缩</td>
</tr>
<tr>
<td align="left">gzip_proxied</td>
<td align="left">http、server、location</td>
<td align="left">off</td>
<td align="left">off 或 expired 或 no-cache 或 no-store 或 private 或 no_last_modified 或 no_etag 或 auth 或 any</td>
<td align="left">根据被代理服务器返回响应数据的响应头属性字段判断是否启用 gzip 压缩</td>
</tr>
<tr>
<td align="left">gzip_types</td>
<td align="left">http、server、location</td>
<td align="left">text&#x2F;html</td>
<td align="left">–</td>
<td align="left">设置可进行 gzip 压缩的响应数据的 MIME 类型，指令值为 * 时表示所有 MIME 类型</td>
</tr>
<tr>
<td align="left">gzip_vary</td>
<td align="left">http、server、location</td>
<td align="left">off</td>
<td align="left">on 或 off</td>
<td align="left">在响应头中添加 Vary:Accept-Encoding，返回给前端代理或 CDN 服务器，用于判岗是否向客户端发送 gzip 的缓存副本，避免代理或 CDN 服务器将 gzip 压缩后的缓存副本响应给不具备 gzip 解压能力的浏览器</td>
</tr>
</tbody></table>
<p> gzip_proxied 指令的指令值可选项说明如下:</p>
<ul>
<li>off:关闭该指令功能；</li>
<li>expired:若 HTTP 响应头中包含属性字段 Expires，则启用压缩；</li>
<li>no-cache:若 HTTP 响应头中包含属性字段 Cache-Control:no-cache，则启用压缩；</li>
<li>no-store:若 HTTP 响应头中包含属性字段 Cache-Control:no-store，则启用压缩；</li>
<li>private:若 HTTP 响应头中包含属性字段 Cache-Control:private，则启用压缩；</li>
<li>no_last_modified:若 HTTP 响应头中不包含属性字段 Last-Modified，则启用压缩；</li>
<li>no_etag:若 HTTP 响应头中不包含属性字段 ETag，则启用压缩；</li>
<li>auth:若 HTTP 响应头中包含属性字段 Authorization，则启用压缩；</li>
<li>any:对所有响应数据启用压缩。</li>
</ul>
<p>当客户端浏览器<strong>不支持 gzip</strong> 压缩时，可以使用 <strong>ngx_http_gunzip_module</strong> 模块将压缩的数据解压后发送给客户端。对支持 gzip 压缩的浏览器不做处理。</p>
<p>ngx_http_gunzip_module 模块的内置配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">作用域</th>
<th align="left">默认值</th>
<th align="left">指令值可选项</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gunzip</td>
<td align="left">http、server、location</td>
<td align="left">off</td>
<td align="left">on 或 off</td>
<td align="left">设置是否启用动态解压支持</td>
</tr>
<tr>
<td align="left">gunzip_buffers</td>
<td align="left">http、server、location</td>
<td align="left">32 4K</td>
<td align="left">–</td>
<td align="left">设置用于解压的缓冲区大小</td>
</tr>
</tbody></table>
<p>通常 gzip 压缩指令都是读取未压缩的文本，在进行动态压缩后把响应数据发送给客户端，<strong>ngx_http_gzip_static_module</strong> 模块可以使 Nginx 把 gzip 压缩过的以 <strong>.gz</strong> 为后缀的文件或已压缩的响应数据直接发送给客户端。</p>
<p><strong>ngx_http_gzip_static_module</strong> 模块的内置配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">静态压缩指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">gzip_static</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">http、server、location</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">off</td>
</tr>
<tr>
<td align="left">指令值可选项</td>
<td align="left">on 或 off 或 always</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">启用压缩数据读取功能</td>
</tr>
</tbody></table>
<p>gzip_static 指令的指令值可选项说明如下:</p>
<ul>
<li>on:不检查客户端是否支持 gzip 压缩数据，始终发送 gzip 压缩数据；</li>
<li>always:不检查客户端是否支持 gzip 压缩数据，始终发送 gzip 压缩数据；</li>
<li>该指令的执行优先级高于 gzip 指令；</li>
<li>开启该指令后，默认优先查找以 .gz 为后缀的文件；</li>
<li>gzip_types 指令对 gzip_static 的设置无效。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gzip_static always;                  <span class="comment"># 始终发送静态的gzip压缩数据</span></span><br><span class="line">gunzip on;                           <span class="comment"># 若客户端浏览器不支持gzip压缩数据，则解压后发送</span></span><br><span class="line">gunzip_buffers 16 8k;                                         <span class="comment"># 解压缓冲区大小为128KB</span></span><br><span class="line">gzip_proxied expired no-cache no-store private auth;    <span class="comment"># 当被代理的服务器符合条件时，</span></span><br><span class="line">                                                        <span class="comment"># 对响应数据启用gzip压缩</span></span><br><span class="line"></span><br><span class="line">gzip on;                             <span class="comment"># 启用动态gzip压缩功能</span></span><br><span class="line">gzip_min_length  1k;                 <span class="comment"># 响应数据超过1KB时启用gzip压缩</span></span><br><span class="line">gzip_buffers     4 16k;              <span class="comment"># 动态压缩的缓冲区大小是64KB</span></span><br><span class="line">gzip_comp_level 3;                   <span class="comment"># 压缩级别为3</span></span><br><span class="line">gzip_types       text/plain application/x-javascript</span><br><span class="line">                text/css application/xml text/javascript</span><br><span class="line">                application/x-httpd-php image/jpeg</span><br><span class="line">                image/gif image/png; <span class="comment"># 对指定的MIME类型数据启用动态压缩</span></span><br><span class="line">gzip_vary on;                        <span class="comment"># 向前端代理或缓存服务器发送添加&quot;Vary: Accept-</span></span><br><span class="line">                                     <span class="comment"># Encoding&quot;的响应数据</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="静态资源服务器搭建"><a href="#静态资源服务器搭建" class="headerlink" title="静态资源服务器搭建"></a>静态资源服务器搭建</h3><p>配置样式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /opt/nginx-web/www;                <span class="comment"># 存放静态文件的文件目录</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    location /js &#123;</span><br><span class="line">        <span class="built_in">alias</span> /opt/nginx-web/static/js/;    <span class="comment"># 存放JavaScript文件的文件目录</span></span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 server 指令域等同于一个虚拟服务器，每个 location 指令域等同于一个虚拟目录。</p>
<h3 id="文件下载服务器搭建"><a href="#文件下载服务器搭建" class="headerlink" title="文件下载服务器搭建"></a>文件下载服务器搭建</h3><p>配置样式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root    /opt/nginx-web/files;             <span class="comment"># 文件存放目录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下载</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        autoindex on;                         <span class="comment"># 启用自动首页功能</span></span><br><span class="line">        autoindex_format html;                <span class="comment"># 首页格式为HTML</span></span><br><span class="line">        autoindex_exact_size off;             <span class="comment"># 文件大小自动换算</span></span><br><span class="line">        autoindex_localtime on;               <span class="comment"># 按照服务器时间显示文件时间</span></span><br><span class="line"></span><br><span class="line">        default_type application/octet-stream;# 将当前目录中所有文件的默认MIME类型设置为</span><br><span class="line">                                              <span class="comment"># application/octet-stream</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$request_filename</span> ~* ^.*?\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx)$)&#123;</span><br><span class="line">            <span class="comment"># 当文件格式为上述格式时，将头字段属性Content-Disposition的值设置为&quot;attachment&quot;</span></span><br><span class="line">            add_header Content-Disposition: <span class="string">&#x27;attachment;&#x27;</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        sendfile on;                          <span class="comment"># 开启零复制文件传输功能</span></span><br><span class="line">        sendfile_max_chunk 1m;                <span class="comment"># 每个sendfile调用的最大传输量为1MB</span></span><br><span class="line">        tcp_nopush on;                        <span class="comment"># 启用最小传输限制功能</span></span><br><span class="line"></span><br><span class="line">        aio on;                               <span class="comment"># 启用异步传输</span></span><br><span class="line">        directio 5m;                          <span class="comment"># 当文件大于5MB时以直接读取磁盘的方式读取文件</span></span><br><span class="line">        directio_alignment 4096;              <span class="comment"># 与磁盘的文件系统对齐</span></span><br><span class="line">        output_buffers 4 32k;                 <span class="comment"># 文件输出的缓冲区大小为128KB</span></span><br><span class="line"></span><br><span class="line">        limit_rate 1m;                        <span class="comment"># 限制下载速度为1MB</span></span><br><span class="line">        limit_rate_after 2m;                  <span class="comment"># 当客户端下载速度达到2MB时进入限速模式</span></span><br><span class="line">        max_ranges 4096;                      <span class="comment"># 客户端执行范围读取的最大值是4096B</span></span><br><span class="line">        send_timeout 20s;                     <span class="comment"># 客户端引发传输超时时间为20s</span></span><br><span class="line">        postpone_output 2048;                 <span class="comment"># 当缓冲区的数据达到2048B时再向客户端发送</span></span><br><span class="line">        chunked_transfer_encoding on;         <span class="comment"># 启用分块传输标识</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伪动态SSI服务器"><a href="#伪动态SSI服务器" class="headerlink" title="伪动态SSI服务器"></a>伪动态SSI服务器</h3><p>Nginx 可以通过 SSI 命令将<strong>多个超文本文件</strong>组合成<strong>一个页面文件</strong>发送给<strong>客户端</strong>。</p>
<p>SSI（Server Side Include）是一种基于服务端的超文本文件处理技术。</p>
<p>SSI 仍是通过其他动态脚本语言获取动态数据的，所以此处将其归类为伪动态服务功能。</p>
<p>SSI 服务器可通过 SSI 命令实现诸多<strong>动态脚本语言的 HTML 模板功能</strong>，配合其他动态脚本服务的 API，<strong>完全可以实现前后端分离的 Web 应用</strong>。</p>
<p><strong>简单理解</strong>：</p>
<p><strong>Nginx的“伪动态SSI服务器”可以理解为：‌用静态文件实现简单动态效果的功能‌，就像给网页添加“自动拼图”能力一样。</strong></p>
<p><strong>简单来说</strong>：</p>
<ul>
<li>‌<strong>静态网页</strong>‌：普通HTML文件，内容固定不变（比如一个写死的“欢迎页面”）。</li>
<li>‌<strong>动态网页</strong>‌：内容由程序实时生成（比如购物车页面显示不同用户的信息）。</li>
</ul>
<p>而 ‌<strong>Nginx的SSI（伪动态）<strong>‌ 介于两者之间：<br>你仍然用静态HTML文件，但可以在文件中‌</strong>插入特殊指令</strong>‌，让服务器在发送网页前自动完成一些“小修改”，比如：</p>
<ol>
<li>‌<strong>插入公共模块</strong>‌：自动把页头、页脚拼接到每个页面。</li>
<li>‌<strong>显示动态信息</strong>‌：自动插入当前时间、文件修改日期等。</li>
<li>‌<strong>条件判断</strong>‌：根据设备类型（手机&#x2F;电脑）显示不同内容。</li>
</ol>
<p><strong>为什么叫“伪动态”？</strong></p>
<ul>
<li>‌<strong>真动态</strong>‌：每次访问都通过程序生成完整页面（比如PHP、Python）。</li>
<li>‌<strong>伪动态</strong>‌：页面主体还是静态文件，只是服务器在发送前按指令“修改了一下”（比如替换、插入内容），不需要复杂程序。</li>
</ul>
<p><strong>适合场景</strong>：</p>
<ul>
<li>静态网站中需要复用部分内容（比如导航栏、版权声明）。</li>
<li>希望减少维护重复代码，但不想用后端编程。</li>
</ul>
<h4 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h4><p>Nginx 是通过 ngx_http_ssi_module 模块实现 SSI 命令处理的，SSI 配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ssi</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">启用 SSI 命令功能</td>
</tr>
<tr>
<td align="left">ssi_last_modified</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">允许保留原始响应头中的属性字段 Last-Modified，默认配置下该字段会被移除</td>
</tr>
<tr>
<td align="left">ssi_min_file_chunk</td>
<td align="left">size</td>
<td align="left">1k</td>
<td align="left">设置存储在磁盘上的响应数据的最小值，超过该值的文件使用 sendfile 功能发送</td>
</tr>
<tr>
<td align="left">ssi_silent_errors</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">当指令值为 on 时，SSI 处理出现错误后不输出 errmsg 的内容</td>
</tr>
<tr>
<td align="left">ssi_types</td>
<td align="left">mime-type…</td>
<td align="left">text&#x2F;html</td>
<td align="left">设置 SSI 处理的 MIME 类型</td>
</tr>
<tr>
<td align="left">ssi_value_length</td>
<td align="left">length</td>
<td align="left">256</td>
<td align="left">SSI 中变量值的最大长度</td>
</tr>
</tbody></table>
<p>上述指令均可编写在 http、server、location 指令域中，ssi 指令还可编写在 if 指令域中。</p>
<h4 id="SSI-命令"><a href="#SSI-命令" class="headerlink" title="SSI 命令"></a>SSI 命令</h4><p>SSI 命令格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# <span class="built_in">command</span> parameter1=value1 parameter2=value2 ... --&gt;</span><br></pre></td></tr></table></figure>

<p>Nginx 支持如下 SSI 命令。</p>
<ul>
<li><strong>block</strong></li>
</ul>
<p>通过 block 命令可以定义一个超文本内容，该内容可以被 include 命令参数 stub 引用。超文本内容中可以包含其他 SSI 命令。</p>
<ul>
<li><strong>include</strong></li>
</ul>
<p>通过 include 命令可以引入一个文件或请求响应的结果数据。参数有 file（引入一个文件）、virtual（引入一个内部请求响应数据）、stub（引入一个 block 内容为默认数据）、wait（是否等待 virtual 参数发起请求处理完毕再处理 SSI 命令）、set（将 virtual 参数的响应内容输出到指定的变量）。</p>
<p>SSI 文件配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# block name=<span class="string">&quot;one&quot;</span> --&gt;&amp;nbsp;&lt;!--# endblock --&gt;   <span class="comment"># block one的内容为空</span></span><br><span class="line">&lt;!--# include file=<span class="string">&quot;footer.html&quot;</span> stub=<span class="string">&quot;one&quot;</span> --&gt;    </span><br><span class="line">	<span class="comment"># 引用文件footer.html的内容，若footer.html文件不存在或SSI命令出错，输出block one的内容</span></span><br><span class="line">&lt;!--# include virtual=<span class="string">&quot;/remote/body.php?argument=value&quot;</span> <span class="built_in">wait</span>=<span class="string">&quot;yes&quot;</span> stub=<span class="string">&quot;one&quot;</span> <span class="built_in">set</span>=<span class="string">&quot;body&quot;</span> --&gt;</span><br><span class="line">	<span class="comment"># 引用内部请求的响应数据，等待请求完毕再处理SSI指令，若出错则输出block one的内容，成功则把返回结果赋值给变量body</span></span><br></pre></td></tr></table></figure>

<p>Nginx中样例配置如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /remote/ &#123;</span><br><span class="line">  subrequest_output_buffer_size 128k;　<span class="comment"># 子请求的输出缓冲区大小是128KB</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>include 不支持”..&#x2F;“这样的相对路径；另外 include 参数 set 的响应数据大小通过指令 subrequest_output_buffer_size 设置。</p>
<ul>
<li><strong>config</strong></li>
</ul>
<p>通过 config 命令可以设置 SSI 处理过程中使用的参数 errmsg（SSI 处理出错时输出的字符串）和 timefmt（输出时间的格式，默认为”%A,%d-%b-%Y %H:%M:%S %Z”）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# config errmsg=<span class="string">&quot;oh!出错了&quot;</span> timefmt=<span class="string">&quot;%A, %d-%b-%Y %H:%M:%S %Z&quot;</span> --&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>set</strong></li>
</ul>
<p>通过 set 命令设置变量。参数有 var（变量名）和 value（变量值）。</p>
<ul>
<li><strong>echo</strong></li>
</ul>
<p>通过 echo 命令输出变量的值。参数有 encoding（HTML 编码方式，默认为 entity）、default（变量不存在时定义的默认输出，默认为 none）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# <span class="built_in">set</span> var=<span class="string">&quot;This_TEST&quot;</span> value=<span class="string">&quot;with a SSI test value&quot;</span> --&gt;</span><br><span class="line">&lt;!--# <span class="built_in">echo</span> var=<span class="string">&quot;This_TEST&quot;</span> --&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>if</strong></li>
</ul>
<p>通过 if 命令可进行条件控制，且 if 命令支持正则判断。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--# <span class="keyword">if</span> <span class="built_in">expr</span>=<span class="string">&quot;<span class="variable">$name</span> != /text/&quot;</span> --&gt;</span><br><span class="line">  &lt;!--# <span class="built_in">echo</span> var=<span class="string">&quot;name&quot;</span> --&gt;</span><br><span class="line">&lt;!--# endif --&gt;</span><br><span class="line">&lt;!--# <span class="keyword">if</span> <span class="built_in">expr</span>=<span class="string">&quot;<span class="variable">$name</span> = /(.+)@(?P&lt;domain&gt;.+)/&quot;</span> --&gt;</span><br><span class="line">  &lt;!--# <span class="built_in">echo</span> var=<span class="string">&quot;domain&quot;</span> --&gt;</span><br><span class="line">&lt;!--# <span class="keyword">else</span> --&gt;</span><br><span class="line">  &lt;!--# <span class="built_in">echo</span> var=<span class="string">&quot;1&quot;</span> --&gt;</span><br><span class="line">&lt;!--# endif --&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置样例"><a href="#配置样例" class="headerlink" title="配置样例"></a>配置样例</h3><p>根据 Nginx SSI 模块提供的功能可以搭建一个类似 HTML 框架的前端模板网站。模板目录规划如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── _footer.html </span><br><span class="line">├── _header.html</span><br><span class="line">├── _head.html</span><br><span class="line">├── index.html</span><br><span class="line">├── _sidebar.html</span><br><span class="line">├── static</span><br><span class="line">│   └── main.css</span><br><span class="line">└── table.html</span><br></pre></td></tr></table></figure>

<p>文件 <strong>_footer.html</strong> 内容如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--# config timefmt=&quot;%Y&quot; --&gt;</span><span class="symbol">&amp;copy;</span></span><br><span class="line">    <span class="comment">&lt;!--# echo var=&quot;date_local&quot; --&gt;</span> Nginx SSI sample - All Rights Reserved.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>文件 <strong>_header.html</strong> 内容如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;logo&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://nginx.org/nginx.png&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;nginx&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav nav-pills&quot;</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index.html&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>        			<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;table.html&quot;</span>&gt;</span>表格测试<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>文件 <strong>_head.html</strong> 内容如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/main.css?v=12&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>文件 <strong>index.html</strong> 内容如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--# block name=&quot;one&quot; --&gt;</span><span class="comment">&lt;!--# endblock --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--# include file=&quot;_head.html&quot; stub=&quot;one&quot; --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--# include file=&quot;_header.html&quot; stub=&quot;one&quot; --&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!--# include file=&quot;_sidebar.html&quot; stub=&quot;one&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--# include file=&quot;_footer.html&quot; stub=&quot;one&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>文件 <strong>_sidebar.html</strong> 内容如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav navbar-nav&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;blank&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>效果图：</strong></p>
<p><img src="https://nginx.mosong.cc/assets/8-200Z3125643141.BeWm2lgY.gif" alt="img"></p>
<p>文件 <strong>table.html</strong> 内容如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--# block name=&quot;one&quot; --&gt;</span><span class="comment">&lt;!--# endblock --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--# include file=&quot;_head.html&quot; stub=&quot;one&quot; --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--# include file=&quot;_header.html&quot; stub=&quot;one&quot; --&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!--# include file=&quot;_sidebar.html&quot; stub=&quot;one&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格示例<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>省份<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>省会<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>广东<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--# include file=&quot;_footer.html&quot; stub=&quot;one&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表格页页面效果如下图所示。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200Z3125G9523.CHVZkCT6.gif" alt="img"></p>
<p>Nginx 配置内容如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8081;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web/nginx-ssi;</span><br><span class="line">    sendfile on;</span><br><span class="line">    ssi on;                         <span class="comment"># 启用SSI命令解析支持</span></span><br><span class="line">    ssi_min_file_chunk 1k;          <span class="comment"># 存储在磁盘上的响应数据的最小值为1KB</span></span><br><span class="line">    ssi_value_length 1024;          <span class="comment"># SSI中变量值的最大长度为1024字节</span></span><br><span class="line">    ssi_silent_errors off;          <span class="comment"># 输出errmsg的内容</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">         index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="HTTPS服务器搭建"><a href="#HTTPS服务器搭建" class="headerlink" title="HTTPS服务器搭建"></a>HTTPS服务器搭建</h3><p>HTTPS 协议可验证用户客户端和服务器的身份，确保数据可以在正确的用户客户端和服务器间传输。</p>
<p>因为 HTTPS 协议的数据传输是加密的，所以在传输过程中可以有效防止数据被窃取和修改，从而保障网络信息的安全。</p>
<p>Nginx 的 HTTPS 协议服务是通过 ngx_http_ssl_module 模块实现的，在配置编译参数时需要添加 <strong>–with-http_ssl_module</strong> 参数启用该功能。</p>
<h4 id="配置指令-1"><a href="#配置指令-1" class="headerlink" title="配置指令"></a>配置指令</h4><p>Nginx HTTPS 配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ssl</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">启用 SSL 支持，建议使用 listen 的 ssl 参数开启</td>
</tr>
<tr>
<td align="left">ssl_protocols</td>
<td align="left">[SSLv2][SSLv3] [TLSvl][TLSv1.1] [TLSv1.2][TLSv1.3]</td>
<td align="left">TLSv1 TLSv1.1 TLSv1.2</td>
<td align="left">设置使用的 SSL 协议</td>
</tr>
<tr>
<td align="left">ssl_buffer_size</td>
<td align="left">size</td>
<td align="left">16k</td>
<td align="left">设置用于发送数据的缓存大小</td>
</tr>
<tr>
<td align="left">ssl_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">PEM 格式的网站证书文件，可自建或由 CA 机构颁发</td>
</tr>
<tr>
<td align="left">ssl_certificate_key</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">PEM 格式的网站证书私钥文件，可自建或由 CA 机构颁发</td>
</tr>
<tr>
<td align="left">ssl_password_file</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">存放网站证书私钥密码的文件，一个密码一行，有多个密码时，Nginx 会依次尝试</td>
</tr>
<tr>
<td align="left">ssl_ciphers</td>
<td align="left">ciphers</td>
<td align="left">HIGH: !aNULL: !MD5</td>
<td align="left">设置 HTTPS 建立连接时用于协商使用的加密算法组合，也称密码套件，指令值内容为 openssl 的密码套件名称，多个套件名称间用”:”分隔</td>
</tr>
<tr>
<td align="left">ssl_prefer_server_ciphers</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用在 SSLv3 和 TLSv1 协议的 HTTPS 连接时优先使用服务端设置的密码套件</td>
</tr>
<tr>
<td align="left">ssl_dhparam</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">DH 密钥交换的 Diffie-Hellman 参数文件</td>
</tr>
<tr>
<td align="left">ssl_ecdh_curve</td>
<td align="left">curve</td>
<td align="left">auto</td>
<td align="left">配置 SSL 加密时使用椭圆曲线DH密钥交换的曲线参数，多个参数间使用”:”分隔。ecdh 是 Elliptic-Curve 和 Diffie-Hellman 的缩写，指令值为 auto 时，配置的曲线参数是 prime256v1</td>
</tr>
<tr>
<td align="left">ssl_early_data</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用 TLS 1.3 0-RTT 支持</td>
</tr>
<tr>
<td align="left">ssl_session_cache</td>
<td align="left">off 或 none 或 [builtin[:size]] [shared:name:size]</td>
<td align="left">none</td>
<td align="left">HTTPS 会话缓存设置，指令值参数见后面的介绍</td>
</tr>
<tr>
<td align="left">ssl_session_tickets</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">是否启用会话凭证（Session Ticket）机制实现 HTTPS 会话缓存，当指令值为 off 时，使用会话编号（Session ID）机制</td>
</tr>
<tr>
<td align="left">ssl_session_ticket_key</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定会话凭证密钥文件，用于在多台 Nginx 间实现会话凭证共享，否则 Nginx 会随机生成一个会话凭证密钥</td>
</tr>
<tr>
<td align="left">ssl_session_timeout</td>
<td align="left">time</td>
<td align="left">5m</td>
<td align="left">设置客户端可用会话缓存的超时时间</td>
</tr>
<tr>
<td align="left">ssl_verify_client</td>
<td align="left">on 或 off 或 optional 或 optional_no_ca</td>
<td align="left">off</td>
<td align="left">设置是否启用客户端证书验证功能。当指令值为 on 时启用验证；当指令值为 optional 时，如果接收到客户端证书则启用验证；当指令值为 optional_no_ca 时，若接收到客户端证书则启用客户端证书验证，但不进行证书链校验。将验证结果存储在 $ssl_client_verity 变量中</td>
</tr>
<tr>
<td align="left">ssl_verify_depth</td>
<td align="left">number</td>
<td align="left">1</td>
<td align="left">设置客户端证书链验证深度</td>
</tr>
<tr>
<td align="left">ssl_crl</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">用于验证客户端证书有效性的证书吊销列表文件</td>
</tr>
<tr>
<td align="left">ssl_client_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定一个 PEM 格式的 CA 证书（根或中间证书）文件，该证书用作在线证书协议（OCSP）响应的证书验证或客户端证书验证，该证书列表会发送给客户端</td>
</tr>
<tr>
<td align="left">ssl_trusted_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定一个 PEM 格式的 CA 证书（根或中间证书）文件，该证书用作在线证书协议响应的证书验证或客户端证书验证，该证书列表不会发送给客户端</td>
</tr>
<tr>
<td align="left">ssl_stapling</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用在线证书协议结果缓存</td>
</tr>
<tr>
<td align="left">ssl_stapling_file</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">在线证书协议结果缓存文件</td>
</tr>
<tr>
<td align="left">ssl_stapling_responder</td>
<td align="left">url</td>
<td align="left">–</td>
<td align="left">设置获取在线证书协议结果的 URL，优先级低于 ssl_stapling_file，仅支持 HTTP 协议，默认端口为 80</td>
</tr>
<tr>
<td align="left">ssl_stapling_verify</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置是否启用在线证书协议结果缓存证书验证</td>
</tr>
</tbody></table>
<ol>
<li>上述指令都可编写在 http、server 指令域中。</li>
<li>ssl_ciphers 指令值的内容是 OpenSSL 参数 ciphers 的内容，可通过如下命令查看。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl ciphers                 <span class="comment"># 列出OpenSSL支持的密码套件</span></span><br><span class="line">openssl ciphers -v <span class="string">&#x27;ALL:eNULL&#x27;</span>  <span class="comment"># 列出指定密码套件详情</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>密码套件格式及说明可参见 OpenSSL 相关文档。</li>
<li>ssl_session_cache 指令值参数如下。</li>
</ol>
<ul>
<li>off:禁用 HTTPS 会话缓存；</li>
<li>none:启用伪会话缓存支持，Nginx 告知客户端可进行会话重用，但服务端并未存储会话参数；</li>
<li>builtin:使用内置 OpenSSL 缓存机制，无法在 Nginx 的多个工作进程中共享缓存内容；</li>
<li>shared:使用 Nginx 的共享缓存机制，会在 Nginx 的多个工作进程中共享缓存内容，1MB 内存可以存储 4000 个会话。</li>
</ul>
<h4 id="HTTPS-基本配置"><a href="#HTTPS-基本配置" class="headerlink" title="HTTPS 基本配置"></a>HTTPS 基本配置</h4><p>HTTPS 协议数据的传输是基于 SSL 层加密的数据，</p>
<p>简单模型：</p>
<ol>
<li>服务端获得客户请求后，将用私钥加密的协商数据发送给客户端。</li>
<li>客户端先使用服务端提供的公钥解密协商数据并读取真实的内容，再用公钥加密返回协商数据并发送给服务端，完成彼此间的密钥协商。</li>
<li>密钥协商完毕后，服务端和客户端通过协商后的密钥进行通信数据的加解密传输。</li>
<li>私钥只存放在<strong>服务端</strong>，公钥则由所有的<strong>客户端</strong>持有。</li>
</ol>
<p>使用第三方 CA 机构的证书实现对服务器身份的认证和网站公钥的安全传递。HTTPS 先通过非对称加密方式交换密钥，建立连接后再通过协商后的密钥与加密算法进行对称加密数据传输，如下图所示。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200Z3150252264.D8eNiZEc.gif" alt="img"></p>
<ol>
<li>服务端按照自身的域名等身份信息创建网站证书私钥和网站证书申请文件，网站管理员将证书申请文件提交给 CA 机构并获得网站证书，网站证书和网站证书私钥被部署到服务端。</li>
<li>客户端发送包含协议版本号、客户端随机数（Client Random）、支持加密套件列表的请求给服务端。</li>
<li>服务端获得客户端 HTTPS 请求后，将包含网站信息及网站证书公钥的证书、服务端随机数（Server Random）及随机选择的客户端支持加密套件返回给客户端，若需要验证客户端身份，也会在此时发送相关信息给客户端。</li>
<li>客户端通过操作系统中的 CA 公钥解密证书获取网站证书公钥并进行网站证书的合法性、有效期和是否被吊销的验证。</li>
<li>客户端用网站证书公钥将新生成的客户端随机数加密后发送给服务端，同时使用 3 个随机数生成会话密钥。</li>
<li>服务端使用网站证书私钥解密客户端数据获取客户端随机数（Pre-master），使用 3 个随机数生成会话密钥。</li>
<li>服务端与客户端使用一致的会话密钥和加密算法完成传输数据的加解密交互。</li>
</ol>
<p>HTTPS 网站证书是由 CA 机构颁发的，网站管理员只需按照相关流程向 CA 机构提交请求文件即可，操作步骤如下。</p>
<ul>
<li><strong>生成请求文件</strong></li>
</ul>
<p>生成请求文件的脚本如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建无密码网站证书私钥文件的请求文件</span></span><br><span class="line">openssl req -out /etc/nginx/conf/ssl/www_nginxbar_org.csr -new -sha256 -newkey rsa:2048 -nodes -keyout /etc/nginx/conf/ssl/www_nginxbar_org.key -subj <span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=admin/CN=nginxbar.com/emailAddress=admin@nginxbar.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建有密码私钥文件的请求文件</span></span><br><span class="line">openssl genrsa -aes256 -passout pass:111111 -out /etc/nginx/conf/ssl/www_nginxbar_org.key 2048</span><br><span class="line"></span><br><span class="line">openssl req -out /etc/nginx/conf/ssl/www_nginxbar_org.csr -new -sha256 -nodes -passin pass:111111 -key /etc/nginx/conf/ssl/www_nginxbar_org.key -subj <span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=admin/CN=nginxbar.com/emailAddress=admin@nginxbar.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 保存私钥密码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;111111&quot;</span> &gt;&gt;/etc/nginx/conf/ssl/www_nginxbar_org.pass</span><br></pre></td></tr></table></figure>

<p>网站证书私钥文件是否需要密码由用户自行选择，只需选择一种方式执行即可。</p>
<ul>
<li><strong>获取证书文件</strong></li>
</ul>
<p>将 www_nginxbar_org.csr 文件提交给 CA 机构后，即可获得 Nginx 支持的 PEM 格式证书文件。</p>
<p>CA 机构为方便进行证书管理，通常会以证书链的方式进行网站证书的颁发与验证，证书链通常由网站证书、中间证书与根证书组成。证书链的验证是由网站证书开始、自下而上进行信任验证传递的。根证书通常存放在客户端，吊销根证书的过程非常困难；中间证书只是增加了一个中间验证环节，可以减少 CA 机构对根证书的管理维护工作，吊销也相对简单。除了向 CA 机构申请证书外，也可以自签证书在内部使用，自签证书操作如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建独立站点使用的自签证书</span></span><br><span class="line">openssl req -new -x509 -nodes -out /etc/nginx/conf/ssl/www_nginxbar_org.pem -keyout /etc/nginx/conf/ssl/www_nginxbar_org.key -days 3650 -subj <span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=admin/CN=nginxbar.com/emailAddress=admin@nginxbar.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建独立站点使用有密码的网站证书私钥文件的自签证书</span></span><br><span class="line">openssl genrsa -aes256 -passout pass:111111 -out /etc/nginx/conf/ssl/www_nginxbar_org.key 2048</span><br><span class="line"></span><br><span class="line">openssl req -new -x509 -nodes -out /etc/nginx/conf/ssl/www_nginxbar_org.pem -passin pass:111111 -key /etc/nginx/conf/ssl/www_nginxbar_org.key -days 3650 -subj <span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=admin/CN=nginxbar.com/emailAddress=admin@nginxbar.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 保存私钥密码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;111111&quot;</span> &gt;&gt;/etc/nginx/conf/ssl/www_nginxbar_org.pass</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建自签客户端证书</span></span><br><span class="line">openssl req -new -x509 -nodes -out /etc/nginx/conf/ssl/client.pem -keyout /etc/nginx/conf/ssl/client.key -days 3650 -subj <span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=admin/CN=nginxbar.com/emailAddress=admin@nginxbar.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 转换客户端证书为可被浏览器导入的pkcs12格式</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> /etc/nginx/conf/ssl/client.pem -inkey /etc/nginx/conf/ssl/client.key -out /etc/nginx/conf/ssl/client.p12</span><br></pre></td></tr></table></figure>

<p>获得网站证书后，可以按照如下方式配置 HTTPS 站点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;                                 <span class="comment"># 启用HTTPS支持</span></span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;       <span class="comment"># HTTPS网站证书</span></span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;   <span class="comment"># HTTPS网站证书私钥</span></span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;    <span class="comment"># HTTPS网站证书私钥密码文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTTPS-密钥交换算法"><a href="#HTTPS-密钥交换算法" class="headerlink" title="HTTPS 密钥交换算法"></a>HTTPS 密钥交换算法</h4><p>在 HTTPS 建立连接进行密钥交换阶段，可以通过多种密钥交换算法实现密钥交换。基于 RSA 的密钥交换过程是客户端把第 3 个随机数发送给服务端，但在 HTTPS 建立连接阶段的传输仍是明文的，会存在安全问题。</p>
<p>DH（Diffie-Hellman）密钥交换算法可保证通信双方在明文传输的环境下安全地交换密钥。基于 DH 的密钥交换过程是在服务端产生服务端随机数后，将 DH 参数和密钥交换服务端公钥加密后传递给客户端，客户端根据 DH 参数和密钥交换服务端公钥计算出第 3 个随机数，并把自己产生的密钥更换为客户端公钥发送给服务端，服务端依据密钥交换客户端公钥计算出第 3 个随机数并完成后续的操作。</p>
<p>椭圆曲线的 DH（ECDH）密钥交换算法与 DH 交换算法相似，但使用了不同的数学模型。在使用椭圆曲线的 DH 密钥交换时，服务器会为密钥交换指定一条预先定义好参数的曲线，Nginx 的 ECDH 密钥交换默认配置的是 prime256v1 曲线算法。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;</span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;</span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;</span><br><span class="line">    ssl_dhparam ssl/dhparam.pem;                    <span class="comment"># DH参数文件</span></span><br><span class="line">    ssl_ecdh_curve auto;                            <span class="comment"># ECDH椭圆曲线算法为prime256v1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DH 参数文件可通过如下命令生成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dhparam -out /etc/nginx/conf/ssl/dhparam.pem 2048</span><br></pre></td></tr></table></figure>

<p>基于 DH 的密钥交换算法也称前向加密（Forward Secrecy）或完全前向加密（Perfect Forward Secrecy），其应用场景是即便日后服务器的 SSL 私钥被第三方获得，后者也无法推算出会话密钥。</p>
<h4 id="HTTPS-会话缓存"><a href="#HTTPS-会话缓存" class="headerlink" title="HTTPS 会话缓存"></a>HTTPS 会话缓存</h4><p>HTTPS 建立连接时传递证书及协商会话密钥会占用一定资源，为加快 HTTPS 建立连接的速度，提升性能，TLS 协议使用了会话缓存机制。会话缓存机制可以使已经断开连接的 HTTPS 会话重用之前的协商会话密钥继续 HTTPS 数据传输。会话缓存机制有两种实现方式:会话编号（Session ID）和会话凭证（Session Ticket）。</p>
<p><strong>会话编号</strong></p>
<p>服务端在与客户端进行数据传输时，会为每次会话生成一个会话编号，并存储该会话编号与会话协商数据。HTTPS 会话中断需要重新连接时，客户端将最后一次会话的会话编号发送给服务端，服务端检查存储中该编号是否存在，如果存在就与客户端使用原有的会话密钥进行数据传输。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;</span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;</span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;               <span class="comment"># HTTPS会话缓存存储大小为10MB</span></span><br><span class="line">    ssl_session_tickets off;                        <span class="comment"># 以会话编号机制实现会话缓存</span></span><br><span class="line">    ssl_session_timeout 10m;                        <span class="comment"># 会话缓存超时时间为10分钟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里作以下两点说明。</p>
<ul>
<li>服务端会存储会话编号和会话协商数据，相对会消耗服务器资源；</li>
<li>当 Nginx 服务器为多台时，无法实现会话共享。</li>
</ul>
<p><strong>会话凭证</strong></p>
<p>会话凭证类似于 cookie，它将协商的通信数据加密之后发送给客户端保存，服务端只保存密钥。HTTPS 建立连接后，服务端发送一个会话凭证给客户端，当需要重新连接时，客户端发送会话凭证与服务端恢复会话连接。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;</span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;</span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;               <span class="comment"># HTTPS会话缓存存储大小为10MB</span></span><br><span class="line">    ssl_session_tickets off;                        <span class="comment"># 以会话凭证机制实现会话缓存</span></span><br><span class="line">    ssl_session_timeout 10m;                        <span class="comment"># 会话缓存超时时间为10分钟</span></span><br><span class="line">    ssl_session_ticket_key ssl/session_ticket.key;  <span class="comment"># 会话凭证密钥文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ssl_session_ticket_key 可以实现多台 Nginx 间共用会话缓存，解决了会话缓存共享问题，可通过如下命令生成:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand 80 &gt; /etc/nginx/conf/ssl/session_ticket.key</span><br></pre></td></tr></table></figure>

<h4 id="HTTPS-双向认证配置"><a href="#HTTPS-双向认证配置" class="headerlink" title="HTTPS 双向认证配置"></a>HTTPS 双向认证配置</h4><p>通常网站的 HTTPS 访问，都是客户端通过证书验证所访问服务器的身份，而服务器对来访的客户端并不做身份验证，也称单向认证。在一些场景中，也会增加客户端身份验证以提高数据传输的安全性，这就是双向认证。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;</span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;</span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    ssl_session_ticket_key ssl/session_ticket.key;</span><br><span class="line"></span><br><span class="line">    ssl_verify_client on;                          <span class="comment"># 启用客户端证书认证</span></span><br><span class="line">    ssl_client_certificate ssl/ca.pem;             <span class="comment"># 客户端证书信任链的CA中间证书或根证书</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTTPS-吊销证书配置"><a href="#HTTPS-吊销证书配置" class="headerlink" title="HTTPS 吊销证书配置"></a>HTTPS 吊销证书配置</h4><p>HTTPS 的证书会因安全原因在正常有效期到期前进行证书变更，为了方便客户端或浏览器及时判断当前使用的网站证书是否已被吊销，通常会采用以下两种方式实现:证书吊销列表（CRL）和在线证书协议（OCSP）。</p>
<p><strong>证书吊销列表</strong></p>
<p>证书吊销列表是由 CA 机构维护的列表，列表中包含已被吊销的证书序列号和时间，通常在 CA 机构证书中都会包含 CRL 下载地址。证书吊销列表 Nginx 配置如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;</span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;</span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    ssl_session_ticket_key ssl/session_ticket.key;</span><br><span class="line"></span><br><span class="line">    ssl_crl ssl/ca.crl;                          <span class="comment"># 证书吊销列表文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>证书吊销列表可通过查看网站证书字段”CRL分发点”的字段值下载获得。</p>
<p><strong>在线证书协议</strong></p>
<p>在线证书协议是一个吊销证书在线查询协议，虽然可以实现实时查询，但同时也会因在 HTTPS 建立连接时查询 OCSP 接口引发性能问题。为解决 OCSP 查询造成的性能影响，引入了 OCSP Stapling 机制，即由 HTTPS 服务器查询 OCSP 接口或本地 OCSP 缓存，并通过证书状态消息返回给客户端。</p>
<p>在线证书协议缓存 Nginx 配置如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">resolver 114.114.114.114 valid=300s;             <span class="comment"># DNS服务器地址</span></span><br><span class="line">resolver_timeout 1s;                             <span class="comment"># DNS解析超时时间为1s</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;</span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;</span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    ssl_session_ticket_key ssl/session_ticket.key;</span><br><span class="line"></span><br><span class="line">    ssl_stapling on;                                 <span class="comment"># 启用OCSP缓存</span></span><br><span class="line">    ssl_stapling_file ssl/ocsp.pem;                  <span class="comment"># OCSP结果缓存文件</span></span><br><span class="line">    ssl_stapling_responder http://ocsp.example.com/; <span class="comment"># 设置获取OCSP结果的URL</span></span><br><span class="line">    ssl_stapling_verify on;                          <span class="comment"># 设置OCSP结果缓存证书验证</span></span><br><span class="line">    ssl_trusted_certificate ssl/ca.pem;              <span class="comment"># 网站证书信任证书链的中间证书文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，OCSP 结果缓存文件和获取 OCSP 结果的 URL 同时设置时，OCSP 结果缓存文件的优先级最高。</p>
<p>OCSP 响应结果可通过如下命令获得。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl ocsp -issuer /etc/nginx/conf/ssl/ca.pem -cert</span><br><span class="line">/etc/nginx/conf/ssl/www_nginxbar_org.pem -no_nonce -text -url</span><br><span class="line">http://ocsp.example.com -text -respout /etc/nginx/conf/ssl/ocsp.pem</span><br></pre></td></tr></table></figure>

<h4 id="HTTPS-配置样例"><a href="#HTTPS-配置样例" class="headerlink" title="HTTPS 配置样例"></a>HTTPS 配置样例</h4><p>HTTPS 通过加密通道保护客户端与服务端之间的数据传输，极大地降低了数据被窃取、篡改的风险，增强了网站对数据安全的保护能力，已成为当前网站建设的必选配置。根据Nginx提供的配置指令，HTTPS 配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">resolver 114.114.114.114 valid=300s;               <span class="comment"># DNS服务器地址</span></span><br><span class="line">resolver_timeout 5s;                               <span class="comment"># DNS解析超时时间为5s</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;   <span class="comment"># DNS服务器地址</span></span><br><span class="line">    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;                  <span class="comment"># 启用服务端密码组件优先</span></span><br><span class="line">    ssl_dhparam  ssl/dhparam.pem;                  <span class="comment"># 设置DH密钥交换算法参数</span></span><br><span class="line">    ssl_ecdh_curve secp384r1;                      <span class="comment"># DH密钥交换椭圆曲线算法为secp384r1</span></span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;      <span class="comment"># 网站证书文件</span></span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;  <span class="comment"># 网站证书密钥文件</span></span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;   <span class="comment"># 网站证书密钥密码文件</span></span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;              <span class="comment"># 会话缓存存储大小为10MB</span></span><br><span class="line">    ssl_session_timeout  10m;                      <span class="comment"># 会话缓存超时时间为10分钟</span></span><br><span class="line">    ssl_session_tickets on;                        <span class="comment"># 设置会话凭证为会话缓存机制</span></span><br><span class="line">    ssl_session_ticket_key  ssl/session_ticket.key;# 设置会话凭证密钥文件</span><br><span class="line"></span><br><span class="line">    ssl_stapling on;                               <span class="comment"># 启用OCSP缓存</span></span><br><span class="line">    ssl_stapling_file ssl/ocsp.pem;                <span class="comment"># OCSP结果缓存文件</span></span><br><span class="line">    ssl_stapling_verify on;                        <span class="comment"># 设置OCSP结果缓存证书验证</span></span><br><span class="line">    ssl_trusted_certificate  ssl/ca.pem;           <span class="comment"># 网站证书信任证书链的中间证书文件</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 启用HSTS</span></span><br><span class="line">    add_header Strict-Transport-Security <span class="string">&quot;max-age=63072000; includeSubDomains; preload&quot;</span>;</span><br><span class="line"></span><br><span class="line">    add_header X-Frame-Options DENY;               <span class="comment"># 禁止被嵌入框架</span></span><br><span class="line">    add_header X-XSS-Protection <span class="string">&quot;1; mode=block&quot;</span>;   <span class="comment"># XSS跨站防护</span></span><br><span class="line">    add_header X-Content-Type-Options nosniff;     <span class="comment"># 防止在浏览器中的MIME类型混淆攻击</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    rewrite ^(.*)$  https://$host<span class="variable">$1</span>? permanent;    <span class="comment"># 强制HTTP访问跳转为HTTPS访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过网站 ssllabs.com 对 HTTPS 的配置进行安全性检测，并按照测试结果有针对性地进行优化。</p>
<h3 id="FastCGI模块配置简述"><a href="#FastCGI模块配置简述" class="headerlink" title="FastCGI模块配置简述"></a>FastCGI模块配置简述</h3><p>Nginx 的 FastCGI 模块默认编译在 Nginx 的二进制文件中，无须单独编译。该模块配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fastcgi_bind</td>
<td align="left">address [transparent] 或 off</td>
<td align="left">–</td>
<td align="left">设置从指定的本地 IP 地址及端口号与 FastCGI 服务器建立连接，指令值可以是变量。当指令值参数为 transparent 时，允许将客户端的真实 IP 透传给 FastCGI 服务器，并以客户端真实 IP 为访问 FastCGI 服务器的源 IP，当指令值为 off 时，取消上一层指令域同名指令的配置</td>
</tr>
<tr>
<td align="left">fastegi_buffering</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否启用响应数据缓冲区</td>
</tr>
<tr>
<td align="left">fastcgi_buffers</td>
<td align="left">number size</td>
<td align="left">8 4k 或 8k</td>
<td align="left">设置单个连接从 FastCGI 服务器接收响应数据缓冲区的数量及单个缓冲区的大小，至少是两个</td>
</tr>
<tr>
<td align="left">fastcgi_buffer_size</td>
<td align="left">size</td>
<td align="left">4k 或 8k</td>
<td align="left">设置用于读取 FastCGI 服务器响应数据第一部分的缓冲区大小，默认值根据操作系统平台的不同为 4KB 或 8KB</td>
</tr>
<tr>
<td align="left">fastcgi_busy_buffers_size</td>
<td align="left">size</td>
<td align="left">8k 或 16k</td>
<td align="left">限制在响应数据未完全读取完毕时忙于向客户端发送响应的缓冲区的大小，以使其余的缓冲区用于读取响应数据。该值必须大于单个缓冲区或 fastcgi_buffer_size 的大小，小于总缓冲区大小减掉一个缓冲区的大小</td>
</tr>
<tr>
<td align="left">fastcgi_limit_rate</td>
<td align="left">rate</td>
<td align="left">0</td>
<td align="left">限制从 FastCGI 服务器读取响应的每个请求的速率，单位是字节&#x2F;秒，指令值为 0 表示不限制。该指令只在 fastcgi_buffer_ing 启用时有效</td>
</tr>
<tr>
<td align="left">fastcgi_max_temp_file_size</td>
<td align="left">size</td>
<td align="left">1024m</td>
<td align="left">当响应数据超出响应数据缓冲区的大小时，超出部分的数据将存储于临时文件中。该指令用于设置临时文件的最大值。该指令值必须大于单个缓冲区或 fastcgi_buffer_size 的大小</td>
</tr>
<tr>
<td align="left">fastegi_temp_file_write_size</td>
<td align="left">size</td>
<td align="left">8k 或 16k</td>
<td align="left">限制一次写入临时文件的数据大小。默认配置下，其大小通过 fastcgi-buffer-size 和 fastcgi-buffers 指令配置进行限制，最大值是 fastcgi_max_temp_file_size 指令的值，最小值必须大于单个缓冲区或 fastcgi_buffer_size 的大小</td>
</tr>
<tr>
<td align="left">fastcgi_temp_path</td>
<td align="left">path[level1 [level2[level3]]]</td>
<td align="left">fastcgi_temp</td>
<td align="left">设置临时文件存储目录</td>
</tr>
<tr>
<td align="left">fastcgi_request_buffering</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否在将请求转发给 FastCGI 服务器之前先从客户端读取整个请求体。当禁用该功能时，如果已经发送请求主体，则无法将请求传递到下一个服务器</td>
</tr>
<tr>
<td align="left">fastcgi_store</td>
<td align="left">on、off 或 string</td>
<td align="left">off</td>
<td align="left">设置是否将 FastCGI 的响应数据在本地持久存储。当指令值为 on 时，存储路径为 root 或 alias 的设置。该指令可以为不经常变更的 FastCGI 响应文件创建本地镜像。响应数据先存储到临时文件中，再进行复制或重命名存储</td>
</tr>
<tr>
<td align="left">fastcgi_store_access</td>
<td align="left">users:permissions…</td>
<td align="left">user:rw</td>
<td align="left">设置创建持久存储路径的文件夹权限</td>
</tr>
<tr>
<td align="left">fastcgi_cache</td>
<td align="left">zone 或 off</td>
<td align="left">off</td>
<td align="left">设置一个共享内存 zone 用作缓存</td>
</tr>
<tr>
<td align="left">fastegi_cache_path</td>
<td align="left">path 参数</td>
<td align="left">–</td>
<td align="left">设置缓存文件存储路径及参数。缓存数据以 URL 的 MD5 值命名并存储在缓存目录中。</td>
</tr>
<tr>
<td align="left">fastcgi_cache_bypass</td>
<td align="left">string…</td>
<td align="left">–</td>
<td align="left">设置不使用缓存响应数据的条件，指令值中至少有一个值不为空或 0 时，当前请求不使用缓存中的响应数据</td>
</tr>
<tr>
<td align="left">fastcgi_cache_key</td>
<td align="left">string</td>
<td align="left">–</td>
<td align="left">设置缓存的关键字</td>
</tr>
<tr>
<td align="left">fastegi_cache_lock</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用缓存锁指令。向 FastCGI 发送请求时，每次只允许一个请求按照 fastcgi_cache_key 指令设置的标识增添新的缓存数据，其他相同的请求将等待缓存中出现响应数据或该缓存锁被释放，等待时间由 fastcgi_cache_lock_timeout 指令设置</td>
</tr>
<tr>
<td align="left">fastcgi_cache_lock_age</td>
<td align="left">time</td>
<td align="left">5s</td>
<td align="left">如果一个请求在该指令设定的时间内没有完成响应数据缓存的添加，则再向 FastCGI 发送一次请求</td>
</tr>
<tr>
<td align="left">fastcgi_cache_lock_timeout</td>
<td align="left">time</td>
<td align="left">5s</td>
<td align="left">缓存锁超时时间。超过该时间的请求将直接从 FastCGI 读取响应</td>
</tr>
<tr>
<td align="left">fastcgi_cache_max_range_offset</td>
<td align="left">number</td>
<td align="left">–</td>
<td align="left">用于设置范围请求（byte-range）请求时的最大偏移量。超出该偏移量的请求将直接从 FastCGI 读取响应</td>
</tr>
<tr>
<td align="left">fastcgi_cache_methods</td>
<td align="left">GET、HEAD 或 POST …</td>
<td align="left">GET HEAD</td>
<td align="left">指定可被缓存的请求方法列表</td>
</tr>
<tr>
<td align="left">fastcgi_cache_min_uses</td>
<td align="left">number</td>
<td align="left">1</td>
<td align="left">响应数据超过设置请求次数后将被缓存</td>
</tr>
<tr>
<td align="left">fastcgi_no_cache</td>
<td align="left">string…</td>
<td align="left">–</td>
<td align="left">指定字符串的值不为空或不等于 0，则不对当前请求的响应数据进行缓存</td>
</tr>
<tr>
<td align="left">fastcgi_cache_purge</td>
<td align="left">string…</td>
<td align="left">–</td>
<td align="left">定义清除缓存请求条件，若指定的字符串不为空或 0，则将 fastcgi_cache_key 设置的标识的缓存清除。清除成功则返回状态码 204，商业版有效</td>
</tr>
<tr>
<td align="left">fastcgi_cache_revalidate</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置在 HTTP 头中有字段属性 If-Modified-Since 和 If-None-Match 时是否启用重新验证</td>
</tr>
<tr>
<td align="left">fastcgi_cache_use_stale</td>
<td align="left">error、timeout、 invalid_header、 updating、http_500、 http_503、http_403、 http_404、http_429、 off…</td>
<td align="left">off</td>
<td align="left">当出现指定的条件时，使用已经过期的缓存响应数据</td>
</tr>
<tr>
<td align="left">fastcgi_cache_background_update</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">当允许使用过期的响应数据时，设置是否启用后台子请求更新过期缓存，同时向客户端返回过期的缓存响应数据</td>
</tr>
<tr>
<td align="left">fastcgi_cache_valid</td>
<td align="left">[code…]time</td>
<td align="left">–</td>
<td align="left">根据响应码设置缓存时间</td>
</tr>
<tr>
<td align="left">fastcgi_catch_stderr</td>
<td align="left">string</td>
<td align="left">–</td>
<td align="left">错误响应标识。若 FastCGI 响应中包含指定的字符串，则被判断为返回了无效响应</td>
</tr>
<tr>
<td align="left">fastcgi_index</td>
<td align="left">name</td>
<td align="left">–</td>
<td align="left">设置默认 index 文件</td>
</tr>
<tr>
<td align="left">fastcgi_pass</td>
<td align="left">address</td>
<td align="left">–</td>
<td align="left">设置 FastCGI 服务器的 IP 地址或套接字，也可以是域名或 upstream 定义的服务器组</td>
</tr>
<tr>
<td align="left">fastcgi_pass_request_body</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否将客户端请求体传递给 FastCGI 服务器</td>
</tr>
<tr>
<td align="left">fastcgi_pass_request_headers</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否将客户端请求头传递给 FastCGI 服务器</td>
</tr>
<tr>
<td align="left">fastcgi_force_ranges</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">无论 FastCGI 的 HTTP 响应头中是否有字段 Accept-Ranges，都启用 byte-range 请求支持</td>
</tr>
<tr>
<td align="left">fastcgi_hide_header</td>
<td align="left">field</td>
<td align="left">–</td>
<td align="left">指定 FastCGI 响应数据中不向客户端传递的 HTTP 头字段名称</td>
</tr>
<tr>
<td align="left">fastcgi_pass_header</td>
<td align="left">field</td>
<td align="left">–</td>
<td align="left">默认配置下，Nginx 不会将头字段属性 Status 和 X-Accel-… 传递给客户端，可通过该指令开放传递</td>
</tr>
<tr>
<td align="left">fastcgi_ignore_headers</td>
<td align="left">field…</td>
<td align="left">–</td>
<td align="left">设置禁止 Nginx 处理从 FastCGI 获取响应的头字段</td>
</tr>
<tr>
<td align="left">fastcgi_connect_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">Nginx 与 FastCGI 服务器建立连接的超时时间，通常不超过 75s</td>
</tr>
<tr>
<td align="left">fastcgi_keep_conn</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">默认配置下，FastCGI 发送完响应数据后会立刻关闭连接，当该指令的指令值为 on 时，将启用保持连接</td>
</tr>
<tr>
<td align="left">fastcgi_ignore_client_abort</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置当客户端关闭连接时，是否关闭与 FastCGI 服务器的连接</td>
</tr>
<tr>
<td align="left">fastcgi_read_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个从 FastCGI 服务器接收数据的读操作之间的间隔时间超过设定的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">fastcgi_send_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个发送到 FastCGI 服务器的写操作之间的间隔时间超过设定的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">fastcgi_send_lowat</td>
<td align="left">size</td>
<td align="left">0</td>
<td align="left">设置 FreeBSD 系统中使用 kqueue 驱动时，socket 接口 SO_SNDLOWAT 选项的大小。在 Linux、Solaris 及 Windows 台该指令无效</td>
</tr>
<tr>
<td align="left">fastcgi_socket_keepalive</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置是否对 FastCGI 的连接启用 so-keepalive socket 选项</td>
</tr>
<tr>
<td align="left">fastcgi_intercept_errors</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">在 FastCGI 响应数据中响应码大于或等于 300 时，设置是直接传递给客户端还是重定向给 Nginx，以便 error_page 指令进行处理</td>
</tr>
<tr>
<td align="left">fastcgi_next_upstream</td>
<td align="left">error、timeout、 invalid、header、 http_500、http_503、 http_403、http_404、 http_429、non_idempotent、off…</td>
<td align="left">error timeout</td>
<td align="left">当出现指定的条件时，将未返回响应的客户端请求传递给 upstream 中的下一个服务器</td>
</tr>
<tr>
<td align="left">fastcgi_next_upstream_timeout</td>
<td align="left">time</td>
<td align="left">0</td>
<td align="left">设置将符合条件的请求传递给 upstream 中下一个服务器的超时时间。当指令值为 0 时，关闭该限制</td>
</tr>
<tr>
<td align="left">fastcgi_next_upstream_tries</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">设置将符合条件的请求传递给 upstream 中下一个服务器的尝试次数。当指令值为 0 时，关闭该限制</td>
</tr>
<tr>
<td align="left">fastcgi_split_path_info</td>
<td align="left">regex</td>
<td align="left">–</td>
<td align="left">定义一个正则表达式，可以将 URI 正则匹配赋值到 $fastcgi_script_name 及 $fastcgi_path_info 两个变量中，可用于获取 index.php&#x2F;arg1&#x2F;111&#x2F;arg2&#x2F;222 格式的请求参数</td>
</tr>
<tr>
<td align="left">fastegi_param</td>
<td align="left">parameter value[if_not_empty]</td>
<td align="left">–</td>
<td align="left">设置发送请求到 FastCGI 时传递的请求参数。指令值为 if_not_empty 时，表示当传递的参数值不为空时才进行传递</td>
</tr>
</tbody></table>
<p>对于上表，有以下几点说明。</p>
<ul>
<li>除 fastcgi_cache_path 指令外，FastCGI 模块指令均可编写在 http、server、location 指令域中。</li>
<li>fastcgi_cache_purge 指令仅商业版 Nginx 才支持。开源版可通过第三方模块或自己写脚本实现。</li>
<li>fastcgi_cache_path 指令只能编写在 http 指令域中。</li>
<li>fastcgi_cache 与 fastcgi_store 指令不能在同一指令域中同时使用。</li>
<li>non_idempotent 是指 POST、LOCK、PATCH 请求方法的处理。</li>
</ul>
<p>fastcgi_cache_path 指令值参数如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">参数格式</th>
<th align="left">默认值</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">levels</td>
<td align="left">levels</td>
<td align="left">–</td>
<td align="left">设置缓存目录的层级及命名方式</td>
</tr>
<tr>
<td align="left">use_temp_path</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">当指令值为 on 时，使用 fastcgi_temp_path 设置作为临时文件目录；当指令值为 off 时，使用缓存目录作为临时文件目录</td>
</tr>
<tr>
<td align="left">keys_zone</td>
<td align="left">name:size</td>
<td align="left">–</td>
<td align="left">设置存储 cache_key 的共享内存 zone 及其大小，1MB 内存可以存储 8000 个 key</td>
</tr>
<tr>
<td align="left">inactive</td>
<td align="left">time</td>
<td align="left">10 分钟</td>
<td align="left">设定时间内未被访问的缓存将被删除</td>
</tr>
<tr>
<td align="left">max_size</td>
<td align="left">size</td>
<td align="left">–</td>
<td align="left">缓存数据的最大值，超出设定的最大值时，将执行一次迭代更新，并删除最近使用最少的缓存数据</td>
</tr>
<tr>
<td align="left">manager_files</td>
<td align="left">number</td>
<td align="left">100</td>
<td align="left">当执行一次迭代更新时，删除文件的最大数</td>
</tr>
<tr>
<td align="left">manager_sleep</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">连续两次迭代更新间的最短时间间隔</td>
</tr>
<tr>
<td align="left">manager_threshold</td>
<td align="left">time</td>
<td align="left">200ms</td>
<td align="left">执行一次迭代更新时的最大执行时间</td>
</tr>
<tr>
<td align="left">loader_files</td>
<td align="left">number</td>
<td align="left">100</td>
<td align="left">每次迭代加载时，加载缓存目录中缓存数据的最大文件数</td>
</tr>
<tr>
<td align="left">loader_sleep</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">连续两次迭代加载间的最短时间间隔</td>
</tr>
<tr>
<td align="left">loader_threshold</td>
<td align="left">time</td>
<td align="left">200ms</td>
<td align="left">每次迭代加载时的最大执行时间</td>
</tr>
<tr>
<td align="left">purger</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用缓存清除功能。仅商业版有效</td>
</tr>
<tr>
<td align="left">purger_files</td>
<td align="left">number</td>
<td align="left">10</td>
<td align="left">每次迭代清除时，清除缓存目录中缓存数据的最大文件数。仅商业版有效</td>
</tr>
<tr>
<td align="left">purger_sleep</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">连续两次迭代清除间的最短时间间隔。仅商业版有效</td>
</tr>
<tr>
<td align="left">purger_threshold</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">每次迭代清除时的最大执行时间。仅商业版有效</td>
</tr>
</tbody></table>
<h3 id="基于FastCGI实现负载均衡"><a href="#基于FastCGI实现负载均衡" class="headerlink" title="基于FastCGI实现负载均衡"></a>基于FastCGI实现负载均衡</h3><p>Nginx 支持后端多个 FastCGI 服务器的负载均衡，负载均衡有两种方式:一种是通过域名解析多个 FastCGI 服务器，该方式通过所有域名地址轮询（round-robin）的方式实现负载；另一种是通过配置 Nginx 的 <strong>upstream</strong> 模块实现负载。</p>
<p>本节通过后一种方式实现负载均衡场景的搭建。Nginx 的 FastCGI 模块支持对后端 PHP 解析数据的缓存，对于动态数据的缓存可以在实际应用场景中提升动态网站的访问速度。</p>
<p>Nginx 配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">upstream fscgi_server &#123;</span><br><span class="line">    ip_hash;                               <span class="comment"># session会话保持</span></span><br><span class="line">    server 192.168.2.145:9000;             <span class="comment"># PHP-FPM服务器IP</span></span><br><span class="line">    server 192.168.2.159:9000;             <span class="comment"># PHP-FPM服务器IP</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fastcgi_cache_path /usr/local/nginx/nginx-cache1</span><br><span class="line">                            levels=1:2</span><br><span class="line">                            keys_zone=fscgi_hdd1:100m</span><br><span class="line">                            max_size=10g</span><br><span class="line">                            use_temp_path=off</span><br><span class="line">                            inactive=60m;    <span class="comment"># 设置缓存存储路径1，缓存的共享内存名称和大小</span></span><br><span class="line">                                             <span class="comment"># 100MB，无效缓存的判断时间为1小时</span></span><br><span class="line"></span><br><span class="line">fastcgi_cache_path /usr/local/nginx/nginx-cache2</span><br><span class="line">                            levels=1:2</span><br><span class="line">                            keys_zone=fscgi_hdd2:100m</span><br><span class="line">                            max_size=10g</span><br><span class="line">                            use_temp_path=off</span><br><span class="line">                            inactive=60m;   <span class="comment"># 设置缓存存储路径2，缓存的共享内存名称和大小</span></span><br><span class="line">                                            <span class="comment"># 100MB，无效缓存的判断时间为1小时</span></span><br><span class="line"></span><br><span class="line">split_clients <span class="variable">$request_uri</span> <span class="variable">$fscgi_cache</span> &#123;</span><br><span class="line">              50%           <span class="string">&quot;fscgi_hdd1&quot;</span>;  <span class="comment"># 50%请求的缓存存储在第一个磁盘上</span></span><br><span class="line">              50%           <span class="string">&quot;fscgi_hdd2&quot;</span>;  <span class="comment"># 50%请求的缓存存储在第二个磁盘上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /opt/nginx-web/phpweb;</span><br><span class="line">    index index.php;</span><br><span class="line">    include        fscgi.conf;             <span class="comment"># 引入默认配置文件</span></span><br><span class="line">   </span><br><span class="line">    location ~ \.(gif|jpg|png|htm|html|css|js|flv|ico|swf)(.*) &#123;  <span class="comment"># 静态资源文件过期时间</span></span><br><span class="line">                                                                  <span class="comment"># 为12小时</span></span><br><span class="line">        expires      12h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$no_cache</span> 0;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$query_string</span> != <span class="string">&quot;&quot;</span>) &#123;              <span class="comment"># URI无参数的数据不进行缓存</span></span><br><span class="line">        <span class="built_in">set</span> <span class="variable">$no_cache</span> 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php(.*)$ &#123;</span><br><span class="line">        root /opt/nginx-web/phpweb;</span><br><span class="line"></span><br><span class="line">        fastcgi_cache <span class="variable">$fscgi_cache</span>;        <span class="comment"># 启用fastcgi_cache_path设置的$fscgi_cache</span></span><br><span class="line">                                           <span class="comment"># 的共享内存区域做缓存</span></span><br><span class="line">        fastcgi_cache_key <span class="variable">$&#123;request_method&#125;</span>://$host<span class="variable">$request_uri</span>; <span class="comment"># 设置缓存的关键字</span></span><br><span class="line">        fastcgi_cache_lock on;             <span class="comment"># 启用缓存锁</span></span><br><span class="line">        fastcgi_cache_lock_age 5s;         <span class="comment"># 启用缓存锁时，添加缓存请求的处理时间为5s</span></span><br><span class="line">        fastcgi_cache_lock_timeout 5s;     <span class="comment"># 等待缓存锁超时时间为5s</span></span><br><span class="line">        fastcgi_cache_methods GET HEAD;    <span class="comment"># 默认对GET及HEAD方法的请求进行缓存</span></span><br><span class="line">        fastcgi_cache_min_uses 1;          <span class="comment"># 响应数据被请求一次就将被缓存</span></span><br><span class="line"></span><br><span class="line">        fastcgi_no_cache <span class="variable">$no_cache</span>;        <span class="comment"># $no_cache时对当前请求不进行缓存</span></span><br><span class="line">        fastcgi_cache_bypass <span class="variable">$no_cache</span>;    <span class="comment"># $no_cache时对当前请求不进行缓存</span></span><br><span class="line"></span><br><span class="line">        fastcgi_cache_use_stale error <span class="built_in">timeout</span> invalid_header</span><br><span class="line">                                updating http_500 http_503</span><br><span class="line">                                http_403 http_404 http_429;        <span class="comment"># 当出现指定的条件时，使用</span></span><br><span class="line">                                                                   <span class="comment"># 已经过期的缓存响应数据</span></span><br><span class="line">        fastcgi_cache_background_update on; <span class="comment"># 允许使用过期的响应数据时，启用后台子请求用于</span></span><br><span class="line">                                            <span class="comment"># 更新过期缓存，并将过期的缓存响应数据返回给客户端</span></span><br><span class="line"></span><br><span class="line">        fastcgi_cache_revalidate on;       <span class="comment"># 当缓存过期时，向后端服务器发起包含If-</span></span><br><span class="line">                                           <span class="comment"># Modified-Since和If-None-Match HTTP消息</span></span><br><span class="line">                                           <span class="comment"># 头字段的服务端校验</span></span><br><span class="line">        fastcgi_cache_valid 200 301 302 10h; <span class="comment"># 200 301 302状态码的响应缓存10小时</span></span><br><span class="line">        fastcgi_cache_valid any 1m;        <span class="comment"># 其他状态码的响应缓存1分钟</span></span><br><span class="line"></span><br><span class="line">        add_header X-Cache-Status <span class="variable">$upstream_cache_status</span>;   <span class="comment"># 查看缓存命中状态</span></span><br><span class="line"></span><br><span class="line">        fastcgi_pass   fscgi_server;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_split_path_info       ^(.+\.php)(.*)$;      <span class="comment"># 获取$fastcgi_path_info变量值</span></span><br><span class="line">        fastcgi_param PATH_INFO       <span class="variable">$fastcgi_path_info</span>;   <span class="comment"># 赋值给参数PATH_INFO</span></span><br><span class="line">        include        fastcgi.conf;                        <span class="comment"># 引入默认参数文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CGI、FastCGI、SCGI、WSGI网关接口简介"><a href="#CGI、FastCGI、SCGI、WSGI网关接口简介" class="headerlink" title="CGI、FastCGI、SCGI、WSGI网关接口简介"></a>CGI、FastCGI、SCGI、WSGI网关接口简介</h3><p>我们将服务端程序分为了 <strong>web 服务器</strong>和<strong>应用程序服务器</strong>两个部分。web 服务器是用于处理 HTML 文件，让客户可以通过浏览器进行访问。主流的有 Apache、IIS、Nginx、Lghttpd 等。而应用服务器处理业务逻辑，比如使用 python 的 django,flask 写成的程序。</p>
<p>通常来自客户端浏览器的请求被 web 服务器截获，如果是静态请求，则如 nginx 会自己做处理，如果是动态请求，则会抛给后端应用服务器来处理。于是如何在 web 服务器与应用服务器之间进行通信成了主要问题，这就引出了以下四种处理的接口:CGI、FastCGI、SCGI、WSGI。</p>
<p><strong>CGI（Common Gateway Interface，通用网关接口）</strong></p>
<p>CGI 是一种通用网关接口规范，该规范详细描述了 Web 服务器和请求处理程序（脚本解析器）在获取及返回数据过程中传输数据的标准，如 HTTP 协议的参数名称等。大多数 Web 程序以脚本形式接收并处理请求，然后返回响应数据，如脚本程序 PHP、JSP、Python 等。</p>
<p><strong>FastCGI（Fast Common Gateway Interface，快速通用网关接口）</strong></p>
<p>FastCGI 是 CGI 的增强版本，其将请求处理程序独立于 Web 服务器之外，并通过减少系统为创建进程而产生的系统开销，使 Web 服务器可以处理更多的 Web 请求。FastCGI 与 CGI 的区别在于，FastCGI 不像 CGI 那样对 Web 服务器的每个请求均建立一个进程进行请求处理，而是由 FastCGI 服务进程接收 Web 服务器的请求后，由自己的进程自行创建线程完成请求处理。</p>
<p><strong>SCGI（Simple Common Gateway Interface，简单通用网关接口）</strong></p>
<p>SCGI 是 CGI 的替代版本，它与 FastCGI 类似，同样是将请求处理程序独立于 Web 服务器之外，但更容易实现，性能比 FastCGI 要弱一些。</p>
<p><strong>WSGI（Web Server Gateway Interface，Web 服务网关接口）</strong></p>
<p>WSGI 是为 Python 语言中定义的 Web 服务器与 Python 应用程序或框架间的通用通信接口，可以使 Python 应用程序或框架与支持这一协议的不同Web服务器进行通信。常见的 Python Web 框架都实现了该协议的封装。</p>
<hr>
<h3 id="uWSGI模块配置简述"><a href="#uWSGI模块配置简述" class="headerlink" title="uWSGI模块配置简述"></a>uWSGI模块配置简述</h3><p>uWSGI 是 Python 实现 WSGI、uWSGI（uWSGI 独有的协议）、HTTP 等协议功能的 Web 服务器。</p>
<p>Nginx 通过 ngx_http_uwsgi_module 模块实现与 uWSGI 服务器的数据交换并完成 Python 网站的请求处理。</p>
<p>该模块默认编译在 Nginx 二进制文件中，无须单独编译。该模块的配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uwsgi_bind</td>
<td align="left">address [transparent] 或 off</td>
<td align="left">–</td>
<td align="left">设置从指定的本地 IP 地址及端口号与 uWSGI 服务器建立连接，指令值可以是变量。当指令值为 transparent 时，允许将客户端的真实 IP 透传给 uWSGI 服务器，并以客户端真实IP为访问 uWSGI 服务器的源 IP；当指令值为 off 时，则取消上一层指令域同名指令的配置</td>
</tr>
<tr>
<td align="left">uwsgi_buffering</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否启用响应数据缓冲区</td>
</tr>
<tr>
<td align="left">uwsgi_buffers</td>
<td align="left">number size</td>
<td align="left">8 4k 或 8k</td>
<td align="left">设置单个连接从 uWSGI 服务器接收响应数据缓冲区的数量及单个缓冲区的大小。至少是两个</td>
</tr>
<tr>
<td align="left">uwsgi_buffer_size</td>
<td align="left">size</td>
<td align="left">4k 或 8k</td>
<td align="left">设置用于读取 uWSGI 服务器响应数据第一部分的缓冲区大小，默认值根据操作系统平台的不同为 4KB 或 8KB</td>
</tr>
<tr>
<td align="left">uwsgi_busy_buffers_size</td>
<td align="left">size</td>
<td align="left">8k 或 16k</td>
<td align="left">限制在响应数据未完全读取完毕时忙于向客户端发送响应的缓冲区的大小，以使其余的缓冲区用于读取响应数据。该值必须大于单个缓冲区或 uwsgi_buffer_size 的大小，小于总缓冲区大小减掉一个缓冲区的大小</td>
</tr>
<tr>
<td align="left">uwsgi_limit_rate</td>
<td align="left">rate</td>
<td align="left">0</td>
<td align="left">限制从 uWSGI 服务器读取响应的每个请求的速率，单位是字节&#x2F;秒，指令值为 0 表示不限制。该指令只在 uwsgi_buffering 启用时有效</td>
</tr>
<tr>
<td align="left">uwsgi_max_temp_file_size</td>
<td align="left">size</td>
<td align="left">1024m</td>
<td align="left">当响应数据超出响应数据缓冲区的大小时，超出部分的数据将存储于临时文件中。该指令设置临时文件的最大值。该值必须大于单个缓冲区或 uwsgi_buffer_size 的大小</td>
</tr>
<tr>
<td align="left">uwsgi_temp_file_write_size</td>
<td align="left">size</td>
<td align="left">8k 或 16k</td>
<td align="left">限制一次写入临时文件的数据大小。默认配置下，大小通过 uwsgi-buffer-size 和 uwsgi-buffers 配置指令进行限制，最大值是 uwsgi_max_temp_filesize 指令的值，最小值必须大于单个缓冲区或 uwsgi_buffer_size 的大小</td>
</tr>
<tr>
<td align="left">uwsgi_temp_path</td>
<td align="left">path[level1 [level2 [level3]]]</td>
<td align="left">uwsgi_temp</td>
<td align="left">设置临时文件存储目录</td>
</tr>
<tr>
<td align="left">uwsgi_request_buffering</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否在将请求转发给 uWSGI 服务器之前先从客户端读取整个请求体。若禁用该功能，如果已经发送请求主体，则无法将请求传递到下一个服务器。对于基于 HTTP&#x2F;1.1 协议的分块传输请求，会强制读取完整请求体</td>
</tr>
<tr>
<td align="left">uwsgi_store</td>
<td align="left">on 或 off 或 string</td>
<td align="left">off</td>
<td align="left">设置是否将 uWSGI 服务器的响应数据在本地持久存储。当指令值为 on 时，存储路径为 root 或 alias 的设置。该指令可以为不经常变更的 uWSGI 服务器响应文件创建本地镜像。响应数据先存储到临时文件中再进行复制或重命名存储</td>
</tr>
<tr>
<td align="left">uwsgi_store_access</td>
<td align="left">users:permissions…</td>
<td align="left">user:rw</td>
<td align="left">设置创建持久存储路径的文件夹权限</td>
</tr>
<tr>
<td align="left">uwsgi_cache</td>
<td align="left">zone 或 off</td>
<td align="left">off</td>
<td align="left">设置一个共享内存 zone 用作缓存</td>
</tr>
<tr>
<td align="left">uwsgi_cache_path</td>
<td align="left">path 参数</td>
<td align="left">–</td>
<td align="left">设置缓存文件存储路径及参数。缓存数据以 URI 的 MD5 值命名并存储在缓存目录中</td>
</tr>
<tr>
<td align="left">uwsgi_cache_bypass</td>
<td align="left">string…</td>
<td align="left">–</td>
<td align="left">设置不使用缓存响应数据的条件，指令值中至少一个值不为空或 0 时，则当前请求不使用缓存中的响应数据</td>
</tr>
<tr>
<td align="left">uwsgi_cache_key</td>
<td align="left">string</td>
<td align="left">–</td>
<td align="left">设置缓存的关键字</td>
</tr>
<tr>
<td align="left">uwsgi_cache_lock</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用缓存锁指令。向 uWSGI 服务器发送请求时，每次只允许一个请求按照 uwsgi_cache_key 指令设置的标识增添新的缓存数据，其他相同的请求将等待缓存中出现响应数据或该缓存锁被释放，等待时间通过 uwsgi_cache_lock_timeout 指令设置</td>
</tr>
<tr>
<td align="left">uwsgi_cache_lock_age</td>
<td align="left">time</td>
<td align="left">5s</td>
<td align="left">如果一个请求在该指令设定的时间内没有完成响应数据缓存的添加，则向 uWSGI 服务器再发送一次请求</td>
</tr>
<tr>
<td align="left">uwsgi_cache_lock_timeout</td>
<td align="left">time</td>
<td align="left">5s</td>
<td align="left">缓存锁超时时间。超过该时间的请求将直接从 uWSGI 服务器读取响应</td>
</tr>
<tr>
<td align="left">uwsgi_cache_max_range_offset</td>
<td align="left">number</td>
<td align="left">–</td>
<td align="left">用于设置范围请求请求时的最大偏移量。超出该偏移量的请求将直接从 uWSGI 服务器读取响应</td>
</tr>
<tr>
<td align="left">uwsgi_cache_methods</td>
<td align="left">GET、HEAD 或 POST…</td>
<td align="left">GET HEAD</td>
<td align="left">指定可被缓存的请求方法列表</td>
</tr>
<tr>
<td align="left">uwsgi_cache_min_uses</td>
<td align="left">number</td>
<td align="left">1</td>
<td align="left">响应数据超过设置请求次数后将被缓存</td>
</tr>
<tr>
<td align="left">uwsgi_no_cache</td>
<td align="left">string…</td>
<td align="left">–</td>
<td align="left">指定字符串的值不为空或不等于 0，则不对当前请求的响应数据进行缓存</td>
</tr>
<tr>
<td align="left">uwsgi_cache_purge</td>
<td align="left">string</td>
<td align="left">–</td>
<td align="left">定义清除缓存请求条件，若指定的字符串不为空或 0，则对 uwsgi_cache_key 设置的标识的缓存进行清除。清除成功则返回状态码 204。仅商业版有效</td>
</tr>
<tr>
<td align="left">uwsgi_cache_revalidate</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置在 HTTP 头中有字段属性 If-Modified-Since 和 If-None-Match 时是否启用重新验证</td>
</tr>
<tr>
<td align="left">uwsgi_cache_ use_stale</td>
<td align="left">error、timeout、  invalid_header、 updating、http_500、 http_503、http_403、 http_404、http_429、 off …</td>
<td align="left">off</td>
<td align="left">当出现指定的条件时，使用已经过期的缓存响应数据</td>
</tr>
<tr>
<td align="left">uwsgi_cache_background_update</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">允许使用过期的响应数据时，设置是否启用后台子请求更新过期缓存，同时向客户端返回过期的缓存响应数据</td>
</tr>
<tr>
<td align="left">uwsgi_cache_valid</td>
<td align="left">[code …] time</td>
<td align="left">–</td>
<td align="left">根据响应码设置缓存时间</td>
</tr>
<tr>
<td align="left">uwsgi_pass</td>
<td align="left">address</td>
<td align="left">–</td>
<td align="left">设置 uWSGI 服务器的协议、IP 地址或套接字，也可以是域名或 upstream 定义的服务器组。支持的协议有 HTTP、uWSGI、suwsgi（基于 SSL 的 uWSGI）</td>
</tr>
<tr>
<td align="left">uwsgi_pass_request_body</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否将客户端请求体传递给 uWSGI 服务器</td>
</tr>
<tr>
<td align="left">uwsgi_pass_request_headers</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否将客户端请求头传递给 uWSGI 服务器</td>
</tr>
<tr>
<td align="left">uwsgi_force_ranges</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">无论 uWSGI 服务器的 HTTP 响应头中是否有字段 Accept-Ranges，都启用 byte-range 请求支持</td>
</tr>
<tr>
<td align="left">uwsgi_hide_header</td>
<td align="left">field</td>
<td align="left">–</td>
<td align="left">指定 uWSGI 服务器响应数据中不向客户端传递的 HTTP 头字段名称</td>
</tr>
<tr>
<td align="left">uwsgi_pass_header</td>
<td align="left">field</td>
<td align="left">–</td>
<td align="left">默认配置下，Nginx 不会将头字段属性 Status 和 X-Accel-… 传递给客户端，可通过该指令开放传递</td>
</tr>
<tr>
<td align="left">uwsgi_ignore_headers</td>
<td align="left">field …</td>
<td align="left">–</td>
<td align="left">设置禁止 Nginx 处理从 uWSGI 服务器获取响应的头字段</td>
</tr>
<tr>
<td align="left">uwsgi_modifier1</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">设置 uWSGI 数据包头中 modifier1 字段的值</td>
</tr>
<tr>
<td align="left">uwsgi_modifier2</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">设置 uWSGI 数据包头中 modified2 字段的值</td>
</tr>
<tr>
<td align="left">uwsgi_connect_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">Nginx 与 uWSGI 服务器建立连接的超时时间，通常不超过 75s</td>
</tr>
<tr>
<td align="left">uwsgi_ignore_client_abort</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">当客户端关闭连接时，是否关闭与 uWSGI 服务器的连接</td>
</tr>
<tr>
<td align="left">uwsgi_read_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个从 uWSGI 服务器接收数据的读操作之间的间隔时间超过设定的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">uwsgi_send_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个发送到 uWSGI 服务器的写操作之间的间隔时间超过设定的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">uwsgi_socket_keepalive</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置是否对 uWSGI 服务器的连接启用 so-kccpalive socket 选项</td>
</tr>
<tr>
<td align="left">uwsgi_intercept_errors</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">在 uWSGI 服务器响应数据中响应码大于或等于 300 时，设置是直接传递给客户端还是重定向给 Nginx，以便 error_page 指令进行处理</td>
</tr>
<tr>
<td align="left">uwsgi_next_ upstream</td>
<td align="left">error、timeout、 invalid_header、 http_500、http_503、 http_403、http_404、 http_429、 non_idempotent、 off …</td>
<td align="left">error timeout</td>
<td align="left">当出现指定条件时，将未返回响应的客户端请求传递给 upstream 中的下一个服务器</td>
</tr>
<tr>
<td align="left">uwsgi_next_upstream_timeout</td>
<td align="left">time</td>
<td align="left">0</td>
<td align="left">设置将符合条件的请求传递给 upstream 中的下一个服务器的超时时间。指令值为 0 时关闭该限制</td>
</tr>
<tr>
<td align="left">uwsgi_next_upstream_tries</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">设置将符合条件的请求传递给 upstream 中的下一个服务器的尝试次数。指令值为 0 时关闭该限制</td>
</tr>
<tr>
<td align="left">uwsgi_param</td>
<td align="left">parameter value [if_not_empty]</td>
<td align="left">–</td>
<td align="left">设置发送请求到 uWSGI 服务器时传递的请求参数。指令值为 if_not_empty 时，表示传递的参数值不为空时才进行传递</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定用于安全 uWSGI 服务器 SSL 身份认证的 PEM 格式服务器证书文件</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_certificate_key</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定用于安全 uWSGI 服务器 SSL 身份认证的 PEM 格式服务器证书密钥文件</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_password_file</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定一个包含服务器证书密钥密码的文件。文件中每行一个密码，Nginx 将遍历整个文件并尝试有效的密码</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_ciphers</td>
<td align="left">ciphers</td>
<td align="left">DEFAULT</td>
<td align="left">指定用于安全 uWSGI 服务器 SSL 请求的 OpenSSL 格式密码套件</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_crl</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定用于验证安全 uWSGI 服务器 SSL 证书的 PEM 格式吊销证书文件</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_trusted_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定用于验证安全 uWSGI 服务器 SSL 证书的 PEM 格式 CA 证书文件</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_name</td>
<td align="left">name</td>
<td align="left">uwsgi_pass 指 令指定的主机</td>
<td align="left">允许指定并覆盖安全uWSGI服务器SSL证书验证的 主机名，将通过SNI向建立连接的SSL安全uWSGI服 务器进行传递</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_protocols</td>
<td align="left">[SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]</td>
<td align="left">TLSv1 TLSv1.1 TLSv1.2</td>
<td align="left">指定安全 uWSGI 服务器 SSL 协议的版本</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_server_name</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">启用通过 SNI 或 RFC 6066 向建立连接的 SSL 安全 uWSGI 服务器传递主机名</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_session_reuse</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">启用 SSL 会话重用功能</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_verify</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">启用安全 uWSGI 服务器的证书验证功能</td>
</tr>
<tr>
<td align="left">uwsgi_ssl_verify_depth</td>
<td align="left">number</td>
<td align="left">1</td>
<td align="left">设置安全 uWSGI 服务器的证书链的验证深度</td>
</tr>
</tbody></table>
<p>关于上表，有以下几点需要说明:</p>
<ul>
<li>除 uwsgi_cache_path 指令外，uWSGI 模块指令均可编写在 http、server、location 指令域中；</li>
<li>uwsgi_cache_path 指令只能编写在 http 指令域中；</li>
<li>uwsgi_cache 与 uwsgi_store 指令不可在同一指令域中同时使用；</li>
<li>non_idempotent 是指 POST、LOCK、PATCH 请求方法的处理。</li>
</ul>
<p>uwsgi_cache_path 指令值参数如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">参数格式</th>
<th align="left">默认值</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">levels</td>
<td align="left">levels</td>
<td align="left">–</td>
<td align="left">设置缓存目录的层级及命名方式</td>
</tr>
<tr>
<td align="left">use_temp_path</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">当指令值为 on 时，使用 uwsgi_temp_path 设置作为临时文件目录；当指令值为 off 时，使用缓存目录作为临时文件目录</td>
</tr>
<tr>
<td align="left">keys_zone</td>
<td align="left">name:size</td>
<td align="left">–</td>
<td align="left">设置存储 cache_key 的共享内存 zone 及其大小，1MB 内存可以存储 8000 个 key</td>
</tr>
<tr>
<td align="left">inactive</td>
<td align="left">time</td>
<td align="left">10m</td>
<td align="left">设定时间内未被访问的缓存将被删除</td>
</tr>
<tr>
<td align="left">max_size</td>
<td align="left">size</td>
<td align="left">–</td>
<td align="left">缓存数据的最大值，超出设定的最大值时将执行一次迭代更新，并删除最近使用最少的缓存数据</td>
</tr>
<tr>
<td align="left">manager_files</td>
<td align="left">number</td>
<td align="left">100</td>
<td align="left">执行一次迭代更新时删除文件的最大数</td>
</tr>
<tr>
<td align="left">manager_sleep</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">连续两次迭代更新间的最短时间间隔</td>
</tr>
<tr>
<td align="left">manager_threshold</td>
<td align="left">time</td>
<td align="left">200ms</td>
<td align="left">执行一次迭代更新时的最大执行时间</td>
</tr>
<tr>
<td align="left">loader_files</td>
<td align="left">number</td>
<td align="left">100</td>
<td align="left">每次迭代加载时，加载缓存目录中缓存数据的最大文件数</td>
</tr>
<tr>
<td align="left">loader_sleep</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">连续两次迭代加载间的最短时间间隔</td>
</tr>
<tr>
<td align="left">loader_threshold</td>
<td align="left">time</td>
<td align="left">200ms</td>
<td align="left">每次迭代加载时的最大执行时间</td>
</tr>
<tr>
<td align="left">purger</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用缓存清除功能。仅商业版有效</td>
</tr>
<tr>
<td align="left">purger_files</td>
<td align="left">number</td>
<td align="left">10</td>
<td align="left">每次迭代清除时，清除缓存目录中缓存数据的最大文件数。仅商业版有效</td>
</tr>
<tr>
<td align="left">purger_sleep</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">连续两次迭代清除间的最短时间间隔。仅商业版有效</td>
</tr>
<tr>
<td align="left">purger_threshold</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">每次迭代清除时的最大执行时间。仅商业版有效</td>
</tr>
</tbody></table>
<hr>
<h3 id="伪流媒体服务器搭建"><a href="#伪流媒体服务器搭建" class="headerlink" title="伪流媒体服务器搭建"></a>伪流媒体服务器搭建</h3><p>Nginx 支持伪流媒体播放功能，其可以和客户端的 Flash 播放器结合，对以 .flv、.f4f、.mp4、.m4v、.m4a 为扩展名的文件实现流媒体的播放功能。</p>
<p>若启用伪流媒体的支持功能，需要按媒体文件格式在配置编译时增加 –with-http_f4f_module、–with-http_flv_module 和 –with-http_mp4_module 这 3 个参数。</p>
<h4 id="模块配置指令"><a href="#模块配置指令" class="headerlink" title="模块配置指令"></a>模块配置指令</h4><p>伪流媒体模块配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">f4f</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">启用 F4F 文件支持</td>
</tr>
<tr>
<td align="left">f4f_buffer_size</td>
<td align="left">size</td>
<td align="left">512k</td>
<td align="left">设置读取 .f4x 索引文件的缓冲区大小</td>
</tr>
<tr>
<td align="left">flv</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">启用 FLV 文件支持</td>
</tr>
<tr>
<td align="left">mp4</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">启用 MP4 文件支持</td>
</tr>
<tr>
<td align="left">mp4_buffer_size</td>
<td align="left">size</td>
<td align="left">512k</td>
<td align="left">设置处理 MP4 文件的缓冲区大小</td>
</tr>
<tr>
<td align="left">mp4_max_buffer_size</td>
<td align="left">size</td>
<td align="left">512k</td>
<td align="left">Metadata 数据处理过程中的最大缓冲区大小</td>
</tr>
<tr>
<td align="left">mp4_limit_rate</td>
<td align="left">on 或 off 或 facto</td>
<td align="left">off</td>
<td align="left">限制客户单媒体流请求的最大速率。仅在 Nginx 商业版本中提供</td>
</tr>
<tr>
<td align="left">mp4_limit_rate_after</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">客户单媒体流请求的速率达到指定值时开始限速。仅在 Nginx 商业版本中提供</td>
</tr>
</tbody></table>
<p>F4F 格式仅在 Nginx 商业版本中提供。</p>
<h4 id="伪流媒体配置样例"><a href="#伪流媒体配置样例" class="headerlink" title="伪流媒体配置样例"></a>伪流媒体配置样例</h4><p>伪流媒体配置样例是利用 Nginx 的自动索引功能生成 XML 格式的目录列表，通过 XSLT 生成前端页面，使用 jQuery 插件 video.js 的 Flash 播放器播放 FLV 及 MP4 格式的流媒体文件。页面效果如下图所示。</p>
<p>Nginx 配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8081;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web/files;</span><br><span class="line">    default_type text/xml;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">       autoindex on;                                    <span class="comment"># 启用自动页面功能</span></span><br><span class="line">       autoindex_localtime on;                          <span class="comment"># 使用Nginx服务器时间</span></span><br><span class="line">       autoindex_format xml;                            <span class="comment"># 自动页面输出格式为XML</span></span><br><span class="line">       xslt_stylesheet conf/conf.d/example/test.xslt;   <span class="comment"># 引入XSLT模板文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.flv$ &#123;</span><br><span class="line">        flv;                                            <span class="comment"># FLV文件启用伪流媒体支持</span></span><br><span class="line">    &#125;</span><br><span class="line">    location ~ \.mp4$ &#123;</span><br><span class="line">        mp4;                                            <span class="comment"># MP4文件启用伪流媒体支持</span></span><br><span class="line">        mp4_buffer_size       1m;                       <span class="comment"># MP4文件的缓冲区大小为1MB</span></span><br><span class="line">        mp4_max_buffer_size   5m;                       <span class="comment"># MP4文件最大缓冲区大小为5MB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件 <strong>test.xslt</strong> 内容如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">xmlns:xsl</span>=<span class="string">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/ 3.3.7/css/bootstrap.min.css&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/video.js/6.6.2/video-js.css&quot;</span> <span class="attr">ref</span>= <span class="string">&quot;stylesheet&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/video.js/6.6.2/video.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Nginx流媒体示例<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-striped table-bordered&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>文件名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>文件类型<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>文件大小<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>文件修改时间<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">xsl:for-each</span> <span class="attr">select</span>=<span class="string">&quot;list/*&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsl:sort</span> <span class="attr">select</span>=<span class="string">&quot;mtime&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsl:variable</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;.&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xsl:variable</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsl:variable</span> <span class="attr">name</span>=<span class="string">&quot;ext&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;substring($name,string-length($name)-2,3)&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xsl:variable</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsl:variable</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsl:if</span> <span class="attr">test</span>=<span class="string">&quot;string-length(@size) <span class="symbol">&amp;gt;</span> 0&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">xsl:if</span> <span class="attr">test</span>=<span class="string">&quot;number(@size) <span class="symbol">&amp;gt;</span> 0&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">xsl:choose</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">xsl:when</span> <span class="attr">test</span>=<span class="string">&quot;round(@size div 1024) <span class="symbol">&amp;lt;</span> 1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;@size&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">xsl:when</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">xsl:when</span> <span class="attr">test</span>=<span class="string">&quot;round(@size div 1048576) <span class="symbol">&amp;lt;</span> 1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;format-number((@size div 1024), &#x27;0.0&#x27;)&quot;</span> /&gt;</span>K<span class="tag">&lt;/<span class="name">xsl:when</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">xsl:otherwise</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;format-number((@size div 1048576), &#x27;0.00&#x27;)&quot;</span> /&gt;</span>M<span class="tag">&lt;/<span class="name">xsl:otherwise</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">xsl:choose</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">xsl:if</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">xsl:if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xsl:variable</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsl:variable</span> <span class="attr">name</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;substring(@mtime,1,4)&quot;</span>/&gt;</span>-<span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>= <span class="string">&quot;substring(@mtime,6,2)&quot;</span>/&gt;</span>-<span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;substring(@mtime,9,2)&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">xsl:text</span>&gt;</span> <span class="tag">&lt;/<span class="name">xsl:text</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;substring(@mtime,12,2)&quot;</span>/&gt;</span>:<span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;substring(@mtime,15,2)&quot;</span>/&gt;</span>:<span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;substring(@mtime,18,2)&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xsl:variable</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;$name&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;.&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsl:choose</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">xsl:when</span>  <span class="attr">test</span>=<span class="string">&quot;$ext=&#x27;mp4&#x27; or $ext=&#x27;flv&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;example_video_1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;video-js vjs-default-skin&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;true&quot;</span> <span class="attr">preload</span>=<span class="string">&quot;none&quot;</span> <span class="attr">width</span>=<span class="string">&quot;640&quot;</span> <span class="attr">height</span>=<span class="string">&quot;264&quot;</span>  <span class="attr">poster</span>=<span class="string">&quot;http://vjs.zencdn.net/v/oceans.png&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;&#123;$name&#125;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">xsl:when</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">xsl:otherwise</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;$ext&quot;</span>/&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">xsl:otherwise</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">xsl:otherwise</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">xsl:choose</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;$size&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;$date&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsl:for-each</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTTP2模块配置简述"><a href="#HTTP2模块配置简述" class="headerlink" title="HTTP2模块配置简述"></a>HTTP2模块配置简述</h3><p>HTTP&#x2F;2 是 HTTP 协议的 2.0 版本，该协议通过多路复用、请求优化、HTTP 头压缩等功能提升网络传输速度、优化用户体验。</p>
<p>HTTP&#x2F;2 使用二进制分帧层将传输的数据分割为<strong>更小的数据和帧</strong>，并对它们进行二进制格式编码处理，以实现在不改变 HTTP 现有语义等标准的基础上提升传输性能，从而降低响应延迟、提高请求吞吐的能力。</p>
<p>HTTP&#x2F;2 通过多路复用技术使客户端可以并行发送多个请求，以提高带宽的利用率。</p>
<p>HTTP&#x2F;2 是基于 SPDY 协议设计的，是 SPDY 的演进版本，但其不强制使用 HTTPS 协议，仍可支持 HTTP 明文传输。Nginx 是通过</p>
<p>ngx_http_v2_module 实现 HTTP&#x2F;2 协议支持的，编译配置时可通过增加参数 –with-http_v2_module 启用 HTTP2 模块。</p>
<p>HTTP2 模块配置指令如下。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">http2_body_preread_size</td>
<td align="left">size</td>
<td align="left">64k</td>
<td align="left">设置每个请求可用缓冲区的大小，可用于保存请求体数据</td>
</tr>
<tr>
<td align="left">http2_chunk_size</td>
<td align="left">size</td>
<td align="left">8k</td>
<td align="left">设置响应体被分割成块的大小，该指令值设置得太小时将消耗服务器资源，太大时将因队列头部阻塞（Head-of-line Blocking，HOL）影响优先级</td>
</tr>
<tr>
<td align="left">http2_idle_timeout</td>
<td align="left">time</td>
<td align="left">3m</td>
<td align="left">设置关闭连接后非活动连接超时时间</td>
</tr>
<tr>
<td align="left">http2_max_concurrent_pushes</td>
<td align="left">number</td>
<td align="left">10</td>
<td align="left">设置连接中并发推送请求的最大数</td>
</tr>
<tr>
<td align="left">http2_max_concurrent_streams</td>
<td align="left">number</td>
<td align="left">128</td>
<td align="left">设置连接中并发 HTTP&#x2F;2 流的最大数</td>
</tr>
<tr>
<td align="left">http2_max_field_size</td>
<td align="left">size</td>
<td align="left">4k</td>
<td align="left">设置 HPACK 压缩请求头字段的最大大小，如果应用了 Huffman 编码，解压缩后的名称和值字符串的实际大小可能会更大</td>
</tr>
<tr>
<td align="left">http2_max_header_size</td>
<td align="left">size</td>
<td align="left">16k</td>
<td align="left">设置 HPACK 解压缩后整个请求头列表的最大大小</td>
</tr>
<tr>
<td align="left">http2_max_requests</td>
<td align="left">number</td>
<td align="left">1000</td>
<td align="left">设置一个连接多路复用最大请求数</td>
</tr>
<tr>
<td align="left">http2_push</td>
<td align="left">uri 或 off</td>
<td align="left">off</td>
<td align="left">设置服务端主动推送的资源 URI，指令值 uri 是推送资源的网站绝对路径</td>
</tr>
<tr>
<td align="left">http2_push_preload</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置当响应头中有 Link 字段时，是否自动向客户端推送 Link 字段中设置的网站资源</td>
</tr>
<tr>
<td align="left">http2_recv_buffer_size</td>
<td align="left">size</td>
<td align="left">256k</td>
<td align="left">设置 Nginx 每个工作进程接收缓冲区的大小</td>
</tr>
<tr>
<td align="left">http2_recv_timeout</td>
<td align="left">time</td>
<td align="left">30s</td>
<td align="left">设置等待客户端发送更多数据的超时时间，超过设定时间之后关闭连接</td>
</tr>
</tbody></table>
<p>关于上面的表格，有以下几点需要说明。</p>
<ul>
<li>http2_recv_buffer_size 指令可编写在 http 指令域中；</li>
<li>http2_chunk_size、http2_push、http2_push_preload 指令可编写在 http、server、location 指令域中；</li>
<li>其余的指令可编写在 http、server 指令域中。</li>
</ul>
<p>HTTP2 服务器推送可以实现将多个资源文件（CSS、JS、图片等）同时发送到客户端，如下页面中包含 style.css 和 nginx.png 两个资源文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Nginx HTTPv2 Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Nginx HTTPv2 Test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;nignx.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在没有服务器推送的情况下，客户端通过 3 个 GET 方法获取该页面的所有资源。在启用服务器推送后客户端只需通过一个 GET 方法，就可以获取到该页面的所有资源。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2 default_server;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;       <span class="comment"># 网站证书文件</span></span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;   <span class="comment"># 网站证书密钥文件</span></span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;    <span class="comment"># 网站证书密钥密码文件</span></span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    location / &#123;</span><br><span class="line">        http2_push /style.css                       <span class="comment"># 服务端推送</span></span><br><span class="line">        http2_push /nginx.png                       <span class="comment"># 服务端推送</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WebDAV模块配置简述"><a href="#WebDAV模块配置简述" class="headerlink" title="WebDAV模块配置简述"></a>WebDAV模块配置简述</h3><p>WebDAV（Web-based Distributed Authoring and Versioning）是基于 HTTP&#x2F;1.1 的增强协议。</p>
<p>该协议使用户可以直接对 Web 服务器进行<strong>文件读写</strong>，并支持对文件的版本控制和写文件的加锁及解锁等操作。</p>
<p>Nginx 通过 ngx_http_dav_module 模块实现对 WebDAV 协议的支持，使用户通过 WebDAV 模块的配置指令实现文件的管理操作，该模块支持 WebDAV 协议的 <strong>PUT、DELETE、MKCOL、COPY</strong> 和<strong>MOVE</strong> 请求方法，在配置编译参数时，需要添加 <code>--with-http_dav_module</code> 参数启用该功能。</p>
<p>ngx_http_dav_module 模块的配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">create_full_put_path</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">启用创建目录支持，默认情况下，Put 方法只能在已存在的目录里创建文件</td>
</tr>
<tr>
<td align="left">dav_access</td>
<td align="left">users:permissions…</td>
<td align="left">user:rw</td>
<td align="left">设置创建的文件及目录的访问权限，如果定义了 group 或 all 权限，user 设置可省略</td>
</tr>
<tr>
<td align="left">dav_methods</td>
<td align="left">off 或  [PUT]、[DELETE]、[MKCOL]、[COPY]、[MOVE]</td>
<td align="left">off</td>
<td align="left">指定支持的 WebDAV 方法</td>
</tr>
<tr>
<td align="left">min_delete_depth</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">允许删除文件及目录的最小层级，小于该层级的文件及目录不允许删除</td>
</tr>
</tbody></table>
<p>上述指令都可编写在 http、server、location 指令域中。</p>
<p>Nginx 的自有模块对 WebDAV 协议的支持并不完整，可以通过第三方模块 nginx-dav-ext-module 增加文件特性查找和对写文件的加锁与解锁支持。nginx-dav-ext-module 模块的配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dav_ext_methods</td>
<td align="left">[PROPFIND]、[OPTIONS]、[LOCK]、[UNLOCK]</td>
<td align="left">–</td>
<td align="left">指定支持的 WebDAV 方法</td>
</tr>
<tr>
<td align="left">dav_ext_lock_zone</td>
<td align="left">zone&#x3D;NAME:SIZE[timeout&#x3D;TIMEOUT]</td>
<td align="left">–</td>
<td align="left">定义存储文件锁的共享内存区域及锁超时时间，默认锁超时时间是 1 分钟</td>
</tr>
<tr>
<td align="left">dav_ext_lock</td>
<td align="left">zone&#x3D;NAME</td>
<td align="left">–</td>
<td align="left">启用 WebDav 的锁操作支持</td>
</tr>
</tbody></table>
<p>关于上表，有以下几点需要说明。</p>
<ul>
<li>dav_ext_lock_zone 指令只能编写在 http 指令域中；</li>
<li>dav_methods 和 dav_ext_lock 指令可编写在 http、server、location 指令域中；</li>
<li>WebDAV 协议方法及方法说明如下表所示。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法名称</th>
<th align="left">文件权限</th>
<th align="left">方法说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OPTIONS</td>
<td align="left">–</td>
<td align="left">支持 WebDAV 的检索服务方法</td>
</tr>
<tr>
<td align="left">GET</td>
<td align="left">读</td>
<td align="left">获取文件</td>
</tr>
<tr>
<td align="left">PUT、POST</td>
<td align="left">写</td>
<td align="left">上传文件</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">删除</td>
<td align="left">删除文件或集合</td>
</tr>
<tr>
<td align="left">COPY</td>
<td align="left">读、写</td>
<td align="left">复制文件</td>
</tr>
<tr>
<td align="left">MOVE</td>
<td align="left">删除、写</td>
<td align="left">移动文件</td>
</tr>
<tr>
<td align="left">MKCOL</td>
<td align="left">写</td>
<td align="left">创建由一个或多个文件 URI 组成的新集合</td>
</tr>
<tr>
<td align="left">PROPFIND</td>
<td align="left">读</td>
<td align="left">获取一个或多个文件的特性（创建日期、文件作者等），实现文件的查找与管理</td>
</tr>
<tr>
<td align="left">LOCK、UNLOCK</td>
<td align="left">写</td>
<td align="left">添加、删除文件锁，实现写操作保护</td>
</tr>
</tbody></table>
<p>进行 WebDAV 协议的 MOVE&#x2F;COPY 操作时，会通过 HTTP 请求头属性字段 Destination 指定目标路径，如果客户端请求头中没有字段 Destination，Nginx 会直接报错。为增加服务端兼容性，可以通过第三方模块 headers-more-nginx-module 的 more_set_input_headers 指令在 MOVE&#x2F;COPY 操作的 HTTP 请求头中强制添加 Destination 字段。</p>
<p>WebDAV 协议服务配置过程如下所示。</p>
<p><strong>模块编译</strong></p>
<p>模块编译配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译模块</span></span><br><span class="line">$ ./configure --with-http_dav_module --add-module=../nginx-dav-ext-module --add-module=../headers-more-nginx-module</span><br></pre></td></tr></table></figure>

<p><strong>设置文件夹权限</strong></p>
<p>文件夹权限配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R nobody:nobody /opt/nginx-web/davfile</span><br><span class="line"><span class="built_in">chmod</span> -R 700 /opt/nginx-web/davfile</span><br></pre></td></tr></table></figure>

<p><strong>设置登录账号及密码</strong></p>
<p>登录账号及密码配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;admin:<span class="subst">$(openssl passwd 123456)</span>&quot;</span> &gt;/etc/nginx/conf/.davpasswd</span><br></pre></td></tr></table></figure>

<p><strong>Nginx</strong> 配置</p>
<p>Nginx 配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">dav_ext_lock_zone zone=davlock:10m;                   <span class="comment"># DAV文件锁内存共享区</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;                             <span class="comment"># 启用HTTPS及HTTP/2提升传输性能</span></span><br><span class="line">    server_name  dav.nginxbar.org;</span><br><span class="line">    access_log  logs/webdav.access.log  main;</span><br><span class="line">    root    /opt/nginx-web/davfile;</span><br><span class="line">   </span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;         <span class="comment"># 网站证书文件</span></span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;     <span class="comment"># 网站证书密钥文件</span></span><br><span class="line">    ssl_password_file ssl/www_nginxbar_org.pass;      <span class="comment"># 网站证书密钥密码文件</span></span><br><span class="line">    ssl_session_cache shared:SSL:10m;                 <span class="comment"># 会话缓存存储大小为10MB</span></span><br><span class="line">    ssl_session_timeout  20m;                         <span class="comment"># 会话缓存超时时间为20分钟</span></span><br><span class="line"></span><br><span class="line">    client_max_body_size 20G;                         <span class="comment"># 最大允许上传的文件大小</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">set</span> <span class="variable">$dest</span> <span class="variable">$http_destination</span>;</span><br><span class="line">        <span class="keyword">if</span> (-d <span class="variable">$request_filename</span>) &#123;                   <span class="comment"># 对目录请求、对URI自动添加&quot;/&quot;</span></span><br><span class="line">            rewrite ^(.*[^/])$ <span class="variable">$1</span>/;</span><br><span class="line">            <span class="built_in">set</span> <span class="variable">$dest</span> <span class="variable">$dest</span>/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$request_method</span> ~ (MOVE|COPY)) &#123; <span class="comment"># 对MOVE|COPY方法强制添加Destination请求头</span></span><br><span class="line">            more_set_input_headers <span class="string">&#x27;Destination: $dest&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$request_method</span> ~ MKCOL) &#123;</span><br><span class="line">            rewrite ^(.*[^/])$ <span class="variable">$1</span>/ <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dav_methods PUT DELETE MKCOL COPY MOVE;      <span class="comment"># DAV支持的请求方法</span></span><br><span class="line">        dav_ext_methods PROPFIND OPTIONS LOCK UNLOCK;# DAV扩展支持的请求方法</span><br><span class="line">        dav_ext_lock zone=davlock;                   <span class="comment"># DAV扩展锁绑定的内存区域</span></span><br><span class="line">        create_full_put_path  on;                    <span class="comment"># 启用创建目录支持</span></span><br><span class="line">        dav_access user:rw group:r all:r;            <span class="comment"># 设置创建的文件及目录的访问权限</span></span><br><span class="line"></span><br><span class="line">        auth_basic <span class="string">&quot;Authorized Users WebDAV&quot;</span>;</span><br><span class="line">        auth_basic_user_file /etc/nginx/conf/.davpasswd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="HTTP代理服务器"><a href="#HTTP代理服务器" class="headerlink" title="HTTP代理服务器"></a><font color="red">HTTP代理服务器</font></h3><p>代理功能根据应用方式的不同可以分为正向代理和反向代理。</p>
<ul>
<li><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a><strong>正向代理</strong></h4><p>客户端设置代理地址后，以代理服务器的 IP 作为源 IP 访问互联网应用服务的代理方式；</p>
</li>
<li><p><strong>反向代理</strong></p>
<p>客户端直接访问<strong>代理服务器</strong>，代理服务器再根据客户端请求的主机名、端口号及 URI 路径等条件判断后，将客户端请求转发到应用服务器获取响应数据的代理方式。</p>
</li>
</ul>
<h4 id="模块指令"><a href="#模块指令" class="headerlink" title="模块指令"></a>模块指令</h4><p>Nginx 的 HTTP 代理功能是通过 ngx_http_proxy_module 模块实现的，该模块会被默认构建，无须特殊配置编译参数。配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">proxy_bind</td>
<td align="left">address[transparent] 或 off</td>
<td align="left">–</td>
<td align="left">设置从指定的本地 IP 地址及端口与被代理服务器建立连接，指令值可以是变量。指令值参数为 transparent 时，允许将客户端的真实 IP 透传给被代理服务器，并将客户端的真实 IP 设置为访问被代理服务器的源 IP；指令值参数为 off 时，取消上一层指令域同名指令的配置</td>
</tr>
<tr>
<td align="left">proxy_buffering</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否启用响应数据缓冲区</td>
</tr>
<tr>
<td align="left">proxy_buffers</td>
<td align="left">number size</td>
<td align="left">4k 或 8k</td>
<td align="left">设置每个连接从被代理服务器接收响应数据的缓冲区数量及单个缓冲区的大小。默认单个缓冲区的大小与操作系统的单个内存页（Page Size）的大小相等。缓冲区至少有 2 个</td>
</tr>
<tr>
<td align="left">proxy_buffer_size</td>
<td align="left">size</td>
<td align="left">4k 或 8k</td>
<td align="left">设置用于读取被代理服务器响应数据第一部分的缓冲区大小，默认值等于操作系统的单个内存页的大小</td>
</tr>
<tr>
<td align="left">proxy_busy_buffers_size</td>
<td align="left">size</td>
<td align="left">8k 或 16k</td>
<td align="left">当每个连接从被代理服务器接收响应数据时，限制 proxy_buffers 设置的缓冲区中可用于向客户端发送响应数据的缓冲区大小，以使其余的缓冲区用于从被代理服务器接收响应数据。该值必须大于单个缓冲区或 proxy_buffer_size 的大小，小于总缓冲区减掉一个缓冲区的大小。默认值为单个缓冲区大小的 2 倍</td>
</tr>
<tr>
<td align="left">proxy_limit_rate</td>
<td align="left">rate</td>
<td align="left">0</td>
<td align="left">限制从被代理服务器读取响应的每个请求的流量速度，单位是字节&#x2F;秒，指令值为”0”时表示不限制。该指令只有在 proxy_buffering 启用时才有效</td>
</tr>
<tr>
<td align="left">proxy_max_temp_file_size</td>
<td align="left">size</td>
<td align="left">1024m</td>
<td align="left">当响应数据超出响应数据缓冲区的大小时，超出部分数据将存储到临时文件中。该指令设置临时文件的最大值，指令值为”0”时，关闭存储临时文件的功能。该值必须大于单个缓冲区或 proxy_buffer_size 的大小</td>
</tr>
<tr>
<td align="left">proxy_temp_file_write_size</td>
<td align="left">size</td>
<td align="left">8k 或 16k</td>
<td align="left">限制一次写入临时文件的数据大小，默认值为 2 个缓冲区的大小。在默认配置下，缓冲区大小由 proxy_buffer_size 和 proxy_buffers 指令配置限制，最大值是 proxy_max_temp_file_size 指令的值</td>
</tr>
<tr>
<td align="left">proxy_temp_path</td>
<td align="left">path [level1 [level2 [level3]]]</td>
<td align="left">proxy_temp</td>
<td align="left">设置临时文件存储目录</td>
</tr>
<tr>
<td align="left">proxy_request_buffering</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否将请求转发给被代理服务器之前，先从客户端读取整个请求体。若禁用该功能，Nginx 接收到请求体时会立即转发给被代理服务器，已经发送请求体的请求，将无法使用 proxy_next_upstream 指令功能。对于基于 HTTP&#x2F;1.1 协议的分块传输请求，会强制读取完整请求体</td>
</tr>
<tr>
<td align="left">proxy_pass</td>
<td align="left">address</td>
<td align="left">–</td>
<td align="left">设置连接被代理服务器的协议、IP 地址或套接字，也可以是域名或 upstream 定义的服务器组</td>
</tr>
<tr>
<td align="left">proxy_method</td>
<td align="left">method</td>
<td align="left">–</td>
<td align="left">将当前客户端的请求方法改为指令值设定的请求方法，并向被代理服务器发送请求</td>
</tr>
<tr>
<td align="left">proxy_pass_request_body</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否将客户端请求体传递给被代理服务器</td>
</tr>
<tr>
<td align="left">proxy_pass_request_headers</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">设置是否将客户端请求头传递给被代理服务器</td>
</tr>
<tr>
<td align="left">proxy_set_header</td>
<td align="left">field value</td>
<td align="left">–</td>
<td align="left">在转发给被代理服务器前，修改或添加客户端的请求头属性字段</td>
</tr>
<tr>
<td align="left">proxy_set_body</td>
<td align="left">value</td>
<td align="left">–</td>
<td align="left">修改客户端的请求体为指令值指定的内容，指令值可以是文本、变量及其组合</td>
</tr>
<tr>
<td align="left">proxy_redirect</td>
<td align="left">default 或 off 或 redirect replacement</td>
<td align="left">default</td>
<td align="left">替换被代理服务器返回的响应头中属性字段 location 或 Refresh 的值，并返回给客户端。指令值为 default 时，使用 proxy_pass 指令值的内容进行替换</td>
</tr>
<tr>
<td align="left">proxy_cookie_domain</td>
<td align="left">off 或 domain replacement</td>
<td align="left">off</td>
<td align="left">修改被代理服务器返回的响应头属性字段 Set-Cookie 中 domain 的内容，支持正则及变量</td>
</tr>
<tr>
<td align="left">proxy_cookie_path</td>
<td align="left">off 或 path replacement</td>
<td align="left">off</td>
<td align="left">修改被代理服务器返回的响应头属性字段 Set-Cookie 中 path 的内容，支持正则及变量</td>
</tr>
<tr>
<td align="left">proxy_force_ranges</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">无论被代理服务器的 HTTP 响应头中是否有属性字段 Accept-Ranges，都启用 byte-range 请求支持</td>
</tr>
<tr>
<td align="left">proxy_hide_header</td>
<td align="left">field</td>
<td align="left">–</td>
<td align="left">指定被代理服务器响应数据中不向客户端传递的 HTTP 头字段名称</td>
</tr>
<tr>
<td align="left">proxy_pass_header</td>
<td align="left">field</td>
<td align="left">–</td>
<td align="left">默认配置下 Nginx 不会将头属性字段 Status 和 X-Accel-… 传递给客户端，可通过该指令开放传递</td>
</tr>
<tr>
<td align="left">proxy_headers_hash_bucket_size</td>
<td align="left">size</td>
<td align="left">64</td>
<td align="left">设置指令 proxy_set_header 及 proxy_hide_header 使用哈希表的桶的大小</td>
</tr>
<tr>
<td align="left">proxy_headers_hash_max_size</td>
<td align="left">size</td>
<td align="left">512</td>
<td align="left">设置指令 proxy_set_header 及 proxy_hide_header 使用哈希表的大小</td>
</tr>
<tr>
<td align="left">proxy_ignore_headers</td>
<td align="left">field…</td>
<td align="left">–</td>
<td align="left">设置 Nginx 对被代理服务器响应头包含指定字段时，不执行响应操作。如 Expires 和 Cache-Control</td>
</tr>
<tr>
<td align="left">proxy_send_lowat</td>
<td align="left">size</td>
<td align="left">0</td>
<td align="left">设置 FreeBSD 系统中，使用 kqueue 驱动时 socket 接口 SO_SNDLOWAT 选项的大小。在 Linux、Solaris 及 Windows 平台，该指令无效</td>
</tr>
<tr>
<td align="left">proxy_connect_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">Nginx 与被代理服务器建立连接的超时时间，通常不应该超过 75s，与请求是否返回响应无关</td>
</tr>
<tr>
<td align="left">proxy_read_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个从被代理服务器接收数据的读操作之间的间隔时间超过设置的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">proxy_send_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个发送到被代理服务器的操作之间的间隔时间超过设置的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">proxy_ignore_client_abort</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置当客户端未接收响应就关闭连接时，是否关闭 Nginx 与被代理服务器的连接。默认配置下，Nginx 会记录日志响应码 499，并关闭连接</td>
</tr>
<tr>
<td align="left">proxy_http_version</td>
<td align="left">1.0</td>
<td align="left">1.0 或 1.1</td>
<td align="left">设置用于代理的 HTTP 协议版本，若使用 keepalive 或 NTLM 认证，建议指令值设置为 1.1</td>
</tr>
<tr>
<td align="left">proxy_socket_keepalive</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置 Nginx 与被代理服务器的 TCP keepalive 行为的心跳检测机制，默认使用操作系统的 socket 配置。若指令值为 on，则开启 SO_KEEPALIVE 选项进行心跳检测</td>
</tr>
<tr>
<td align="left">proxy_intercept_errors</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">当指令值为 on 时，将拦截被代理服务器响应码大于或等于 300 的结果，error_page 指令可对该结果做后续处理；当指令值为 off 时，直接返回给客户端</td>
</tr>
<tr>
<td align="left">proxy_next_upstream</td>
<td align="left">error、timeout、 invalid_header、 http_500、http_502、 http_503、http_504、 http_403、http_404、 http_429、 non_idempotent、 off…</td>
<td align="left">enror timeout</td>
<td align="left">当出现指令值中指定的条件时，将未返回响应的客户端请求传递给 upstream 中的下一个服务器</td>
</tr>
<tr>
<td align="left">proxy_next_upstream_timeout</td>
<td align="left">time</td>
<td align="left">0</td>
<td align="left">设置将符合条件的客户端请求传递给 upstream 中下一个服务器的超时时间。”0”为不做超时限制，此时须遍历完所有上游服务器组中的服务器</td>
</tr>
<tr>
<td align="left">proxy_next_upstream_tries</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">设置将符合条件的客户端请求传递给 upstream 中下一个服务器的尝试次数，包括第一次失败次数。”0”为不做尝试次数限制，此时须遍历完所有上游服务器组中的服务器</td>
</tr>
<tr>
<td align="left">proxy_ssl_protocols</td>
<td align="left">[SSLv2]、[SSLv3]、 [TLSv1]、[TLSv1.1] 、[TLSv1.2]、[TLSv1.3]</td>
<td align="left">TLSv1 TLSv1.1 TLSv1.2</td>
<td align="left">指定可用于 Nginx 与被代理服务器建立 SSL 连接的 SSL 协议版本</td>
</tr>
<tr>
<td align="left">proxy_ssl_server_name</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">在与被代理服务器建立 HTTPS 连接时，设置是否启用通过 SNI 或 RFC 6066 传递主机名</td>
</tr>
<tr>
<td align="left">proxy_ssl_ciphers</td>
<td align="left">ciphers</td>
<td align="left">DEFAULT</td>
<td align="left">设置与被代理服务器建立 SSL 连接时用于协商使用的加密算法组合，又称密码套件，指令值内容为 openssl 的密码套件名称，多个套件名称由”:”分隔</td>
</tr>
<tr>
<td align="left">proxy_ssl_session_reuse</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">决定是否启用与被代理服务器 HTTPS 连接的 SSL 会话重用功能</td>
</tr>
<tr>
<td align="left">proxy_ssl_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定被代理服务器对 Nginx 服务器身份验证的 PEM 格式 SSL 证书文件</td>
</tr>
<tr>
<td align="left">proxy_ssl_certificate_key</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定被代理服务器对 Nginx 服务器身份验证的 PEM 格式 SSL 证书私钥文件</td>
</tr>
<tr>
<td align="left">proxy_ssl_password_file</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">存放被代理服务器对 Nginx 服务器身份验证的 PEM 格式 SSL 证书私钥文件的密码文件，一个密码一行。有多个密码时，Nginx 会依次尝试</td>
</tr>
<tr>
<td align="left">proxy_ssl_verify</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置是否启用对被代理服务器的 SSL 证书验证功能</td>
</tr>
<tr>
<td align="left">proxy_ssl_crl</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">证书吊销列表文件，用以验证被代理服务器 SSL 证书有效性的 PEM 格式文件</td>
</tr>
<tr>
<td align="left">proxy_ssl_trusted_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定一个 PEM 格式 CA 证书（根或中间证书）文件，该证书用作被代理服务器的证书链验证</td>
</tr>
<tr>
<td align="left">proxy_ssl_name</td>
<td align="left">name</td>
<td align="left">$proxy_host</td>
<td align="left">指定对被代理服务器 SSL 证书验证的主机名</td>
</tr>
<tr>
<td align="left">proxy_ssl_verify_depth</td>
<td align="left">number</td>
<td align="left">1</td>
<td align="left">设置对被代理服务器 SSL 证书链的验证深度</td>
</tr>
</tbody></table>
<p>关于上表，有以下几点需要说明。</p>
<ul>
<li>在 ngx_http_proxy_module 模块指令列表中，除 proxy_pass 指令以外，其余指令使用的指令域范围都是 http、server 或 location；</li>
<li>缓冲区的大小默认为操作系统中单个内存页的大小，在 CentOS 下可通过如下命令查询:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf PAGE_SIZE</span><br></pre></td></tr></table></figure>

<ul>
<li>proxy_next_upstream 指令值中，当 non_idempotent 参数启用时，请求方法 POST、LOCK、PATCH 在出现错误时，也可以向下一个服务器重复提交。</li>
</ul>
<h4 id="正向代理-1"><a href="#正向代理-1" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理是客户端设置代理地址后，通过将代理服务器的 IP 作为源 IP 访问互联网应用服务的代理方式。通过对正向代理访问设置，可以实现限制客户端的访问行为、下载速度、访问记录统计、隐藏客户端信息等目的。实现原理如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z41A3095G.gif" alt="正向代理"></p>
<p><strong>HTTP 的正向代理</strong></p>
<p>Nginx 的 proxy 模块可以实现基础的 HTTP 代理功能。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$host</span> <span class="variable">$deny</span> &#123;</span><br><span class="line">     hostnames;</span><br><span class="line">     default 0;</span><br><span class="line">     www.google.com 1;                             <span class="comment"># 禁止访问www.google.com</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    resolver 114.114.114.114;</span><br><span class="line">    resolver_timeout 30s;</span><br><span class="line">    access_log logs/proxy_access.log;              <span class="comment"># 记录访问日志</span></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( <span class="variable">$deny</span> ) &#123;</span><br><span class="line">            <span class="built_in">return</span> 403;                            <span class="comment"># 被禁止访问的网址返回403错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        proxy_limit_rate    102400;                <span class="comment"># 限制客户端的下载速率是100KB/s</span></span><br><span class="line">        proxy_buffering on ;                       <span class="comment"># 启用代理缓冲</span></span><br><span class="line">        proxy_buffers   8 8k;                      <span class="comment"># 代理缓冲区大小为64KB</span></span><br><span class="line">        proxy_buffer_size   8k;                    <span class="comment"># 响应数据第一部分的缓冲区大小为8KB</span></span><br><span class="line">        proxy_busy_buffers_size 16k;               <span class="comment"># 向客户端发送响应的缓冲区大小16KB</span></span><br><span class="line">        proxy_temp_file_write_size  16k;           <span class="comment"># 一次写入临时文件的数据大小为16KB</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置所有代理客户端的agent</span></span><br><span class="line">        proxy_set_header User-Agent <span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14&quot;</span> ;</span><br><span class="line"></span><br><span class="line">        proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">        proxy_connect_timeout   70s;               <span class="comment"># 代理连接超时时间</span></span><br><span class="line">        proxy_http_version  1.1;                   <span class="comment"># 代理协议为http/1.1</span></span><br><span class="line">        proxy_pass <span class="variable">$scheme</span>://$http_host<span class="variable">$request_uri</span>; <span class="comment"># 代理到远端服务器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HTTPS 的正向代理</strong></p>
<p>Nginx 默认不支持 HTTP 的 CONNECT 方法，所以无法实现 HTTPS 的正向代理的功能，若要实现 Nginx 的 HTTPS 的正向代理功能，需要添加一个第三方模块 ngx_http_proxy_connect_module，实现 HTTPS 的正向代理支持。对于该模块，官网提示可支持到 Nginx 1.15.8 版本，但实测 Nginx 的 1.17.0 版本也可以编译通过。模块配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">proxy_connect</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">启用 HTTP 的 CONNECT 方法支持</td>
</tr>
<tr>
<td align="left">proxy_connect_allow</td>
<td align="left">all 或端口或端口范围</td>
<td align="left">443 563</td>
<td align="left">设置允许 CONNECT 方法的访问端口</td>
</tr>
<tr>
<td align="left">proxy_connect_timeout</td>
<td align="left">time</td>
<td align="left">–</td>
<td align="left">设置与被代理服务器建立连接的超时时间</td>
</tr>
<tr>
<td align="left">proxy_connect_read_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个从被代理服务器接收数据的操作之间的间隔时间超过设置的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">proxy_connect_send_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个发送到被代理服务器的操作之间的间隔时间超过设置的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">proxy_connect_address</td>
<td align="left">address 或 off</td>
<td align="left">none</td>
<td align="left">设置代理服务器的 IP 地址，指令值可以是变量。指令值 off 等于 none</td>
</tr>
<tr>
<td align="left">proxy_connect_bind</td>
<td align="left">address[tran-sparent] 或 off</td>
<td align="left">none</td>
<td align="left">设置从指定的本地 IP 地址及端口号与被代理服务器建立连接，指令值不能是变量。transparent 参数启用时，将会允许以非 Nginx 的客户端 IP 为源 IP 访问被代理服务器。指令值 off 等于 none</td>
</tr>
</tbody></table>
<p>proxy_connect 模块指令使用的指令域范围为 server。模块编译如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install patch</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/chobits/ngx_http_proxy_connect_module.git</span><br><span class="line"><span class="built_in">cd</span> nginx</span><br><span class="line">patch -p1 &lt; ../ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_101504.patch</span><br><span class="line">./configure --add-module=../ngx_http_proxy_connect_module</span><br></pre></td></tr></table></figure>

<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    resolver 114.114.114.114;</span><br><span class="line">    resolver_timeout 30s;</span><br><span class="line">    access_log logs/proxy_access.log             <span class="comment"># 记录访问日志</span></span><br><span class="line"></span><br><span class="line">    proxy_connect;                               <span class="comment"># 启用HTTP的CONNECT方法支持</span></span><br><span class="line">    proxy_connect_allow            all;          <span class="comment"># 允许所有端口</span></span><br><span class="line">    proxy_connect_connect_timeout  60s;          <span class="comment"># 与互联网网站建立连接的超时时间</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_buffering on ;                     <span class="comment"># 启用代理缓冲</span></span><br><span class="line">        proxy_buffers   8 8k;                    <span class="comment"># 代理缓冲区的大小为64KB</span></span><br><span class="line">        proxy_buffer_size   8k;                  <span class="comment"># 响应数据第一部分的缓冲区的大小为8KB</span></span><br><span class="line">        proxy_busy_buffers_size 16k;             <span class="comment"># 向客户端发送响应的缓冲区的大小16KB</span></span><br><span class="line">        proxy_limit_rate    102400;              <span class="comment"># 限制客户端的下载速率是100KB/s</span></span><br><span class="line">        proxy_temp_file_write_size  16k;         <span class="comment"># 一次写入临时文件的数据大小为16KB</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置所有代理客户端的agent</span></span><br><span class="line">        proxy_set_header    User-Agent <span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14&quot;</span> ;</span><br><span class="line"></span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_connect_timeout   70s;             <span class="comment"># 代理连接</span></span><br><span class="line">        proxy_http_version  1.1;                 <span class="comment"># 代理协议为http/1.1</span></span><br><span class="line">        proxy_pass <span class="variable">$scheme</span>://$http_host<span class="variable">$request_uri</span>;# 代理到远端服务器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 本地测试</span></span><br><span class="line">curl -x 127.0.0.1:8080  https://www.baidu.com</span><br></pre></td></tr></table></figure>

<p>各浏览器可以通过代理功能配置使用 Nginx 代理服务器访问互联网服务器。</p>
<h4 id="HTTP-的反向代理"><a href="#HTTP-的反向代理" class="headerlink" title="HTTP 的反向代理"></a>HTTP 的反向代理</h4><p>反向代理是用户客户端访问代理服务器后，被反向代理服务器软件按照一定的规则从一个或多个被代理服务器中获取响应资源并返回给客户端的代理模式，客户端只知道代理服务器的 IP，并不知道后端服务器的 IP，原因是代理服务器隐藏了被代理服务器的信息。</p>
<p>因为编写 Nginx 的反向代理配置时，被代理服务器通常会被编写在 upstream 指令域中，所以被代理服务器也被称为上游服务器。实现原理如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z41A624934.gif" alt="反向代理"></p>
<p>为方便反向代理的配置，此处把通用的代理配置写在 proxy.conf 文件中。在使用时，通过主配置文件 nginx.conf 用 include 指令引入。文件 proxy.conf 的内容如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;proxy.conf&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">proxy_buffering on;           # 启用响应数据缓冲区</span></span><br><span class="line"><span class="string">proxy_buffers 8 8k;           # 设置每个HTTP请求读取上游服务器响应数据缓冲区的大小为64KB</span></span><br><span class="line"><span class="string">proxy_buffer_size 8k;         # 设置每个HTTP请求读取响应数据第一部分缓冲区的大小为8KB</span></span><br><span class="line"><span class="string">proxy_busy_buffers_size 16k;  # 接收上游服务器返回响应数据时，同时用于向客户端发送响应的缓</span></span><br><span class="line"><span class="string">                              # 冲区的大小为16KB</span></span><br><span class="line"><span class="string">proxy_limit_rate 0;           # 不限制每个HTTP请求每秒读取上游服务器响应数据的流量</span></span><br><span class="line"><span class="string">proxy_request_buffering on;   # 启用客户端HTTP请求读取缓冲区功能</span></span><br><span class="line"><span class="string">proxy_http_version 1.1;       # 使用HTTP 1.1版本协议与上游服务器建立通信</span></span><br><span class="line"><span class="string">proxy_connect_timeout 5s;     # 设置与上游服务器建立连接的超时时间为5s</span></span><br><span class="line"><span class="string">proxy_intercept_errors on;    # 拦截上游服务器中响应码大于300的响应处理</span></span><br><span class="line"><span class="string">proxy_read_timeout 60s;       # 从上游服务器获取响应数据的间隔超时时间为60s</span></span><br><span class="line"><span class="string">60sproxy_send_timeout 60s;    # 向上游服务器发送请求的间隔超时时间为60s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 设置发送给上游服务器的头属性字段Host为客户端请求头头字段Host的值</span></span><br><span class="line"><span class="string">proxy_set_header   Host              $host:$server_port;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 设置发送给上游服务器的头属性字段Referer为客户端请求头头字段的值Host</span></span><br><span class="line"><span class="string">proxy_set_header   Referer           $http_referer;</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string"># 设置发送给上游服务器的头属性字段Cookie为客户端请求头头字段的值Host</span></span><br><span class="line"><span class="string">proxy_set_header   Cookie            $http_cookie;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 设置发送给上游服务器的头属性字段X-Real-IP为客户端的IP</span></span><br><span class="line"><span class="string">proxy_set_header   X-Real-IP         $remote_addr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 设置发送给上游服务器的头属性字段X-Forwarded-For为客户端请求头的X-Forwarded-For的</span></span><br><span class="line"><span class="string"># 值，如果没有该字段，则等于$remote_addr</span></span><br><span class="line"><span class="string">proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 设置发送给上游服务器的头属性字段X-Forwarded-Proto为请求协议的值</span></span><br><span class="line"><span class="string">proxy_set_header   X-Forwarded-Proto $scheme;  </span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>在 nginx.conf 的 http 指令域中引入该文件，配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    include proxy.conf</span><br><span class="line">    include conf.d/*.conf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx 的指令支持在指令域中对上级指令域指令的继承和修改，若对 proxy.conf 有特殊配置需求的，可在对应的 server 指令域中添加同名指令。</p>
<p>反向代理的配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8088;</span><br><span class="line">    access_log  logs/proxy.access.log  main;</span><br><span class="line">   </span><br><span class="line">    tcp_nodelay off;                 <span class="comment"># 因启用缓冲区功能，所以关闭立刻发送功能</span></span><br><span class="line"></span><br><span class="line">    location ~ ^/ &#123;</span><br><span class="line">        proxy_force_ranges on;       <span class="comment"># 强制启用字节范围请求支持</span></span><br><span class="line">        proxy_pass   http://192.168.2.145:8082;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTTPS-的反向代理"><a href="#HTTPS-的反向代理" class="headerlink" title="HTTPS 的反向代理"></a>HTTPS 的反向代理</h4><p>HTTPS 通过加密通道保护客户端与服务端之间的数据传输，已成为当前网站部署的必选配置。在部署有 Nginx 代理集群的 HTTPS 站点，通常会把 SSL 证书部署在 Nginx 的服务器上，然后把请求代理到后端的上游服务器。这种部署方式由 Nginx 服务器负责 SSL 请求的运算，相对减轻了后端上游服务器的 CPU 运算量，这种方式也被称为 SSL 终止（SSL Termination）。</p>
<p>因 Nginx 启用了对 TSL SNI（Server Name Identification）技术的支持，所以在同一服务器上可以安装多个绑定不同域名的 SSL 证书，使其可以在 Nginx 服务器上统一部署，同时也极大地方便了证书的管理和维护。</p>
<p>由 Nginx 服务器实现 SSL 终止的 HTTPS 的反向代理的常见方式有两种，一种是由 Nginx 通过 HTTP 方式与被代理服务器建立连接；另一种是由 Nginx 通过 HTTPS 方式与被代理服务器建立连接。由 Nginx 通过 HTTP 方式与被代理服务器建立连接的部署方式为客户端 → Nginx 服务器（HTTPS）→ 上游服务器（HTTP），配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    access_log  logs/sslproxy.access.log  main;</span><br><span class="line">   </span><br><span class="line">    tcp_nodelay off;                              <span class="comment"># 因启用缓冲区功能，所以关闭立刻发送功能</span></span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;     <span class="comment"># 网站证书文件</span></span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key; <span class="comment"># 网站证书密钥文件</span></span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;               <span class="comment"># 会话缓存的存储大小为10MB</span></span><br><span class="line">    ssl_session_timeout  10m;                       <span class="comment"># 会话缓存的超时时间为10分钟</span></span><br><span class="line">    ssl_session_tickets on;                         <span class="comment"># 设置会话凭证为会话缓存机制</span></span><br><span class="line">    ssl_session_ticket_key  ssl/session_ticket.key; <span class="comment"># 设置会话凭证密钥文件</span></span><br><span class="line"></span><br><span class="line">    location ~ ^/ &#123;</span><br><span class="line">        proxy_pass   http://192.168.2.145:8082;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照上面的配置，Nginx 服务器与后端的上游服务器之间仍然采用的是 HTTP 透明传输，虽然可以与上游服务器部署在同一内网，但数据传输仍是不安全的。为了提高传输安全性，建议在上游服务器也开启 HTTPS 协议，实现全链路的安全数据传输。由 Nginx 通过 HTTPS 方式与被代理服务器建立连接的配置样例场景如下。</p>
<p>在配置样例的场景中有两个 HTTPS 节点，为方便举例说明配置指令的功能及配置指令中所用的 SSL 证书的区别，共设计了 3 个 SSL 证书并通过自签证书的方式进行签发，部署方式如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z41AK02T.gif" alt="HTTPS代理"></p>
<p><code>www.nginxbar.org (http://www.nginxbar.org)</code> 证书为对外网站的域名证书，用于给用户提供身份验证。</p>
<p><code>backend.nginxbar.org (htp://backend.nginxbar.org)</code> 证书为被代理服务器的域名证书，用于给 Nginx 服务器提供身份验证。</p>
<p><code>proxy.nginxbar.com (http://proxy.nginxbar.com)</code> 证书为 Nginx 服务器的域名证书，用于给被代理服务器提供身份验证。</p>
<p>自签证书命令如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成自建根域nginxbar.org证书</span></span><br><span class="line">openssl req -new -x509 -out /etc/nginx/conf/ssl/root.pem -keyout</span><br><span class="line">/etc/nginx/conf/ssl/root.key -days 3650 -subj</span><br><span class="line"><span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=admin/CN=nginxbar.org/emailAddress= admin@nginxbar.org&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 域名www.nginxbar.org生成请求文件，面向用户端的域名请求文件</span></span><br><span class="line">openssl req -out /etc/nginx/conf/ssl/www_nginxbar_org.csr -new -sha256</span><br><span class="line">-newkey rsa:2048 -nodes -keyout /etc/nginx/conf/ssl/www_nginxbar_org.key</span><br><span class="line">-subj</span><br><span class="line"><span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=www/CN=www.nginxbar.org/emailAddress= www@nginxbar.org&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 颁发自签域名www.nginxbar.org证书，面向用户端的域名证书</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> /etc/nginx/conf/ssl/www_nginxbar_org.csr -out</span><br><span class="line">/etc/nginx/conf/ssl/www_nginxbar_org.pem -CA /etc/nginx/conf/ssl/root.pem</span><br><span class="line">-CAkey /etc/nginx/conf/ssl/root.key  -CAcreateserial -days 3650</span><br><span class="line"></span><br><span class="line"><span class="comment"># 域名backend.nginxbar.org生成请求文件，后端上游服务器的SSL请求文件</span></span><br><span class="line">openssl req -out /etc/nginx/conf/ssl/backend_nginxbar_org.csr -new -sha256</span><br><span class="line">-newkey rsa:2048 -nodes -keyout</span><br><span class="line">/etc/nginx/conf/ssl/backend_nginxbar_org.key -subj</span><br><span class="line"><span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=backend/CN=backend.nginxbar.org/emailAddress=backend@nginxbar.org&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 颁发自签域名backend.nginxbar.org证书，后端上游服务器的SSL证书</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> /etc/nginx/conf/ssl/backend_nginxbar_org.csr -out</span><br><span class="line">/etc/nginx/conf/ssl/backend_nginxbar_org.pem -CA</span><br><span class="line">/etc/nginx/conf/ssl/root.pem -CAkey /etc/nginx/conf/ssl/root.key</span><br><span class="line">-CAcreateserial -days 3650</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成自建根域nginxbar.com证书，该域名仅为方便区分代理端和后端证书使用，实际使用时可以使用一个根证书</span></span><br><span class="line">openssl req -new -x509 -out /etc/nginx/conf/ssl/proxy_root.pem -keyout</span><br><span class="line">/etc/nginx/conf/ssl/proxy_root.key -days 3650 -subj</span><br><span class="line"><span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=admin/CN=nginxbar.com/emailAddress= admin@nginxbar.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 域名proxy.nginxbar.com生成请求文件，Nginx服务器的SSL代理请求文件</span></span><br><span class="line">openssl req -out /etc/nginx/conf/ssl/proxy_nginxbar_com.csr -new -sha256</span><br><span class="line">-newkey rsa:2048 -nodes -keyout /etc/nginx/conf/ssl/proxy_nginxbar_com.key</span><br><span class="line">-subj <span class="string">&quot;/C=CN/ST=Shanghai/L=Shanghai/O=nginxbar/OU=proxy/CN=proxy.nginxbar.com</span></span><br><span class="line"><span class="string">/emailAddress=proxy@nginxbar.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 颁发自签域名proxy.nginxbar.com证书，Nginx服务器的SSL代理证书</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> /etc/nginx/conf/ssl/proxy_nginxbar_com.csr -out</span><br><span class="line">/etc/nginx/conf/ssl/proxy_nginxbar_com.pem -CA</span><br><span class="line">/etc/nginx/conf/ssl/proxy_root.pem -CAkey</span><br><span class="line">/etc/nginx/conf/ssl/proxy_root.key  -CAcreateserial -days 3650</span><br></pre></td></tr></table></figure>

<p>Nginx 代理服务器的配置如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">resolver 114.114.114.114 valid=300s;              <span class="comment"># DNS服务器地址</span></span><br><span class="line">resolver_timeout 5s;                              <span class="comment"># DNS解析的超时时间为5s</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      443 ssl;</span><br><span class="line">    server_name www.nginxbar.org;</span><br><span class="line">    access_log  logs/sslproxy2_access.<span class="built_in">log</span>  main;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;     <span class="comment"># 网站www.nginxbar.org证书文件</span></span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key; <span class="comment"># 网站www.nginxbar.org证书密钥文件</span></span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;             <span class="comment"># 会话缓存的存储大小为10MB</span></span><br><span class="line">    ssl_session_timeout  10m;                     <span class="comment"># 会话缓存的超时时间为10分钟</span></span><br><span class="line">    ssl_session_tickets on;                       <span class="comment"># 设置会话凭证为会话缓存机制</span></span><br><span class="line">    ssl_session_ticket_key  ssl/session_ticket.key;  <span class="comment"># 设置会话凭证密钥文件</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass                    https://backend.nginxbar.org; <span class="comment"># 被代理服务器的地址</span></span><br><span class="line">        proxy_ssl_certificate         ssl/proxy_nginxbar_com.pem;   <span class="comment"># 代理服务器的客户端证书</span></span><br><span class="line">                                                                    <span class="comment"># 文件</span></span><br><span class="line">        proxy_ssl_certificate_key     ssl/proxy_nginxbar_com.key;   <span class="comment"># 代理服务器的客户端证书</span></span><br><span class="line">                                                                    <span class="comment"># 密钥文件</span></span><br><span class="line">        proxy_ssl_protocols           TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        proxy_ssl_ciphers             HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">        proxy_ssl_verify        on;                  <span class="comment"># 启用验证被代理服务器的证书</span></span><br><span class="line">        proxy_ssl_trusted_certificate ssl/root.pem;  <span class="comment"># 用于验证被代理服务器的主机名backend.</span></span><br><span class="line">                                                     <span class="comment"># nginxbar.org的根证书</span></span><br><span class="line">        proxy_ssl_verify_depth  2;                   <span class="comment"># 证书验证深度为2</span></span><br><span class="line">        proxy_ssl_session_reuse on;                  <span class="comment"># SSL连接启用会话重用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx Web 服务器配置如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen      443 ssl;</span><br><span class="line">    server_name backend.nginxbar.org;</span><br><span class="line">    access_log  logs/sslbackend_access.log  main;</span><br><span class="line"></span><br><span class="line">    ssl_certificate        ssl/backend_nginxbar_org.pem;# 网站backend.nginxbar.org证书文件</span><br><span class="line">    ssl_certificate_key    ssl/backend_nginxbar_org.key;# 网站backend.nginxbar.org证书密钥</span><br><span class="line">                                                        <span class="comment"># 文件</span></span><br><span class="line">    ssl_verify_client      on;                          <span class="comment"># 启用对Nginx服务的证书验证</span></span><br><span class="line">    ssl_client_certificate ssl/proxy_root.pem;          <span class="comment"># 用以验证Nginx服务器主机名</span></span><br><span class="line">                                                        <span class="comment"># proxy.nginxbar.com的根证书</span></span><br><span class="line">    ssl_verify_depth  2;                                <span class="comment"># 证书验证深度为2</span></span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;                   <span class="comment"># HTTPS会话缓存的存储大小为10MB</span></span><br><span class="line">    ssl_session_tickets off;                            <span class="comment"># 以会话编号机制实现会话缓存</span></span><br><span class="line">    ssl_session_timeout 10m;                            <span class="comment"># 会话缓存的超时时间为10分钟</span></span><br><span class="line"></span><br><span class="line">    charset utf-8;</span><br><span class="line">    root /opt/nginx-web;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反向代理的真实客户端-IP"><a href="#反向代理的真实客户端-IP" class="headerlink" title="反向代理的真实客户端 IP"></a>反向代理的真实客户端 IP</h4><p>客户端在访问互联网应用服务器时，与真实的应用服务器之间会因为有多层反向代理，而导致真实应用服务器获取的仅是最近一层的反向代理服务器 IP。为使 Nginx 后端的上游服务器可以获得真实客户端 IP，Nginx 提供了 ngx_http_realip_module 模块用以实现真实客户端 IP 的获取及传递的功能。</p>
<p>通过该模块提供的配置指令，用户可以手动设置上层反向代理服务器的 IP 作为授信 IP，Nginx 服务器根据配置指令的配置排除授信 IP，而甄别出真实的客户端 IP 进行日志记录，并传递给上游服务器。模块配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">set_real_ip_from</td>
<td align="left">address 或 CIDR 或 unix</td>
<td align="left">–</td>
<td align="left">设置授信 IP，IP 网段或 UNIX 套接字</td>
</tr>
<tr>
<td align="left">real_ip_header</td>
<td align="left">field 或 X-Real-IP 或 X-For-warded-For 或 proxy_protocol</td>
<td align="left">X-Real-IP</td>
<td align="left">通过指定的 HTTP 头字段获取真实客户端 IP</td>
</tr>
<tr>
<td align="left">real_ip_recursive</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">当客户端经多层反向代理到达当前服务器时，指定的 HTTP 头字段中会有多个 IP 地址。默认会以最后一个 IP 为真实客户端 IP，当指令值为 on 时，会以最后一个非信 IP 为真实客户端 IP</td>
</tr>
</tbody></table>
<p>该模块指令使用的指令域范围为http、server、location。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8088;</span><br><span class="line">    access_log  logs/proxy.access.log  main;</span><br><span class="line">   </span><br><span class="line">    set_real_ip_from 192.168.2.159;   <span class="comment"># 设置192.168.2.159为授信IP</span></span><br><span class="line">    real_ip_header X-Forwarded-For;   <span class="comment"># 通过HTTP头字段X-Forwarded-For获取真实客户端IP</span></span><br><span class="line">    real_ip_recursive on;             <span class="comment"># 以最后一个非授信IP为真实客户端IP</span></span><br><span class="line">   </span><br><span class="line">    tcp_nodelay off;                  <span class="comment"># 因启用缓冲区功能，所以关闭立刻发送功能</span></span><br><span class="line"></span><br><span class="line">    location ~ ^/ &#123;</span><br><span class="line">        proxy_force_ranges on;        <span class="comment"># 强制启用字节范围请求支持</span></span><br><span class="line">        proxy_pass   http://192.168.2.145:8082;</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="stream模块简述"><a href="#stream模块简述" class="headerlink" title="stream模块简述"></a>stream模块简述</h3><p>Nginx 的 TCP&#x2F;UDP 代理功能的模块分为核心模块和辅助模块、核心模块 stream 需要在编译配置时增加”–with-stream”参数进行编译。核心模块的全局配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">listen</td>
<td align="left">address:port[ssl][udp][proxy protocol] [backlog&#x3D;number][rcvbuf&#x3D;size]</td>
<td align="left">–</td>
<td align="left">stream 监听协议及端口</td>
</tr>
<tr>
<td align="left">listen</td>
<td align="left">[sndbuf&#x3D;size][bind][ipv6only&#x3D;on 或 off] [reuseport][so_keepalive&#x3D;on 或 off 或 [keepidle]:[keepintvl]:[keepent]]</td>
<td align="left">–</td>
<td align="left">stream 监听协议及端口</td>
</tr>
<tr>
<td align="left">preread_buffer_size</td>
<td align="left">size</td>
<td align="left">16k</td>
<td align="left">设置每个会话数据预读缓冲区的大小</td>
</tr>
<tr>
<td align="left">preread_timeout</td>
<td align="left">timeout</td>
<td align="left">30s</td>
<td align="left">设置每个会话数据预读取的超时时间</td>
</tr>
<tr>
<td align="left">proxy_protocol_timeout</td>
<td align="left">timeout</td>
<td align="left">30s</td>
<td align="left">读取代理协议头的超时时间</td>
</tr>
<tr>
<td align="left">resolver</td>
<td align="left">address… [valid&#x3D;time][ipv6&#x3D;on 或 off]</td>
<td align="left">–</td>
<td align="left">域名解析服务器地址</td>
</tr>
<tr>
<td align="left">resolver_timeout</td>
<td align="left">time</td>
<td align="left">30s</td>
<td align="left">域名解析超时时间</td>
</tr>
<tr>
<td align="left">tcp_nodelay</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">启用或关闭立即发送数据（tcp_nodelay）选项</td>
</tr>
<tr>
<td align="left">variables_hash_bucket_size</td>
<td align="left">size</td>
<td align="left">64</td>
<td align="left">设置变量哈希表中桶的大小</td>
</tr>
<tr>
<td align="left">variables_hash_max_size</td>
<td align="left">size</td>
<td align="left">1024</td>
<td align="left">设置变量哈希表的最大值</td>
</tr>
</tbody></table>
<p>关于上表有以下几点需要说明。</p>
<ul>
<li>指令 listen 使用的指令域范围为 server；</li>
<li>指令 variables_hash_bucket_size 和 variables_hash_max_size 使用的指令域范围为 stream；</li>
<li>stream 核心模块其余指令使用的指令域范围为 stream、server；</li>
<li>resolver 指令值可填写多个域名解析服务器地址，各个地址用空格分隔；</li>
<li>listen 指令值参数如下表所示。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">默认</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ssl</td>
<td align="left">–</td>
<td align="left">在指定监听端口上启用 SSL 协议支持</td>
</tr>
<tr>
<td align="left">udp</td>
<td align="left">–</td>
<td align="left">在指定监听端口上启用 UDP 协议支持</td>
</tr>
<tr>
<td align="left">proxy_protocol</td>
<td align="left">–</td>
<td align="left">在指定监听端口上启用 proxy_protocol 协议支持</td>
</tr>
<tr>
<td align="left">backlog</td>
<td align="left">-1&#x2F;511</td>
<td align="left">设置挂起连接队列的最大长度，在 FreeBSD、DragonFly BSD 和 macOS 操作系统上，设置默认值为 -1，其他平台为 511</td>
</tr>
<tr>
<td align="left">rcvbuf</td>
<td align="left">–</td>
<td align="left">设置套接字（socket）接收缓冲区（SO_RCVBUF 选项）的大小，Linux 操作系统下默认值为内核参数 net.core.rmem_default 的值</td>
</tr>
<tr>
<td align="left">sndbuf</td>
<td align="left">–</td>
<td align="left">设置套接字（socket）发送缓冲区（SO_SNDBUF 选项）的大小，Linux 操作系统下默认值为内核参数 net.core.wmem_default 的值</td>
</tr>
<tr>
<td align="left">bind</td>
<td align="left">–</td>
<td align="left">address:port 指定 IP 及端口</td>
</tr>
<tr>
<td align="left">ipv6only</td>
<td align="left">on</td>
<td align="left">只接收 IPv6 连接，或接收 IPv6 和 IPv4 连接</td>
</tr>
<tr>
<td align="left">reuseport</td>
<td align="left">–</td>
<td align="left">在默认情况下，所有的工作进程都会共享一个 socket 去监听同一 IP 和端口的组合。该参数启用后，允许每个工作进程由独立的 socket 去监听同一 IP 和端口的组合，内核会对传入的连接进行负载均衡。目前，它只适用于 Linux 3.9+、DragonFly BSD 和 FreeBSD 12+</td>
</tr>
<tr>
<td align="left">so_keepalive</td>
<td align="left">off</td>
<td align="left">配置监听的端口启用 TCP keepalive 机制时的心跳检测参数。当指令值为 on 时，默认等同于 so_keepalive&#x3D;30m::10，表示 30 分钟无数据传输时发送探测包，总共发送 10 次，发送时间间隔为系统内核参数 tcp_keepalive_intvl 的设定值</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    resolver 114.114.114.114 valid=300s; </span><br><span class="line">    resolver_timeout 2s;</span><br><span class="line"></span><br><span class="line">    upstream backend &#123;</span><br><span class="line">       server 192.168.0.1:333;</span><br><span class="line">       server www.example.com:333;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 127.0.0.1:333 udp reuseport;</span><br><span class="line">        proxy_timeout 20s;</span><br><span class="line">        proxy_pass backend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen [::1]:12345;</span><br><span class="line">        proxy_pass unix:/tmp/stream.socket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>stream 辅助模块</strong></p>
<ul>
<li><strong>ngx_stream_map_module</strong></li>
</ul>
<p>该模块的功能是在客户端每次连接时，Nginx按照map指令域中源变量的当前值，把设定的对应值赋给新变量。该指令的语法格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map 源变量 新变量&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个指令使用的指令域只有 stream，指令值参数如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">参数值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">default</td>
<td align="left">为新变量指定一个默认值。若不指定这个参数，新变量默认值为空</td>
</tr>
<tr>
<td align="left">hostnames</td>
<td align="left">当源变量为主机名时，允许使用主机名前缀或后缀对源变量值进行匹配</td>
</tr>
<tr>
<td align="left">include</td>
<td align="left">引入一个外部文件作为 map 的指令域内容</td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">map 默认创建的是可被缓存的变量，启用该参数后，创建的为不可被缓存的变量</td>
</tr>
</tbody></table>
<p>map 指令域中，当源变量值存在相同匹配项时，匹配的顺序如下:</p>
<ul>
<li>完全匹配的字符串；</li>
<li>有主机前缀的最长字符串；</li>
<li>有主机后缀的最长字符串；</li>
<li>在指令域中按自上而下的顺序最先匹配到的正则表达式；</li>
<li>default 参数给定的默认值。</li>
</ul>
<p>map 哈希表大小指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">map 哈希表大小指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">map_hash_max_size</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">2048</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">map 指令中，存储变量的哈希表的大小</td>
</tr>
<tr>
<td align="left">map 哈希桶大小指令如下表所示。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>map 哈希桶大小指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">map 哈希桶大小指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">map_hash_bucket_size</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">32、64 或 128</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">map 指令中，存储变量的哈希桶的大小</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stream&#123;</span><br><span class="line">   </span><br><span class="line">    map <span class="variable">$remote_addr</span> <span class="variable">$limit</span> &#123;</span><br><span class="line">        127.0.0.1    <span class="string">&quot;&quot;</span>;</span><br><span class="line">        default      <span class="variable">$binary_remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    limit_conn_zone <span class="variable">$limit</span> zone=addr:10m;</span><br><span class="line">    limit_conn addr 1;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 33060 reuseport;</span><br><span class="line">        access_log  logs/tcp.log tcp;</span><br><span class="line"></span><br><span class="line">        proxy_timeout 20s;</span><br><span class="line">        proxy_pass 127.0.0.1:3306;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ngx_stream_geo_module</strong></li>
</ul>
<p>该模块的功能是从源变量获取 IP 地址，并根据设定的 IP 与对应值的列表对新变量进行赋值。该模块只有一个 geo 指令，指令格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geo [源变量]新变量&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>geo 指令的默认源变量是 $remote_addr，新变量默认值为空，这个指令使用的指令域只有 stream，指令值参数如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">参数描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">delete</td>
<td align="left">删除配置中已经存在的相同 IP 地址的设定</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">如果从源变量获取的IP无法匹配任意一个 IP 或 IP 范围时，使用这个参数的值作为新变量赋值</td>
</tr>
<tr>
<td align="left">include</td>
<td align="left">引入一个包含 IP 与对应值的外部文件</td>
</tr>
<tr>
<td align="left">ranges</td>
<td align="left">以地址段的形式定义 IP 地址，这个参数必须放在最上面</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">geo <span class="variable">$country</span> &#123;</span><br><span class="line">    ranges;</span><br><span class="line">    default                   CN;</span><br><span class="line">    127.0.0.0-127.0.0.0       US;</span><br><span class="line">    10.1.0.0-10.1.255.255     RU;</span><br><span class="line">    192.168.1.0-192.168.1.255 UK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">geo <span class="variable">$country</span> &#123;</span><br><span class="line">    default        ZZ;</span><br><span class="line">    include        conf/geo.conf;</span><br><span class="line">    delete         127.0.0.0/16;</span><br><span class="line"></span><br><span class="line">    127.0.0.0/24   US;</span><br><span class="line">    10.1.0.0/16    RU;</span><br><span class="line">    192.168.1.0/24 UK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ngx_stream_geoip_module</strong></li>
</ul>
<p>该模块的功能首先是根据客户端的 IP 地址与 MaxMind 数据库中的城市地址信息做比对，然后再将对应的城市地址信息赋值给内置变量。</p>
<p>国家信息数据库指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">国家信息数据库指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">geoip_country</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">指定国家信息的 MaxMind 数据库文件路径</td>
</tr>
</tbody></table>
<p>城市信息数据库指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">城市信息数据库指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">geoip_city</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">指定城市信息的 MaxMind 数据库文件路径</td>
</tr>
</tbody></table>
<p>机构信息数据库指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">机构信息数据库指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">geoip_org</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">指定机构信息的 MaxMind 数据库文件路径</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    geoip_country         /usr/share/GeoIP/GeoIP.dat;</span><br><span class="line">    geoip_city            /usr/share/GeoIP/GeoLiteCity.dat;</span><br><span class="line"></span><br><span class="line">    map <span class="variable">$geoip_city_continent_code</span> <span class="variable">$nearest_server</span> &#123;</span><br><span class="line">        default        example.com;</span><br><span class="line">        EU          eu.example.com;</span><br><span class="line">        NA          na.example.com;</span><br><span class="line">        AS          as.example.com;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ngx_stream_split_clients_module</strong></li>
</ul>
<p>该模块会按照配置指令将一个 0～232 之间的数值根据设定的比例分割为多个数值范围，每个数值范围会被设定一个对应的给定值。用户每次请求时，指定的字符串会被计算出一个数值，该模块会将该数值所在范围对应的给定值赋值给配置中定义的变量。该功能常用来按照用户的来源IP进行访问流量分流。该指令的语法格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split_clients 字符串 新变量 &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    split_clients <span class="string">&quot;<span class="variable">$&#123;remote_addr&#125;</span>AAA&quot;</span> <span class="variable">$upstream</span> &#123;  <span class="comment"># $&#123;remote_addr&#125;AAA会被计算出一个数值</span></span><br><span class="line">        0.5%     backend1;  <span class="comment"># 数值在0 ~ 21474835之间，$upstream被赋值backend1</span></span><br><span class="line">        80.0%    backend2;  <span class="comment"># 数值在21474836 ~ 3435973836之间，$upstream被赋值backend2</span></span><br><span class="line">        *        backend;   <span class="comment"># 数值在3435973837 ~ 4294967295，$upstream被赋值backend</span></span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 389;</span><br><span class="line">        proxy_pass <span class="variable">$upstream</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个指令使用的指令域只有 stream；客户端每次请求时，指定字符串会被使用 MurmurHash2 算法计算出一个 0～232（0～4294967295）之间的数值，该模块会将该数值所在范围对应的给定值赋值给配置中定义的变量。</p>
<ul>
<li><strong>ngx_stream_ssl_preread_module</strong></li>
</ul>
<p>该模块可以在预读取阶段从 ClientHello 消息中提取信息，赋值给内置变量后供用户调用。</p>
<p>SSL 信息预读如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">SSL 信息预读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">ssl_preread</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream、server</td>
</tr>
<tr>
<td align="left">可选项</td>
<td align="left">on 或 off</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">off</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置是否启用 SSL 信息预读功能</td>
</tr>
</tbody></table>
<p>内置变量如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">变量说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$ssl_preread_protocol</td>
<td align="left">客户端支持的最高 SSL 协议版本</td>
</tr>
<tr>
<td align="left">$ssl_preread_server_name</td>
<td align="left">通过 SNI 请求的服务器名称</td>
</tr>
<tr>
<td align="left">$ssl_preread_alpn_protocols</td>
<td align="left">客户通过 ALPN 公布的协议列表</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    map <span class="variable">$ssl_preread_protocol</span> <span class="variable">$upstream</span> &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>        ssh.example.com:22;</span><br><span class="line">        <span class="string">&quot;TLSv1.2&quot;</span> new.example.com:443;</span><br><span class="line">        default   tls.example.com:443;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen      192.168.0.1:443;</span><br><span class="line">        proxy_pass  <span class="variable">$upstream</span>;</span><br><span class="line">        ssl_preread on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ngx_stream_limit_conn_module</strong></li>
</ul>
<p>该模块对访问连接中含有指定变量且变量值相同的连接数进行计数，当计数值达到 limit_conn 指令设定的值时，Nginx 服务器将关闭此类连接。由于 Nginx 采用的是多进程的架构，因此该模块通过共享内存存储计数状态并实现了多个进程间的计数状态共享。</p>
<p>计数存储区指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">计数存储区指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">limit_conn_zone</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设定用以存储指定变量计数的共享内存区域</td>
</tr>
</tbody></table>
<p>连接数设置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">连接数设置指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">limit_conn</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream、server</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置指定变量并发连接的最大数</td>
</tr>
</tbody></table>
<p>连接数日志级别指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">连接数日志级别指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">limit_conn_log_level</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream、server</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">error</td>
</tr>
<tr>
<td align="left">可选项</td>
<td align="left">info、notice、warn、error</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">当指定变量的并发连接数达最大值时，输出日志的级别</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    limit_conn_zone <span class="variable">$binary_remote_addr</span> zone=addr:10m; <span class="comment"># 对客户端IP进行并发计数，计数内存区</span></span><br><span class="line">                                                       <span class="comment"># 命名为addr，计数内存区的大小为10MB</span></span><br><span class="line">    server &#123;</span><br><span class="line">        limit_conn addr 1;                             <span class="comment"># 限制客户端的并发连接数为1</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置说明如下所示:</p>
<p>limit_conn_zone 的格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone key zone=name:size;</span><br></pre></td></tr></table></figure>

<p>limit_conn_zone 的 key 可以是文本、变量或文本与变量的组合；</p>
<p>$binary_remote_addr 为 IPv4 时，占用 4B；为 IPv6 时，占用 16B；</p>
<p>limit_conn_zone 中，1MB 的内存空间可以存储 32000 个 32B 或 16000 个 64B 的变量计数状态；</p>
<p>变量计数状态在 32 位系统平台占用 32B 或 64B，在 64 位系统平台占用 64B。</p>
<ul>
<li><strong>ngx_stream_access_module</strong></li>
</ul>
<p>这个模块可以允许或拒绝客户端的源 IP 地址进行连接。</p>
<p>允许连接指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">允许连接指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">allow</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream、server</td>
</tr>
<tr>
<td align="left">可选项</td>
<td align="left">address 或 CIDR 或 unix: 或 all</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">允许指定源 IP 的客户端连接</td>
</tr>
</tbody></table>
<p>拒绝连续指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">拒绝连接指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">deny</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">stream、server</td>
</tr>
<tr>
<td align="left">可选项</td>
<td align="left">address 或 CIDR 或 unix: 或 all</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">拒绝指定源 IP 的客户端连接</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        deny  192.168.1.1;          <span class="comment"># 禁止192.168.1.1</span></span><br><span class="line">        allow 192.168.0.0/24;       <span class="comment"># 允许192.168.0.0/24的IP访问</span></span><br><span class="line">        allow 10.1.1.0/16;          <span class="comment"># 允许10.1.1.0/16的IP访问</span></span><br><span class="line">        allow 2001:0db8::/32;</span><br><span class="line">        deny  all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx 按照自上而下的顺序进行匹配。</p>
<ul>
<li><strong>ngx_stream_return_module</strong></li>
</ul>
<p>该模块向客户端返回指定值并关闭连接。</p>
<p>返回值指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">返回值指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">return</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">server</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">向客户端返回指定值并关闭连接</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 12345;</span><br><span class="line">        <span class="built_in">return</span> <span class="variable">$time_iso8601</span>; <span class="comment"># 返回当前连接的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCP-UDP代理简述"><a href="#TCP-UDP代理简述" class="headerlink" title="TCP&#x2F;UDP代理简述"></a>TCP&#x2F;UDP代理简述</h3><p>Nginx 并不直接提供 TCP&#x2F;UDP 的应用响应，Nginx Stream 模块的核心功能是将客户端的 TCP&#x2F;UDP 连接反向代理给后端的被代理服务器。</p>
<h4 id="核心配置指令"><a href="#核心配置指令" class="headerlink" title="核心配置指令"></a>核心配置指令</h4><p>TCP&#x2F;UDP 代理功能的核心配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">proxy_bind</td>
<td align="left">address[transparent] 或 off</td>
<td align="left">–</td>
<td align="left">设置从指定的本地 IP 地址及端口与被代理服务器建立连接，指令值可以是变量。指令值参数为 transparent 时，允许将客户端的真实 IP 透传给被代理服务器，并以客户端真实 IP 为访问被代理服务器的源 IP；指令值参数为 off 时，则取消上一层指令域同名指令的配置</td>
</tr>
<tr>
<td align="left">proxy_buffer_size</td>
<td align="left">size</td>
<td align="left">16k</td>
<td align="left">设置用于从被代理服务器读取数据的缓冲区的大小，也用于设置从客户端读取会话数据的缓冲区的大小</td>
</tr>
<tr>
<td align="left">proxy_connect_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">与被代理服务器建立连接的超时时间</td>
</tr>
<tr>
<td align="left">proxy_timeout</td>
<td align="left">time</td>
<td align="left">10m</td>
<td align="left">Nginx 服务器与客户端或被代理服务器的两个连续成功的读或写操作的最大间隔时间，如果在间隔时间内没有数据传输，则关闭连接</td>
</tr>
<tr>
<td align="left">proxy_download_rate</td>
<td align="left">rate</td>
<td align="left">0</td>
<td align="left">限制每个连接每秒从被代理服务器中读取数据的字节数，默认不限制</td>
</tr>
<tr>
<td align="left">proxy_upload_rate</td>
<td align="left">rate</td>
<td align="left">0</td>
<td align="left">限制每个连接每秒发送到被代理服务器的数据的字节数，默认不限制</td>
</tr>
<tr>
<td align="left">proxy_next_upstream</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">当被代理的服务返回错误或超时时，将未返回响应的客户端连接请求传递给 upstream 中的下一个服务器</td>
</tr>
<tr>
<td align="left">proxy_next_upstream_timeout</td>
<td align="left">time</td>
<td align="left">0</td>
<td align="left">设置将符合条件的客户端连接请求传递给 upstream 中下一个服务器的超时时间。”0”为不做超时限制，即直到遍历完所有上游服务器组中的服务器为止</td>
</tr>
<tr>
<td align="left">proxy_next_upstream_tries</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">设置将符合条件的客户端连接请求传递给 upstream 中下一个服务器的尝试次数，包括第一次的失败次数。”0”为不做尝试次数限制，即直到遍历完所有上游服务器组中的服务器为止</td>
</tr>
<tr>
<td align="left">proxy_pass</td>
<td align="left">address</td>
<td align="left">–</td>
<td align="left">被代理服务器的地址，支持 IP 或域名加端口、UNIX 域套接字、upstream 名</td>
</tr>
<tr>
<td align="left">proxy_protocol</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置是否对被代理服务器的连接启用代理协议（proxy_protocol）支持</td>
</tr>
<tr>
<td align="left">proxy_socket_keepalive</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置 Nginx 与被代理服务器的 TCP keepalive 行为的心跳检测机制，默认使用操作系统的 socket 配置，若指令值为 on，则开启 SO_KEEPALIVE 选项进行心跳检测</td>
</tr>
<tr>
<td align="left">proxy_ssl</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置是否启用 SSL&#x2F;TLS 协议与被代理服务器建立连接</td>
</tr>
<tr>
<td align="left">proxy_ssl_protocols</td>
<td align="left">[SSLv2][SSLv3] [TLSv1][TLSv1.1] [TLSv1.2][TLSv1.3]</td>
<td align="left">TLSv1 TLSv1.1 TLSv1.2</td>
<td align="left">指定可用于 Nginx 与被代理服务器建立 SSL 连接的 SSL 协议版本</td>
</tr>
<tr>
<td align="left">proxy_ssl_session_reuse</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">是否启用与被代理服务器 SSL TCP 连接的 SSL 会话重用功能</td>
</tr>
<tr>
<td align="left">proxy_ssl_ciphers</td>
<td align="left">ciphers</td>
<td align="left">DEFAULT</td>
<td align="left">设置与被代理服务器建立 SSL 连接时，用于协商使用的加密算法组合，也称为密码套件，指令值内容为 openssl 的密码套件名称，多个套件名称由”:”分隔</td>
</tr>
<tr>
<td align="left">proxy_ssl_server_name</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">在与被代理服务器建立 SSL 连接时，设置是否启用通过 SNI 或 RFC 6066 传递主机名</td>
</tr>
<tr>
<td align="left">proxy_ssl_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定被代理服务器对 Nginx 服务器身份验证的 PEM 格式 SSL 证书文件</td>
</tr>
<tr>
<td align="left">proxy_ssl_certificate_key</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定被代理服务器对 Nginx 服务器身份验证的 PEM 格式 SSL 证书私钥文件</td>
</tr>
<tr>
<td align="left">proxy_ssl_password_file</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">存放被代理服务器对 Nginx 服务器身份验证的 PEM 格式 SSL 证书私钥文件的密码文件，一个密码一行。有多个密码时，Nginx 会依次尝试</td>
</tr>
<tr>
<td align="left">proxy_ssl_verify</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置是否启用对被代理服务器的 SSL 证书的验证功能</td>
</tr>
<tr>
<td align="left">proxy_ssl_name</td>
<td align="left">name</td>
<td align="left">proxy_pass 指令指定的主机名</td>
<td align="left">指定对被代理服务器 SSL 证书验证的主机名</td>
</tr>
<tr>
<td align="left">proxy_ssl_crl</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">证书品销列表文件，用于验证被代理服务器 SSL 证书有效性的 PEM 格式文件</td>
</tr>
<tr>
<td align="left">proxy_ssl_trusted_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定一个 PEM 格式的 CA 证书（根或中间证书）文件，该证书用作被代理服务器的证书链验证</td>
</tr>
<tr>
<td align="left">proxy_ssl_verify_depth</td>
<td align="left">number</td>
<td align="left">1</td>
<td align="left">设置被代理服务器的证书链的验证深度</td>
</tr>
<tr>
<td align="left">proxy_requests</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">UDP 代理时，设置同一客户端被 Nginx 在每次 UDP 会话中，转发给被代理服务器的数据报的数量。当达到这个数量时，将启用一个新的 UDP 会话继续转发。可用于 Nginx 对 UDP 虚拟连接会话的控制</td>
</tr>
<tr>
<td align="left">proxy_responses</td>
<td align="left">number</td>
<td align="left">–</td>
<td align="left">UDP 代理时，设置允许被代理服务器返回 UDP 数据报的数量，超过指令值时将中止会话。默认无限制，0 为不返回响应数据</td>
</tr>
</tbody></table>
<p>该模块的指令使用的指令域范围为 stream、server。</p>
<h4 id="TCP-反向代理配置样例"><a href="#TCP-反向代理配置样例" class="headerlink" title="TCP 反向代理配置样例"></a>TCP 反向代理配置样例</h4><p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 389 ;                          <span class="comment"># 设置监听端口为389</span></span><br><span class="line">        proxy_pass 192.168.2.100:389;         <span class="comment"># 将连接代理到后端192.168.2.100:389</span></span><br><span class="line">        proxy_timeout 5s;                     <span class="comment"># 与被代理服务器的连续通信间隔大于5s，</span></span><br><span class="line">                                              <span class="comment"># 则认为通信超时，将关闭连接</span></span><br><span class="line">        proxy_connect_timeout 5s;             <span class="comment"># 与被代理服务器建立连接的超时时间为5s</span></span><br><span class="line">        access_log logs/ldap_access.log tcp;  <span class="comment"># 记录日志文件为logs/ldap_access.log，</span></span><br><span class="line">                                              <span class="comment"># 日志模板为tcp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理-SSL-TCP"><a href="#代理-SSL-TCP" class="headerlink" title="代理 SSL TCP"></a>代理 SSL TCP</h4><p>代理模块 stream 可以实现基于 SSL&#x2F;TLS 协议的被代理服务器的反向代理，部署方式为客户端 → Nginx 服务器（TCP）→ 被代理服务器（SSL TCP）。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 636;                            <span class="comment"># 设置监听端口为636</span></span><br><span class="line">        access_log  logs/ldap_access.log tcp;</span><br><span class="line">        proxy_pass  192.168.2.100:636;</span><br><span class="line">        proxy_ssl   on;                        <span class="comment"># 启用SSL/TLS协议，与被代理服务器建立连接</span></span><br><span class="line">        proxy_ssl_session_reuse on;            <span class="comment"># 与被代理服务器SSL TCP连接的SSL会话重用功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UDP-反向代理配置"><a href="#UDP-反向代理配置" class="headerlink" title="UDP 反向代理配置"></a>UDP 反向代理配置</h4><p>UDP 协议是一种无连接的协议，发送端与接收端传输数据之前不需要建立连接，发送端会尽最大努力把数据发送出去，不能保证安全地传输到接收端。由于传输数据不建立连接，也不需要维持复杂的链路关系（包括连接状态、收发状态等），因此发送端可同时向多个接收端传输相同的消息。</p>
<p>虽然 UDP 的数据传输是不可靠的，但如果有一个数据报丢失，另一个新的数据报会在几秒内替换它发送到接收端。UDP 协议通常被用在单向传输无须返回响应及信息分发的场景，如日志收集或在屏幕上的航班信息、股票行情等多媒体场景。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1514 udp;               <span class="comment"># 设置监听端口为1514并启用UDP协议</span></span><br><span class="line">        proxy_pass 192.168.2.123:1514;</span><br><span class="line">        proxy_responses 0;             <span class="comment"># 会话接收数据报后无须等待返回响应，立即关闭会话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于SSL的TCP代理服务器"><a href="#基于SSL的TCP代理服务器" class="headerlink" title="基于SSL的TCP代理服务器"></a>基于SSL的TCP代理服务器</h3><p>Nginx 可以通过代理模块实现上游服务器 SSL&#x2F;TLS 协议的连接，同时 Nginx 还通过模块 ngx_stream_ssl_module 提供了基于 SSL&#x2F;TLS 协议的 TCP 连接监听。Nginx 还可以把 SSL 证书部署在 Nginx 服务器上，这就减轻了后端上游服务器的 CPU 运算量并实现 SSL 证书的统一管理和维护。</p>
<p>ngx_stream_ssl_module 模块默认不会被构建，这就需要在编译的时候通过<code>--with-stream_ssl_module</code>参数进行启用。相关配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ssl_protocols</td>
<td align="left">[SSLv2][SSLv3] [TLSv1][TLSv1.1] [TLSv1.2][TLSv1.3]</td>
<td align="left">TLSv1 TLSv1.1 TLSv1.2</td>
<td align="left">设置使用的 SSL 协议版本</td>
</tr>
<tr>
<td align="left">ssl_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">PEM 格式的 SSL 证书文件，可自建或由 CA 机构颁发</td>
</tr>
<tr>
<td align="left">ssl_certificate_key</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">PEM 格式的 SSL 证书私钥文件，可自建或由 CA 机构颁发</td>
</tr>
<tr>
<td align="left">ssl_password_file</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">存放 SSL 证书私钥文件的密码文件，一个密码一行。有多个密码时，Nginx 会依次尝试</td>
</tr>
<tr>
<td align="left">ssl_ciphers</td>
<td align="left">ciphers</td>
<td align="left">HIGH:!aNULL:!MD5</td>
<td align="left">设置 SSL TCP 建立连接时用于协商使用的加密算法组合，也称为密码套件。指令值内容为 openssl 的密码套件名称，多个套件名称由”:”分隔</td>
</tr>
<tr>
<td align="left">ssl_prefer_server_ciphers</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用 SSLv3 和 TLSv1 协议在 SSL TCP 连接时优先使用服务端设置的密码套件</td>
</tr>
<tr>
<td align="left">ssl_dhparam</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">DH 密钥交换的 Diffie-Hellman 参数文件</td>
</tr>
<tr>
<td align="left">ssl_ecdh_curve</td>
<td align="left">curve</td>
<td align="left">auto</td>
<td align="left">配置 SSL 加密时使用椭圆曲线 DH 密钥交换的曲线参数，多个参数使用”:”分隔。ecdh 是 Elliptic-Curve 和 Diffie-Hellman 的缩写，指令值为 auto 时，配置的曲线参数是 prime256v1</td>
</tr>
<tr>
<td align="left">ssl_session_cache</td>
<td align="left">off 或 none 或 [builtin[:size]] [shared:name:size]</td>
<td align="left">none</td>
<td align="left">SSL TCP 会话缓存设置</td>
</tr>
<tr>
<td align="left">ssl_session_tickets</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">是否启用 SSL TCP 会话缓存 session ticket 机制，指令值为 off 时，使用 session ID 会话缓存机制</td>
</tr>
<tr>
<td align="left">ssl_session_ticket_key</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定会话凭证密钥文件，用以多台 Nginx 间实现 session ticket 共享，否则 Nginx 会随机生成一个会话凭证密钥</td>
</tr>
<tr>
<td align="left">ssl_session_timeout</td>
<td align="left">time</td>
<td align="left">5m</td>
<td align="left">设置客户端可用会话缓存的超时时间</td>
</tr>
<tr>
<td align="left">ssl_verify_client</td>
<td align="left">on 或 off 或 optional 或 optional_no_ca</td>
<td align="left">off</td>
<td align="left">设置是否启用对客户端证书验证功能，指令值为 on 时，启用验证；指令值为 optional 时，如果接收到客户端证书则启用验证；指令值为 optional_no_ca 时，若接收到客户端证书，则启用客户端证书验证，但不进行证书链校验。验证结果将存储在 $ssl_client_verity 变量中</td>
</tr>
<tr>
<td align="left">ssl_crl</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">证书吊销列表文件，用以验证客户端 SSL 证书有效性的 PEM 格式文件</td>
</tr>
<tr>
<td align="left">ssl_client_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定一个 PEM 格式的 CA 证书（根或中间证书）文件，该证书用作客户端的证书验证。该证书列表会被发送给客户端</td>
</tr>
<tr>
<td align="left">ssl_trusted_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定一个 PEM 格式的 CA 证书（根或中间证书）文件，该证书用作客户端的证书验证。该证书列表不会被发送给客户端</td>
</tr>
<tr>
<td align="left">ssl_verify _depth</td>
<td align="left">number</td>
<td align="left">1</td>
<td align="left">设置客户端证书链验证深度</td>
</tr>
</tbody></table>
<p>关于上表有以下几点需要说明。</p>
<ul>
<li>该模块指令值使用的指令域范围为 stream、server。</li>
<li>Nginx 建立 SSL TCP 监听，用户发送 SSL TCP 连接时，由 Nginx 实现 SSL 终止并把 TCP 会话代理到上游服务器，部署方式为客户端 → Nginx 服务器（SSL TCP）→ 上游服务器（TCP）。配置样例如下:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen              636 ssl;                    <span class="comment"># 设置监听端口为636</span></span><br><span class="line">        access_log logs/ldap_access.log tcp;</span><br><span class="line"></span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;      <span class="comment"># 设置使用的SSL协议版本</span></span><br><span class="line">        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;</span><br><span class="line">            <span class="comment"># 设置服务端使用的密码套件</span></span><br><span class="line">        ssl_certificate     ssl/www_nginxbar_org.pem;   <span class="comment"># 主机名www.nginxbar.org证书文件</span></span><br><span class="line">        ssl_certificate_key ssl/www_nginxbar_org.key;   <span class="comment"># 主机名www.nginxbar.org证书密钥文件</span></span><br><span class="line">        ssl_session_cache   shared:SSL:10m;             <span class="comment"># SSL TCP会话缓存设置共享内存区域名为</span></span><br><span class="line">                                                        <span class="comment"># SSL，区域大小为10MB</span></span><br><span class="line">        ssl_session_timeout 10m;                        <span class="comment"># SSL TCP会话缓存超时时间为10分钟</span></span><br><span class="line">        proxy_pass                    192.168.2.100:389;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以通过代理模块的 proxy_ssl 指令配置与上游服务器实现全链路的安全数据通信。部署方式为客户端 → Nginx 服务器（SSL TCP）→ 被代理服务器（SSL TCP）。配置样例如下:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen              636 ssl;                   <span class="comment"># 设置监听端口为636</span></span><br><span class="line">        access_log logs/ldap_access.log tcp;</span><br><span class="line"></span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;     <span class="comment"># 设置使用的SSL协议版本</span></span><br><span class="line">        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;</span><br><span class="line">            <span class="comment"># 设置服务端使用的密码套件</span></span><br><span class="line">        ssl_certificate     ssl/www_nginxbar_org.pem;  <span class="comment"># 主机名www.nginxbar.org证书文件</span></span><br><span class="line">        ssl_certificate_key ssl/www_nginxbar_org.key;  <span class="comment"># 主机名www.nginxbar.org证书密钥文件</span></span><br><span class="line">        ssl_session_cache   shared:SSL:10m;  <span class="comment"># SSL TCP会话缓存设置共享内存区域名为SSL，区域大小为10MB</span></span><br><span class="line">        ssl_session_timeout 10m;             <span class="comment"># SSL TCP会话缓存超时时间为10分钟</span></span><br><span class="line"></span><br><span class="line">        proxy_ssl   on;                      <span class="comment"># 启用SSL/TLS协议，与被代理服务器建立连接</span></span><br><span class="line">        proxy_ssl_session_reuse on;          <span class="comment"># 与被代理服务器SSL TCP连接的SSL会话重用功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gRPC代理服务器"><a href="#gRPC代理服务器" class="headerlink" title="gRPC代理服务器"></a>gRPC代理服务器</h3><p>通过 gRPC 模块的反向代理功能对外发布包括基于 SSL 的 gRPC 服务，且其应用 Nginx 提供的 HTTPv2 模块可实现速率限定、基于 IP 的访问控制以及日志等功能。</p>
<p>通过 Nginx 的 location 指令可检查方法调用，可将不同的调用方法路由到后端的多个不同 gRPC 服务器，以实现单点部署多个 gRPC 服务器的应用场景。并且通过 Nginx 实现 gRPC 服务器负载均衡，还可以使用轮询、最少连接数等算法实现流量分发。</p>
<h4 id="gRPC-介绍"><a href="#gRPC-介绍" class="headerlink" title="gRPC 介绍"></a>gRPC 介绍</h4><p>gRPC 是一个开源的基于 HTTP&#x2F;2 协议的高性能、跨语言的远程过程调用（RPC）框架。它提供了双向流、流控、头部压缩、单 TCP 连接上的多复用请求等功能，这些功能使其在移动设备上可更节省空间和降低电量消耗。而且 gRPC 相对于 REST 的数据调用方式，提供了一个更加适合服务间调用数据的通信方案。</p>
<p>基于 gRPC 的客户端应用可以像调用本地对象方法一样直接调用 gRPC 服务端提供的方法，使其更适合分布式应用和服务场景。</p>
<h4 id="gRPC-模块指令"><a href="#gRPC-模块指令" class="headerlink" title="gRPC 模块指令"></a>gRPC 模块指令</h4><p>Nginx 默认会构建 gRPC 代理的支持，但 gRPC 是基于 HTTP&#x2F;2 协议的，而 ngx_http_v2_module 模块默认不会被构建，这就需要在编译时通过<code>–with-http_v2_module</code>参数来启用对 HTTP&#x2F;2 协议的支持。</p>
<p>gRPC 代理模块配置指令下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">grpc_bind</td>
<td align="left">address[transparent] 或 off</td>
<td align="left">–</td>
<td align="left">设置从指定的本地 IP 地址及端口与被代理服务器建立连接，指令值可以是变量。指令值参数为 transparent 时，允许将客户端的真实 IP 透传给被代理服务器，并以客户端真实 IP 为访问被代理服务器的源 IP</td>
</tr>
<tr>
<td align="left">grpc_buffer_size</td>
<td align="left">size</td>
<td align="left">4k 或 8k</td>
<td align="left">设置用于从 gRPC 服务器读取响应数据缓冲区的大小，当 Nginx 收到响应数据后将同步传递给客户端</td>
</tr>
<tr>
<td align="left">grpc_pass</td>
<td align="left">address</td>
<td align="left">–</td>
<td align="left">设置 gRPC 服务器的地址及端口，地址可以是 IP、域名或 UNIX 套接字</td>
</tr>
<tr>
<td align="left">grpc_hide_header</td>
<td align="left">field</td>
<td align="left">–</td>
<td align="left">指定 gRPC 服务器响应数据中，不向客户端传递的 HTTP 头字段名称</td>
</tr>
<tr>
<td align="left">grpc_pass_header</td>
<td align="left">field</td>
<td align="left">–</td>
<td align="left">默认配置下 Nginx 不会将头字段属性 Status 和 X-Accel-… 传递给客户端，可通过该指令开放传递</td>
</tr>
<tr>
<td align="left">grpc_ignore_headers</td>
<td align="left">field…</td>
<td align="left">–</td>
<td align="left">设置禁止 Nginx 处理从 gRPC 服务器获取响应的头字段</td>
</tr>
<tr>
<td align="left">grpc_set_header</td>
<td align="left">field value</td>
<td align="left">Content-Length $content_length</td>
<td align="left">在转发给 gRPC 服务器前，修改或添加客户端的请求头属性字段</td>
</tr>
<tr>
<td align="left">grpc_connect_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">Nginx 与 gRPC 服务器建立连接的超时时间，通常不应该超过 75s</td>
</tr>
<tr>
<td align="left">grpc_read_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个从 gRPC 服务器接收数据的”读”操作之间的间隔时间超过设置的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">grpc_send_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个发送到 gRPC 服务器的”写”操作之间的间隔时间超过设置的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">grpc_socket_keepalive</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置 Nginx 与被代理服务器的 TCP keepalive 行为的心跳检测机制，默认使用操作系统的 socket 配置，若指令值为 on 时，则开启 SO_KEEPALIVE 选项进行心跳检测</td>
</tr>
<tr>
<td align="left">grpc_intercept_errors</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">指令值为 on 时，将拦截 gRPC 服务器啊应码大于或等于 300 的结果，error page 指令可对该结果做后续处理；指令值为 off 时，则直接返回给客户端</td>
</tr>
<tr>
<td align="left">grpc_next_upstream</td>
<td align="left">error、timeout、 invalid_header、 http_500、http_503、 http_403、http_404、 http_429、 non_idempotent、 off…</td>
<td align="left">error timeout</td>
<td align="left">当出现指令值中指定的条件时，将未返回响应的客户请求传递给 upstream 中的下一个服务器</td>
</tr>
<tr>
<td align="left">grpc_next_upstream_timeout</td>
<td align="left">time</td>
<td align="left">0</td>
<td align="left">设置将符合条件的客户端请求传递给 upstream 的过程中，下一个服务器的超时时间。指令值为 0 不做超时限制，直到遍历完所有上游服务器组中的服务器为止</td>
</tr>
<tr>
<td align="left">grpc_next_upstream_tries</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">设置符合条件的客户端请求传递给 upstream 的过程中，下一个服务器的尝试次数，包括第一次的失败次数。指令值为 0 不做尝试次数限制，直到遍历完所有上游服务器组中的服务器为止</td>
</tr>
<tr>
<td align="left">grpe_ssl_protocols</td>
<td align="left">[SSLv2][SSLv3] [TLSv1][TLSv1.1] [TLSv1.2][TLSv1.3]</td>
<td align="left">TLSv1 TLSv1.1 TLSv1.2</td>
<td align="left">指定可用于 Nginx 与 gRPC 服务器建立 SSL 连接的 SSL 协议的版本</td>
</tr>
<tr>
<td align="left">grpe_ssl_session_reuse</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">是否启用与 gRPC 服务器 HTTPS 连接的 SSL 会话重用功能</td>
</tr>
<tr>
<td align="left">grpc_ssl_ciphers</td>
<td align="left">ciphers</td>
<td align="left">DEFAULT</td>
<td align="left">设置 HTTPS 建立连接时用于协商使用的加密算法组合，也称为密码套件，指令值内容为 openssl 的密码套件名称，多个套件名称由”:”分隔</td>
</tr>
<tr>
<td align="left">grpc_ssl_server_name</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">在与 gRPC 服务器建立 SSL 连接时，设置是否启用通过 SNI 或 RFC 6066 传递主机名</td>
</tr>
<tr>
<td align="left">grpc_ssl_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定 gRPC 服务器对 Nginx 服务器身份验证的 PEM 格式 SSL 证书文件</td>
</tr>
<tr>
<td align="left">grpc_ssl_certificate_key</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定 gRPC 服务器对 Nginx 服务器身份验证的 PEM 格式 SSL 证书私钥文件</td>
</tr>
<tr>
<td align="left">grpc_ssl_password_file</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">存放 gRPC 服务器对 Nginx 服务器身份验证的 PEM 格式 SSL 证书私钥文件的密码文件，一个密码一行。有多个密码时，Nginx 会依次尝试</td>
</tr>
<tr>
<td align="left">grpe_ssl_verify</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置是否启用对 gRPC 服务器的 SSL 证书验证机制</td>
</tr>
<tr>
<td align="left">grpc_ssl_name</td>
<td align="left">name</td>
<td align="left">proxy_pass 指令指定的主机名</td>
<td align="left">指定对 gRPC 服务器 SSL 证书验证的主机名</td>
</tr>
<tr>
<td align="left">grpc_ssl_crl</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">证书吊销列表文件，用以验证被代理服务器 SSL 证书有效性的 PEM 格式文件</td>
</tr>
<tr>
<td align="left">grpc_ssl_trusted_certificate</td>
<td align="left">file</td>
<td align="left">–</td>
<td align="left">指定一个 PEM 格式的 CA 证书（根或中间证书）文件，该证书用作 gRPC 服务器的证书链验证</td>
</tr>
<tr>
<td align="left">grpc_ssl_verify_depth</td>
<td align="left">number</td>
<td align="left">1</td>
<td align="left">设置 gRPC 服务器的证书链的验证深度</td>
</tr>
</tbody></table>
<h4 id="gRPC-反向代理配置"><a href="#gRPC-反向代理配置" class="headerlink" title="gRPC 反向代理配置"></a>gRPC 反向代理配置</h4><p>gRPC 是基于 HTTP&#x2F;2 协议的，所以 Nginx 的 gRPC 代理需要启用 HTTP&#x2F;2，然后 gRPC 客户端将请求发送到 Nginx。Nginx 为 gRPC 服务提供了一个稳定的网关。其部署方式如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZG522312I.gif" alt="gRPC 代理"></p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  8080 http2;                               <span class="comment"># 设置监听端口为8080并启用http/2协议支持</span></span><br><span class="line">    access_log /var/log/nginx/grpc_access.log main;</span><br><span class="line">    location / &#123;</span><br><span class="line">        grpc_pass grpc://192.168.2.145:50051;         <span class="comment"># 设置gRPC服务器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gRPC 模块同样提供对后端 SSL gRPC 服务器的反向代理，配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80 http2;                                 <span class="comment"># 设置监听端口为80并启用http/2协议支持</span></span><br><span class="line">    access_log /var/log/nginx/grpcs_access.log main;</span><br><span class="line">    grpc_ssl_verify off;                              <span class="comment"># 关闭对gRPC服务器的SSL证书验证</span></span><br><span class="line">    grpc_ssl_session_reuse on;                        <span class="comment"># 设置gRPC服务器</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        grpc_pass grpcs://192.168.2.145:50051;        <span class="comment"># 设置SSL gRPC服务器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx 可以通过 HTTP 协议的 SSL 证书，对外提供安全的 gRPC 代理转发，部署方式为客户端 → Nginx 服务器（HTTPS）→ 被代理服务器（SSL gRPC）。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2 default_server;         <span class="comment"># 设置监听端口为443并启用SSL及HTTP/2协议支持</span></span><br><span class="line">    access_log /var/log/nginx/grpcs_access.log main;</span><br><span class="line"></span><br><span class="line">    ssl_certificate ssl/www_nginxbar_org.pem;    <span class="comment"># 网站证书文件</span></span><br><span class="line">    ssl_certificate_key ssl/www_nginxbar_org.key;# 网站证书密钥文件</span><br><span class="line"></span><br><span class="line">    grpc_ssl_verify off;</span><br><span class="line">    grpc_ssl_session_reuse on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        grpc_pass grpcs://192.168.2.145:50051;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><p>Web 缓存可节约网络带宽，有效提高用户打开网站的速度。</p>
<p>由于应用服务器被请求次数的降低，也相对使它的稳定性得到了提升。</p>
<p>Web 缓存从数据内容传输的方向分为前向位置缓存和反向位置缓存两类。如下图所示。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200ZG61314U5.BDnD5CUT.gif" alt="img"></p>
<p>前向位置缓存既可以是用户的客户端浏览器，也可以是位于用户 ISP 或内部局域网的服务器。</p>
<p>反向位置缓存通常位于互联网端，如内容分发网络或网站的反向代理缓存等。</p>
<h4 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h4><p>为了减少客户端每次访问网站时获取资源的过程的浪费，提高访问效率，客户端浏览器会将访问的内容在本地生成内容缓存。</p>
<p>客户端会通过内容缓存的有效期及 Web 服务器提供的访问请求校验机制，快速判断请求的内容是否已经更新。（避免网站发生变更没来得及更新）</p>
<p><img src="https://nginx.mosong.cc/assets/8-200ZG61340340.Cqb7uLLo.gif" alt="img"></p>
<p>客户端通过<strong>内容缓存有效期的本地校验</strong>和由 <strong>Web 服务端提供的服务端校验</strong>两种方式共同校验内容缓存是否有效，</p>
<p>这两种方式都是通过 <strong>HTTP 消息头</strong>中的相应字段进行判断或与服务端交互的。</p>
<p>HTTP 消息头字段功能说明如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">消息头字段</th>
<th align="left">示例</th>
<th align="left">类型</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cache-Control</td>
<td align="left">Cache-Control: no-cache</td>
<td align="left">请求&#x2F;响应</td>
<td align="left">HTTP&#x2F;1.1 协议加入的缓存控制字段，用于服务端告知客户端是否缓存及缓存的有效期。也可用于客户端本地缓存检验流程的控制</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">Pragma: no-cache</td>
<td align="left">请求&#x2F;响应</td>
<td align="left">一个在 HTTP&#x2F;1.0 中规定的通用消息头字段，当字段值为 no-cache 时，功能与消息头 Cache-Control:no-cache 的设定一致</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">Date: Tue, 15 Nov 2018 08:12:31 GMT</td>
<td align="left">响应</td>
<td align="left">原始服务器消息发出的时间</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">Expires: Fri, 16 Aug 2019 19:43:31 GMT</td>
<td align="left">响应</td>
<td align="left">告知客户端当前响应内容缓存的有效期，是个绝对时间，属于 HTTP&#x2F;1.0 的协议约定，优先级低于 HTTP&#x2F;1.1 协议的 max-age 设置</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">Last-Modified: Fri, 16 Aug 2019 12:45:26 GMT</td>
<td align="left">响应</td>
<td align="left">当前响应数据的最后修改时间</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">If-Modified-Since: Fri, 16 Aug 2019 19:43:31 GMT</td>
<td align="left">请求</td>
<td align="left">将当前请求本地内容缓存的最后修改时间发送给服务端进行校验，如果请求的内容在指定时间之后被修改了，将返回被修改的内容，否则返回响应状态码 304，客户端将使用本地缓存</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">If-Unmodified-Since: Fri, 16 Aug 2019 19:43:31 GMT</td>
<td align="left">请求</td>
<td align="left">将当前请求本地内容缓存的最后修改时间发送给服务端进行校验，如果请求的内容在指定时间之后未被修改，将继续传输内容，否则返回响应状态码 412，其常被用在 byte-range 请求的断点续传场景</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">ETag: “0a3ea38e4fd51:0”</td>
<td align="left">响应</td>
<td align="left">当前响应数据的实体标签值</td>
</tr>
<tr>
<td align="left">If-Match</td>
<td align="left">If-Match: “0a3ea38e4fd51:0”</td>
<td align="left">请求</td>
<td align="left">将当前内容缓存的 ETag 值发送给服务端进行校验，如果与服务端的 ETag 匹配一致就继续响应请求，否则返回响应状态码 412</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">If-None-Match: “0a3ea38e4fd51:0”</td>
<td align="left">请求</td>
<td align="left">将当前内容缓存的 ETag 值发送给服务端进行校验，如果与服务端的 ETag 值匹配不一致，则返回新的内容，否则返回响应状态码 304，客户端将使用本地缓存</td>
</tr>
</tbody></table>
<ol>
<li>消息头字段 <strong>Cache-Control</strong> 由客户端发起缓存控制的相关字段值如下表所示。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">消息头</th>
<th align="left">功能分类</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cache-Control: max-age&#x3D;</td>
<td align="left">有效期</td>
<td align="left">当 max-age&#x3D;0 时，不进行内容缓存的有效期验证，直接向 Web 服务器发起请求，不影响缓存的服务端验证</td>
</tr>
<tr>
<td align="left">Cache-Control: max-stale[&#x3D;]</td>
<td align="left">有效期</td>
<td align="left">如果内容缓存的过期时间不超过指定值，仍可被认为有效并被客户端使用。单位为秒</td>
</tr>
<tr>
<td align="left">Cache-Control: min-fresh&#x3D;</td>
<td align="left">有效期</td>
<td align="left">内容缓存的更新时间不超过指定值，则认为有效。单位为秘</td>
</tr>
<tr>
<td align="left">Cache-Control: no-cache</td>
<td align="left">可缓存性</td>
<td align="left">不进行内容缓存的有效期验证，直接向 Web 服务器发起请求。常用在 Ctrl+F5 的场景，强制从服务端获取最新内容</td>
</tr>
<tr>
<td align="left">Cache-Control: only-if-cached</td>
<td align="left">其他</td>
<td align="left">只使用本地已经缓存的内容，不向 Web 服务器发送请求</td>
</tr>
</tbody></table>
<p>当按下 F5 或者点击刷新时，客户端浏览器会添加请求消息头字段<code>Cache-Control:max-age=0</code>，该请求不进行内容缓存的本地验证，会直接向Web服务端发起请求，服务端将根据消息头字段进行服务端验证。</p>
<p>当按下 Ctrl+F5 时，客户端浏览器会添加请求消息头字段<code>Cache-Control:no-cache</code>和<code>Pragma:no-cache</code>，并忽略所有服务端验证的消息头字段，该请求不进行内容缓存的本地验证，它会直接向 Web 服务端发起请求，因没有服务端验证的消息头字段，所以会直接返回请求内容。</p>
<ol start="2">
<li>消息头字段 Cache-Control 由服务端发起缓存控制的相关字段值如下表所示。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">消息头</th>
<th align="left">类型</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cache-Control: no-cache</td>
<td align="left">可缓存性</td>
<td align="left">不对响应数据的内容缓存设置有效期，不需要进行本地有效期验证</td>
</tr>
<tr>
<td align="left">Cache-Control: no-store</td>
<td align="left">可缓存性</td>
<td align="left">响应数据不在本地保留内容缓存</td>
</tr>
<tr>
<td align="left">Cache-Control: public</td>
<td align="left">可缓存性</td>
<td align="left">表明当前数据可以被任何对象（客户端、缓存服务器等）缓存</td>
</tr>
<tr>
<td align="left">Cache-Control: private</td>
<td align="left">可缓存性</td>
<td align="left">当响应数据在经过缓存服务器（CDN 或反向代理缓存服务器）时，用于告知缓存服务器不能缓存该响应数据</td>
</tr>
<tr>
<td align="left">Cache-Control: max-age&#x3D;</td>
<td align="left">有效期</td>
<td align="left">设置内容缓存的最大有效期，是个相对值，表示一个时间区间，单位为 s</td>
</tr>
<tr>
<td align="left">Cache-Control: s-maxage&#x3D;</td>
<td align="left">有效期</td>
<td align="left">当响应数据在经过缓存服务器（CDN 或反向代理缓存服务器）时，用于对缓存服务器中缓存的控制，该值优先级高于 max-age 的设定，与客户端浏览器无关</td>
</tr>
<tr>
<td align="left">Cache-Control: must-revalidate</td>
<td align="left">服务端验证</td>
<td align="left">当响应数据被设置有效期时，超过有效期的缓存请求必须进行服务端验证</td>
</tr>
<tr>
<td align="left">Cache-Control: proxy-revalidate</td>
<td align="left">服务端验证</td>
<td align="left">当响应数据在经过缓存服务器（CDN 或反向代理缓存服务器）时，用于缓存服务器缓存的控制，功能与 must-revalidate相同</td>
</tr>
<tr>
<td align="left">Cache-Control: no-transform</td>
<td align="left">其他</td>
<td align="left">当响应数据在经过缓存服务器（CDN 或反向代理缓存服务器）时，用于告知缓存服务器不得对消息头进行修改，与客户端浏览器无关</td>
</tr>
</tbody></table>
<ol start="3">
<li>Last-Modified 与 if-modified-since 属于 HTTP&#x2F;1.0，是用于<strong>服务端对响应数据修改时间进行校验的服务端校验方法。</strong></li>
</ol>
<p>Last-Modified 的值是由服务端生成后传递给客户端的，客户端发送请求时，它会将本地内容缓存中的 Last-Modified 的值由请求消息头的 if-modified-since 字段传递给服务端，如果服务端被请求的内容在 if-modified-since 字段值的时间之后被修改了，将返回被修改的内容，否则返回响应状态码 304，客户端将使用本地缓存。</p>
<ol start="4">
<li>ETag 与 If-None-Match 属于 HTTP&#x2F;1.1，优先级高于 Last-Modified 的验证，是<strong>用于服务端对响应数据进行实体标签校验的服务端校验方法。</strong></li>
</ol>
<p>ETag 类似于<strong>身份指纹</strong>，是一个可以与 Web 资源关联的记号（token）。当客户端第一次发起请求时，ETag 的值在响应消息头中传递给客户端；当客户端再次发送请求时，如果验证本地内容缓存需要发起服务端验证，Etag 的值将由请求消息头的 If-None-Match 字段传递给服务端。</p>
<p>如果验证本地内容缓存与服务端的 ETag 的匹配不一致，则认为请求的内容已经更新，服务端将返回新的内容，否则返回响应状态码 304，客户端将使用本地缓存。</p>
<ol start="5">
<li>客户端会通过 HTTP 消息头字段对本地内容缓存进行本地校验和服务端校验，内容缓存校验的流程如下图所示。</li>
</ol>
<p><img src="https://nginx.mosong.cc/assets/8-200ZG61413K9.Bu9LEcNR.gif" alt="img"></p>
<hr>
<h4 id="正向代理缓存"><a href="#正向代理缓存" class="headerlink" title="正向代理缓存"></a>正向代理缓存</h4><p>当客户端浏览器通过正向代理缓存服务器访问互联网 Web 服务器时，正向代理缓存服务器会<strong>先检查本地的缓存</strong>，如果本地已经有客户端访问网站的内容缓存，则会根据缓存策略将缓存内容返回客户端；</p>
<p>如果<strong>本地没有相应的内容缓存</strong>，则会向网站 Web 服务器发起访问请求，在获得响应数据后，它会先将响应内容在本地缓存生成内容缓存，然后再转发给客户端。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200ZG61434247.BKfceQrh.gif" alt="img"></p>
<p>通常是<strong>多个客户端共享一台正向代理缓存服务器</strong>，当一台客户端访问某个网站后，其他客户端均会共享这个网站的缓存，无须再向网站服务器发起访问请求，提升内容响应速度。</p>
<p>通过共享正向代理缓存服务器，不仅减少了外网的访问次数，也降低了网络带宽的需求。通过正向代理缓存服务器的控制策略，可以有效地针对内网客户端及访问的目标进行过滤控制，提升内网安全。</p>
<p>正向代理缓存服务器并不严格限制其一定要在客户端的内网，因它是通过<strong>七层协议</strong>实现代理转发的，所以只要客户端通过 HTTP 或 HTTPS 协议可以连接到正向代理服务器即可。</p>
<hr>
<h4 id="内容分发网络（CDN）"><a href="#内容分发网络（CDN）" class="headerlink" title="内容分发网络（CDN）"></a><font color="red">内容分发网络（CDN）</font></h4><p>CDN 是基于反向代理缓存技术实现的大规模网络应用，其将<strong>缓存服务器</strong>分布到用户访问相对集中的<strong>地区或网络</strong>中（被缓存的是更新较少的静态资源（如静态页面、CSS、JavaScript、图片、视频等），当用户访问目标网站时，它会利用全局负载策略，将用户的访问<strong>分配到离用户最近的缓存服务器</strong>，并由被分配的缓存服务器处理用户的访问请求。</p>
<p>国内跨运营商的网络访问会很<strong>慢</strong>，通过 CDN 的分配策略，可有效地优化网络路径，并结合 CDN 缓存服务器节点的缓存，有效提高用户的访问速度，从而提升用户体验。内容分发网络架构如下图所示。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200ZG61454432.WUOQQGK0.gif" alt="img"></p>
<p>CDN 的各缓存服务器节点是通过 HTTP 响应头的 Cache-Control 来控制本地内容缓存有效期的。</p>
<p>CDN 的缓存有效期设置会影响内容缓存的回源率。如果缓存有效期设置的较长，回源率较低，则会使缓存服务器的缓存数据与源网站不同步，影响访问；</p>
<p>如果缓存有效期设置的较短，回源率较高，则会增加源网站的负载，影响 CDN 缓存服务器的使用效率。</p>
<hr>
<h4 id="反向代理缓存"><a href="#反向代理缓存" class="headerlink" title="反向代理缓存"></a>反向代理缓存</h4><p>反向代理缓存是基于反向代理技术在用户请求转发到 Web 服务器<strong>前</strong>进行缓存加载的缓存方式。</p>
<p>反向代理缓存服务器通常位于 Web 服务器之前，通过反向代理缓存服务器可以对被代理服务器的响应内容进行缓存，以加速用户请求响应的处理速度，降低被代理服务器的负载。反向代理缓存服务器架构如下图所示。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200ZG61513411.DT-ym0QX.gif" alt="img"></p>
<p>反向代理缓存提高了网站内容的加载速度，降低了被代理服务器的负载，并可以在被代理服务器发生<strong>故障</strong>时<strong>通过缓存的内容作为备份来提高网站的可用性</strong>。</p>
<p><strong>提升网站性能</strong>。反向代理缓存以与静态内容相同的处理速度为所有类型的缓存内容提供用户响应处理，从而减少因被代理服务器动态计算产生的延迟，进一步提升网站的性能。</p>
<p><strong>增加资源容量</strong>。因为减少了被代理服务器的请求，被代理服务器将有更多的计算资源处理动态响应，相对增加了应用服务器的资源容量。</p>
<p><strong>提高可用性</strong>。通过反向代理缓存服务器的本地缓存，可以在被代理服务器出现故障或停机产生的故障等待时，让用户仍可访问网站（单向的浏览缓存中的内容），避免了用户因收到故障信息而产生的负面影响。</p>
<hr>
<h3 id="代理缓存配置"><a href="#代理缓存配置" class="headerlink" title="代理缓存配置"></a>代理缓存配置</h3><p>Nginx 的缓存功能是集成在代理模块中的。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>存储位置</th>
</tr>
</thead>
<tbody><tr>
<td>请求返回的响应数据</td>
<td>服务器磁盘</td>
</tr>
<tr>
<td>响应数据缓存的相关元数据、有效期及缓存内容等信息</td>
<td>共享内存</td>
</tr>
</tbody></table>
<p>当收到客户端请求时，Nginx 会在<strong>共享内存</strong>中搜索缓存信息，并把查询到的缓存数据从<strong>磁盘</strong>中快速交换到操作系统的页面缓存（Page Cache）中，整个过程的速度非常快。</p>
<p>Nginx 缓存会对<strong>缓存加载进程</strong>（Cache Loader Process）和<strong>库存管理</strong>（Cade Manger Process）进行管理。</p>
<p><strong>缓存加载进程</strong>只在 Nginx <strong>启动时执行一次</strong>，将上一次 Nginx 运行时缓存有关数据的元数据加载到共享内存区域，加载结束后它将自动退出。</p>
<p>缓存加载进程会采用<strong>周期性迭代式</strong>加载缓存数据，避免缓存因加载缓存降低 Nginx 的性能，配置指令 proxy_cache_path 的指令值参数设置来调整周期。</p>
<p>缓存管理进程则周期性的检查缓存的状态，负责清除在一段时间内未被访问的缓存文件，并对超出缓存存储最大值的缓存对象进行删除，缓存管理进程的删除操作也是周期性迭代执行的，并由配置指令 proxy_cache_path 的指令值参数设置。</p>
<h4 id="缓存处理流程及状态"><a href="#缓存处理流程及状态" class="headerlink" title="缓存处理流程及状态"></a>缓存处理流程及状态</h4><p>当客户端发起请求到 Nginx 缓存服务器时，Nginx 会先检查本地是否已经有该请求的内容缓存，有的话会直接返回数据，缓存请求状态会被标记为 <strong>HIT</strong>，否则该缓存请求状态就会被标记为 <strong>MISS</strong>。</p>
<p>如果指令 proxy_cache_lock 未被启用，则会直接向源服务器发起访问请求，如果被启用，则会先确认当前请求是不是第一个发起的请求，若不是，则等待；若是，则向源服务器发起访问请求。服务器响应数据返回后会先被存储在本地缓存，然后再返回给客户端。缓存处理流程如下图所示。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200ZGGS0R0.Ezom-1yk.gif" alt="img"></p>
<p>Nginx 在处理缓存过程中，客户端请求的缓存请求状态会被记录在变量 $upstream_cache_status 中，缓存请求状态如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">缓存请求状态</th>
<th align="left">状态说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MISS</td>
<td align="left">缓存未命中，从源服务器获取响应数据</td>
</tr>
<tr>
<td align="left">HIТ</td>
<td align="left">缓存命中，从本地缓存获取数据</td>
</tr>
<tr>
<td align="left">BYPASS</td>
<td align="left">proxy_cache_bypass 生效，直接从源服务器获取响应数据</td>
</tr>
<tr>
<td align="left">REVALIDATED</td>
<td align="left">启用 proxy_cache_revalidate 指令后，缓存将被源服务器服务端验证为有效状态，从本地缓存获取数据</td>
</tr>
<tr>
<td align="left">EXPIRED</td>
<td align="left">缓存过期，从源服务器获取响应数据</td>
</tr>
<tr>
<td align="left">UPDATING</td>
<td align="left">正在更新缓存，当前返回为旧缓存内容，在配置指令 proxy_cache_use_stale updating 时会存在该状态</td>
</tr>
<tr>
<td align="left">STALE</td>
<td align="left">源服务器无法正常返回更新的内容，当前返回为旧缓存内容，在配置指令 proxy_cache_use_stale error timeout 时会存在该状态</td>
</tr>
<tr>
<td align="left">SCARCE</td>
<td align="left">缓存节点被查询次数未达到配置指令 proxy_cache_min_uses 设定的值时，对此请求无法启用缓存机制，将从源服务器获取响应数据</td>
</tr>
</tbody></table>
<h4 id="缓存配置指令"><a href="#缓存配置指令" class="headerlink" title="缓存配置指令"></a>缓存配置指令</h4><p>Nginx 缓存配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">proxy_store</td>
<td align="left">on、off 或 string</td>
<td align="left">off</td>
<td align="left">设置是否将被代理服务器的响应数据在本地按照请求的 URL 建立目录结构镜像。当指令值为 on 时，存储路径的设置为 root 或 alias，响应数据先存储到临时文件后再复制或重命名保存</td>
</tr>
<tr>
<td align="left">proxy_store_access</td>
<td align="left">users:permissions…</td>
<td align="left">user:rw</td>
<td align="left">设置创建本地镜像存储路径的文件夹权限</td>
</tr>
<tr>
<td align="left">proxy_cache</td>
<td align="left">zone 或 off</td>
<td align="left">off</td>
<td align="left">设置一个用以做缓存管理的共享内存区域</td>
</tr>
<tr>
<td align="left">proxy_cache_path</td>
<td align="left">path 参数</td>
<td align="left">–</td>
<td align="left">设置缓存文件存储路径及参数。缓存数据以 URL 的 MD5 值命名存储在缓存目录中</td>
</tr>
<tr>
<td align="left">proxy_cache_key</td>
<td align="left">string</td>
<td align="left">$scheme $proxy_host $request_uri</td>
<td align="left">设置缓存的关键字</td>
</tr>
<tr>
<td align="left">proxy_cache_lock</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用缓存锁指令。当启用缓存锁机制时，每次只允许个向被代理服务器转发的请求，按照 proxy_cache_key 指令设置的标识增添新的缓存数据，其他相同的请求则将等待缓存中出现响应数据或该缓存锁被释放，其等待时间由 proxy_cache_lock_timeout 指令设置</td>
</tr>
<tr>
<td align="left">proxy_cache_lock_age</td>
<td align="left">time</td>
<td align="left">5s</td>
<td align="left">缓存锁有效时间。当启用缓存锁机制时，如果一个请求在该指令的时间内没有完成响应数据缓存的添加，缓存锁将会被释放，获取缓存锁的请求将被转发给被代理服务器由代理服务器负责生成缓存</td>
</tr>
<tr>
<td align="left">proxy_cache_lock_timeout</td>
<td align="left">time</td>
<td align="left">5s</td>
<td align="left">缓存锁等待超时时间。当启用缓存锁机制时，等待超过该时间的请求将直接从被代理服务器中读取响应，该请求响应不会被添加到缓存中</td>
</tr>
<tr>
<td align="left">proxy_cache_max_range_offset</td>
<td align="left">number</td>
<td align="left">–</td>
<td align="left">用以设置范围请求（byte-range）请求时的最大偏移量。超出该偏移量的请求将直接从被代理服务器中读取响应数据</td>
</tr>
<tr>
<td align="left">proxy_cache_methods</td>
<td align="left">GET 或 HEAD 或 POST…</td>
<td align="left">GET HEAD</td>
<td align="left">指定可被缓存的请求方法</td>
</tr>
<tr>
<td align="left">proxy_cache_convert_head</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">开启或禁用将请求方法 HEAD 转换为 GET，如果该功能被禁用，配置指令 proxy_cache_key 的指令值应该添加变量 $request_method</td>
</tr>
<tr>
<td align="left">proxy_cache_min_uses</td>
<td align="left">numberstring</td>
<td align="left">1</td>
<td align="left">响应数据超过设置请求次数后将被缓存</td>
</tr>
<tr>
<td align="left">proxy_no_cache</td>
<td align="left">string…</td>
<td align="left">–</td>
<td align="left">设置不生成缓存数据的条件，指定字符串的值不为空或不等于 0，则不将当前请求返回的响应数据进行缓存</td>
</tr>
<tr>
<td align="left">proxy_cache_bypass</td>
<td align="left">string…</td>
<td align="left">–</td>
<td align="left">设置不使用缓存数据的条件，指令值中至少有一个值不为空或不等于 0 时，当前请求不使用缓存中的响应数据，直接访问源应用服务器。它可以与 proxy_no_cache 指令一起使用</td>
</tr>
<tr>
<td align="left">proxy_cache_revalidate</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">启用该指令后，如果缓存过期，则通过在 HTTP 头中添加字段属性 If-Modified-Since 和 If-None-Match 的方式发送给源服务器，从而进行缓存的服务端校验</td>
</tr>
<tr>
<td align="left">proxy_cache_use_stale</td>
<td align="left">error、timeout、 invalid_header、 updating、http_500、 http_503、http_403、 http_404、http_429、 off…</td>
<td align="left">off</td>
<td align="left">当出现指定的条件时，使用已经过期的缓存响应数据</td>
</tr>
<tr>
<td align="left">proxy_cache_background_update</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">允许使用过期的响应数据时，设置是否启用后台子请求更新过期缓存，同时向客户端返回过期的缓存响应数据</td>
</tr>
<tr>
<td align="left">proxy_cache_valid</td>
<td align="left">[code…] time</td>
<td align="left">–</td>
<td align="left">根据响应码设置缓存时间</td>
</tr>
<tr>
<td align="left">proxy_cache_purge</td>
<td align="left">string…</td>
<td align="left">–</td>
<td align="left">定义清除缓存请求条件，若指定的字符串不为空或 0，则将 proxy_cache_key 设置的标识的缓存进行清除。清除成功则返回状态码 204，仅商业版有效</td>
</tr>
</tbody></table>
<p>关于上表有以下几点需要说明。</p>
<ul>
<li>该模块指令列表中指令的指令域范围都是 http、server、location；</li>
<li>proxy_cache_path 指令只能编写在 http 指令域中；</li>
<li>proxy_cache 与 proxy_store 指令不能在同一指令域中同时使用；</li>
<li>proxy_cache_path 指令值参数如下表所示。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">参数格式</th>
<th align="left">默认值</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">levels</td>
<td align="left">levels</td>
<td align="left">–</td>
<td align="left">设置缓存目录的层级及命名方式</td>
</tr>
<tr>
<td align="left">use_temp_path</td>
<td align="left">on 或 off</td>
<td align="left">on</td>
<td align="left">参数值为 on，则使用 proxy_temp_path 设置作为临时文件目录。参数值为 off 时，则使用缓存目录做临时文件目录</td>
</tr>
<tr>
<td align="left">keys_zone</td>
<td align="left">name:size</td>
<td align="left">–</td>
<td align="left">设置存储 cache_key 的共享内存 zone 及大小，1MB 可以存储 8000 个 key</td>
</tr>
<tr>
<td align="left">inactive</td>
<td align="left">time</td>
<td align="left">10 分钟</td>
<td align="left">设置时间内未被访问的缓存将被删除</td>
</tr>
<tr>
<td align="left">max_size</td>
<td align="left">size</td>
<td align="left">–</td>
<td align="left">缓存数据的最大值，超出这个最大值时，缓存管理进程将执行迭代更新，即删除最近最少使用的缓存</td>
</tr>
<tr>
<td align="left">manager_files</td>
<td align="left">number</td>
<td align="left">100</td>
<td align="left">缓存管理进程执行一次迭代更新时，删除文件的最大数</td>
</tr>
<tr>
<td align="left">manager_sleep</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">缓存管理进程每次更新缓存的迭代间隔时间</td>
</tr>
<tr>
<td align="left">manager_threshold</td>
<td align="left">time</td>
<td align="left">200ms</td>
<td align="left">缓存管理进程执行一次迭代更新时，最大执行的时间，单位为 ms</td>
</tr>
<tr>
<td align="left">loader_threshold</td>
<td align="left">time</td>
<td align="left">200ms</td>
<td align="left">缓存加载进程每次迭代加载时，加载数据的最大执行时间</td>
</tr>
<tr>
<td align="left">loader_files</td>
<td align="left">number</td>
<td align="left">100</td>
<td align="left">缓存加载进程每次迭代加载时，加载缓存目录中缓存数据的最大文件数</td>
</tr>
<tr>
<td align="left">loader_sleep</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">缓存加载进程每次迭代的间隔时间</td>
</tr>
<tr>
<td align="left">purger</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">是否启用缓存清除功能。仅商业版有效</td>
</tr>
<tr>
<td align="left">purger_files</td>
<td align="left">number</td>
<td align="left">10</td>
<td align="left">每次迭代清除时，清除缓存目录中缓存数据的最大文件数。仅商业版有效</td>
</tr>
<tr>
<td align="left">purger_sleep</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">连续两次迭代清除间的最少间隔时间。仅商业版有效</td>
</tr>
<tr>
<td align="left">purger_threshold</td>
<td align="left">time</td>
<td align="left">50ms</td>
<td align="left">每次迭代清除时，最大执行的时间。仅商业版有效</td>
</tr>
</tbody></table>
<h4 id="HTTP-范围请求"><a href="#HTTP-范围请求" class="headerlink" title="HTTP 范围请求"></a>HTTP 范围请求</h4><p>范围请求允许服务器<strong>只发送请求的一部分响应数据</strong>给客户端，通常对大文件传输时，用以实现断点续传、多线程下载等功能。</p>
<p>若服务端响应信息头中包含字段 <strong>Accept-Ranges:bytes</strong>，则表示服务端支持<strong>范围请求</strong>，且节点范围的单位为字节（bytes）。</p>
<p>在 Nginx 缓存默认配置下，Nginx 处理完一个大文件的初始请求后，后续的用户请求必须等待整个文件下载结束并存入缓存后才可以继续被处理，整个过程非常耗时。为解决这个问题，Nginx 提供了 ngx_http_slice_module 模块，用以缓存范围请求的支持。该模块将文件分成<strong>更小的切片（slices）</strong>，客户端每个范围请求覆盖特定的切片，如果该范围没有缓存，则从源服务器请求后存入缓存，否则就从缓存中返回数据。</p>
<p>http_slice 模块配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">切片指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">slice</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">http、server、location</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设定范围请求切片的大小。默认为不启用该功能</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    slice             1m;                               <span class="comment"># 切片大小为1MB</span></span><br><span class="line">    proxy_cache       cache;                            <span class="comment"># 缓存共享内存名称为cache</span></span><br><span class="line">    proxy_cache_key   $uri$is_args$args<span class="variable">$slice_range</span>;    <span class="comment"># 设置缓存key</span></span><br><span class="line">    proxy_set_header  Range <span class="variable">$slice_range</span>;               <span class="comment"># 添加头字段Range的字段值为</span></span><br><span class="line">                                                        <span class="comment"># $slice_range</span></span><br><span class="line">    proxy_cache_valid 200 206 1h;                       <span class="comment"># 响应状态码为200及206的内容缓存有效期为1h</span></span><br><span class="line">    proxy_pass        http://localhost:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Memcached缓存模块"><a href="#Memcached缓存模块" class="headerlink" title="Memcached缓存模块"></a>Memcached缓存模块</h3><p>Nginx 的 ngx_http_memcached_module 模块本身并没有提供缓存功能，它只是一个将用户请求转发到 Memcached 服务器的<strong>代理模块</strong>。</p>
<p>在以 Memcached 服务器为<strong>缓存应用</strong>的方案中，Memcached 作为内容缓存的存储服务器，用户通过 <strong>URL</strong> 为 Memcached 的 key 将 Web 请求数据缓存到 Memcached 服务器中，在客户端发起请求时，Nginx 通过一致的 URL 为 key，快速地从 Memcached 服务器中将缓存的内容作为用户的请求响应数据返回给客户端。</p>
<p>Memcached 是一个开源、高性能的内存对象缓存系统，使用 Memcached 服务器作为缓存存储服务器，充分利用了 Memcached 的高效缓存功能，减少了 Nginx 服务器磁盘 I&#x2F;O 的操作，也可以通过 upstream 指令对多台 Memcached 做分布式集群负载，以便整体提升 Nginx 缓存服务器的性能。</p>
<p>Memcached 缓存模块配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">指令值格式</th>
<th align="left">默认值</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">memcached_bind</td>
<td align="left">address[transparent] 或 off</td>
<td align="left">–</td>
<td align="left">设置从指定的本地 IP 地址及端口与 Memcached 服务器建立连接，指令值可以是变量。指令值参数为 transparent 时，允许将客户端的真实 IP 透传给被代理服务器，并以客户端真实 IP 为访问被代理服务器的源 IP，指令值为 off 时，则取消上一层指令域同名指令的配置</td>
</tr>
<tr>
<td align="left">memcached_buffer_size</td>
<td align="left">size</td>
<td align="left">4k 或 8k</td>
<td align="left">设置用于读取 Memcached 服务器，读取响应数据缓冲区的大小，当 Nginx 收到响应数据后，将同步传递给客户端</td>
</tr>
<tr>
<td align="left">memcached_connect_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">Nginx 与 Memcached 服务器建立连接的超时时间，通常不应超过 75s</td>
</tr>
<tr>
<td align="left">memcached_force_ranges</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">启用来自 Memcached 服务器的缓存和未缓存响应的 byte-range 请求支持，而不考虑这些响应头中的 Accept-Ranges 字段</td>
</tr>
<tr>
<td align="left">memcached_gzip_flag</td>
<td align="left">flag</td>
<td align="left">–</td>
<td align="left">启用对 Memcached 服务器缓存数据 fags 的测试，flags 为客户端写入缓存时的自定义标记，此处用以判断缓存数据是否被压缩存储，如果数据被压缩存储，则将响应头字段 Content-Encoding 设置为 gzip</td>
</tr>
<tr>
<td align="left">memcached_next_upstream</td>
<td align="left">error、timeout、 invalid_header、 not found 或 off…</td>
<td align="left">error timeout</td>
<td align="left">当出现指令值中指定的条件时，将未返回响应的客户请求传递给 upstream 中的下一个服务器</td>
</tr>
<tr>
<td align="left">memcached_next_upstream_timeout</td>
<td align="left">time</td>
<td align="left">0</td>
<td align="left">设置将符合条件的客户端请求传递给 upstream 中下一个服务器的超时时间。0 为不做超时限制，遍历完所有上游服务器组中的服务器为止</td>
</tr>
<tr>
<td align="left">memcached_next_upstream_tries</td>
<td align="left">number</td>
<td align="left">0</td>
<td align="left">设置符合条件的客户端请求传递给upstream中下一个服务器的尝试次数，包括第一次失败的次数。0为不做尝试次数限制，遍历完所有上游服务器组中的服务器为止</td>
</tr>
<tr>
<td align="left">memcached_pass</td>
<td align="left">address</td>
<td align="left">–</td>
<td align="left">设置 Memcached 服务器的地址及端口，地址可以是 IP、域名或 UNIX 套接字</td>
</tr>
<tr>
<td align="left">memcached_read_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个从 Memcached 服务器接收数据的读操作之间的间隔时间超过设置的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">memcached_send_timeout</td>
<td align="left">time</td>
<td align="left">60s</td>
<td align="left">在连续两个发送到 Memcached 服务器的写操作之间的间隔时间超过设置的时间时，将关闭连接</td>
</tr>
<tr>
<td align="left">memcached_socket_keepalive</td>
<td align="left">on 或 off</td>
<td align="left">off</td>
<td align="left">设置 Nginx 与 Memcached 服务器的 TCP keepalive 行为的心跳检测机制，默认使用操作系统的 socket 配置，若指令值为 on，则开启 SO_KEEPALIVE 选项进行心跳检测</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="built_in">set</span>            <span class="variable">$memcached_key</span> <span class="string">&quot;<span class="variable">$uri</span>?<span class="variable">$args</span>&quot;</span>;  <span class="comment"># 设置Memcached缓存key</span></span><br><span class="line">        memcached_pass 127.0.0.1:11211;              <span class="comment"># 设置被代理Memcached地址</span></span><br><span class="line">        error_page     404 502 504 = @fallback;      <span class="comment"># 返回状态码404、502、504时跳入内部请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @fallback &#123;</span><br><span class="line">        proxy_pass     http://backend;               <span class="comment"># 将请求转发给后端服务器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Memcached-缓存应用"><a href="#Memcached-缓存应用" class="headerlink" title="Memcached 缓存应用"></a>Memcached 缓存应用</h4><p>为了提高动态网站的响应速度，有时会采用将<strong>动态网站转换成静态化文件</strong>的方式进行优化，而相对于磁盘存储，使用 Memcached 进行静态文件的存储则可以进一步提升网站的响应速度。</p>
<p>Memcached 是基于<strong>内存</strong>的高性能对象缓存系统，因为存储数据都是在内存中的，所以减少了系统的 I&#x2F;O 操作，从而避免了因磁盘性能带来的影响。</p>
<p>使用 Memcached 作为缓存存储服务器，可以直接利用 Memcached 缓存的过期机制实现缓存的自动化过期管理，且利用 Nginx 的负载机制和 Memcached 分布式特性，可以非常方便地横向扩展，以提升处理性能。Memcached 缓存应用场景如下图所示。</p>
<p><img src="https://nginx.mosong.cc/assets/8-200ZP9350G45.Bu3JUOPM.gif" alt="img"></p>
<p>Web 服务器将动态文件以请求 URI 作为 Memcached 的 key 初始化到 Memcached 服务器中；</p>
<p>Nginx 将用户请求转发到 Memcached 服务器中，并将以请求 URI 作为 Memcached key 的数据返回给用户；</p>
<p>当 Memcached 的请求失败后，则将请求转发给后端 Web 服务器的接口动态生成对应的静态文件，返回响应数据并更新 Memcached。</p>
<p>Memcached 的安装非常简单，在 CentOS 7 系统下使用 yum 安装即可，安装方法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum -y install memcached</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/sysconfig/memcached</span><br><span class="line">PORT=<span class="string">&quot;11211&quot;</span>         <span class="comment"># 端口</span></span><br><span class="line">USER=<span class="string">&quot;memcached&quot;</span></span><br><span class="line">MAXCONN=<span class="string">&quot;1024&quot;</span>     <span class="comment"># 最大连接数</span></span><br><span class="line">CACHESIZE=<span class="string">&quot;64&quot;</span>       <span class="comment"># 使用内存大小为64M</span></span><br><span class="line">OPTIONS=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">systemctl start memcached</span><br></pre></td></tr></table></figure>

<p>Nginx 服务器配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 192.168.2.145:8190;                              <span class="comment"># 后端PHP服务器IP</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream memcached &#123;</span><br><span class="line">    <span class="built_in">hash</span> $host<span class="variable">$request_uri</span> consistent;                      <span class="comment"># 一致性hash</span></span><br><span class="line">    server 192.168.2.145:11211;                             <span class="comment"># Memcached服务器IP</span></span><br><span class="line">    server 192.168.2.109:11211;                             <span class="comment"># Memcached服务器IP</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       8181;</span><br><span class="line">    access_log logs/mem_access.log;</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$memcached_key</span> $host<span class="variable">$request_uri</span>;                   <span class="comment"># 设置Memcached的key</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        memcached_connect_timeout 5s;             <span class="comment"># 与Memcached建立连接超时时间为5s</span></span><br><span class="line">        memcached_read_timeout 2s;                <span class="comment"># 连续两次读的超时时间为2s</span></span><br><span class="line">        memcached_send_timeout 2s;                <span class="comment"># 连续两次写的超时时间为2s</span></span><br><span class="line">        memcached_pass memcached;                 <span class="comment"># 代理到Memcached集群</span></span><br><span class="line">        add_header X-Cache-Satus HIT;             <span class="comment"># 显示缓存命中状态</span></span><br><span class="line">        add_header Content-Type <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>; <span class="comment"># 强制响应数据格式为html</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page     404 502 504 = @fallback;</span><br><span class="line"></span><br><span class="line">    location @fallback &#123;</span><br><span class="line">        proxy_set_header   X-Memcached-Key <span class="variable">$memcached_key</span>;  <span class="comment"># 将memecached key传递</span></span><br><span class="line">                                                            <span class="comment"># 给PHP服务器</span></span><br><span class="line">        proxy_pass     http://backend;                      <span class="comment"># PHP服务器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="反向代理缓存服务器配置"><a href="#反向代理缓存服务器配置" class="headerlink" title="反向代理缓存服务器配置"></a>反向代理缓存服务器配置</h3><p>Nginx 代理功能根据应用方式的不同分为正向代理和反向代理，Nginx 开源版本的正向代理功能并不完整，不支持 HTTP 的 CONNECT 方法，所以 <strong>HTTPS 的正向代理功能通常是使用第三方模块来实现的。</strong></p>
<p>Nginx 的 HTTPS 正向代理使用最多的第三方模块是 ngx_http_proxy_connect_module，但<strong>其不支持缓存</strong>，所以开源版本 Nginx 无法在正向代理缓存的使用场景中应用。</p>
<p>Nginx 的重点缓存应用是在反向代理缓存的应用场景，官方也一直在不断地增强该功能。</p>
<p>Nginx 反向代理缓存是目前网站架构中最常用的缓存方式，其不仅被网站架设者用以提高访问速度，降低应用服务器的负载，同时也被广泛应用于 CDN 的缓存服务器中。</p>
<p>Nginx的反向代理缓存有以下几个功能特点。</p>
<ul>
<li>故障降级。如果源服务器因故障停机，即便缓存过期，也可以被返回给用户使用，这就避免了页面无法打开的故障信息传递，从而实现有效容错降级；</li>
<li>缓存负载。基于Nginx提供的比例分配赋值指令，可以将请求分配给由多个不同的硬盘组成的缓存池，以实现缓存存储负载，降低I&#x2F;O瓶颈，提升磁盘效率；</li>
<li>缓存锁。使多个相同的请求只有一个可以访问被代理服务器，其他的请求则等待缓存生成后，从缓存中获取响应数据，从而有效地提升缓存利用率，降低被代理服务器的负载；</li>
<li>缓存验证支持。支持在Nginx本地缓存有效期过期后，通过服务器远端验证的方式确认缓存是否有效；</li>
<li>范围请求支持。通过切片指令设置，提升了范围请求的缓存效率，使其响应速度更快；</li>
<li>缓存控制。可对用户的请求是否使用缓存、响应数据是否被缓存、可被缓存的最低使用频率等方式实现缓存控制。</li>
</ul>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">upstream backend_server &#123;</span><br><span class="line">    ip_hash;                                 <span class="comment"># session会话保持</span></span><br><span class="line">    server 192.168.2.145:8081;               <span class="comment"># 被代理服务器IP</span></span><br><span class="line">    server 192.168.2.159:8081;               <span class="comment"># 被代理服务器IP</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxy_cache_path /usr/local/nginx/nginx-cache1</span><br><span class="line">                            levels=1:2</span><br><span class="line">                            keys_zone=cache_hdd1:100m</span><br><span class="line">                            max_size=10g</span><br><span class="line">                            use_temp_path=off</span><br><span class="line">                            inactive=60m;    <span class="comment"># 设置缓存存储路径1，缓存的共享内存名称和大小100MB，</span></span><br><span class="line">                                             <span class="comment"># 无效缓存的判断时间为1小时</span></span><br><span class="line"></span><br><span class="line">proxy_cache_path /usr/local/nginx/nginx-cache2</span><br><span class="line">                            levels=1:2</span><br><span class="line">                            keys_zone=cache_hdd2:100m</span><br><span class="line">                            max_size=10g</span><br><span class="line">                            use_temp_path=off</span><br><span class="line">                            inactive=60m;    <span class="comment"># 设置缓存存储路径2，缓存的共享内存名称和大小100MB，</span></span><br><span class="line">                                             <span class="comment"># 无效缓存的判断时间为1小时</span></span><br><span class="line"></span><br><span class="line">split_clients <span class="variable">$request_uri</span> <span class="variable">$proxy_cache</span> &#123;</span><br><span class="line">              50%          <span class="string">&quot;cache_hdd1&quot;</span>;     <span class="comment"># 50%请求的缓存存储在第一个磁盘上</span></span><br><span class="line">              50%          <span class="string">&quot;cache_hdd2&quot;</span>;     <span class="comment"># 50%请求的缓存存储在第二个磁盘上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /opt/nginx-web/phpweb;</span><br><span class="line">    index index.php;</span><br><span class="line">    include        proxy.conf;               <span class="comment"># 引入默认配置文件</span></span><br><span class="line">   </span><br><span class="line">    location ~ \.(gif|jpg|png|htm|html|css|js|flv|ico|swf)(.*) &#123;</span><br><span class="line">                                                <span class="comment"># 设置客户端静态资源文件缓存过期时间为12小时</span></span><br><span class="line">        expires      12h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxy_ignore_headers Cache-Control Set-Cookie;</span><br><span class="line">                                                <span class="comment"># 忽略被代理服务器返回响应头中指定字段的控制响应</span></span><br><span class="line">    location ~ / &#123;</span><br><span class="line">        root /opt/nginx-web/phpweb;</span><br><span class="line"></span><br><span class="line">        proxy_cache <span class="variable">$proxy_cache</span>;     <span class="comment"># 启用proxy_cache_path设置的$proxy_cache的共享内存区域</span></span><br><span class="line">        proxy_cache_lock on;          <span class="comment"># 启用缓存锁</span></span><br><span class="line">        proxy_cache_lock_age 5s;      <span class="comment"># 缓存锁有效期为5s</span></span><br><span class="line">        proxy_cache_lock_timeout 5s;  <span class="comment"># 等待缓存锁超时时间为5s</span></span><br><span class="line">        proxy_cache_methods GET HEAD; <span class="comment"># 默认对GET及HEAD方法的请求进行缓存</span></span><br><span class="line">        proxy_cache_min_uses 1;       <span class="comment"># 响应数据至少被请求1次，才将被缓存</span></span><br><span class="line"></span><br><span class="line">        proxy_cache_bypass <span class="variable">$http_pragma</span>;    <span class="comment"># 当客户端请求头包含字段pragma时，不适用缓存</span></span><br><span class="line"></span><br><span class="line">        proxy_cache_use_stale error <span class="built_in">timeout</span> invalid_header</span><br><span class="line">                                updating http_500 http_503</span><br><span class="line">                                http_403 http_404 http_429;</span><br><span class="line">                                        　　　　<span class="comment"># 当出现指定条件时，使用已经过期的缓存响应数据</span></span><br><span class="line"></span><br><span class="line">        proxy_cache_background_update on;   <span class="comment"># 允许使用过期的响应数据时，启用后台子请求用以更新过</span></span><br><span class="line">                                            <span class="comment"># 期缓存，并将过期的缓存响应数据返回给客户端</span></span><br><span class="line"></span><br><span class="line">        proxy_cache_revalidate on;          <span class="comment"># 当缓存过期时，向后端服务器发起服务端校验</span></span><br><span class="line">        proxy_cache_valid 200 301 302 10h;  <span class="comment"># 200 301 302状态码的响应缓存10小时</span></span><br><span class="line">        proxy_cache_valid any 1m;           <span class="comment"># 其他状态码的响应缓存1分钟</span></span><br><span class="line"></span><br><span class="line">        add_header X-Cache-Status <span class="variable">$upstream_cache_status</span>;</span><br><span class="line">                                               <span class="comment"># 添加缓存请求状态标识</span></span><br><span class="line"></span><br><span class="line">        proxy_pass   http://backend_server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认配置下，Nginx 会对被代理服务器返回<strong>响应数据信息头</strong>的缓存控制字段 Cache-Control 执行相关操作。当 Cache-Control 字段的值为 private、no-cache 或者有字段 Set-Cookie 时，它会对响应数据缓存产生影响，可以使用 proxy_ignore_headers 指令忽略这些字段的操作响应。</p>
<p>proxy_ignore_headers Cache-Control Set-Cookie; Nginx <strong>默认只对 GET 和 HEAD 方法的请求进行缓存</strong>，如果想对 POST 请求方法的数据进行缓存，则可以使用 proxy_cache_methods 指令进行设置。 proxy_cache_methods GET HEAD POST;</p>
<hr>
<h3 id="客户端缓存控制"><a href="#客户端缓存控制" class="headerlink" title="客户端缓存控制"></a>客户端缓存控制</h3><p><strong>expires、etag、if_modified_since</strong></p>
<p>客户端的缓存有两种验证机制，一种是基于<strong>有效期的本地有效期验证</strong>；另一种是<strong>由服务端提供的服务端验证</strong>。Nginx 提供了 expires、etag、if_modified_since 指令可实现对客户端缓存的控制。</p>
<h4 id="有效期验证"><a href="#有效期验证" class="headerlink" title="有效期验证"></a>有效期验证</h4><p>expires 指令可实现在响应状态码为 200、201、204、206、301、302、303、304、307 或 308 时，对响应头中的属性字段 Expires 和 Cache-Control 进行添加或编辑操作。该指令会同时设置 Expires 和 Cache-Control 两个字段，客户端根据这两个字段的值执行内容缓存的本地有效期设置。</p>
<ul>
<li><strong>设置相对时间</strong></li>
</ul>
<p>响应头字段 Expires 的值为当前时间与指令值的时间之和，响应头字段 Cache-Control 的值为指令值的时间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    expires    24h;           <span class="comment"># 设置Expires为当前时间过后的24小时，Cache-Control的值为24</span></span><br><span class="line">                              <span class="comment"># 小时</span></span><br><span class="line">    expires    modified +24h; <span class="comment"># 编辑Expires增加24小时，Cache-Control的值增加24小时</span></span><br><span class="line">    expires    <span class="variable">$expires</span>;      <span class="comment"># 根据变量$expires的内容设置缓存时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>设置绝对时间</strong></li>
</ul>
<p>可以通过前缀 @ 指定一个绝对时间，表示在当天的指定时间失效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    expires    @15h;        <span class="comment"># 设置Expires为当前日的15点，Cache-Control的值为到</span></span><br><span class="line">                            <span class="comment"># 当前时间到15点的时间差</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>无有效期设置</strong></li>
</ul>
<p>时间为负值或为 epoch 时，响应头字段 Cache-Control 的值为 no-cache，表示当前响应数据的内容缓存无有效期。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    expires    -1;</span><br><span class="line">    expires    epoch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>最大值设置</strong></li>
</ul>
<p>指令值为 max 时，Expires 的值为 Thu,31 Dec 2037 23:55:55 GMT，Cache-Control 为 10 年。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    expires  max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx 除了提供指令 expires 可以实现有效期控制外，还提供了指令 add_header，可以让用户自定义响应头实现客户端缓存的控制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    add_header Cache-Control no-cache;  <span class="comment"># 响应数据的内容缓存无有效期</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务端验证"><a href="#服务端验证" class="headerlink" title="服务端验证"></a>服务端验证</h4><ul>
<li><strong>Etag 实体标签</strong></li>
</ul>
<p>Nginx 作为 Web 服务器时，对静态资源会自动在响应头中添加响应头字段 Etag，<strong>字段值为静态资源文件的最后编辑时间（last_modified_time）和文件大小的十六进制组合。</strong></p>
<p>对于代理的响应内容则由被代理服务器进行控制，不会自动添加 Etag 字段，只有存在 Nginx 服务器由 Nginx 直接读取的文件时才会自动添加 Etag 字段，它可以通过添加 etag off 指令禁止自动生成 Etag。</p>
<ul>
<li><strong>文件修改时间</strong></li>
</ul>
<p>Nginx 作为 Web 服务器时，会对静态资源自动添加响应头字段 Last-Modified，字段值为静态资源文件的最后编辑时间（last_modified_time）。</p>
<p>Nginx 提供了配置指令 if_modified_since，对文件修改时间的服务端校验提供了两种不同的比对方式。一种是指令值为 exact 时，Nginx 会将请求头中 if_modified_since 的时间与响应数据中的时间做精确匹配，即完全相等才认为客户端缓存有效，返回响应状态码 304；另一种是指令值为 before 时，则在请求头中 if_modified_since 的时间大于响应数据中的时间也认为客户端缓存有效，返回响应状态码 304。该指令功能控制处于数据流的出入口，对于任何形式产生的响应数据都有效，当指令值为 off 时，则关闭 Nginx 对客户端缓存文件修改时间的服务端校验功能。</p>
<p>任何与用户私人相关的数据都不应该被缓存，所以对于私人内容数据建议设置 HTTP 信息头 Cache-Control 字段值为 no-cache、no-store 或 private 控制客户端不进行缓存，根据数据内容的敏感性，正确设置这些头字段，可以在保持维护私人信息安全的前提下利用缓存的优势提升网站的响应速度。</p>
<hr>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="负载均衡模块"><a href="#负载均衡模块" class="headerlink" title="负载均衡模块"></a>负载均衡模块</h3><p>Nginx 负载均衡是由代理模块和上游（upstream）模块共同实现的，</p>
<p>Nginx 通过代理模块的反向代理功能将用户请求转发到上游服务器组，上游模块通过指定的负载均衡策略及相关的参数配置将用户请求转发到目标服务器上。</p>
<h4 id="服务器配置指令"><a href="#服务器配置指令" class="headerlink" title="服务器配置指令"></a><strong>服务器配置指令</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com       weight=5;     <span class="comment"># 被代理服务器端口号为80，权重为5</span></span><br><span class="line">    server backend2.example.com:8080;               <span class="comment"># 被代理服务器端口号为8080，默认权重为1</span></span><br><span class="line">    server unix:/tmp/backend3;</span><br><span class="line"></span><br><span class="line">    server backup1.example.com:8080   backup;       <span class="comment"># 该被代理服务器为备份状态</span></span><br><span class="line">    server backup2.example.com:8080   backup;       <span class="comment"># 该被代理服务器为备份状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;          <span class="comment"># 将客户端请求反向代理到上游服务器组backend</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx 上游模块定义了 upstream 指令域，在该指令域内可设置服务器、负载均衡策略等负载均衡配置，配置样例如下，具体指令说明如下面表格中所示。</p>
<p><strong>表:服务器指令</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">服务器指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">server</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">upstream</td>
</tr>
<tr>
<td align="left">配置格式</td>
<td align="left">address[parameters];</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设定上游服务器组的服务器地址及连接参数</td>
</tr>
<tr>
<td align="left">关于上表有以下几点需要注意:</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>服务器地址可以是指定端口的 IP、域名或 Unix 套接字；</p>
<p>如不指定端口，默认端口号为 80。</p>
<p><strong>表:服务器指令参数</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">参数名称</th>
<th align="left">参数类型</th>
<th align="left">默认值</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">weight</td>
<td align="left">权重</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left">设置服务器的权重</td>
</tr>
<tr>
<td align="left">max_fails</td>
<td align="left">最大失败数</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left">被代理服务器在 fail timeout 规定时间内的最大请求失败次数，超过设定值后，被代理服务器便被认为不可用。是否失败由 proxy_next_upstream、fastcgi_next_upstream、uwsgi_next_upstream、scgi_next_upstream、memcached_next_upstream 及 grpe_next_upstream 指令定义。0 表示关闭被代理服务器的失败检测功能</td>
</tr>
<tr>
<td align="left">fail_timeout</td>
<td align="left">失败超时</td>
<td align="left">time</td>
<td align="left">10s</td>
<td align="left">被代理服务器被置为不可用的最长时间及被代理服务器被连续失败检测的最长时间</td>
</tr>
<tr>
<td align="left">backup</td>
<td align="left">备份服务器</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">将被代理服务器标为备份状态，当其他非备份被代理服务器不可用时，会把请求转发给备份被代理服务器</td>
</tr>
<tr>
<td align="left">down</td>
<td align="left">无效服务器</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">将被代理服务器标为不可用状态</td>
</tr>
<tr>
<td align="left">max_conns</td>
<td align="left">最大连接数</td>
<td align="left">int</td>
<td align="left">0</td>
<td align="left">与被代理服务器建立活动连接的最大数量，默认值 0 表示没有限制</td>
</tr>
<tr>
<td align="left">resolve</td>
<td align="left">动态解析</td>
<td align="left">–</td>
<td align="left">–</td>
<td align="left">在被代理服务器域名对应的 IP 变化时，自动更新被代理服务器的 IP，该参数依赖 resolver 指令设置的域名解析服务器。仅对商业版本有效</td>
</tr>
<tr>
<td align="left">service</td>
<td align="left">DNS SRV 记录</td>
<td align="left">name</td>
<td align="left">–</td>
<td align="left">DNS SRV 记录设置。仅对商业版本有效</td>
</tr>
<tr>
<td align="left">slow_start</td>
<td align="left">慢恢复时间</td>
<td align="left">time</td>
<td align="left">0</td>
<td align="left">不可用服务器在设置时间内检测持续有效后便被恢复正常，默认关闭。仅对商业版本有效</td>
</tr>
</tbody></table>
<p>其中，slow_start 参数不能与 Hash 负载均衡方法一同使用；若上游服务器组中只有一台被代理服务器，则 max_fails、fail_timeout 和 slow_start 参数都会被忽略，并且这个服务器将永远不会被置为无效。</p>
<p><strong>表:共享内存区指令</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">共享内存区指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">zone</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">upstream</td>
</tr>
<tr>
<td align="left">配置格式</td>
<td align="left">name[size];</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设定共享内存区域的名称及大小，用以在多个工作进程间共享配置及运行时的状态</td>
</tr>
</tbody></table>
<p><strong>表:长连接最大请求数指令</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">长连接最大请求数指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">keepalive_requests</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">upstream</td>
</tr>
<tr>
<td align="left">指令格式</td>
<td align="left">number;</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">100;</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置每个与被代理服务器建立的长连接中传输请求的最大数量，超过这个值后，该连接将被关闭</td>
</tr>
</tbody></table>
<p><strong>表:长连接缓存数</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">长连接缓存数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">keepalive</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">upstream</td>
</tr>
<tr>
<td align="left">指令格式</td>
<td align="left">connections;</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">当 Nginx 与被代理服务器建立长连接时，设定每个工作进程可以缓存的与当前上游服务器组中被代理服务器保持长连接的数量。当超过设定值时，将根据最近最少使用算法（LRU）关闭连接</td>
</tr>
</tbody></table>
<p>注意:该指令不会对活跃的 TCP 连接数有影响。</p>
<p><strong>表:长连接缓存超时时间</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">长连接缓存超时时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">keepalive_timeout</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">upstream</td>
</tr>
<tr>
<td align="left">指令格式</td>
<td align="left">timeout;</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">60;</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置长连接缓存中，每个连接的超时时间，被缓存的连接超过这个时间仍未被激活使用时将被关闭</td>
</tr>
</tbody></table>
<h4 id="负载均衡策略指令"><a href="#负载均衡策略指令" class="headerlink" title="负载均衡策略指令"></a><strong>负载均衡策略指令</strong></h4><p>Nginx 支持多种负载均衡策略，如轮询（Round Robin）、一致性哈希（Consistent Hash）、IP 哈希（IP Hash）、最少连接（least_conn）等。Nginx 的默认负载均衡策略为轮询策略，不需要配置指令，轮询策略通过 server 的权重参数可实现手动分配的加权轮询策略。</p>
<p>负载均衡策略配置指令均应编辑在 upstream 指令域的最上方，常见的配置指令如下面表格中所示。</p>
<p><strong>表:哈希策略</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">哈希策略</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">hash</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">upstream</td>
</tr>
<tr>
<td align="left">指令格式</td>
<td align="left">key[consistent];</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置用于哈希策略计算哈希值的键值，并对上游服务器组启用哈希的负载均衡策略。键值可以是文本、变量及其组合，当 consistent 参数被指定时，将启用 Ketama 一致性哈希的负载均衡策略</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    <span class="built_in">hash</span> <span class="variable">$request_uri</span>;              <span class="comment"># 以客户端请求URI为计算哈希值的key</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream backend &#123;</span><br><span class="line">    <span class="built_in">hash</span> <span class="variable">$request_uri</span> consistent;   <span class="comment"># 以客户端请求URI为计算哈希值的key，采用一致性哈希算法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>表:IP 哈希策略</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">IP 哈希策略</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">ip_hash</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">upstream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置启用 IP 哈希负载均衡策略，根据客户端的 IPv4 地址的前三个八位字节或整个 IPv6 地址作为哈希键计算哈希值，该方法确保同一客户端的请求总会被同一被代理服务器处理。当 IP 哈希值对应的被代理服务器不可用时，请求将被分配给其他服务器</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    ip_hash;                <span class="comment"># 启用IP哈希负载均衡策略</span></span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend3.example.com down;</span><br><span class="line">    server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当服务器组中一台服务器被临时删除时，可使用 down 参数标记，那么客户端 IP 哈希值将会保留。</p>
<p><strong>表:最少连接策略</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">最少连接策略</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">least_conn</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">upstream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">在考虑上游服务器组中各服务器权重的前提下，将客户端请求分配给拥有最少活跃连接被代理服务器的负载均衡策略</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    least_conn;             <span class="comment"># 启用最少连接负载均衡策略</span></span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>表:随机负载策略</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">随机负载策略</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">random</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">upstream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">在考虑上游服务器组中各服务器权重的前提下，将客户端请求分配给随机选择的被代理服务器</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    random;                 <span class="comment"># 每个请求都被随机发送到某个服务器</span></span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指令值参数 two，该参数表示随机选择两台被代理服务器，然后使用指定的负载策略进行选择，默认方法为 least_conn；可被指定的负载策略为 least_conn、least_time（仅对商业版有效）。</p>
<hr>
<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡技术是将大量的客户端请求通过特定的策略分配到集群中的节点，实现快速响应的应用技术。在应对高并发的应用请求时，单节点的应用服务计算能力有限，无法满足客户端的响应需求，通过负载均衡技术，可以将请求分配到集群中的多个节点中，让多个节点分担高并发请求的运算，快速完成客户端的请求响应。</p>
<h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>轮询（Round Robin）策略是 Nginx 配置中默认的负载均衡策略，该策略将客户端的请求依次分配给后端的服务器节点，对后端集群中的服务器实现轮流分配。轮询策略绝对均衡，且实现简单，但也会因后端服务器处理能力的不同而影响整个集群的处理性能。</p>
<ul>
<li><strong>加权轮询</strong></li>
</ul>
<p>在 Nginx 的轮询策略中，为了避免因集群中服务器性能的差异对整个集群性能造成影响，在轮询策略的基础上增加了权重参数，让使用者可以手动根据集群中各服务器的性能将请求数量按照权重比例分配给不同的被代理服务器。</p>
<ul>
<li><strong>平滑轮询</strong></li>
</ul>
<p>在加权轮询策略中，会按照权重的高低分配客户端请求，若按照高权重分配完再进行低权重分配的话，可能会出现的情况是高权重的服务器一直处于繁忙状态，压力相对集中。Nginx 通过平滑轮询算法，使得上游服务器组中的每台服务器在总权重比例分配不变的情况下，均能参与客户端请求的处理，有效避免了在一段时间内集中将请求都分配给高权重服务器的情况发生。</p>
<p>配置样例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server a weight=5;</span><br><span class="line">        server b weight=1;</span><br><span class="line">        server c weight=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置样例中 Nginx 平滑轮询策略计算过程如下。</p>
<p>1.当前配置中 a,b,c 服务器的配置权重为 {5,1,1}；</p>
<p>2.配置样例中 Nginx 平滑轮询计算过程如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">轮询次数</th>
<th align="left">当前权重</th>
<th align="left">选择后权重</th>
<th align="left">选择节点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">{0, 0, 0}</td>
<td align="left">{0, 0, 0}</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">{5, 1, 1}</td>
<td align="left">{-2, 1, 1}</td>
<td align="left">a</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">{3, 2, 2}</td>
<td align="left">{-4, 2, 2}</td>
<td align="left">a</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">{1, 3, 3}</td>
<td align="left">{1, -4, 3}</td>
<td align="left">b</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">{6, -3, 4}</td>
<td align="left">{-1, -3, 4}</td>
<td align="left">a</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">{4, -2, 5}</td>
<td align="left">{4, -2, -2}</td>
<td align="left">c</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">{9, -1, -1}</td>
<td align="left">{2, -1, -1}</td>
<td align="left">a</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">{7, 0, 0}</td>
<td align="left">{0, 0, 0}</td>
<td align="left">a</td>
</tr>
</tbody></table>
<p>关于上表有以下几点需要说明:</p>
<ul>
<li>有效权重（effective_weight），初始值为配置文件中权重的值，会因节点的健康状态而变化；</li>
<li>当前权重（current_weight），节点被选择前的权重值，由上一个选择后权重值及各节点与自己的有效权重值相加而得；</li>
<li>选择后权重，所有节点中权重最高节点的当前权重值为其初始值与有效总权重相减的值，其他节点的权重值不变；</li>
<li>有效总权重为所有节点中非备份、非失败状态的服务器的有效权重之和；</li>
<li>根据上述平滑轮询算法，选择节点顺序为 {a,a,b,a,c,a,a}。</li>
</ul>
<h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><p>Nginx 启用哈希的负载均衡策略，是用 hash 指令来设置的。哈希策略方法可以针对客户端访问的 URL 计算哈希值，对相同的 URL 请求，Nginx 可以因相同的哈希值而将其分配到同一后端服务器。当后端服务器为缓存服务器时，将极大提高命中率，提升访问速度。</p>
<p>一致性哈希的优点是，可以使不同客户端的相似请求发送给同一被代理服务器，当被代理服务器为缓存服务器场景应用时，可以极大提高缓存的命中率。</p>
<p>一致性哈希的缺点是，当上游服务器组中的节点数量发生变化时，将导致所有绑定被代理服务器的哈希值重新计算，影响整个集群的绑定关系，产生大量回源请求。</p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        <span class="built_in">hash</span> <span class="variable">$request_uri</span>;  <span class="comment"># 以客户端请求URI为计算哈希值的key</span></span><br><span class="line">        server a weight=5;</span><br><span class="line">        server b weight=1;</span><br><span class="line">        server c weight=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置样例中 Nginx 哈希策略计算过程如下。</p>
<ul>
<li>首先会根据 $request_uri 计算哈希值；</li>
<li>根据哈希值与配置文件中非备份状态服务器的总权重计算出哈希余数；</li>
<li>按照轮询策略选出初始被代理服务器，如果哈希余数大于初始被代理服务器的权重，则遍历轮询策略中被代理服务器列表；</li>
<li>当遍历轮询策略中被代理服务器列表时，要用哈希余数依次减去轮询策略中的上一个被代理服务器的权重，直到哈希余数小于某个被代理服务器的权重时，该被代理服务器被选出；</li>
<li>若循环 20 次仍无法选出，则使用轮询策略进行选择。</li>
</ul>
<p>针对哈希算法的缺点，Nginx 提供了 consistent 参数启用一致性哈希（Consistent Hash）负载均衡策略。Nginx 采用的是 Ketama 一致性哈希算法，使用一致性哈希策略后，当上游服务器组中的服务器数量变化时，只会影响少部分客户端的请求，不会产生大量回源。</p>
<p>Nginx 一致性哈希计算过程如下。</p>
<ol>
<li><p>根据配置文件中非备份状态服务器的总权重乘以 160 计算出总的虚拟节点数量，初始化虚拟节点数组。</p>
</li>
<li><p>遍历轮询策略中的被代理服务器列表，根据每个服务器的权重数乘以160得出该服务器的虚拟节点数量，并根据服务器的 HOST 和 PORT 计算出该服务器的基本哈希（base_hash）。</p>
</li>
<li><p>循环每个服务器虚拟节点总数次数，由基本哈希（base_hash）值与上一个虚拟节点的哈希值（PREV_HASH）依次计算出所有属于该服务器的虚拟节点哈希值，并把虚拟节点哈希值与服务器映射关系保存在虚拟节点哈希值数组中。</p>
</li>
<li><p>对虚拟节点哈希值数组进行排序去重处理，得到新的有效虚拟节点哈希值数组。</p>
</li>
</ol>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        <span class="built_in">hash</span> <span class="variable">$request_uri</span> consistent;       <span class="comment"># 以客户端请求URI为计算哈希值的key，使用一致性</span></span><br><span class="line">                                                <span class="comment"># 哈希算法</span></span><br><span class="line">        server a weight=1;</span><br><span class="line">        server b weight=1;</span><br><span class="line">        server c weight=1;</span><br><span class="line">        server c weight=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置样例中 Nginx 一致性哈希策略计算过程如下。</p>
<ul>
<li>首先根据 $request_uri 计算哈希值；</li>
<li>通过二分法，快速在虚拟节点列表中选出该哈希值所在范围的最大虚拟节点哈希值；</li>
<li>通过虚拟节点哈希值与虚拟节点集合总数取余，获得对应的服务器作为备选服务器；</li>
<li>遍历轮询策略中被代理服务器列表，判断备选服务器的有效性，选出服务器；</li>
<li>若循环 20 次仍无法选出，则使用轮询策略进行选择。</li>
</ul>
<h4 id="IP-哈希"><a href="#IP-哈希" class="headerlink" title="IP 哈希"></a>IP 哈希</h4><p>IP 哈希（IP Hash）负载均衡策略根据客户端IP计算出哈希值，然后把请求分配给该数值对应的被代理服务器。在哈希值不变且被代理服务器可用的前提下，同一客户端的请求始终会被分配到同一台被代理服务器上。IP 哈希负载均衡策略常被应用在会话（Session）保持的场景。</p>
<p>HTTP 客户端在与服务端交互时，因为 HTTP 协议是无状态的，所以任何需要上下文逻辑的情景都必须使用会话保持机制，会话保持机制是通过客户端存储由唯一的 Session ID 进行标识的会话信息，每次与服务器交互时都会将会话信息提交给服务端，服务端依照会话信息实现客户端请求上下文的逻辑关联。</p>
<p>会话信息通常存储在被代理服务器的内存中，如果负载均衡将客户端的会话请求分配给其他被代理服务器，则该会话逻辑将因为会话信息失效而中断。所以为确保会话不中断，需要负载均衡将同一客户端的会话请求始终都发送到同一台被代理服务器，通过会话保持实现会话信息的有效传递。</p>
<p>配置样例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        ip_hash;            # 启用IP哈希负载均衡策略</span><br><span class="line">        server a weight=5;</span><br><span class="line">        server b weight=1;</span><br><span class="line">        server c weight=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置样例中 Nginx 的 IP 哈希策略计算过程如下。</p>
<ul>
<li>在多层代理的场景下，请确保当前 Nginx 可获得真实的客户端源 IP；</li>
<li>首先会根据客户端的 IPv4 地址的前三个八位字节或整个 IPv6 地址作为哈希键计算哈希值；</li>
<li>根据哈希值与配置文件中非备份状态服务器的总权重计算出哈希余数；</li>
<li>按照轮询策略选出初始被代理服务器，如果哈希余数大于初始被代理服务器的权重，则遍历轮询策略中被代理服务器列表，否则初始被代理服务器将被选出；</li>
<li>当遍历轮询策略中被代理服务器列表时，要用哈希余数依次减去轮询策略中的上一个被代理服务器的权重，直到哈希余数小于某个被代理服务器的权重时该被代理服务器被选出；</li>
<li>若循环 20 次仍无法选出，则使用轮询策略进行选择。</li>
</ul>
<h4 id="最少连接"><a href="#最少连接" class="headerlink" title="最少连接"></a>最少连接</h4><p>默认配置下轮询算法是把客户端的请求平均分配给每个被代理服务器，每个被代理服务器的负载大致相同，该场景有个前提就是每个被代理服务器的请求处理能力是相当的。如果集群中某个服务器处理请求的时间比较长，那么该服务器的负载也相对增高。在最少连接（least_conn）负载均衡策略下，会在上游服务器组中各服务器权重的前提下将客户端请求分配给活跃连接最少的被代理服务器，进而有效提高处理性能高的被代理服务器的使用率。</p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    least_conn;         <span class="comment"># 启用最少连接负载均衡策略</span></span><br><span class="line">    server a weight=4;</span><br><span class="line">    server b weight=2;</span><br><span class="line">    server c weight=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置样例中 Nginx 最少连接策略计算过程如下。</p>
<ul>
<li>遍历轮询策略中被代理服务器列表，比较各个后端的活跃连接数（conns）与其权重（weight）的比值，选取比值最小者分配客户端请求；</li>
<li>如果上一次选择了 a 服务器，则当前请求将在 b 和 c 服务器中选择；</li>
<li>设 b 的活跃连接数为 100，c 的活跃连接数为 60，则 b 的比值（conns&#x2F;weight）为 50，c 的比值（conns&#x2F;weight）为 60，因此当前请求将分配给 b。</li>
</ul>
<h4 id="随机负载算法"><a href="#随机负载算法" class="headerlink" title="随机负载算法"></a>随机负载算法</h4><p>在 Nginx 集群环境下，每个 Nginx 均通过自身对上游服务器的了解情况进行负载均衡处理，这种场景下，很容易出现多台 Nginx 同时把请求都分配给同一台被代理服务器的场景，该场景被称为羊群行为（Herd Behavior）。</p>
<p>Nginx 基于两种选择的力量（Power of Two Choices）原理，设计了随机（Random）负载算法。该算法使 Nginx 不再基于片面的情况了解使用固有的负载均衡策略进行被代理服务器的选择，而是随机选择两个，在经过比较后进行最终的选择。随机负载算法提供了一个参数 two，当这个参数被指定时，Nginx 会在考虑权重的前提下，随机选择两台服务器，然后用以下几种方法选择一个服务器。</p>
<ul>
<li>最少连接数，配置指令为 least_conn，默认配置；</li>
<li>响应头最短平均时间，配置指令为 least_time&#x3D;header，仅对商业版本有效；</li>
<li>完整请求最短平均时间，配置指令为 least_time&#x3D;last_byte，仅对商业版本有效。</li>
</ul>
<p>配置样例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    random two least_conn;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend3.example.com;</span><br><span class="line">    server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在只有单台 Nginx 服务器时，一般不建议使用随机负载算法。</p>
<hr>
<h3 id="长连接负载均衡"><a href="#长连接负载均衡" class="headerlink" title="长连接负载均衡"></a>长连接负载均衡</h3><p>当客户端通过浏览器访问 HTTP 服务器时，HTTP 请求会通过 TCP 协议与 HTTP 服务器建立一条访问通道，当本次访问数据传输完毕后，该 TCP 连接会立即被断开，由于这个连接存在的时间很短，所以 HTTP 连接也被称为短连接。</p>
<p>在 HTTP&#x2F;1.1 版本中默认开启 <strong>Connection:keep-alive</strong>，实现了 HTTP 协议的长连接，可以在一个 TCP 连接中传输多个 HTTP 请求和响应，减少了建立和关闭 TCP 连接的消耗和延迟，提高了传输效率。网络应用中，每个网络请求都会打开一个 TCP 连接，基于上层的软件会根据需要决定这个连接的保持或关闭。例如，FTP 协议的底层也是 TCP，是长连接。</p>
<p>默认配置下，HTTP 协议的负载均衡与上游服务器组中被代理的连接都是 HTTP&#x2F;1.0 版本的短连接。Nginx 的连接管理机制如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZQ13044937.gif" alt="Nginx 连接管理机制"></p>
<p>相关说明如下。</p>
<p>Nginx 启动初始化时，每个 Nginx 工作进程（Worker Process）会生成一个由配置指令 worker_connections 指定大小的可用连接池（free_connection pool）。工作进程每建立一个连接，都会从可用连接池中分配（ngx_get_connection）到一个连接资源，而关闭连接时再通知（ngx_free_connection）可用连接池回收此连接资源。</p>
<p>客户端向 Nginx 发起 HTTP 连接时，Nginx 的工作进程获得该请求的处理权并接受请求，同时从可用连接池中获得连接资源与客户端建立客户端连接资源。</p>
<p>Nginx 的工作进程从可用连接池获取连接资源，并与通过负载均衡策略选中的被代理服务器建立代理连接。</p>
<p>默认配置下，Nginx 的工作进程与被代理服务器建立的连接都是短连接，所以获取请求响应后就会关闭连接并通知可用连接池回收此代理连接资源。</p>
<p>Nginx 的工作进程将请求响应返回给客户端，若该请求为长连接，则保持连接，否则关闭连接并通知可用连接池回收此客户端连接资源。</p>
<p>Nginx 能建立的最大连接数是 worker_connections×worker_processes。而对于反向代理的连接，最大连接数是 worker_connections×worker_processes&#x2F;2，但是其会占用与客户端及与被代理服务器建立的两个连接。</p>
<p>在高并发的场景下，Nginx 频繁与被代理服务器建立和关闭连接会消耗大量资源。Nginx 的 upstream_keepalive 模块提供与被代理服务器间建立长连接的管理支持，该模块建立了一个长连接缓存，用于管理和存储与被代理服务器建立的连接。Nginx 长连接管理机制如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZQ13109228.gif" alt="Nginx 长连接管理机制"></p>
<p>相关说明如下。</p>
<p>当 upstream_keepalive 模块初始化时，将建立按照 upstream 指令域中的 keepalive 指令设置大小的长连接缓存（Keepalive Connect Cache）池。</p>
<p>当 Nginx 的工作进程与被代理服务器新建的连接完成数据传输时，其将该连接缓存在长连接缓存池中。</p>
<p>当工作进程与被代理服务器有新的连接请求时，会先在长连接缓存池中查找符合需求的连接，如果存在则使用该连接，否则创建新连接。</p>
<p>对于超过长连接缓存池数量的连接，将使用最近最少使用（LRU）算法进行关闭或缓存。</p>
<p>长连接缓存池中每个连接最大未被激活的超时时间由 upstream 指令域中 keepalive_timeout 指令设置，超过该指令值时间未被激活的连接将被关闭。</p>
<p>长连接缓存池中每个连接可复用传输的请求数由 upstream 指令域中 keepalive_requests 指令设置，超过该指令值复用请求数的连接将被关闭。</p>
<p>Nginx 与被代理服务器间建立的长连接是通过启用 HTTP&#x2F;1.1 版本协议实现的。由于 HTTP 代理模块默认会将发往被代理服务器的请求头属性字段 Connection 的值设置为 Close，因此需要通过配置指令清除请求头属性字段 Connection 的内容。</p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream http_backend &#123;</span><br><span class="line">    server 192.168.2.154:8080;</span><br><span class="line">    server 192.168.2.109:8080;</span><br><span class="line">    keepalive 32;                           <span class="comment"># 长连接缓存池大小为32</span></span><br><span class="line">    keepalive_requests 2000;                <span class="comment"># 每条长连接最大复用请求数为2000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location /http/ &#123;</span><br><span class="line">        proxy_pass http://http_backend;</span><br><span class="line">        proxy_http_version 1.1;             <span class="comment"># 启用HTTP/1.1版本与被代理服务器建立连接</span></span><br><span class="line">        proxy_set_header Connection <span class="string">&quot;&quot;</span>;     <span class="comment"># 清空发送被代理服务器请求头属性字段Connection</span></span><br><span class="line">                                            <span class="comment"># 的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 FastCGI 协议服务器，需要设置 fastcgi_keep_conn 指令启用长连接支持。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream fastcgi_backend &#123;</span><br><span class="line">    server 192.168.2.154:9000;</span><br><span class="line">    server 192.168.2.109:9000;</span><br><span class="line">    keepalive 8;                            <span class="comment"># 长连接缓存池大小为8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    location /fastcgi/ &#123;</span><br><span class="line">        fastcgi_pass fastcgi_backend;</span><br><span class="line">        fastcgi_keep_conn on;               <span class="comment"># 启用长连接支持</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SCGI 和 uWSGI 协议没有长连接的概念；Memcached 协议（由 ngx_http_memcached_module 模块提供）的长连接配置，只需在 upstream 指令域中设置 keepalive 指令即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream memcached_backend &#123;</span><br><span class="line">    server 127.0.0.1:11211;</span><br><span class="line">    server 10.0.0.2:11211;</span><br><span class="line"></span><br><span class="line">    keepalive 32;                           <span class="comment"># 长连接缓存池大小为32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    location /memcached/ &#123;</span><br><span class="line">        <span class="built_in">set</span> <span class="variable">$memcached_key</span> <span class="variable">$uri</span>;            <span class="comment"># 设置$memcached_key为$uri</span></span><br><span class="line">        memcached_pass memcached_backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="stream容错机制详解"><a href="#stream容错机制详解" class="headerlink" title="stream容错机制详解"></a>stream容错机制详解</h3><p>Nginx 在 upstream 模块中默认的检测机制是通过用户的真实请求去检查被代理服务器的可用性，这是一种被动的检测机制，通过 upstream 模块中 server 指令的指令值参数 max_fails 及 fail_timeout 实现对被代理服务器的检测和熔断。</p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">upstream http_backend &#123;</span><br><span class="line">    <span class="comment"># 10s内出现3次错误，该服务器将被熔断10s</span></span><br><span class="line">    server 192.168.2.154:8080 max_fails=3 fail_timeout=10s;</span><br><span class="line">    server 192.168.2.109:8080 max_fails=3 fail_timeout=10s;</span><br><span class="line">    server 192.168.2.108:8080 max_fails=3 fail_timeout=10s;</span><br><span class="line">    server 192.168.2.107:8080 max_fails=3 fail_timeout=10s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    proxy_connect_timeout 5s;               <span class="comment"># 与被代理服务器建立连接的超时时间为5s</span></span><br><span class="line">    proxy_read_timeout 10s;                 <span class="comment"># 获取被代理服务器的响应最大超时时间为10s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当与被代理服务器通信出现指令值指定的情况时，认为被代理出错，并将请求转发给上游服务器组中</span></span><br><span class="line">    <span class="comment"># 的下一个可用服务器</span></span><br><span class="line">    proxy_next_upstream http_502 http_504 http_404 error <span class="built_in">timeout</span> invalid_header;</span><br><span class="line">    proxy_next_upstream_tries 3;            <span class="comment"># 转发请求最多3次</span></span><br><span class="line">    proxy_next_upstream_timeout 10s;        <span class="comment"># 总尝试超时时间为10s</span></span><br><span class="line"></span><br><span class="line">    location /http/ &#123;</span><br><span class="line">        proxy_pass http://http_backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的参数和指令说明如下。</p>
<ul>
<li>指令值参数 max_fails 是指 10s 内 Nginx 分配给当前服务器的请求失败次数累加值，每 10s 会重置为 0；</li>
<li>指令值参数 fail_timeout 既是失败计数的最大时间，又是服务器被置为失败状态的熔断时间，超过这个时间将再次被分配请求；</li>
<li>指令 proxy_connect_timeout 或 proxy_read_timeout 为超时状态时，都会触发 proxy_next_upstream 的 timeout 条件；</li>
<li>proxy_next_upstream 是 Nginx 下提高请求成功率的机制，当被代理服务器返回错误并符合 proxy_next_upstream 指令值设置的条件时，将尝试转发给下一个可用的被代理服务器；</li>
<li>指令 proxy_next_upstream_tries 的指令值次数包括第一次转发请求的次数。</li>
</ul>
<p>Nginx 被动检测机制的优点是不需要增加额外进程进行健康检测，但用该方法检测是不准确的。如当响应超时时，有可能是被代理服务器故障，也可能是业务响应慢引起的。如果是被代理服务器故障，那么 Nginx 仍会在一定时间内将客户端的请求转发给该服务器，用以判断其是否恢复。</p>
<p>Nginx 官方的主动健康检测模块仅集成在商业版本中，对于开源版本，推荐使用 Nginx 扩展版 OpenResty 中的健康检测模块 lua-resty-upstream-healthcheck。该模块的检测参数如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">默认值</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">shm</td>
<td align="left">–</td>
<td align="left">指定用于健康检测的共享内存名称，共享内存名称由 lua_shared_dict 设定</td>
</tr>
<tr>
<td align="left">upstream</td>
<td align="left">–</td>
<td align="left">指定要做健康检查的 upstream 组名</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">http</td>
<td align="left">指定检测的协议类型，目前只支持 http</td>
</tr>
<tr>
<td align="left">http_req</td>
<td align="left">–</td>
<td align="left">指定用于健康探测的 raw 格式 http 请求字符串</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">1000</td>
<td align="left">检测请求超时时间，单位为 ms</td>
</tr>
<tr>
<td align="left">interval</td>
<td align="left">1000</td>
<td align="left">健康检测的时间间隔，单位为 ms</td>
</tr>
<tr>
<td align="left">valid_status</td>
<td align="left">–</td>
<td align="left">健康检测请求返回的合法响应码列表，比如 {200, 302}</td>
</tr>
<tr>
<td align="left">concurrency</td>
<td align="left">1</td>
<td align="left">健康检测请求的并发数，建议大于上游服务器组中的节点数</td>
</tr>
<tr>
<td align="left">fall</td>
<td align="left">5</td>
<td align="left">对 UP 状态的设备，连续 fall 次失败，认定为 DOWN</td>
</tr>
<tr>
<td align="left">rise</td>
<td align="left">2</td>
<td align="left">对 DOWN 状态的设备，连续 rise 次成功，认定为 UP</td>
</tr>
<tr>
<td align="left">version</td>
<td align="left">0</td>
<td align="left">每次执行健康检测时的版本号，有节点状态改变，版本号加 1</td>
</tr>
</tbody></table>
<p>模块 lua-resty-upstream-healthcheck 的原理是每到（interval）设定的时间，就会对被代理服务器的 HTTP 端口主动发起 GET 请求（http_req），当请求的响应状态码在确定为合法的列表（valid_status）中出现时，则认为被代理服务器是健康的，如果请求的连续（fall）设定次数返回响应状态码都未在列表（valid_status）中出现，则认为是故障状态。</p>
<p>对处于故障状态的设备，该模块会将其置为 DOWN 状态，直到请求的连续（rise）次返回的状态码都在确定为合法的列表中出现，被代理服务器才会被置为 UP 状态，并获得 Nginx 分配的请求，Nginx 在整个运行过程中不会将请求分配给 DOWN 状态的被代理服务器。</p>
<p>lua-resty-upstream-healthcheck 模块只会使用 Nginx 中的一个工作进程对被代理服务器进行检测，不会对被代理服务器产生大量的重复检测。</p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    <span class="comment"># 关闭socket错误日志</span></span><br><span class="line">    lua_socket_log_errors off;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 上游服务器组样例</span></span><br><span class="line">    upstream foo.com &#123;</span><br><span class="line">        server 127.0.0.1:12354;</span><br><span class="line">        server 127.0.0.1:12355;</span><br><span class="line">        server 127.0.0.1:12356 backup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置共享内存名称及大小</span></span><br><span class="line">    lua_shared_dict _foo_zone 1m;</span><br><span class="line"></span><br><span class="line">    init_worker_by_lua_block &#123;</span><br><span class="line">        <span class="comment"># 引用resty.upstream.health-check模块</span></span><br><span class="line">        <span class="built_in">local</span> hc = require <span class="string">&quot;resty.upstream.healthcheck&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">local</span> ok, err = hc.spawn_checker&#123;</span><br><span class="line">            shm = <span class="string">&quot;_foo_zone&quot;</span>,              <span class="comment"># 绑定lua_shared_dict定义的共享内存</span></span><br><span class="line">            upstream = <span class="string">&quot;foo.com&quot;</span>,           <span class="comment"># 绑定upstream指令域</span></span><br><span class="line">            <span class="built_in">type</span> = <span class="string">&quot;http&quot;</span>,</span><br><span class="line"></span><br><span class="line">            http_req = <span class="string">&quot;GET /status HTTP/1.0\r\nHost: foo.com\r\n\r\n&quot;</span>,</span><br><span class="line">                                                <span class="comment"># 用以检测的raw格式http请求</span></span><br><span class="line"></span><br><span class="line">            interval = 2000,                <span class="comment"># 每2s检测一次</span></span><br><span class="line">            <span class="built_in">timeout</span> = 1000,                 <span class="comment"># 检测请求超时时间为1s</span></span><br><span class="line">            fall = 3,                       <span class="comment"># 连续失败3次，被检测节点被置为DOWN状态</span></span><br><span class="line">            rise = 2,                       <span class="comment"># 连续成功2次，被检测节点被置为UP状态</span></span><br><span class="line">            valid_statuses = &#123;200, 302&#125;,    <span class="comment"># 当健康检测请求返回的响应码为200或302时，被认</span></span><br><span class="line">                                                <span class="comment"># 为检测通过</span></span><br><span class="line">            concurrency = 10,               <span class="comment"># 健康检测请求的并发数为10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> not ok <span class="keyword">then</span></span><br><span class="line">            ngx.log(ngx.ERR, <span class="string">&quot;failed to spawn health checker: &quot;</span>, err)</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        end</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 10080;</span><br><span class="line">        access_log  off;                    <span class="comment"># 关闭access日志输出</span></span><br><span class="line">        error_log  off;                     <span class="comment"># 关闭error日志输出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 健康检测状态页</span></span><br><span class="line">        location = /healthcheck &#123;</span><br><span class="line">            allow 127.0.0.1;</span><br><span class="line">            deny all;</span><br><span class="line"></span><br><span class="line">            default_type text/plain;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                <span class="comment"># 引用resty.upstream.healthcheck模块</span></span><br><span class="line">                <span class="built_in">local</span> hc = require <span class="string">&quot;resty.upstream.healthcheck&quot;</span></span><br><span class="line">                ngx.say(<span class="string">&quot;Nginx Worker PID: &quot;</span>, ngx.worker.pid())</span><br><span class="line">                ngx.print(hc.status_page())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是对该配置样例的几点说明。</p>
<ul>
<li>该配置样例参照 OpenResty 官方样例简单修改；</li>
<li>对不同的 upstream 需要通过参数 upstream 进行绑定；</li>
<li>建议为每个上游服务器组指定独享的共享内存，并用参数 shm 进行绑定。</li>
</ul>
<hr>
<h3 id="动态更新upstream"><a href="#动态更新upstream" class="headerlink" title="动态更新upstream"></a>动态更新upstream</h3><p>Nginx 的配置是启动时<strong>一次性加载到内存中</strong>的，在实际的使用中，对 Nginx 服务器上游服务器组中节点的添加或移除仍需要重启或热加载 Nginx 进程。在 Nginx 的商业版本中，提供了 ngx_http_api_module 模块，可以通过 API 动态添加或移除上游服务器组中的节点。</p>
<p>对于 Nginx 开源版本，通过 Nginx 的扩展版 <strong>OpenResty</strong> 及 <strong>Lua</strong> 脚本也可以实现上游服务器组中节点的动态操作，这里只使用 OpenResty 的 lua-upstream-nginx-module 模块简单演示节点的上下线状态动态修改的操作。该模块提供了 set_peer_down 指令，该指令可以对 upstream 的节点实现上下线的控制。</p>
<p>由于该指令只支持 worker 级别的操作，为使得 Nginx 的所有 worker 都生效，此处通过编写 Lua 脚本与 lua-resty-upstream-healthcheck 模块做了简单的集成，利用 lua-resty-upstream-healthcheck 模块的共享内存机制将节点状态同步给其他工作进程，实现对 upstream 的节点状态的控制。</p>
<p>首先在 OpenResty 的 lualib 目录下创建公用函数文件 api_func.lua，lualib&#x2F;api_func.lua 内容如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span> _M = &#123; _VERSION = <span class="string">&#x27;1.0&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">local</span> cjson = require <span class="string">&quot;cjson&quot;</span></span><br><span class="line"><span class="built_in">local</span> upstream = require <span class="string">&quot;ngx.upstream&quot;</span></span><br><span class="line"><span class="built_in">local</span> get_servers = upstream.get_servers</span><br><span class="line"><span class="built_in">local</span> get_primary_peers = upstream.get_primary_peers</span><br><span class="line"><span class="built_in">local</span> set_peer_down = upstream.set_peer_down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割字符串为table</span></span><br><span class="line"><span class="built_in">local</span> <span class="keyword">function</span> <span class="built_in">split</span>( str,reps )</span><br><span class="line">    <span class="built_in">local</span> resultStrList = &#123;&#125;</span><br><span class="line">    string.gsub(str,<span class="string">&quot;[^&quot;</span>..reps..<span class="string">&quot;]+&quot;</span>,<span class="keyword">function</span> ( w )</span><br><span class="line">        table.insert(resultStrList,w)</span><br><span class="line">    end)</span><br><span class="line">    <span class="built_in">return</span> resultStrList</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取server列表</span></span><br><span class="line"><span class="built_in">local</span> <span class="keyword">function</span> get_args_srv( args )</span><br><span class="line">    <span class="keyword">if</span> not args[<span class="string">&quot;server&quot;</span>] <span class="keyword">then</span></span><br><span class="line">        ngx.say(<span class="string">&quot;failed to get post args: &quot;</span>, err)</span><br><span class="line">        <span class="built_in">return</span> nil</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(args[<span class="string">&quot;server&quot;</span>]) ~= <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            server_list=<span class="built_in">split</span>(args[<span class="string">&quot;server&quot;</span>],<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            server_list=args[<span class="string">&quot;server&quot;</span>]</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> server_list</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取节点在upstream中的顺序</span></span><br><span class="line"><span class="built_in">local</span> <span class="keyword">function</span> get_peer_id(ups,server_name)</span><br><span class="line">    <span class="built_in">local</span> srvs = get_servers(ups)</span><br><span class="line">    <span class="keyword">for</span> i, srv <span class="keyword">in</span> ipairs(srvs) <span class="keyword">do</span></span><br><span class="line">        -- ngx.print(srv[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">        <span class="keyword">if</span> srv[<span class="string">&quot;name&quot;</span>] == server_name <span class="keyword">then</span></span><br><span class="line">            target_srv = srv</span><br><span class="line">            target_srv[<span class="string">&quot;id&quot;</span>] = i-1</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> target_srv[<span class="string">&quot;id&quot;</span>]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取节点共享内存key</span></span><br><span class="line"><span class="built_in">local</span> <span class="keyword">function</span> gen_peer_key(prefix, u, is_backup, <span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">if</span> is_backup <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> prefix .. u .. <span class="string">&quot;:b&quot;</span> .. <span class="built_in">id</span></span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> prefix .. u .. <span class="string">&quot;:p&quot;</span> .. <span class="built_in">id</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置节点状态</span></span><br><span class="line"><span class="built_in">local</span> <span class="keyword">function</span> set_peer_down_globally(ups, is_backup, <span class="built_in">id</span>, value,zone_define)</span><br><span class="line">    <span class="built_in">local</span> u = ups</span><br><span class="line">    <span class="built_in">local</span> dict = zone_define</span><br><span class="line">    <span class="built_in">local</span> ok, err = set_peer_down(u, is_backup, <span class="built_in">id</span>, value)</span><br><span class="line">    <span class="keyword">if</span> not ok <span class="keyword">then</span></span><br><span class="line">        ngx.say(cjson.encode(&#123;code = <span class="string">&quot;E002&quot;</span>, msg = <span class="string">&quot;failed to set peer down&quot;</span>, data = err&#125;))</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> key = gen_peer_key(<span class="string">&quot;d:&quot;</span>, u, is_backup, <span class="built_in">id</span>)</span><br><span class="line">    <span class="built_in">local</span> ok, err = dict:<span class="built_in">set</span>(key, value)</span><br><span class="line">    <span class="keyword">if</span> not ok <span class="keyword">then</span></span><br><span class="line">        ngx.say(cjson.encode(&#123;code = <span class="string">&quot;E003&quot;</span>, msg = <span class="string">&quot;failed to set peer down state&quot;</span>, data = err&#125;))</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定upstream的节点列表</span></span><br><span class="line"><span class="keyword">function</span>  _M.list_server(ups)</span><br><span class="line">    <span class="built_in">local</span> srvs, err = get_servers(ups)</span><br><span class="line">    ngx.say(cjson.encode(srvs))</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置节点状态</span></span><br><span class="line"><span class="keyword">function</span>  _M.set_server(ups,args,status,backup,zone_define)</span><br><span class="line">    <span class="built_in">local</span> server_list = get_args_srv(args)</span><br><span class="line">    <span class="keyword">if</span> server_list == nil <span class="keyword">then</span></span><br><span class="line">        ngx.say(cjson.encode(&#123;code = <span class="string">&quot;E001&quot;</span>, msg = <span class="string">&quot;no args&quot;</span>,data = server_list&#125;))</span><br><span class="line">        <span class="built_in">return</span> nil</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, s <span class="keyword">in</span> pairs(server_list) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">local</span> peer_id = get_peer_id(ups,s)</span><br><span class="line">        <span class="keyword">if</span> status <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">local</span> key = gen_peer_key(<span class="string">&quot;nok:&quot;</span>, ups, backup, peer_id)</span><br><span class="line">            <span class="built_in">local</span> ok, err = zone_define:<span class="built_in">set</span>(key, 1)</span><br><span class="line">            set_peer_down_globally(ups, backup, peer_id, <span class="literal">true</span>,zone_define)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">local</span> key = gen_peer_key(<span class="string">&quot;ok:&quot;</span>, ups, backup, peer_id)</span><br><span class="line">            <span class="built_in">local</span> ok, err = zone_define:<span class="built_in">set</span>(key, 0)</span><br><span class="line">            set_peer_down_globally(ups, backup, peer_id, nil,zone_define)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    ngx.say(cjson.encode(&#123;code = <span class="string">&quot;D002&quot;</span>, msg = <span class="string">&quot;set peer is success&quot;</span>,data = server_list&#125;))</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> _M</span><br></pre></td></tr></table></figure>

<p>Nginx 配置文件 status.conf 的内容如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭socket错误日志</span></span><br><span class="line">lua_socket_log_errors off;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置共享内存名称及大小</span></span><br><span class="line">lua_shared_dict _healthcheck_zone 10m;</span><br><span class="line"></span><br><span class="line">init_worker_by_lua_block &#123;</span><br><span class="line">    <span class="built_in">local</span> hc = require <span class="string">&quot;resty.upstream.healthcheck&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置需要健康监测的upstream</span></span><br><span class="line">    <span class="built_in">local</span> ups = &#123;<span class="string">&quot;foo.com&quot;</span>,<span class="string">&quot;sslback&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历ups，绑定健康监测策略</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> pairs(ups) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">local</span> ok, err = hc.spawn_checker&#123;</span><br><span class="line">            shm = <span class="string">&quot;_healthcheck_zone&quot;</span>,      <span class="comment"># 绑定lua_shared_dict定义的共享内存</span></span><br><span class="line">            upstream = v,                   <span class="comment"># 绑定upstream指令域</span></span><br><span class="line">            <span class="built_in">type</span> = <span class="string">&quot;http&quot;</span>,</span><br><span class="line">            http_req = <span class="string">&quot;GET / HTTP/1.0\r\nHost: foo.com\r\n\r\n&quot;</span>,</span><br><span class="line">                                            <span class="comment"># 用以检测的raw格式http请求</span></span><br><span class="line"></span><br><span class="line">            interval = 2000,                <span class="comment"># 每2s检测一次</span></span><br><span class="line">            <span class="built_in">timeout</span> = 1000,                 <span class="comment"># 检测请求超时时间为1s</span></span><br><span class="line">            fall = 3,                       <span class="comment"># 连续失败3次，被检测节点被置为DOWN状态</span></span><br><span class="line">            rise = 2,                       <span class="comment"># 连续成功2次，被检测节点被置为UP状态</span></span><br><span class="line">                                            <span class="comment"># 当健康检测请求返回的响应码为200或302时，被认</span></span><br><span class="line">                                            <span class="comment"># 为检测通过</span></span><br><span class="line">            valid_statuses = &#123;200, 302&#125;,</span><br><span class="line">            concurrency = 10,               <span class="comment"># 健康检测请求的并发数为10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> not ok <span class="keyword">then</span></span><br><span class="line">            ngx.log(ngx.ERR, <span class="string">&quot;failed to spawn health checker: &quot;</span>, err)</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream foo.com &#123;</span><br><span class="line">    server 192.168.2.145:8080;</span><br><span class="line">    server 192.168.2.109:8080;</span><br><span class="line">    server 127.0.0.1:12356 backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream sslback &#123;</span><br><span class="line">    server 192.168.2.145:443;</span><br><span class="line">    server 192.168.2.159:443;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 18080;</span><br><span class="line">    access_log  off;</span><br><span class="line">    error_log off;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 健康检测状态页</span></span><br><span class="line">    location = /healthcheck &#123;</span><br><span class="line">        access_log off;</span><br><span class="line">        allow 127.0.0.1;</span><br><span class="line">        allow 192.168.2.0/24;</span><br><span class="line">        allow 192.168.101.0/24;</span><br><span class="line">        deny all;</span><br><span class="line"></span><br><span class="line">        default_type text/plain;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            <span class="built_in">local</span> hc = require <span class="string">&quot;resty.upstream.healthcheck&quot;</span></span><br><span class="line">            ngx.say(<span class="string">&quot;Nginx Worker PID: &quot;</span>, ngx.worker.pid())</span><br><span class="line">            ngx.print(hc.status_page())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location = /ups_api &#123;</span><br><span class="line">        default_type  application/json;</span><br><span class="line">        content_by_lua <span class="string">&#x27;</span></span><br><span class="line"><span class="string">            # 获取URL参数</span></span><br><span class="line"><span class="string">            local ups = ngx.req.get_uri_args()[&quot;ups&quot;]</span></span><br><span class="line"><span class="string">            local act = ngx.req.get_uri_args()[&quot;act&quot;]</span></span><br><span class="line"><span class="string">            if act == nil or ups == nil then</span></span><br><span class="line"><span class="string">                ngx.say(&quot;usage: /ups_api?ups=&#123;name&#125;&amp;act=[down,up,list]&quot;)</span></span><br><span class="line"><span class="string">                return</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            # 引用api_func.lua脚本</span></span><br><span class="line"><span class="string">            local api_fun = require &quot;api_func&quot;</span></span><br><span class="line"><span class="string">            # 绑定共享内存_healthcheck_zone</span></span><br><span class="line"><span class="string">            local zone_define=ngx.shared[&quot;_healthcheck_zone&quot;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            if act == &quot;list&quot; then</span></span><br><span class="line"><span class="string">                # 获取指定upstream的节点列表</span></span><br><span class="line"><span class="string">                api_fun.list_server(ups)</span></span><br><span class="line"><span class="string">            else</span></span><br><span class="line"><span class="string">                ngx.req.read_body()</span></span><br><span class="line"><span class="string">                local args, err = ngx.req.get_post_args()</span></span><br><span class="line"><span class="string">                if act == &quot;up&quot; then</span></span><br><span class="line"><span class="string">                    # 节点状态将设置为UP</span></span><br><span class="line"><span class="string">                    api_fun.set_server(ups,args,false,false,zone_define)</span></span><br><span class="line"><span class="string">                end</span></span><br><span class="line"><span class="string">                if act == &quot;down&quot; then</span></span><br><span class="line"><span class="string">                    # 节点状态将设置为DOWN</span></span><br><span class="line"><span class="string">                    api_fun.set_server(ups,args,true,false,zone_define)</span></span><br><span class="line"><span class="string">                end</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">        &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作命令如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看upstream foo.com的服务器列表</span></span><br><span class="line">curl <span class="string">&quot;http://127.0.0.1:18080/ups_api?act=list&amp;ups=foo.com&quot;</span></span><br><span class="line"></span><br><span class="line">\# 将192.168.2.145:8080这个节点设置为DOWN状态</span><br><span class="line">curl -X POST -d <span class="string">&quot;server=192.168.2.145:8080&quot;</span> <span class="string">&quot;http://127.0.0.1:18080/ups_api?act= down&amp;ups=foo.com&quot;</span></span><br><span class="line"></span><br><span class="line">\# 将192.168.2.145:8080这个节点设置为UP状态</span><br><span class="line">curl -X POST -d <span class="string">&quot;server=192.168.2.145:8080&quot;</span> <span class="string">&quot;http://127.0.0.1:18080/ups_api?act= up&amp;ups=foo.com&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Stream-TCP-UDP-负载均衡"><a href="#Stream-TCP-UDP-负载均衡" class="headerlink" title="Stream(TCP&#x2F;UDP)负载均衡"></a>Stream(TCP&#x2F;UDP)负载均衡</h3><p>Nginx 的 TCP&#x2F;UDP 负载均衡是应用 Stream 代理模块（ngx_stream_proxy_module）和 Stream 上游模块（ngx_stream_upstream_module）实现的。Nginx 的 TCP 负载均衡与 LVS 都是四层负载均衡的应用，所不同的是，LVS 是被置于 Linux 内核中的，而 Nginx 是运行于用户层的，基于 Nginx 的 TCP 负载可以实现更灵活的用户访问管理和控制。</p>
<h4 id="TCP-UDP-负载均衡"><a href="#TCP-UDP-负载均衡" class="headerlink" title="TCP&#x2F;UDP 负载均衡"></a>TCP&#x2F;UDP 负载均衡</h4><p>Nginx 的 Stream 上游模块支持与 Nginx HTTP 上游模块一致的轮询（Round Robin）、哈希（Hash）及最少连接数（least_conn）负载均衡策略。Nginx 默认使用轮询负载均衡策略，配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server 192.168.2.145:389 weight=5;</span><br><span class="line">        server 192.168.2.159:389 weight=1;</span><br><span class="line">        server 192.168.2.109:389 weight=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 389;</span><br><span class="line">        proxy_pass backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希负载均衡策略可以通过客户端 IP（$remote_addr）实现简单的会话保持，其可将同一 IP 客户端始终转发给同一台后端服务器。</p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        <span class="built_in">hash</span> <span class="variable">$remote_addr</span>;</span><br><span class="line">        server 192.168.2.145:389 weight=5;</span><br><span class="line">        server 192.168.2.159:389 weight=1;</span><br><span class="line">        server 192.168.2.109:389 weight=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 389;</span><br><span class="line">        proxy_pass backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希负载均衡策略通过指令参数 consistent 设定是否开启一致性哈希负载均衡策略。Nginx 的一致性哈希负载均衡策略是采用 Ketama 一致性哈希算法，当后端服务器组中的服务器数量变化时，只会影响少部分客户端的请求。</p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        <span class="built_in">hash</span> <span class="variable">$remote_addr</span> consistent;</span><br><span class="line">        server 192.168.2.145:389 weight=5;</span><br><span class="line">        server 192.168.2.159:389 weight=1;</span><br><span class="line">        server 192.168.2.109:389 weight=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 389;</span><br><span class="line">        proxy_pass backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最少连接负载均衡策略，可以在后端被代理服务器性能不均时，在考虑上游服务器组中各服务器权重的前提下，将客户端连接分配给活跃连接最少的被代理服务器，从而有效提高处理性能高的被代理服务器的使用率。</p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.2.145:389 weight=5;</span><br><span class="line">        server 192.168.2.159:389 weight=1;</span><br><span class="line">        server 192.168.2.109:389 weight=1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 389;</span><br><span class="line">        proxy_pass backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TCP-UDP-负载均衡的容错机制"><a href="#TCP-UDP-负载均衡的容错机制" class="headerlink" title="TCP&#x2F;UDP 负载均衡的容错机制"></a>TCP&#x2F;UDP 负载均衡的容错机制</h4><p>Nginx 的 TCP&#x2F;UDP 负载均衡在连接分配时也支持被动健康检测模式，如果与后端服务器建立连接失败，并在 fail_timeout 参数的时间内连续超过 max_fails 参数设置的次数，Nginx 就会将该服务器置为不可用状态，并且在 fail_timeout 参数的时间内不再给该服务器分配连接。当 fail_timeout 参数的时间结束时将尝试分配连接检测该服务器是否恢复，如果可以建立连接，则判定为恢复。</p>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        <span class="comment"># 10s内出现3次错误，该服务器将被熔断10s</span></span><br><span class="line">        server 192.168.2.154:8080 max_fails=3 fail_timeout=10s;</span><br><span class="line">        server 192.168.2.109:8080 max_fails=3 fail_timeout=10s;</span><br><span class="line">        server 192.168.2.108:8080 max_fails=3 fail_timeout=10s;</span><br><span class="line">        server 192.168.2.107:8080 max_fails=3 fail_timeout=10s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        proxy_connect_timeout 5s;           <span class="comment"># 与被代理服务器建立连接的超时时间为5s</span></span><br><span class="line">        proxy_timeout 10s;          <span class="comment"># 获取被代理服务器的响应最大超时时间为10s</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当被代理的服务器返回错误或超时时，将未返回响应的客户端连接请求传递给upstream中的下</span></span><br><span class="line">        <span class="comment"># 一个服务器</span></span><br><span class="line">        proxy_next_upstream on;</span><br><span class="line">        proxy_next_upstream_tries 3;        <span class="comment"># 转发尝试请求最多3次</span></span><br><span class="line">        proxy_next_upstream_timeout 10s;    <span class="comment"># 总尝试超时时间为10s</span></span><br><span class="line">        proxy_socket_keepalive on;  <span class="comment"># 开启SO_KEEPALIVE选项进行心跳检测</span></span><br><span class="line">        proxy_pass backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的参数及指令说明如下。</p>
<ul>
<li>指令值参数 max_fails 是指 10s 内 Nginx 分配给当前服务器的连接失败次数累加值，每 10s 会重置为 0；</li>
<li>指令值参数 fail_timeout 既是失败计数的最大时间，又是服务器被置为失败状态的熔断时间，超过这个时间将再次被分配连接；</li>
<li>指令 proxy_connect_timeout 或 proxy_timeout 为超时状态时，都会触发 proxy_next_upstream 机制；</li>
<li>proxy_next_upstream 是 Nginx 下提高连接成功率的机制，当被代理服务器返回错误或超时时，将尝试转发给下一个可用的被代理服务器；</li>
<li>指令 proxy_next_upstream_tries 的指令值次数包括第一次转发请求的次数。</li>
</ul>
<p>TCP 连接在接收到关闭连接通知前将一直保持连接，当 Nginx 与被代理服务器的两个连续成功的读或写操作的最大间隔时间超过 proxy_timeout 指令配置的时间时，连接将会被关闭。在 TCP 长连接的场景中，应适当调整 proxy_timeout 的设置，同时关注系统内核 SO_KEEPALIVE 选项的配置，可以防止过早地断开连接。</p>
<hr>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="日志分析简述"><a href="#日志分析简述" class="headerlink" title="日志分析简述"></a>日志分析简述</h3><p>Nginx 通常被置于服务器访问的<strong>入口</strong>，其访问日志可以全局记录用户访问的来源、响应时间，以及用户行为热点等数据，通过对访问日志的分析，可以清晰地了解用户来源、用户行为习惯及自身服务器性能等情况。</p>
<p>借助 ELK 的高性能处理能力，可以实时地将数据分析结果展现给服务器的维护人员及应用的开发人员，进而不断提高业务的可用性及产品的用户体验。</p>
<p>Nginx 的日志分析可以分为<strong>安全分析、性能分析、可用性分析及访问统计分析</strong> 4 个方面。</p>
<ul>
<li><strong>安全分析</strong></li>
</ul>
<p>通常黑客对互联网应用的入侵都是先从 Web 服务器漏洞扫描开始的，最常用的扫描方式就是在 URL 中加入特定的脚本、命令或字符串不断尝试访问，并根据返回结果判断被扫描网站是否存在漏洞或后门。如 SQL 注入攻击会在访问的 URL 中带有 select、and、or、order by 等常见的 SQL 语句，XSS 攻击会在访问的 URL 中带有 javascript、vbscript、onmouseover、eval 等 Javascript 或 VBscript 脚本命令。</p>
<p>另外，对管理后台入口的扫描也是常用的手段之一，多数情况下管理后台的安全加固是最容易被忽视的，往往认为不提供访问链接就高枕无忧了，而 admin、manage 等关键词通常会轻而易举地被穷举出来。</p>
<p>这些不安全的访问痕迹都会被 Nginx 服务器记录到访问日志中，并通过 ELK 对 Nginx 访问日志中的 request_uri 字段进行关键字过滤和展示，以求在第一时间了解这些不安全事件并提前做好防范工作。</p>
<ul>
<li><strong>性能分析</strong></li>
</ul>
<p>一个网站性能的最直接体现就是请求的响应时间。通常用户的请求响应时间都是以毫秒为单位计算的，若用户的请求响应时间以秒为单位时，将极大地加大用户的等待时间，进而影响用户体验。为方便对请求响应的分析，可以将下表所示的 Nginx 服务器提供的变量添加到访问日志中，以记录请求链中消耗的时间。</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">变量名</th>
<th align="left">变量说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$request_time</td>
<td align="left">完全请求时间</td>
<td align="left">从 Nginx 在客户端获取请求的第一个字节到 Nginx 发送给客户端响应数据的最后一个字节间的时间</td>
</tr>
<tr>
<td align="left">$upstream_connect_time</td>
<td align="left">代理建立连接时间</td>
<td align="left">与后端代理服务器建立连接消耗的时间</td>
</tr>
<tr>
<td align="left">$upstream_header_time</td>
<td align="left">代理请求时间</td>
<td align="left">从与后端代理服务器建立连接到接收到响应数据第一个字节间的时间</td>
</tr>
<tr>
<td align="left">$upstream_response_time</td>
<td align="left">响应时间</td>
<td align="left">从与后端代理服务器建立连接到接收到响应数据最后一个字节间的时间</td>
</tr>
</tbody></table>
<p>对请求响应时间的分析，可以通过 ELK 对访问日志 $request_time 字段的时间做排名，对时间值比较大的 URL 从 SQL、代码、架构等多方面分析原因。</p>
<ul>
<li><strong>可用性分析</strong></li>
</ul>
<p>HTTP 请求的每条访问都会有相应的访问状态码，访问状态码标识了请求成功或失败的状态。通过 ELK 对访问日志按照状态码维度统计总访问量，可以很直观地展示当前网站的可用性比率。</p>
<ul>
<li><strong>访问统计分析</strong></li>
</ul>
<p>访问统计分析，可以让网站管理者最直观地了解网站被访问及用户的访问情况，常见的是 PV 及 UV 统计。</p>
<p>PV（Page View）即页面浏览量或点击量，可以让网站管理者清晰地了解当前网站的访问量；UV（Unique Visitor）即独立访客量，以每个同一 IP（remote_addr）、同一客户端类型（http_user_agent）可被识别为独立访客作为统计单位。</p>
<p>PV 体现了用户的访问量，UV 体现了访问当前网站的人数。URL 的访问数量统计，可以清晰地展示网站的哪些功能被大量使用，可以让网站管理者知道用户对网站功能的喜好，以便进行相关的产品优化。</p>
<hr>
<h3 id="访问日志配置"><a href="#访问日志配置" class="headerlink" title="访问日志配置"></a>访问日志配置</h3><p>Nginx 的访问日志主要记录用户客户端的请求信息（见下表）。用户的每次请求都会记录在访问日志中，access_log 指令可以设置日志的输出方式及引用的日志格式。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">访问日志指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">access_log</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">http、stream、server、location、if in location、limit except</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">logs&#x2F;access.log combined;</td>
</tr>
<tr>
<td align="left">指令值格式</td>
<td align="left">off 或 <code>path[format[buffer=size][gzip[=level]][flush=time][if=condition]];</code></td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置访问日志输出方式及引用的日志格式</td>
</tr>
</tbody></table>
<p>关于 access_log 指令有以下几点需要说明:</p>
<ul>
<li>在同一级别的指令域中，也可指定多个日志；</li>
<li>指令值中的第一个参数用于设置输出日志的方式，默认是输出到本地的文件中。该指令也支持输出到 syslog 或内存缓冲区中；</li>
<li>该指令在 stream 指令域中时，默认值为 off；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log off;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数 path，设置日志输出的文件路径或 syslog 服务器地址；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log logs/access.log combined;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数 format，设置关联 log_format 指令定义的日志格式名；</li>
<li>参数 buffer，设置日志文件缓冲区大小。当缓冲区日志数据超出该值时，缓冲区日志数据会被写到磁盘文件。默认缓冲区大小为 64KB；</li>
<li>参数 flush，设置日志缓冲区刷新的时间间隔，缓冲区日志的保护时间超过这个设定值时，缓冲区日志数据会被写到磁盘文件；</li>
<li>参数 gzip，设置缓冲区数据的压缩级别，缓冲区数据会被压缩后再写出到磁盘文件。压缩级别范围 1～9，级别越高压缩比越高，系统资源消耗也最大，默认级别为 1；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log logs/log.gz combined gzip flush=5m;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数 if，设置是否记录日志，当参数值的条件成立，即不为 0 或空时，才记录日志。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map <span class="variable">$status</span> <span class="variable">$loggable</span> &#123;</span><br><span class="line">  ~^[23] 0;</span><br><span class="line">  default 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">access_log logs/access.log combined <span class="keyword">if</span>=<span class="variable">$loggable</span>;</span><br></pre></td></tr></table></figure>

<p>日志格式指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">日志格式指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">log_format</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">http、stream</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">combined”…”;</td>
</tr>
<tr>
<td align="left">指令值格式</td>
<td align="left">name[escape&#x3D;default 或 json 或 none]string…;</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置访问日志输出方式及输出日志格式</td>
</tr>
</tbody></table>
<p>关于 log_format 指令有以下几点需要说明:</p>
<ul>
<li>指令值参数 name 用于设置日志格式名。该名称全局唯一，可以被 access_log 引用；</li>
<li>指令值参数 escape 用于设置日志输出字符串编码格式，json 支持中文字符内容输出；</li>
<li>指令值参数 string 用于设置日志输出格式字符串。该字符串由 Nginx 公共变量和仅在日志写入时存在的变量组成。HTTP 常用变量如下表所示。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">变量说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$time_iso8601</td>
<td align="left">ISO 8601 时间格式</td>
</tr>
<tr>
<td align="left">$time_local</td>
<td align="left">用户请求的时间和时区</td>
</tr>
<tr>
<td align="left">$msec</td>
<td align="left">毫秒级别的日志记录时间</td>
</tr>
<tr>
<td align="left">$remote_addr</td>
<td align="left">发起与 Nginx 建立连接的网络客户端的 IP，有时会是上层代理服务器的 IP</td>
</tr>
<tr>
<td align="left">$http_x_forwarded_for</td>
<td align="left">可以记录客户端 IP，通过代理服务器来记录客户端的 IP</td>
</tr>
<tr>
<td align="left">$remote_user</td>
<td align="left">用于记录远程客户端的用户名称</td>
</tr>
<tr>
<td align="left">$http_user_agent</td>
<td align="left">用户客户端浏览器标识</td>
</tr>
<tr>
<td align="left">$connection</td>
<td align="left">网络连接编号</td>
</tr>
<tr>
<td align="left">$connection_requests</td>
<td align="left">当前连接的请求数</td>
</tr>
<tr>
<td align="left">$request</td>
<td align="left">用户请求的 URI 及请求方法</td>
</tr>
<tr>
<td align="left">$request_method</td>
<td align="left">用户请求方法</td>
</tr>
<tr>
<td align="left">$request_uri</td>
<td align="left">用户请求的 URI 及请求方法</td>
</tr>
<tr>
<td align="left">$server_protocol</td>
<td align="left">请求协议</td>
</tr>
<tr>
<td align="left">$request_time</td>
<td align="left">请求时间</td>
</tr>
<tr>
<td align="left">$request_length</td>
<td align="left">请求数据大小</td>
</tr>
<tr>
<td align="left">$status</td>
<td align="left">用户请求响应状态码</td>
</tr>
<tr>
<td align="left">$bytes_sent</td>
<td align="left">发送到客户端响应数据的大小</td>
</tr>
<tr>
<td align="left">$body_bytes_sent</td>
<td align="left">用户请求返回的响应体字节数</td>
</tr>
<tr>
<td align="left">$http_referer</td>
<td align="left">HTTP 请求头中属性字段 referer</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通格式日志</span></span><br><span class="line">log_format  main  <span class="string">&#x27;$remote_addr - $connection - $remote_user [$time_local] &quot;$request&quot; - $upstream_addr&#x27;</span></span><br><span class="line">                  <span class="string">&#x27;$status  - $body_bytes_sent - $request_time - &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;&quot;$http_user_agent&quot; - &quot;$http_x_forwarded_for&quot; - &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON格式日志</span></span><br><span class="line">log_format json <span class="string">&#x27;&#123;&quot;@timestamp&quot;: &quot;$time_iso8601&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;connection&quot;: &quot;$connection&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;remote_addr&quot;: &quot;$remote_addr&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;remote_user&quot;: &quot;$remote_user&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;request_method&quot;: &quot;$request_method&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;request_uri&quot;: &quot;$request_uri&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;server_protocol&quot;: &quot;$server_protocol&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;status&quot;: &quot;$status&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;body_bytes_sent&quot;: &quot;$body_bytes_sent&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;http_referer&quot;: &quot;$http_referer&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;http_user_agent&quot;: &quot;$http_user_agent&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;http_x_forwarded_for&quot;: &quot;$http_x_forwarded_for&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;request_time&quot;: &quot;$request_time&quot;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>Nginx TCP&#x2F;UDP 的访问日志的变量与 HTTP 的访问日志的变量是不同的，TCP&#x2F;UDP 常见日志变量如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">变量说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$time_iso8601</td>
<td align="left">ISO 8601 时间格式</td>
</tr>
<tr>
<td align="left">$time_local</td>
<td align="left">用户请求的时间和时区</td>
</tr>
<tr>
<td align="left">$connection</td>
<td align="left">网络连接编号</td>
</tr>
<tr>
<td align="left">$remote_addr</td>
<td align="left">发起与 Nginx 建立连接的网络客户端的 IP，有时会是上层代理服务器的 IP</td>
</tr>
<tr>
<td align="left">$server_addr</td>
<td align="left">Nginx 服务器地址</td>
</tr>
<tr>
<td align="left">$server_port</td>
<td align="left">Nginx 服务器端口</td>
</tr>
<tr>
<td align="left">$status</td>
<td align="left">用户请求响应状态码</td>
</tr>
<tr>
<td align="left">$upstream_addr</td>
<td align="left">被代理服务器地址</td>
</tr>
<tr>
<td align="left">$bytes_received</td>
<td align="left">接收字节数</td>
</tr>
<tr>
<td align="left">$bytes_sent</td>
<td align="left">发送字节数</td>
</tr>
<tr>
<td align="left">$session_time</td>
<td align="left">连接会话时间</td>
</tr>
<tr>
<td align="left">$proxy_protocol_addr</td>
<td align="left">代理协议地址</td>
</tr>
<tr>
<td align="left">$proxy_protocol_port</td>
<td align="left">代理协议端口</td>
</tr>
</tbody></table>
<p>Nginx 的 TCP&#x2F;UDP 的日志处理是在连接处理阶段结束时才发生，所以 TCP&#x2F;UDP 代理的访问日志只在连接关闭时才被记录。访问日志格式配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通格式日志</span></span><br><span class="line">log_format  tcp  <span class="string">&#x27;$remote_addr - $connection - [$time_local] $server_addr: $server_port &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;- $status - $upstream_addr - $bytes_received - $bytes_sent - $session_time &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;- $proxy_protocol_addr:$proxy_protocol_port &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON格式日志</span></span><br><span class="line">log_format json <span class="string">&#x27;&#123;&quot;@timestamp&quot;: &quot;$time_iso8601&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;connection&quot;: &quot;$connection&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;remote_addr&quot;: &quot;$remote_addr&quot;, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;server_addr&quot;: &quot;$server_addr:$server_port&quot; &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;status&quot;: &quot;$status&quot; &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;upstream_addr&quot;: &quot;$upstream_addr&quot; &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;bytes_received&quot;: &quot;$bytes_received&quot; &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;bytes_sent&quot;: &quot;$bytes_sent&quot; &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;session_time&quot;: &quot;$session_time&quot; &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;proxy_protocol_addr&quot;: &quot;$proxy_protocol_addr:$proxy_protocol_port&quot; &#x27;</span>&#125;<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>打开日志缓存指令见下表。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">打开日志缓存指令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令</td>
<td align="left">open_log_file_cache</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">http、stream、server、location</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">off</td>
</tr>
<tr>
<td align="left">指令值格式</td>
<td align="left">off 或 max&#x3D;N [inactive&#x3D;time][min_uses&#x3D;N][valid&#x3D;time];</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置存储日志文件描述符（文件句柄）的缓存</td>
</tr>
</tbody></table>
<p>关于 open_log_file_cache 指令有以下几点需要说明:</p>
<ul>
<li>默认配置下，Nginx 每次将缓冲区日志数据保存到磁盘中，都需要先打开文件并获得文件描述符，然后向该文件描述符的文件中写入日志数据，最后关闭该文件描述符的文件。该指令把打开文件的文件描述符（文件句柄）存储在缓存中，进而提升写入日志的效率；</li>
<li>指令值 max 用于设置缓存中存储的文件描述符的最大数量，超过该值时，将按照 LRU 算法对缓存中文件描述符进行关闭；</li>
<li>指令值参数 inactive 用于设置缓存中每个文件描述符存活的时间，默认为 10s；</li>
<li>指令值参数 min_uses 用于设置可被缓存文件描述符的最小使用次数，默认为 1 次；</li>
<li>指令值参数 valid 用于设置缓存检查频率，默认为 60s；</li>
<li>指令值 off 用于关闭打开日志缓存的功能。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;</span><br><span class="line">logs/access.log combined;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="错误日志配置error-log"><a href="#错误日志配置error-log" class="headerlink" title="错误日志配置error_log"></a>错误日志配置error_log</h3><p>Nginx 的错误日志可以帮助用户及时判断 Nginx 配置及运行时出错的原因，错误日志也可以通过 Nginx 内置指令进行配置，但不支持格式定义。配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">说明</th>
<th align="left">错误日志指令组成</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主指令</td>
<td align="left">error_log</td>
</tr>
<tr>
<td align="left">作用域</td>
<td align="left">main、http、mail、stream、server、location</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">logs&#x2F;error.log error;</td>
</tr>
<tr>
<td align="left">指令说明</td>
<td align="left">设置错误日志输出方式及输出日志级别</td>
</tr>
</tbody></table>
<p>关于 error_log 指令有以下几点需要说明:</p>
<ul>
<li>在同一级别的指令域中，也可指定多个日志；</li>
<li>指令值中的第一个参数是输出日志的方式，默认是输出到本地的文件中。该指令也支持输出到 syslog 或内存缓冲区中；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error_log syslog:server=192.168.2.109 error;</span><br><span class="line">error_log memory:32m debug;</span><br><span class="line">error_log /dev/null;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问文件不存在时，记入错误日志</span></span><br><span class="line">log_not_found on;</span><br></pre></td></tr></table></figure>

<p>指令值中第二个参数是输出日志的级别，指定的级别将包含自身及级别值比其小的所有级别日志，日志内容会保存到第一个参数设定的输出位置。</p>
<p>错误日志级别及相关说明如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">级别</th>
<th align="left">级别值</th>
<th align="left">级别说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">debug</td>
<td align="left">8</td>
<td align="left">代码中标记为 NGX_LOG_DEBUG 的输出，输出最为详细，配合调试使用</td>
</tr>
<tr>
<td align="left">info</td>
<td align="left">7</td>
<td align="left">代码中标记为 NGX_LOG_INFO 的输出，因包括除 debug 级别的所有输出，故同样会消耗大量磁盘 IO 资源</td>
</tr>
<tr>
<td align="left">notice</td>
<td align="left">6</td>
<td align="left">代码中标记为 NGX_LOG_NOTICE 的输出</td>
</tr>
<tr>
<td align="left">warn</td>
<td align="left">5</td>
<td align="left">代码中标记为 NGX_LOG_WARN 的输出</td>
</tr>
<tr>
<td align="left">error</td>
<td align="left">4</td>
<td align="left">代码中标记为 NGX_LOG_ERROR 的输出，实际生产环境中常用的输出级别</td>
</tr>
<tr>
<td align="left">crit</td>
<td align="left">3</td>
<td align="left">代码中标记为 NGX_LOG_CRIT 的输出</td>
</tr>
<tr>
<td align="left">alert</td>
<td align="left">2</td>
<td align="left">代码中标记为 NGX_LOG_ALERT 的输出</td>
</tr>
<tr>
<td align="left">emerg</td>
<td align="left">1</td>
<td align="left">代码中标记为 NGX_LOG_EMERG 的输出</td>
</tr>
</tbody></table>
<hr>
<h3 id="日志归档配置"><a href="#日志归档配置" class="headerlink" title="日志归档配置"></a>日志归档配置</h3><p><strong>Logrotate</strong></p>
<p>Nginx 日志存储为文件时，同一 access_log 指令设置的日志文件是以单文件形式存储的，在日常使用中为方便维护，通常需要将日志文件按日期进行归档。虽然 Nginx 本身并没有这一功能，但实现日志归档的方法仍有很多，此处推荐使用 Logrotate 实现日志归档管理。</p>
<p>Logrotate 是 CentOS 操作系统内置日志管理工具，该工具可对系统中生成的大量日志文件进行归档管理，其允许对日志文件实行压缩、删除或邮寄等操作。Logrotate 可以按照每天、周、月或达到某一大小的日志文件进行归档操作，Logrotate 基于 anacrontab 实现计划任务，只需在 &#x2F;etc&#x2F;logrotate.d 目录下编写相关日志管理配置文件，就可以无须人工干预使用自动化方式完成日志归档操作。</p>
<ul>
<li><strong>Logrotate 安装</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install logrotate</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Logrotate 文件目录</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/logrotate.conf                     <span class="comment"># logrotate主配置文件</span></span><br><span class="line">/usr/sbin/logrotate                     <span class="comment"># logrotate二进制文件</span></span><br><span class="line">/etc/logrotate.d/                       <span class="comment"># 自定义logrotate配置文件</span></span><br><span class="line">/var/lib/logrotate/logrotate.status     <span class="comment"># logrotate管理日志执行记录的状态文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Logrotate 命令参数</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    -d, --debug                             <span class="comment"># 测试归档配置文件</span></span><br><span class="line">    -f, --force                             <span class="comment"># 立即执行归档操作</span></span><br><span class="line">    -m, --mail=<span class="built_in">command</span>                      <span class="comment"># 指定发送邮件的命令（默认为&#x27;/bin/mail&#x27;)</span></span><br><span class="line">    -s, --state=statefile                   <span class="comment"># 设置logrotate.status文件路径，可用于区分在同</span></span><br><span class="line">                                                <span class="comment"># 一系统下以不同用户身份运行的logrotate任务</span></span><br><span class="line">    -v, --verbose                           <span class="comment"># 显示配置详细信息</span></span><br><span class="line">    -l, --<span class="built_in">log</span>=STRING                        <span class="comment"># 将Logrotate执行的详情输出到指定的文件</span></span><br><span class="line"></span><br><span class="line">logrotate -v /etc/logrotate.conf                <span class="comment"># 显示配置文件详细信息</span></span><br><span class="line">logrotate -d /etc/logrotate.d/syslog -l /var/log/logrotate.log  <span class="comment"># 配置文件，执行测试</span></span><br><span class="line">logrotate -f /etc/logrotate.d/syslog    <span class="comment"># 立即执行当前配置文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Logrotate 配置指令</strong></li>
</ul>
<p>Logrotate 配置指令如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">指令说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">归档执行周期</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">hourly</td>
<td align="left">日志归档周期为 1 小时，默认 Logrotate 的最小周期为 1 天，需额外调整该参数才可生效</td>
</tr>
<tr>
<td align="left">daily</td>
<td align="left">日志归档周期为 1 天</td>
</tr>
<tr>
<td align="left">weekly</td>
<td align="left">日志归档周期为 1 周</td>
</tr>
<tr>
<td align="left">monthly</td>
<td align="left">日志归档周期为 1 月，通常为每月的第一天</td>
</tr>
<tr>
<td align="left">归档执行条件</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">include</td>
<td align="left">读取外部参数文件</td>
</tr>
<tr>
<td align="left">missingok</td>
<td align="left">如果日志文件不存在，则不显示错误信息</td>
</tr>
<tr>
<td align="left">nomissingok</td>
<td align="left">如果日志文件不存在，则显示错误信息。默认配置</td>
</tr>
<tr>
<td align="left">size</td>
<td align="left">日志文件可被归档的最小值</td>
</tr>
<tr>
<td align="left">minsize</td>
<td align="left">日志文件可被归档的最小值，没到归档周期执行时间，不会执行归档操作</td>
</tr>
<tr>
<td align="left">maxsize</td>
<td align="left">日志文件超过设定值时，即使没到归档周期执行时间，也会执行归档操作</td>
</tr>
<tr>
<td align="left">ifempty</td>
<td align="left">即使日志文件为空，也执行归档操作</td>
</tr>
<tr>
<td align="left">notifempty</td>
<td align="left">如果日志文件为空，则不进行归档。默认设置</td>
</tr>
<tr>
<td align="left">tabooext</td>
<td align="left">不对设置扩展名的日志文件执行归档操作</td>
</tr>
<tr>
<td align="left">归档文件命名</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">start count</td>
<td align="left">使用日志文件归档次数作为归档文件扩展名，count 默认值为 1，默认配置</td>
</tr>
<tr>
<td align="left">dateext</td>
<td align="left">为归档文件名添加日期，默认追加到扩展名后</td>
</tr>
<tr>
<td align="left">dateformat</td>
<td align="left">设置归档文件名中的日期格式，使用”%Y%m%d%H”作为说明符，默认为-%Y%m%d</td>
</tr>
<tr>
<td align="left">dateyesterday</td>
<td align="left">使用前一天的日期而非创建归档文件时的日期作为归档文件的文件名中的日期</td>
</tr>
<tr>
<td align="left">extension</td>
<td align="left">指定日志的扩展名，并将其设置为归档文件的扩展名，启用压缩时，压缩的扩展名在最后</td>
</tr>
<tr>
<td align="left">compressext</td>
<td align="left">启用压缩时，自定义归档文件扩展名，如将”.gz”改为”.ddd”</td>
</tr>
<tr>
<td align="left">归档文件保存方式</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">compress</td>
<td align="left">对归档文件启用压缩，默认为 gzip 压缩</td>
</tr>
<tr>
<td align="left">nocompress</td>
<td align="left">不压缩归档文件。默认设置</td>
</tr>
<tr>
<td align="left">compresscmd</td>
<td align="left">指定压缩归档文件的命令，默认为 gzip 压缩</td>
</tr>
<tr>
<td align="left">uncompresscmd</td>
<td align="left">指定解压归档文件的命令，默认为 gunzip 解压</td>
</tr>
<tr>
<td align="left">compressoptions</td>
<td align="left">启用压缩时，设置压缩工具的命令选项</td>
</tr>
<tr>
<td align="left">delaycompress</td>
<td align="left">在下一个归档周期再对当前归档文件进行压缩</td>
</tr>
<tr>
<td align="left">nodelaycompress</td>
<td align="left">不延迟压缩。默认设置</td>
</tr>
<tr>
<td align="left">归档执行方式</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">copy</td>
<td align="left">为日志文件复制一个副本后再进行归档</td>
</tr>
<tr>
<td align="left">nocopy</td>
<td align="left">不复制源日志文件。默认配置</td>
</tr>
<tr>
<td align="left">copytruncate</td>
<td align="left">复制日志文件后清空日志文件的内容</td>
</tr>
<tr>
<td align="left">nocopytruncate</td>
<td align="left">复制源日志文件后，不清空源文件。默认设置</td>
</tr>
<tr>
<td align="left">create mode owner group, create owner group</td>
<td align="left">重命名日志文件，创建与日志文件同名的文件，默认 mode&#x3D;0644 uid&#x3D;0 gid&#x3D;0，与 copy 指令不能同时使用</td>
</tr>
<tr>
<td align="left">nocreate</td>
<td align="left">不创建与日志文件同名的文件。默认设置</td>
</tr>
<tr>
<td align="left">olddir</td>
<td align="left">设置归档文件保存目录</td>
</tr>
<tr>
<td align="left">noolddir</td>
<td align="left">归档文件与源文件在同一目录。默认设置</td>
</tr>
<tr>
<td align="left">createolddir mode owner group</td>
<td align="left">如果 olddir 参数指定的目录不存在，则创建目录并指定属组，默认 mode &#x3D; 0777 uid &#x3D; 0 gid &#x3D; 0</td>
</tr>
<tr>
<td align="left">nocreateolddir</td>
<td align="left">当 olddir 参数设定目录不存在时，不创建目录。默认设置</td>
</tr>
<tr>
<td align="left">prerotate … endscript</td>
<td align="left">归档执行之前执行脚本，日志文件名为传入的第一个参数</td>
</tr>
<tr>
<td align="left">postrotate … endscript</td>
<td align="left">归档执行之后执行脚本，日志文件名为传入的第一个参数</td>
</tr>
<tr>
<td align="left">firstaction … endscript</td>
<td align="left">prerotate 脚本之前，仅当第一个日志文件被开始执行归档操作时才执行脚本，日志文件名为传入的第一个参数</td>
</tr>
<tr>
<td align="left">lastaction … endscript</td>
<td align="left">postrotate 脚本之后，仅当最后一个日志文件执行归档操作结束时才执行脚本，日志文件名为传入的第一个参数</td>
</tr>
<tr>
<td align="left">preremove … endscript</td>
<td align="left">删除日志文件之前执行脚本，日志文件名为传入的第一个参数</td>
</tr>
<tr>
<td align="left">sharedscripts</td>
<td align="left">当匹配的日志文件为多个时，prerotate 和 postrotate 脚本会在每个日志文件执行归档操作时都执行一次，启用共享模式会让 prerotate 和 postrotate 脚本在全局只运行一次</td>
</tr>
<tr>
<td align="left">nosharedscripts</td>
<td align="left">当匹配的日志文件为多个时，prerotate 和 postrotate 脚本会在每个日志文件执行归档操作时都执行一次。默认设置</td>
</tr>
<tr>
<td align="left">su user group</td>
<td align="left">指定操作源文件执行归档操作的用户及属组</td>
</tr>
<tr>
<td align="left">归档文件清理</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">mail</td>
<td align="left">设置接收归档文件的邮件地址</td>
</tr>
<tr>
<td align="left">nomail</td>
<td align="left">不将归档文件发送到任何邮件地址</td>
</tr>
<tr>
<td align="left">mailfirst</td>
<td align="left">将刚生成的归档文件发送到设置的邮箱</td>
</tr>
<tr>
<td align="left">maillast</td>
<td align="left">将要超过 maxage 设置时间的归档文件发送到设置的邮箱</td>
</tr>
<tr>
<td align="left">mахage</td>
<td align="left">设置过期归档文件的天数</td>
</tr>
<tr>
<td align="left">rotate</td>
<td align="left">保留归档文件数，默认为 0</td>
</tr>
<tr>
<td align="left">shred</td>
<td align="left">彻底删除</td>
</tr>
<tr>
<td align="left">shredcycles count</td>
<td align="left">彻底删除时，覆盖文件的次数，默认为 3</td>
</tr>
<tr>
<td align="left">noshred</td>
<td align="left">不彻底删除</td>
</tr>
</tbody></table>
<p>关于上表有以下几点需要说明:</p>
<ol>
<li><p>copy 与 create 是两种互斥的归档执行方式；</p>
</li>
<li><p>copy 方式是将日志文件复制一份后清空原日志文件的内容，并对复制的文件进行归档操作，应用程序继续向原日志文件输出日志。因日志文件复制与清空操作存在时间间隔，所以切割操作会因日志量的大小及实时产生的频率存在丢失的情况；</p>
</li>
<li><p>create 方式是将日志文件重命名，因日志文件的 inode 编号不变，应用程序会向新命名的文件输出日志。Logrotate 新创建原日志文件名的文件后执行重启或以信号机制通知应用程序重新向新日志文件输出日志内容，完成切割操作；</p>
</li>
<li><p>当与同一自定义配置匹配的日志文件为多个时，会并发执行归档操作。</p>
</li>
</ol>
<ul>
<li><strong>Logrotate 管理 Nginx 日志</strong></li>
</ul>
<p>根据 Logrotate 的功能特点，建议选择 create 方式进行日志归档管理，配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/logrotate.d/nginx</span><br><span class="line">/usr/local/nginx/logs/*.<span class="built_in">log</span> &#123;</span><br><span class="line">    daily                                   <span class="comment"># 日志归档周期为1天</span></span><br><span class="line">    size 1                                  <span class="comment"># 日志文件最小为1字节时才执行归档</span></span><br><span class="line">    minsize 1                               <span class="comment"># 日志文件最小为1字节时才执行归档</span></span><br><span class="line">    notifempty                              <span class="comment"># 日志文件不为空时才执行归档</span></span><br><span class="line">    dateext                                 <span class="comment"># 归档文件名添加时间字符串</span></span><br><span class="line">    dateformat -%Y%m%d%H                    <span class="comment"># 归档文件名时间字符串格式为-%Y%m%d%H</span></span><br><span class="line">    dateyesterday                           <span class="comment"># 归档文件名时间字符串以归档操作的前一天为时间戳</span></span><br><span class="line">    extension .<span class="built_in">log</span>                          <span class="comment"># 归档文件名中保留日志的扩展名</span></span><br><span class="line">    compress                                <span class="comment"># 归档文件执行压缩</span></span><br><span class="line">    delaycompress                           <span class="comment"># 在归档执行的下个周期再进行压缩</span></span><br><span class="line">    create                                  <span class="comment"># 以创建新文件方式实现日志归档</span></span><br><span class="line">    olddir /data/backup/nginx_logs          <span class="comment"># 归档文件存储目录</span></span><br><span class="line">    createolddir                            <span class="comment"># 归档文件存储目录不存在时自动创建</span></span><br><span class="line">    postrotate                              <span class="comment"># 归档执行后执行脚本</span></span><br><span class="line">        /usr/local/nginx/sbin/nginx -s reopen -g <span class="string">&quot;pid /run/nginx.pid;&quot;</span></span><br><span class="line">                                                <span class="comment"># 通知Nginx重新打开日志文件</span></span><br><span class="line">    endscript</span><br><span class="line">    sharedscripts                           <span class="comment"># 启用脚本共享模式</span></span><br><span class="line">    maxage 7                                <span class="comment"># 归档文件最多保留7天</span></span><br><span class="line">    rotate 7                                <span class="comment"># 归档文件最多保留7份</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="日志分析工具（ELK）配置"><a href="#日志分析工具（ELK）配置" class="headerlink" title="日志分析工具（ELK）配置"></a>日志分析工具（ELK）配置</h3><p>Nginx 的访问日志中可以记录用户的 IP、访问方法、访问 URI、响应状态及响应数据大小等 HTTP 请求处理中会涉及的各种信息，通过这些信息可以实现访问用户来源分布、用户请求 URI 排行、响应数据大小及并发连接的分析和统计。</p>
<h4 id="ELK-简介"><a href="#ELK-简介" class="headerlink" title="ELK 简介"></a>ELK 简介</h4><p>ELK（Elasticsearch、Logstash、Kibana）是开源的实时日志收集分析解决方案。ELK 访问逻辑如下图所示，是由 Elasticsearch、Logstash、Kibana 这三款软件和数据采集客户端（如 Filebeat）等实现日志采集、储存、搜索分析等操作。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZZ91153130.gif" alt="ELK 访问逻辑"></p>
<ul>
<li>Elasticsearch 是一款用 Java 语言开发的，基于 Lucene 的开源搜索引擎，它提供了分布式多用户的全文搜索、分析、存储能力。Elasticsearch 的常见关键词如下表所示。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">关键词</th>
<th align="left">名称</th>
<th align="left">关键词说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cluster</td>
<td align="left">集群</td>
<td align="left">集群由一个主节点和多个从节点组成，主节点是通过内部选举产生的。Elastic-search 集群是一个去中心化的分布式架构，对于外部用户来讲，Elasticsearch 集群是个整体，与其中任何一个节点通信获取内容都是一致的</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">索引</td>
<td align="left">Elasticsearch 是面向文档的数据库，一条数据就是一个文档，文档内容为包含多个 key，value 格式字段数据。Elasticsearch 集群可以包括多个索引，每个索引下包含多个类型，每个类型下包含多个文档。索引相当于关系型数据库中的库，类型相当于关系型数据库中的表</td>
</tr>
<tr>
<td align="left">shards</td>
<td align="left">索引分片</td>
<td align="left">Elasticsearch 可以把一个完整的索引分成多个分片，该方式可以把一个大的索引拆分成多个，并分布到不同的节点，实现分布式搜索</td>
</tr>
<tr>
<td align="left">replicas</td>
<td align="left">索引副本</td>
<td align="left">Elasticsearch 可以为索引设置多个副本，当集群中某个节点或某个索引的分片损坏或丢失时，可以通过副本进行恢复，同时可以为搜索请求提供负载均衡，以提高查询效率</td>
</tr>
<tr>
<td align="left">recovery</td>
<td align="left">数据分配与恢复</td>
<td align="left">Elasticsearch 集群在有节点加入或退出时，会根据节点的数量变化对索引分片进行重新分配，当挂掉的节点重启后也会进行数据分配与恢复</td>
</tr>
<tr>
<td align="left">gateway</td>
<td align="left">存储方式</td>
<td align="left">Elasticsearch 存储方式，Elasticsearch 会先把索引存放到内存中，当内存满了时再持久化到 gateway 配置的目标存储中。默认 gateway 配置为本地硬盘，也支持其他分布式文件系统，如 Hadoop 的 HDFS 和 Amazon 的 s3 云存储服务等</td>
</tr>
</tbody></table>
<ul>
<li>Logstash 是基于 C&#x2F;S 架构，对日志进行收集、过滤、转发的日志收集引擎，它可以同时从多个源获取数据，动态地将客户端采集的数据进行分拣、过滤，并转发到不同存储服务器。</li>
</ul>
<p>Logstash 是以 pipeline 方式处理每条日志信息的，在每个 pipeline 中都有输入（INPUTS）、过滤（FILTERS）、输出（OUTPUTS）3 个处理动作。每个处理动作可由一个或多个插件实现复杂的功能。输入处理是获取日志数据；过滤处理可以对日志进行分拣、修改；输出处理则是将日志数据发送给目标存储服务器。</p>
<p>Logstash 工作原理如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZZ91229195.gif" alt="Logstash 原理"></p>
<ul>
<li>Kibana 是 Elasticsearch 的 Web 管理工具，它提供了友好的界面化操作方式和统计分析的 Dashboard 工具，让使用者只需简单点击就可完成基本的数据搜索、分析等工作。</li>
<li>Filebeat 隶属于 Beats 工具包，是负责文件数据采集的客户端工具。Filebeat 由 pro-spector 和 harvester 两个主要组件组成。prospector 目前只支持 log 文件和 stdin 两个输入类型，是 harvester 的管理进程，负责按照配置参数 paths 的内容查找日志文件，并为每个日志文件分配一个 harvester。</li>
</ul>
<p>harvester 负责实时读取单个日志文件，harvester 将日志内容发送给底层的 libbeat，libbeat 将日志数据发送给配置文件中指定的输出目标。Filebeat 工作原理如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200ZZ91244125.gif" alt="Filebeat 原理"></p>
<h4 id="ELK-安装"><a href="#ELK-安装" class="headerlink" title="ELK 安装"></a><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/nginx_log_elk.html">ELK 安装</a></h4><hr>
<h3 id="监控工具配置"><a href="#监控工具配置" class="headerlink" title="监控工具配置"></a>监控工具配置</h3><p><strong>（Prometheus）</strong></p>
<p>Nginx 的 ngx_http_stub_status_module 模块及第三方的主机状态监控模块都提供了自身状态数据的统计和输出功能，但作为监控管理，仍需要进一步实现对各种状态数据的收集、存储、统计展示、阈值报警等工作。为实现监控管理的完整性，需要使用更专业的监控工具来实现后续的工作。</p>
<h4 id="Prometheus简介"><a href="#Prometheus简介" class="headerlink" title="Prometheus简介"></a>Prometheus简介</h4><p>Prometheus 是由 SoundCloud 开源的监控告警解决方案，其在 GitHub 上的 Star 数已经超过 3.1 万，已成为很多大公司首选的监控解决方案。Prometheus 由 Prometheus Server、PushGateway、Alertmanager、Exporter 等 4 个组件共同组成。</p>
<p>其中，Exporter 可以由用户自行开发，只需输出符合 Prometheus 的规范数据即可；Prometheus Server 提供了 api 接口并支持自定义的 PromQL 查询语言对外实现监控数据查询输出，结合 Grafana 强大的图形模板功能，可以非常直观地以监控数据统计图表的形式进行展示。Prometheus 结构如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9131Q5338.gif" alt="Prometheus结构"></p>
<p>关于上图有以下几点需要说明。</p>
<ul>
<li>Prometheus Server:Prometheus 的基础服务，其从配置文件中 job 配置的 tagrets 目标服务器拉取监控数据，拉取数据周期由配置参数 scrape_interval 设置，同时开放 api 接口提供监控数据的对外查询和聚合分析功能；</li>
<li>PushGateway:Prometheus 的推送网关服务。Prometheus 默认都是从被监控服务器上拉取监控数据的，但由于网络原因无法直接访问目标服务器时，可在被监控服务器上通过脚本或工具采集监控数据，然后推送给推送网关服务（PushGateway），Prometheus 的基础服务则实时地从推送网关服务提供的端口 9091 拉取监控数据，完成监控操作；</li>
<li>Alertmanager:Prometheus 的告警服务，其对外开放端口 9093 接收 Prometheus Server 发送的告警信息，并按照告警规则将告警信息发送给接收目标；</li>
<li>Exporter:监控数据采集接口服务，该服务可由用户按照 Prometheus 的数据规范自行开发，只需提供对外访问接口，并能输出 Prometheus 数据格式的监控数据即可。</li>
</ul>
<h4 id="Prometheus部署"><a href="#Prometheus部署" class="headerlink" title="Prometheus部署"></a><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/nginx_log_prometheus.html">Prometheus部署</a></h4><p>Prometheus 支持多种方式部署，鉴于 Docker 化部署的便捷性，此处选择基于 docker-compose 脚本部署 Docker 化的 Prometheus 环境，部署示意如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9131S43E.gif" alt="Prometheus 部署"><br>在服务器 10.10.4.38 上部署 Prometheus 的基础服务和 Grafana 服务；在服务器 10.10.4.39 上部署 Prometheus 的推送网关服务和 Prometheus 的告警服务。</p>
<h4 id="监控HTTP主机状态"><a href="#监控HTTP主机状态" class="headerlink" title="监控HTTP主机状态"></a><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/nginx_log_prometheus.html">监控HTTP主机状态</a></h4><p>Prometheus 针对被监控主机，是通过轮询 Exporter 接口的形式获取监控数据的，nginx-module-vts 模块虽然也提供 Prometheus 数据格式输出，但数据并不详细，推荐使用 nginx-vts-exporter 实现 Prometheus 数据输出。nginx-vts-exporter 是由Go语言开发的，不仅提供了针对信息的监控数据，还提供了配套的 Grafana 模板。</p>
<h4 id="监控TCP-UDP主机状态"><a href="#监控TCP-UDP主机状态" class="headerlink" title="监控TCP&#x2F;UDP主机状态"></a><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/nginx_log_prometheus.html">监控TCP&#x2F;UDP主机状态</a></h4><p>TCP&#x2F;UDP 主机状态模块 nginx-module-sts 虽然也提供了 Prometheus 格式数据输出，但仍然不够详细，同时也没有可用的开源 Exporter。为实现 Nginx TCP&#x2F;UDP 主机状态数据的采集，可以按照 Prometheus 的数据规范编写一个 Exporter。</p>
<h4 id="Prometheus监控告警"><a href="#Prometheus监控告警" class="headerlink" title="Prometheus监控告警"></a><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/nginx_log_prometheus.html">Prometheus监控告警</a></h4><hr>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="Linux虚拟服务器简介"><a href="#Linux虚拟服务器简介" class="headerlink" title="Linux虚拟服务器简介"></a>Linux虚拟服务器简介</h3><p>LVS（Linux Virtual Server）是一个开源的负载均衡项目，是国内最早出现的开源项目之一，目前已被集成到 Linux 内核模块中。该项目在 Linux 内核中实现了基于 TCP 层的 IP 数据负载均衡分发，其工作在内核空间且仅做负载均衡分发处理，所以稳定性相对较好，性能相对较强，对内存及 CPU 资源的消耗也最低。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9151011T8.gif" alt="多层负载均衡网络架构"></p>
<h4 id="LVS术语"><a href="#LVS术语" class="headerlink" title="LVS术语"></a>LVS术语</h4><p>LVS 相关术语说明如下。</p>
<ul>
<li>DS（Director Server）:控制器服务器，部署 LVS 软件的服务器；</li>
<li>RS（Real Server）:真实服务器，被负载的后端服务器；</li>
<li>VIP（Virtual IP）:虚拟 IP，对外提供用户访问的 IP 地址；</li>
<li>DIP（Director Server IP）:控制器服务器 IP，控制器服务器的 IP 地址；</li>
<li>RIP（Real Server IP）:真实服务器 IP，真实服务器的 IP 地址；</li>
<li>CIP（Client IP）:客户端 IP，客户端的 IP 地址；</li>
<li>IPVS（IP Virtual Server）:LVS 的核心代码，工作于内核空间，主要有 IP 包处理、负载均衡算法、系统配置管理及网络链表处理等功能；</li>
<li>ipvsadm:IPVS 的管理器，工作于用户空间，负责 IPVS 运行规则的配置。</li>
</ul>
<h4 id="LVS工作原理"><a href="#LVS工作原理" class="headerlink" title="LVS工作原理"></a>LVS工作原理</h4><p>IPVS 是基于 Linux 的 Netfilter 框架实现的，其以数据包的网络检测链为挂载点完成数据的负载均衡及转发处理。其工作原理如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9150J6392.gif" alt="LVS 工作原理"><br>图:LVS 工作原理</p>
<p>客户访问虚拟 IP（VIP）时，数据包先在主机内核空间被 PREROUTING 链检测，根据数据包的目标地址进行路由判断，若目标地址是本地，则交由 INPUT 链进行处理。</p>
<p>IPVS 工作于 INPUT 链，当数据包到达 INPUT 链时，会先由 IPVS 进行检查，并根据负载均衡算法选出真实服务器 IP。</p>
<p>IPVS 转发模式为 NAT 模式时，将数据包由 FORWARD 链进行处理后由 POST-ROUTING 链发送给真实服务器。</p>
<p>IPVS 转发模式为非 NAT 模式时，则将数据包由 POSTROUTING 链发送给真实服务器。</p>
<h4 id="LVS转发模式"><a href="#LVS转发模式" class="headerlink" title="LVS转发模式"></a>LVS转发模式</h4><p>LVS 支持多种网络部署结构，官方版本提供了 NAT、TUN 及 DR 这 3 种标准转发模式，另阿里巴巴工程师根据自身需求进行扩展，实现了 FullNAT 转发模式。</p>
<ul>
<li><strong>LVS标准转发模式如下:</strong></li>
</ul>
<p>NAT，该模式需要真实服务器的网关指向 DS，客户端的请求包和返回包都要经过 DS，该模式对 DS 的硬件性能的要求相对较高。</p>
<p>TUN，该模式是将客户端的请求包通过 IPIP 方式封装后分发给真实服务器，客户端的返回包则由真实服务器的本地路由自行处理，源 IP 地址还是 VIP 地址（真实服务器需要在本地回环接口配置 VIP）。因 DS 只负责请求包转发，其处理性能比 NAT 模式要高，但需要真实服务器支持 IPIP 协议。</p>
<p>DR，该模式是将客户端的请求包通过修改 MAC 地址为真实服务器的 MAC 地址后将数据包分发给真实服务器，客户端的返回包则由真实服务器的本地路由自行处理，源 IP 地址还是 VIP 地址（真实服务器需要在本地回环接口配置 VIP）。</p>
<p>因 DS 只负责请求包转发，且与真实服务器间进行基于二层的数据分发，所以处理性能最高，但要求 DS 与真实服务器在同一 MAC 广播域内。</p>
<ul>
<li><strong>阿里扩展版本转发模式如下:</strong></li>
</ul>
<p>FullNAT，该模式是客户端的请求包和返回包都要经过 DS，但真实服务器可以在网络中的任意位置，且无须将网关配置为 DS 的 IP 地址，该方式虽然对 DS 的性能要求较高，但始终由 DS 面对客户端，有效保护了真实服务器的安全。</p>
<p>阿里扩展版本还针对 LVS 官方版本在安全方面进行了增强，提供了 SYNPROXY 功能支持，该功能在 LVS 上增加了一层 foold 类型的攻击包防护，实现了 UDP&#x2F;IP FRAG DDOS 攻击防护。</p>
<h4 id="LVS负载均衡算法"><a href="#LVS负载均衡算法" class="headerlink" title="LVS负载均衡算法"></a>LVS负载均衡算法</h4><p>LVS 实现了 10 种负载均衡算法，负载均衡算法及其功能介绍如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">算法名称</th>
<th align="left">英文名称</th>
<th align="left">配置简称</th>
<th align="left">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">轮询调度</td>
<td align="left">Round Robin</td>
<td align="left">rr</td>
<td align="left">将请求依次循环分发给负载的真实服务器</td>
</tr>
<tr>
<td align="left">加权轮询调度</td>
<td align="left">Weight Round Robin</td>
<td align="left">wrr</td>
<td align="left">按照配置的权重比例将请求分发给真实服务器，权重越高，分配的请求越多</td>
</tr>
<tr>
<td align="left">目标地址散列调度</td>
<td align="left">Destination Hashing</td>
<td align="left">dh</td>
<td align="left">该算法将目标地址作为散列键（Hash Key），从散列表中找出对应的真实服务器进行请求分发</td>
</tr>
<tr>
<td align="left">源地址散列调度</td>
<td align="left">Source Hashing</td>
<td align="left">sh</td>
<td align="left">该算法根据源地址作为散列键（Hash Key）从散列表中找出对应的真实服务器进行请求分发</td>
</tr>
<tr>
<td align="left">最小连接调度</td>
<td align="left">Least Connections</td>
<td align="left">lc</td>
<td align="left">将新的请求分发给当前连接数最小的服务器，其通过每个真实服务器当前连接数进行统计判断</td>
</tr>
<tr>
<td align="left">加权最小连接调度</td>
<td align="left">Weight Least Connec-tions</td>
<td align="left">wlc</td>
<td align="left">按照配置的权重，将新请求分发给当前连接数最小的服务器</td>
</tr>
<tr>
<td align="left">最短延迟调度</td>
<td align="left">Shortest Expected Delay</td>
<td align="left">sed</td>
<td align="left">该算法在 WLC 算法的基础上增加了基于活动连接的筛选算法，并把请求分发给算法值最小的真实服务器，该算法避免了 WLC 算法中权重小的空闲服务器无法被分发到连接的情况</td>
</tr>
<tr>
<td align="left">最少队列调度</td>
<td align="left">Never Queue</td>
<td align="left">nq</td>
<td align="left">若有真实服务器的连接数为空，直接分发请求给该真实服务器，如果所有服务器都处于有连接状态，则使用 SED 算法进行调度</td>
</tr>
<tr>
<td align="left">基于局部的最少连接</td>
<td align="left">Locality-Based Least Connections</td>
<td align="left">lblc</td>
<td align="left">该算法将目标地址相同的请求尽可能地分发到上次被分发的真实服务器，真实服务器若超载或不可用则使用最少连接算法进行分发。该方法常用在真实服务器为缓存服务器时，以提高缓存的命中率</td>
</tr>
<tr>
<td align="left">带复制的基于局部性的最少连接</td>
<td align="left">Locality-Based Least Connections with Replication</td>
<td align="left">lblcr</td>
<td align="left">该算法维护一组被分发相同目标地址请求的真实服务器列表，按照最小连接算法创建和添加组成员，并在一定条件下将组内最繁忙的成员移除。目标地址相同的请求将被分发到该组列表中最少连接的成员。该方法常用在真实服务器为缓存服务器时，以提高缓存的命中率</td>
</tr>
</tbody></table>
<h4 id="IPVS的管理器ipvsadm"><a href="#IPVS的管理器ipvsadm" class="headerlink" title="IPVS的管理器ipvsadm"></a>IPVS的管理器ipvsadm</h4><p>ipvsadm 1.2.1 版本命令的常用场景分为虚拟服务管理和真实服务器管理两类。</p>
<ul>
<li><strong>虚拟服务管理</strong></li>
</ul>
<p>在 LVS 配置管理中，每个 VIP 与端口组成一个虚拟服务。虚拟服务管理命令参数格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -A [-t|u|f] [vip_addr:port] [-s:负载算法]</span><br></pre></td></tr></table></figure>

<p>虚拟服务管理命令参数如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">参数选项</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-A</td>
<td align="left"></td>
<td align="left">添加虚拟服务，为虚拟服务绑定 VIP 地址及端口</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-t</td>
<td align="left">虚拟服务协议为 TCP 协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-u</td>
<td align="left">虚拟服务协议为 UDP 协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-s</td>
<td align="left">虚拟服务负载均衡算法</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-p</td>
<td align="left">虚拟服务负载均衡保持连接的超时时间，默认超时时间为 360s。LVS 会把同一个客户端的请求信息记录到 LVS 的 hash 表里，该参数设置了记录的保存时间，设定时间内的客户端连接会被转发到同一真实服务器</td>
</tr>
<tr>
<td align="left">-D</td>
<td align="left"></td>
<td align="left">删除虚拟服务记录</td>
</tr>
<tr>
<td align="left">-E</td>
<td align="left"></td>
<td align="left">修改虚拟服务记录</td>
</tr>
<tr>
<td align="left">-С</td>
<td align="left"></td>
<td align="left">清空所有虚拟服务记录</td>
</tr>
</tbody></table>
<p>命令样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加虚拟服务，VIP地址为192.168.2.100:80，协议为TCP，负载均衡算法为轮询算法（rr），启用保持</span></span><br><span class="line"><span class="comment"># 连接支持，默认超时时间为300s</span></span><br><span class="line">ipvsadm -A -t 192.168.2.100:80 -s rr -p</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>真实服务器管理</strong></li>
</ul>
<p>真实服务器管理命令参数格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -a [-t|u|f] [vip_addr:port] [-r ip_addr] [-g|i|m] [-w指定权重]</span><br></pre></td></tr></table></figure>

<p>真实服务器管理命令参数如下图所示。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">参数选项</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-a</td>
<td align="left"></td>
<td align="left">添加真实服务器</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-t</td>
<td align="left">与真实服务器用 TCP 协议建立连接</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-u</td>
<td align="left">与真实服务器用 UDP 协议建立连接</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-r</td>
<td align="left">真服务器 IP</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-g</td>
<td align="left">与真实服务器的转发模式为 DR 模式</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-i</td>
<td align="left">与真实服务器的转发模式为 TUN 模式</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-m</td>
<td align="left">与真实服务器的转发模式为 NAT 模式</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">-w</td>
<td align="left">指定真实服务器的权重</td>
</tr>
<tr>
<td align="left">-d</td>
<td align="left"></td>
<td align="left">删除真实服务器记录</td>
</tr>
<tr>
<td align="left">-e</td>
<td align="left"></td>
<td align="left">修改真实服务器记录</td>
</tr>
</tbody></table>
<p>命令样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在虚拟服务192.168.2.100:80中添加真实服务器192.168.10.3:80，转发模式为NAT模式</span></span><br><span class="line">ipvsadm -a -t 192.168.2.100:80 -r 192.168.10.3:80 -m</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>其他常用命令参数</strong></li>
</ul>
<p>其他常用命令参数格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看IPVS配置</span></span><br><span class="line">ipvsadm -<span class="built_in">ln</span></span><br></pre></td></tr></table></figure>

<p>更多命令参数可以通过 man 命令查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ipvsadm</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Keepalived配置简述"><a href="#Keepalived配置简述" class="headerlink" title="Keepalived配置简述"></a>Keepalived配置简述</h3><p>Keepalived 是一款用C语言编写的开源路由软件，目前仍处于活跃开发的状态，其主要目标是基于 Linux 系统提供一款配置简单且功能强大的负载均衡和高可用的软件应用。负载均衡是基于 LVS（IPVS）实现的，Keepalived 在 LVS 的基础上增加了多种主动健康检测机制，可以根据后端真实服务器的运行状态，自动对虚拟服务器负载的真实服务器进行维护和管理。</p>
<p>高可用性是通过虚拟冗余路由协议（Virtual Reduntant Routing Protocol，VRRP）实现的。VRRP 是工作在网络层的一种路由容错协议，通过组播的通告机制进行网络路由快速转移，以实现网络设备的高可用。</p>
<h4 id="Keepalived相关术语"><a href="#Keepalived相关术语" class="headerlink" title="Keepalived相关术语"></a>Keepalived相关术语</h4><ul>
<li>虚拟 IP（VIP）:对外提供用户访问的 IP 地址，与 LVS 的 VIP 概念相同；</li>
<li>真实服务器（Real Server）:被负载的后端服务器；</li>
<li>服务器池（Server Pool）:同一虚拟 IP 及端口的一组真实服务器；</li>
<li>虚拟服务器（Virtual Server）:服务器池的外部访问点，每个虚拟 IP 和端口组成一个虚拟服务器；</li>
<li>虚拟服务（Virtual Service）:与 VIP 关联的 TCP&#x2F;UDP 服务；</li>
<li>VRRP:Keepalived 实现高可用的虚拟路由器冗余协议；</li>
<li>VRRP 路由器（VRRP Router）:运行 VRRP 协议的路由器设备；</li>
<li>虚拟路由器（Virtual Router）:一个抽象对象，一组具有相同 VRID（虚拟路由器标识符）的多个 VRRP 路由器集合；</li>
<li>MASTER 状态:主路由状态，是 VIP 地址的拥有者，负责转发到达虚拟路由的三层数据包，负责对虚拟 IP 地址的 ARP 请求进行响应；</li>
<li>BACKUP 状态:备份路由状态，当主路由状态设备故障时，负责接管数据包转发及ARP请求响应。</li>
</ul>
<h4 id="Keepalived的工作模式"><a href="#Keepalived的工作模式" class="headerlink" title="Keepalived的工作模式"></a>Keepalived的工作模式</h4><p>Keepalived 为 LVS 提供了文件形式的配置方式，并为真实服务器提供了多种主动健康检测机制，通过 VRRP 协议为 LVS 提供了高可用的负载集群解决方案。Keepalived 的工作模式如下图所示。</p>
<ul>
<li>处于 MASTER 状态的 Keepalived 主机是 VIP 的拥有者，负责上层路由 VIP 的 ARP 查询响应和数据包转发；</li>
<li>处于 MASTER 状态的 Keepalived 主机通过 VRRP 协议在局域网内组播 VRRP 通告信息；</li>
<li>处于 MASTER 状态的 Keepalived 主机通过配置的健康检测机制主动检查服务器池中真实服务器的状态；</li>
<li>处于 BACKUP 状态的 Keepalived 主机接收 VRRP 通告信息，并根据通告信息判断本机状态是否变更；</li>
<li>当处于 MASTER 状态的路由发生故障时，处于 BACKUP 状态的路由确认主路由状态的 VRRP 通告超时时，则改变自身状态为 MASTER 状态，负责上层路由 IP 地址的 ARP 请求响应，并对外组播 VRRP 通告。</li>
</ul>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9160411W7.gif" alt="Keepalived 的工作模式示意图"><br>图:Keepalived 的工作模式示意图</p>
<h4 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h4><p>Keepalived 设计了多种主动健康检测机制，每个健康检测机制都注册在全局调度框架中，通过检测真实服务器的运行状态，自动对服务池中的真实服务器进行维护和管理。常用的健康检测机制有以下 4 种。</p>
<ul>
<li>TCP 检测。通过非阻塞式 TCP 连接超时检查机制检查真实服务器的状态，当真实服务器不响应请求或响应超时时，则确认为检测失败，并将该真实服务器从服务池中移除。</li>
<li>HTTP 检测。通过 HTTP GET 方法访问指定的 URL 并对返回结果进行 MD5 算法求值，如果与配置文件中的预设值不匹配，则确认为检测失败，并将该真实服务器从服务池中移除。该机制支持同一服务器的多 URL 获取检测。</li>
<li>SSL 检测。对 HTTP 检测增加了 SSL 支持。</li>
<li>自定义脚本。允许用户自定义检测脚本进行检测判断，支持脚本外部传递参数，执行的结果必须是 0 或 1。0 表示检测成功，1 表示检测失败。</li>
</ul>
<h4 id="配置关键字"><a href="#配置关键字" class="headerlink" title="配置关键字"></a>配置关键字</h4><p>Keepalived 配置文件可以分为 3 个部分，分别为全局配置、VRRP 配置和虚拟服务配置。各部分的常用配置关键字及其功能如下。</p>
<ul>
<li><strong>全局配置</strong></li>
</ul>
<p>Keepalived 全局配置关键字实现邮件告警的 SMTP 配置及自身 VRRP 路由相关的全局配置，配置关键字如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">配置关键字</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">global_defs</td>
<td align="left">全局配置区域标识</td>
</tr>
<tr>
<td align="left">notification_email</td>
<td align="left">设置接收告警邮件的地址列表</td>
</tr>
<tr>
<td align="left">notification_email_from</td>
<td align="left">设置发送邮件的地址列表</td>
</tr>
<tr>
<td align="left">smtp_server</td>
<td align="left">设置用于发送邮件的 SMTP 服务器地址</td>
</tr>
<tr>
<td align="left">smtp_connection_timeout</td>
<td align="left">设置 SMTP 服务器连接超时时间</td>
</tr>
<tr>
<td align="left">router_id</td>
<td align="left">设置当前设备的路由 ID，每个设备均不相同</td>
</tr>
<tr>
<td align="left">vrrp_version</td>
<td align="left">VRRP 协议版本</td>
</tr>
<tr>
<td align="left">nopreempt</td>
<td align="left">是否启用非抢占模式，即不参与 MASTER 的选举，默认为抢占模式</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">global_defs&#123;</span><br><span class="line">    notification_email &#123;</span><br><span class="line">        monitor@nginxbar.org        <span class="comment"># 接收邮件的邮箱为monitor@nginxbar.org</span></span><br><span class="line">    &#125;</span><br><span class="line">    smtp_server smtp.nginxbar.org   <span class="comment"># SMTP服务器地址为smtp.nginxbar.org</span></span><br><span class="line">    smtp_connect_timeout 30         <span class="comment"># SMTP服务器连接超时时间为30秒</span></span><br><span class="line">    router_id LVS_Nginx1            <span class="comment"># 当前设备路由ID为LVS_Nginx1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>VRRP配置</strong></li>
</ul>
<p>Keepalived 的 VRRP 配置关键字用于创建 VRRP 路由器，并为其配置运行参数。配置文件中可以创建多个不同名称的 VRRP 路由器实例，每个 VRRP 路由器实例都需要通过设定虚拟路由 ID 加入虚拟路由器中。VRRP 路由器接收组播的 VRRP 通告，并根据 VRRP 通告切换自身状态。当切换状态时会触发配置中对应状态的 shell 脚本，并根据配置参数判断是否发送告警邮件。VRRP 配置关键字如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">配置关键字</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">vrrp_instance</td>
<td align="left">VRRP 实例配置区域标识</td>
</tr>
<tr>
<td align="left">state</td>
<td align="left">设置当前 VRRP 路由的初始状态</td>
</tr>
<tr>
<td align="left">interface</td>
<td align="left">设置 VRRP 绑定的设备网络接口</td>
</tr>
<tr>
<td align="left">virtual_router_id</td>
<td align="left">设置当前设备所属的虚拟路由 ID</td>
</tr>
<tr>
<td align="left">priority</td>
<td align="left">设置当前 VRRP 路由的初始优先级，优先级最高的会被选举为 MASTER，优先级取值范围为 1~254</td>
</tr>
<tr>
<td align="left">advert_int</td>
<td align="left">发送组播包的间隔时间，默认为 1 秒</td>
</tr>
<tr>
<td align="left">nopreempt</td>
<td align="left">是否启用非抢占模式，即不参与 MASTER 的选举，默认为抢占模式</td>
</tr>
<tr>
<td align="left">preempt_delay</td>
<td align="left">设置抢占延时，取值范围为 0~1000，默认为 0，单位为秒。即等待多少秒才参与 MASTER 选举</td>
</tr>
<tr>
<td align="left">authentication</td>
<td align="left">VRRP 通信认证配置区域标识</td>
</tr>
<tr>
<td align="left">auth_type</td>
<td align="left">指定 VRRP 通信的认证类型，有 PASS 简单密码认证和 AH:IPSEC 认证两种类型</td>
</tr>
<tr>
<td align="left">auth_pass</td>
<td align="left">指定 VRRP 通信密码字符串，最大为 8 位</td>
</tr>
<tr>
<td align="left">virtual_ipaddress</td>
<td align="left">VIP 地址配置区域标识</td>
</tr>
<tr>
<td align="left">notify_master</td>
<td align="left">指定一个转换为 MASTER 状态后执行的 shell 脚本</td>
</tr>
<tr>
<td align="left">notify_backup</td>
<td align="left">指定一个转换为 BACKUP 状态后执行的 shell 脚本</td>
</tr>
<tr>
<td align="left">notify_fault</td>
<td align="left">指定一个转换为 FAULT 状态后执行的 shell 脚本</td>
</tr>
<tr>
<td align="left">smtp_alert</td>
<td align="left">使用 SMTP 的配置发送邮件告警通知</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER            <span class="comment"># 初始路由状态为MASTER</span></span><br><span class="line">    interface eth0          <span class="comment"># VRRP绑定接口为eth0</span></span><br><span class="line">    virtual_router_id 51    <span class="comment"># 虚拟路由器的VRID为51</span></span><br><span class="line">    priority 100            <span class="comment"># 当前设备的优先级是100</span></span><br><span class="line">    nopreempt               <span class="comment"># 不参与MASTER的选举</span></span><br><span class="line">    advert_int 5            <span class="comment"># VRRP组播的间隔时间是5秒</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS      <span class="comment"># 认证类型为PASS</span></span><br><span class="line">        auth_pass 2222      <span class="comment"># 认证密码为2222</span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.2.155       <span class="comment"># 虚拟服务器的VIP是192.168.2.155</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>VRRP 本身是通过 VRRP 通告机制实现路由器状态切换判断的，但在实际的应用场景中会存在因网络抖动等原因影响 VRRP 的通告传递的情况，为提高状态切换的准确性，Keepalived 还提供了一种脚本检测机制，可以让用户通过自定义脚本更精准地进行路由状态切换。相关配置关键字如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">配置关键字</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">vrrp_script</td>
<td align="left">VRRP 脚本配置区域标识</td>
</tr>
<tr>
<td align="left">scrip</td>
<td align="left">指定要执行的脚本路径</td>
</tr>
<tr>
<td align="left">weight</td>
<td align="left">用于调整 VRRP 路由器优先级的权重值，如果脚本执行成功且 weight 为正时，则优先级增力相应值；如果脚本执行失败且 weight 为负，则优先级减少相应值。优先级的取值范围为 1~254</td>
</tr>
<tr>
<td align="left">interval</td>
<td align="left">设置检测脚本的执行间隔。单位是 s。默认为 1s</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">脚本执行返回结果超时时间，超过指定时间则认为检测失败</td>
</tr>
<tr>
<td align="left">rise</td>
<td align="left">连续检测成功次数为设定值时才确认为成功状态</td>
</tr>
<tr>
<td align="left">fall</td>
<td align="left">连续检测失败次数为设定值时才确认为失败状态</td>
</tr>
<tr>
<td align="left">init_fail</td>
<td align="left">设置脚本初始检测状态为失败状态</td>
</tr>
</tbody></table>
<p>Keepalived 通过 VRRP 通告判断虚拟路由器中其他 VRRP 路由状态并确保路由的转移，对于业务层的高可用，则需要用户单独对应用进程进行同步检测。例如，Nginx 与 Keepalived 部署在同一台设备上，可以通过脚本检测 Nginx 进程的状态，如果 Nginx 检测失败并无法自动恢复，则降低 VRRP 的优先级。要尽量避免在切换为 MASTER 状态时，因自身业务层故障导致业务高可用切换失败。也可用多个脚本组合实现 VRRP 路由优先级的动态调整。配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vrrp_script checknginx &#123;</span><br><span class="line">    script <span class="string">&quot;/opt/data/scripts/checknginx.sh&quot;</span></span><br><span class="line">    interval 3      <span class="comment"># 检测脚本执行时间间隔</span></span><br><span class="line">    weight -20      <span class="comment"># 当检测失败时，VRRP路由优先级降低20</span></span><br><span class="line">    rise 3          <span class="comment"># 连续监测3次成功才确认为成功</span></span><br><span class="line">    fall 3          <span class="comment"># 连续监测3次失败才确认为失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测脚本内容如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 检测脚本查询Nginx进程是否存在，若存在则返回0，若检测失败则返回1</span></span><br><span class="line">check = `ps aux | grep -v grep | grep nginx | <span class="built_in">wc</span> -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$check</span> &gt; 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    systemctl start nginx</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>虚拟服务器配置</strong></li>
</ul>
<p>Keepalived 的虚拟服务器是负载均衡的外部访问点，通过配置关键字实现对 LVS 运行参数的配置，配置文件中可以为 VIP 绑定不同的端口创建多个虚拟服务器。虚拟服务器配置关键字如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">配置关键字</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">virtual_server</td>
<td align="left">虚拟服务器配置区域标识</td>
</tr>
<tr>
<td align="left">delay_loop</td>
<td align="left">设置健康检测的间隔时间</td>
</tr>
<tr>
<td align="left">lb_algo</td>
<td align="left">LVS 调度算法</td>
</tr>
<tr>
<td align="left">lb_kind</td>
<td align="left">LVS 转模式（NAT、DR、TUN）</td>
</tr>
<tr>
<td align="left">persistence_timeout</td>
<td align="left">设置保持连接的超时时间，在设定时间内会把同一个客户端的连接全部转发给同一真实服务器</td>
</tr>
<tr>
<td align="left">persistence_granularity</td>
<td align="left">对启用保持连接的客户端 IP 进行掩码调整，当 IP 为 255.255.255.255 时，则仅限这个 IP 的客户端；当 IP 为 255.255.255.0 时，则为这个客户端所在子网网段内 IP 的所有客户端</td>
</tr>
<tr>
<td align="left">virtualhost</td>
<td align="left">为 HTTP_GET 或 SSL_GET 设置执行要检测的虚拟主机</td>
</tr>
<tr>
<td align="left">protocol</td>
<td align="left">转发协议类型（TCP、UDP、SCTP）</td>
</tr>
<tr>
<td align="left">sorry_server</td>
<td align="left">设置一个服务池中所有真实服务器都无法访问时的备用服务器</td>
</tr>
</tbody></table>
<p>真实服务器相关关键字如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">配置关键字</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">real_server</td>
<td align="left">配置真实服务器 IP 及端口</td>
</tr>
<tr>
<td align="left">weight</td>
<td align="left">设置真实服务器的权重，默认为 1</td>
</tr>
<tr>
<td align="left">inhibit_on_failure</td>
<td align="left">当健康检测失败时，将当前服务器权重设置为 0，而不将其从服务器池中移除</td>
</tr>
<tr>
<td align="left">notify_up</td>
<td align="left">当前服务器健康检查成功时执行的脚本</td>
</tr>
<tr>
<td align="left">notify_down</td>
<td align="left">当前服务器健康检查失败时执行的脚本</td>
</tr>
<tr>
<td align="left">uthreshold</td>
<td align="left">当前服务器的最大连接数</td>
</tr>
<tr>
<td align="left">lthreshold</td>
<td align="left">当前服务器的最小连接数</td>
</tr>
<tr>
<td align="left">TCP_CHECK</td>
<td align="left">TCP 检测设置区域标识</td>
</tr>
<tr>
<td align="left">MISC_CHECK</td>
<td align="left">自定义检测脚本设置区域标识</td>
</tr>
<tr>
<td align="left">HTTP_GET</td>
<td align="left">HTTP 检测设置区域标识</td>
</tr>
<tr>
<td align="left">SSL_GET</td>
<td align="left">SSL HTTP 检测设置区域标识</td>
</tr>
</tbody></table>
<p>通过 Keepalived 为真实服务器配置关键字不仅可以实现 LVS 真实服务器的运行参数配置，还可以对自身增加的真实服务器的主动健康检测进行配置。真实服务器健康检测配置关键字如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">配置关键字</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">url</td>
<td align="left">HTTP_GET 和 SSL_GET 的 URL 检测标识</td>
</tr>
<tr>
<td align="left">path</td>
<td align="left">HTTP_GET 和 SSL_GET 的 URL 检测路径</td>
</tr>
<tr>
<td align="left">digest</td>
<td align="left">HTTP_GET 和 SSL_GET 的返回结果的 MD5 计算值</td>
</tr>
<tr>
<td align="left">status_code</td>
<td align="left">HTTP_GET 和 SSL_GET 的健康检测返回状态码</td>
</tr>
<tr>
<td align="left">connect_ip</td>
<td align="left">检测的 IP 地址，默认为真实服务器的 IP 地址</td>
</tr>
<tr>
<td align="left">connect_port</td>
<td align="left">检测的端口，默认为真实服务器的端口</td>
</tr>
<tr>
<td align="left">bindto</td>
<td align="left">发起检测连接的接口地址，默认为本地 IP 地址</td>
</tr>
<tr>
<td align="left">bind_port</td>
<td align="left">发起检测连接的源端口，默认为随机端口</td>
</tr>
<tr>
<td align="left">connect_timeout</td>
<td align="left">检测连接的超时时间，默认为 5s</td>
</tr>
<tr>
<td align="left">fwmark</td>
<td align="left">使用 fwmark 对所有发出去的检查数据包进行标记</td>
</tr>
<tr>
<td align="left">warmup</td>
<td align="left">指定一个随机延迟时间用于防止网络阻塞，如果为 0，则表示关闭该功能</td>
</tr>
<tr>
<td align="left">nb_get_retry</td>
<td align="left">GET 尝试次数，仅 HTTP_GET 和 SSL_GET 有效</td>
</tr>
<tr>
<td align="left">retry</td>
<td align="left">重试次数，默认是 1 次，仅 TCP_CHECK 有效</td>
</tr>
<tr>
<td align="left">delay_before_retry</td>
<td align="left">设置在重试之前延迟的秒数</td>
</tr>
</tbody></table>
<p>配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">virtual_server 192.168.2.155 80 &#123;           <span class="comment"># 虚拟服务器IP及端口</span></span><br><span class="line">    delay_loop 6                            <span class="comment"># 健康检测间隔时间为6s</span></span><br><span class="line">    lb_algo wrr                             <span class="comment"># 负载均衡调度算法为加权轮询</span></span><br><span class="line">    lb_kind DR                              <span class="comment"># 转发模式为DR</span></span><br><span class="line">    persistence_timeout 60                  <span class="comment"># 保持连接的超时时间为60s</span></span><br><span class="line">    protocol TCP                            <span class="comment"># 负载均衡转发协议为TCP</span></span><br><span class="line">    real_server 192.168.2.109 80 &#123;                  <span class="comment"># 真实服务器IP及端口</span></span><br><span class="line">        weight 100                                  <span class="comment"># 真实服务器权重为100</span></span><br><span class="line">        notify_down /etc/keepalived/scripts/stop.sh <span class="comment"># 当真实服务器健康检测失败时执</span></span><br><span class="line">                                                                <span class="comment"># 行stop.sh脚本</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">                path <span class="string">&quot;/healthcheck&quot;</span>                         <span class="comment"># 指定要检查的URL的路径</span></span><br><span class="line">                digest bfaa324fdd71444e43eca3b7a1679a1a     <span class="comment"># 检测URL返回值的MD5计算值</span></span><br><span class="line">                status_code 200                             <span class="comment"># 健康检测返回状态码</span></span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 10                      <span class="comment"># 连接超时时间为10s</span></span><br><span class="line">            nb_get_retry 3                          <span class="comment"># 重试3次确认失败</span></span><br><span class="line">            delay_before_retry 3                    <span class="comment"># 失败重试的时间间隔为3s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># digest值的计算方法</span></span><br><span class="line">genhash -s 192.168.2.109 -p 80 -u /healthcheck</span><br></pre></td></tr></table></figure>

<p>Keepalived 的其他配置关键字此处并未列出，更多配置关键字可以通过 man 命令获取。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man keepalived.conf</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="集群负载（基于LVS和Keepalived）搭建"><a href="#集群负载（基于LVS和Keepalived）搭建" class="headerlink" title="集群负载（基于LVS和Keepalived）搭建"></a>集群负载（基于LVS和Keepalived）搭建</h3><p>基于 LVS 和 Keepalived 的 Nginx 集群负载是使用 LVS 做传输层的负载均衡设备，将客户端请求从传输层负载到后端的多组 Nginx 集群，并由 Nginx 集群实现应用层负载均衡处理的多层负载均衡网络架构。Keepalived 通过文件配置的方式实现 LVS 的运行管理，并通过 VRRP 机制实现传输层负载的高可用，为 Nginx 集群提供高性能、高可用的负载应用。</p>
<p>Nginx 集群负载部署图如下图所示。</p>
<ul>
<li>LVS 作为传输层负载均衡与接入路由对接，负责把数据包转发给后端的 Nginx 服务器。</li>
<li>LVS 选用 DR 转发模式，网络数据包在传输层被分发到 Nginx 服务器，并由 Nginx 经过本地路由返回给客户端。</li>
<li>LVS 对后端 Nginx 服务器集群选用加权轮询（wrr）的负载均衡调度策略。</li>
<li>Keepalived 通过 VRRP 协议组播通告状态信息，确保两台 LVS 服务器的高可用。</li>
<li>当处于 MASTER 状态的 Keepalived 发生故障时，处于 BACKUP 状态的 Keepalived 切换为 MASTER 状态，负责与接入路由对接，把数据包转发给后端的 Nginx 服务器。</li>
<li>Keepalived 通过健康检测机制检测 Nginx 集群内每台 Nginx 服务器的健康状态。</li>
<li>Nginx 负责应用层负载均衡，完成客户端请求的负载、路由分流、过滤等操作。</li>
</ul>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z9163540624.gif" alt="Nginx 集群负载部署图"></p>
<ul>
<li><strong>Keepalived安装</strong></li>
</ul>
<p>Keepalived 在 CentOS 7 系统下使用 yum 安装即可。在 CentOS 7 系统下，LVS 已被集成到内核中，无须单独安装。</p>
<p>yum -y install keepalived</p>
<p>systemctl enable keepalived</p>
<ul>
<li><strong>Keepalived配置</strong></li>
</ul>
<p>Keepalived 需要分别在两台 LVS 服务器上进行配置，主服务器上的 Keepalived 配置如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">    notification_email &#123;</span><br><span class="line">      monitor@nginxbar.org                          <span class="comment"># 发生故障时发送邮件告警通知的邮箱</span></span><br><span class="line">    &#125;</span><br><span class="line">    notification_email_from admin@nginxbar.org      <span class="comment"># 使用哪个邮箱发送</span></span><br><span class="line">    smtp_server mail.nginxbar.org                   <span class="comment"># 发件服务器</span></span><br><span class="line">    smtp_connect_timeout 30</span><br><span class="line">    router_id LVS_01                                <span class="comment"># 当前设备路由ID为LVS_01</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER                                    <span class="comment"># 初始路由状态为MASTER</span></span><br><span class="line">    interface eth0                                  <span class="comment"># VRRP绑定的本地网卡接口为eth0</span></span><br><span class="line">    virtual_router_id 51                            <span class="comment"># 虚拟路由器的VRID为51</span></span><br><span class="line">    priority 100                                    <span class="comment"># 当前设备的优先级是100</span></span><br><span class="line">    advert_int 5                                    <span class="comment"># VRRP组播的间隔时间是5s</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS                                      <span class="comment"># 认证类型为PASS</span></span><br><span class="line">        auth_pass 2222                                      <span class="comment"># 认证密码为2222</span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.21.155                                      <span class="comment"># 虚拟服务器的VIP是192.168.21.155</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.21.155 80 &#123;                      <span class="comment"># 虚拟服务器IP及端口</span></span><br><span class="line">    delay_loop 6                                            <span class="comment"># 健康检测间隔时间为6s</span></span><br><span class="line">    lb_algo wrr                                             <span class="comment"># 负载均衡调度算法为加权轮询</span></span><br><span class="line">    lb_kind DR                                              <span class="comment"># 转发模式为DR</span></span><br><span class="line">    persistence_timeout 60                                  <span class="comment"># 保持连接的超时时间为60s</span></span><br><span class="line">    protocol TCP                                            <span class="comment"># 负载均衡转发协议为TCP</span></span><br><span class="line">    real_server 192.168.2.108 80 &#123;                          <span class="comment"># 真实服务器IP及端口</span></span><br><span class="line">        weight 100                                          <span class="comment"># 真实服务器权重为100</span></span><br><span class="line">        notify_down /etc/keepalived/scripts/stop.sh         <span class="comment"># 当真实服务器健康检测失败时执</span></span><br><span class="line">                                                                <span class="comment"># 行stop.sh脚本</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">                path <span class="string">&quot;/healthcheck&quot;</span>                         <span class="comment"># 指定要检查的URL的路径</span></span><br><span class="line">                digest bfaa324fdd71444e43eca3b7a1679a1a     <span class="comment"># 检测URL返回值的MD5计算值</span></span><br><span class="line">                status_code 200                             <span class="comment"># 健康检测返回状态码</span></span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 10                      <span class="comment"># 连接超时时间为10s</span></span><br><span class="line">            nb_get_retry 3                          <span class="comment"># 重试3次确认失败</span></span><br><span class="line">            delay_before_retry 3                    <span class="comment"># 失败重试的时间间隔为3s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.2.109 80 &#123;                  <span class="comment"># 真实服务器IP及端口</span></span><br><span class="line">        weight 100                                  <span class="comment"># 真实服务器权重为100</span></span><br><span class="line">        notify_down /etc/keepalived/scripts/stop.sh <span class="comment"># 当真实服务器健康检测失败时执</span></span><br><span class="line">                                                                <span class="comment"># 行stop.sh脚本</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">                path <span class="string">&quot;/healthcheck&quot;</span>                         <span class="comment"># 指定要检查的URL的路径</span></span><br><span class="line">                digest bfaa324fdd71444e43eca3b7a1679a1a     <span class="comment"># 检测URL返回值的MD5计算值</span></span><br><span class="line">                status_code 200                             <span class="comment"># 健康检测返回状态码</span></span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 10                              <span class="comment"># 连接超时时间为10s</span></span><br><span class="line">            nb_get_retry 3                          <span class="comment"># 重试3次确认失败</span></span><br><span class="line">            delay_before_retry 3                    <span class="comment"># 失败重试的时间间隔为3s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备份服务器上的 Keepalived 配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File <span class="keyword">for</span> keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">    notification_email &#123;</span><br><span class="line">      monitor@nginxbar.org                          <span class="comment"># 发生故障时发送邮件告警通知</span></span><br><span class="line">                                                                <span class="comment"># 的邮箱</span></span><br><span class="line">    &#125;</span><br><span class="line">    notification_email_from admin@nginxbar.org              <span class="comment"># 使用哪个邮箱发送</span></span><br><span class="line">    smtp_server mail.nginxbar.org                   <span class="comment"># 发件服务器</span></span><br><span class="line">    smtp_connect_timeout 30</span><br><span class="line">    router_id LVS_02                                <span class="comment"># 当前设备路由ID为LVS_02，此</span></span><br><span class="line">                                                                <span class="comment"># 处与主服务器配置不同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP                                    <span class="comment"># 初始路由状态为BACKUP，此处</span></span><br><span class="line">                                                                <span class="comment"># 与主服务器配置不同</span></span><br><span class="line">    interface eth0                                  <span class="comment"># VRRP绑定的本地网卡接口为eth0</span></span><br><span class="line">    virtual_router_id 51                            <span class="comment"># 虚拟路由器的VRID为51</span></span><br><span class="line">    priority 99                                     <span class="comment"># 当前设备的优先级是99，此处</span></span><br><span class="line">                                                                <span class="comment"># 与主服务器配置不同</span></span><br><span class="line">    advert_int 5                                    <span class="comment"># VRRP组播的间隔时间是5s</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS                                      <span class="comment"># 认证类型为PASS</span></span><br><span class="line">        auth_pass 2222                                      <span class="comment"># 认证密码为2222</span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.21.155                              <span class="comment"># 虚拟服务器的VIP是192.168.21.155</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.21.155 80 &#123;                      <span class="comment"># 虚拟服务器IP及端口</span></span><br><span class="line">    delay_loop 6                                            <span class="comment"># 健康检测间隔时间为6s</span></span><br><span class="line">    lb_algo wrr                                             <span class="comment"># 负载均衡调度算法为加权轮询</span></span><br><span class="line">    lb_kind DR                                              <span class="comment"># 转发模式为DR</span></span><br><span class="line">    persistence_timeout 60                                  <span class="comment"># 保持连接的超时时间为60s</span></span><br><span class="line">    protocol TCP                                            <span class="comment"># 负载均衡转发协议为TCP</span></span><br><span class="line">    real_server 192.168.2.108 80 &#123;                          <span class="comment"># 真实服务器IP及端口</span></span><br><span class="line">        weight 100                                  <span class="comment"># 真实服务器权重为100</span></span><br><span class="line">        notify_down /etc/keepalived/scripts/stop.sh <span class="comment"># 当真实服务器健康检测失败时执</span></span><br><span class="line">                                                                <span class="comment"># 行stop.sh脚本</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">                path <span class="string">&quot;/healthcheck&quot;</span>                         <span class="comment"># 指定要检查的URL的路径</span></span><br><span class="line">                digest bfaa324fdd71444e43eca3b7a1679a1a     <span class="comment"># 检测URL返回值的MD5计算值</span></span><br><span class="line">                status_code 200                             <span class="comment"># 健康检测返回状态码</span></span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 10                              <span class="comment"># 连接超时时间为10s</span></span><br><span class="line">            nb_get_retry 3                                  <span class="comment"># 重试3次确认失败</span></span><br><span class="line">            delay_before_retry 3                            <span class="comment"># 失败重试的时间间隔为3s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.2.109 80 &#123;                          <span class="comment"># 真实服务器IP及端口</span></span><br><span class="line">        weight 100                                          <span class="comment"># 真实服务器权重为100</span></span><br><span class="line">        notify_down /etc/keepalived/scripts/stop.sh <span class="comment"># 当真实服务器健康检测失败时执</span></span><br><span class="line">                                                                <span class="comment"># 行stop.sh脚本</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123;</span><br><span class="line">                path <span class="string">&quot;/healthcheck&quot;</span>                         <span class="comment"># 指定要检查的URL的路径</span></span><br><span class="line">                digest bfaa324fdd71444e43eca3b7a1679a1a     <span class="comment"># 检测URL返回值的MD5计算值</span></span><br><span class="line">                status_code 200                             <span class="comment"># 健康检测返回状态码</span></span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 10                              <span class="comment"># 连接超时时间为10s</span></span><br><span class="line">            nb_get_retry 3                                  <span class="comment"># 重试3次确认失败</span></span><br><span class="line">            delay_before_retry 3                            <span class="comment"># 失败重试的时间间隔为3s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，高可用的 LVS 负载均衡就配置完成了。当主 LVS 服务器出现故障时，备份 LVS 服务器可以快速接管传输层网络数据的负载均衡工作，将数据包分发给后端的 Nginx 服务器集群。</p>
<hr>
<h3 id="集群配置管理规划"><a href="#集群配置管理规划" class="headerlink" title="集群配置管理规划"></a>集群配置管理规划</h3><p>Nginx 的配置是以文件形式存在的，配置指令会在启动时一次性加载并生效，采用这种方式除 upstream 的配置可动态变更（商业版本支持 API 变更，开源版本依赖第三方模块动态修改）外，其他配置的修改均需要重启或热加载 Nginx 进程才可生效。为实现便捷的 Nginx 配置变更管理，需要从以下几个方面进行规划。</p>
<h4 id="配置目录结构"><a href="#配置目录结构" class="headerlink" title="配置目录结构"></a>配置目录结构</h4><p>Nginx 默认所有配置文件均存放在其安装目录的 conf 目录下，为防止配置文件不方便阅读和管理，可以按照虚拟主机（具有独立主机名或网络端口）进行拆分，每个虚拟主机一个配置文件，并存放在统一的目录下。对功能固定、全局的配置指令以固定文件的形式存放在配置文件目录的根目录下。所有的配置文件都以 nginx.conf 为统一入口，并使用配置指令 include 按需引入。</p>
<p>Nginx 的目录结构规划样例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">conf/</span><br><span class="line"> ├── conf.d</span><br><span class="line"> │  ├── mysql_apps.ream</span><br><span class="line"> │  ├── www.nginxbar.com.conf</span><br><span class="line"> │  └── www.nginxbar.org.conf</span><br><span class="line"> ├── fastcgi.conf</span><br><span class="line"> ├── fastcgi_params</span><br><span class="line"> ├── fscgi.conf</span><br><span class="line"> ├── gzip.conf</span><br><span class="line"> ├── mime.types</span><br><span class="line"> ├── nginx.conf</span><br><span class="line"> ├── proxy.conf</span><br><span class="line"> ├── scgi_params</span><br><span class="line"> ├── ssl</span><br><span class="line"> │  ├── www_nginxbar_org.csr</span><br><span class="line"> │  ├── www_nginxbar_org.key</span><br><span class="line"> │  └── www_nginxbar_org.pem</span><br><span class="line"> └── uwsgi_params</span><br></pre></td></tr></table></figure>

<p>目录说明如下:</p>
<ul>
<li>conf.d 为自建目录，是存放虚拟主机配置文件的目录。</li>
<li>mysql_apps.ream 是自定义应用 apps 的 MySQL 集群代理配置文件。</li>
<li><a target="_blank" rel="noopener" href="http://www.nginxbar.com.conf/">www.nginxbar.com.conf</a> 是域名 <a target="_blank" rel="noopener" href="http://www.nginxbar.com/">www.nginxbar.com</a> (<a target="_blank" rel="noopener" href="http://www.nginxbar.com/">http://www.nginxbar.com</a>) 对应的虚拟主机配置文件。</li>
<li><a target="_blank" rel="noopener" href="http://www.nginxbar.org.conf/">www.nginxbar.org.conf</a> 是域名 <a target="_blank" rel="noopener" href="http://www.nginxbar.org/">www.nginxbar.org</a> (<a target="_blank" rel="noopener" href="http://www.nginxbar.org/">http://www.nginxbar.org</a>) 对应的虚拟主机配置文件。</li>
<li>fscgi.conf 是自定义 FastCGI 代理配置文件。</li>
<li>gzip.conf 是自定义响应数据 gzip 压缩配置指令文件。</li>
<li>proxy.conf 是自定义 HTTP 代理配置指令文件。</li>
<li>ssl 是自建目录，用于存放虚拟主机的 SSL 证书文件。</li>
</ul>
<p>nginx.conf 配置样例如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择加载动态模块</span></span><br><span class="line">load_module <span class="string">&quot;modules/ngx_http_geoip_module.so&quot;</span>;</span><br><span class="line">load_module <span class="string">&quot;modules/ngx_http_image_filter_module.so&quot;</span>;</span><br><span class="line">load_module <span class="string">&quot;modules/ngx_http_xslt_filter_module.so&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作进程及事件配置</span></span><br><span class="line">worker_processes auto;                  <span class="comment"># 启动与CPU核数一致的工作进程</span></span><br><span class="line">worker_priority -5;                     <span class="comment"># 工作进程在linux系统中的优先级为-5</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  65535;              <span class="comment"># 每个工作进程的最大连接数</span></span><br><span class="line">    multi_accept on;                        <span class="comment"># 每个工作进程每次都可以接收多个连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP/UDP代理配置</span></span><br><span class="line">stream &#123;</span><br><span class="line">    <span class="comment"># 配置TCP/UDP代理的日志格式模板，模板名为tcp</span></span><br><span class="line">    log_format  tcp  <span class="string">&#x27;$remote_addr - $connection - [$time_local] $server_addr:$server_port - $protocol&#x27;</span></span><br><span class="line">                      <span class="string">&#x27;- $status - $upstream_addr - $bytes_received - $bytes_sent - $session_time &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;- $proxy_protocol_addr:$proxy_protocol_port &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置TCP/UDP代理的错误日志输出位置，错误级别为error</span></span><br><span class="line">    error_log logs/tcp_error.log error;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 引入conf.d目录下所有后缀名为ream的配置文件</span></span><br><span class="line">    include conf.d/*.ream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP配置</span></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;               <span class="comment"># 引入MIME类型映射表文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置HTTP的错误日志输出位置，错误级别为error</span></span><br><span class="line">    error_log logs/error.log error;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置HTTP的日志格式，模板名为main</span></span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $connection - $remote_user [$time_local] &quot;$request&quot; - $upstream_addr &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status  - $body_bytes_sent - $request_time - &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; - &quot;$http_x_forwarded_for&quot; - &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置全局访问日志输出位置，并以模板main的日志格式输出</span></span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    charset  utf-8;                         <span class="comment"># 字符编码为utf-8</span></span><br><span class="line">    variables_hash_max_size 2048;           <span class="comment"># 变量哈希表最大值为2048B</span></span><br><span class="line">    variables_hash_bucket_size 128;         <span class="comment"># 变量哈希桶最大值为128B</span></span><br><span class="line">    server_names_hash_bucket_size 256;      <span class="comment"># 服务主机名哈希桶大小为256B</span></span><br><span class="line">    client_header_buffer_size 32k;          <span class="comment"># 请求头缓冲区大小为32KB</span></span><br><span class="line">    large_client_header_buffers 4 128k;     <span class="comment"># 最大缓存为4个128KB</span></span><br><span class="line">    client_max_body_size 20m;               <span class="comment"># 允许客户端请求的最大单个文件字节数为20MB</span></span><br><span class="line">    sendfile on;                            <span class="comment"># 开启零复制机制</span></span><br><span class="line">    tcp_nopush on;                          <span class="comment"># 启用在零复制时数据包最小传输的限制机制</span></span><br><span class="line">    tcp_nodelay on;                         <span class="comment"># 当处于保持连接状态时以最快的方式发送数据包</span></span><br><span class="line">    keepalive_timeout  60;                  <span class="comment"># 保持连接超时时间为60s</span></span><br><span class="line">    client_header_timeout 10;               <span class="comment"># 读取客户请求头的超时时间是10s</span></span><br><span class="line">    client_body_timeout 10;                 <span class="comment"># 请求体接收超时时间为10s</span></span><br><span class="line">    server_tokens on;                       <span class="comment"># 不显示Nginx版本信息</span></span><br><span class="line">    include gzip.conf;                      <span class="comment"># HTTP gzip的配置文件</span></span><br><span class="line">    include proxy.conf;                     <span class="comment"># HTTP代理配置</span></span><br><span class="line">    include conf.d/*.conf;                  <span class="comment"># 引入HTTP虚拟主机配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx.conf 中编辑在全局区域的配置指令均可按照 Nginx 配置指令规范在 server、location 指令域中被同名的配置指令覆盖。</p>
<h4 id="配置归档"><a href="#配置归档" class="headerlink" title="配置归档"></a>配置归档</h4><p>Nginx 作为负载均衡应用时，是业务应用的入口，Nginx 服务器的可用性决定了其所负责的所有被代理业务的可用性。所以 Nginx 进行配置变更时要及时做好归档和版本控制，因为 Nginx 配置是以文件方式存在的，所以可以将每次修改的文件以 Git 标签的方式在 Git 仓库中进行存档和版本控制。</p>
<h4 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h4><p>可以使用对应的配置模板进行 Nginx 配置内容的修改、配置部分的标准化及通用性约定，以便进行自动化操作。开源软件 Ansible 提供了自定义模板的功能，使用户可以按照预期设计更加严谨、规范地配置变更。Ansible 支持批量操作，可以快速完成多台 Nginx 服务器配置文件的同步和加载。</p>
<h4 id="配置发布"><a href="#配置发布" class="headerlink" title="配置发布"></a>配置发布</h4><p>Ansible 虽然提供了命令行的操作能力，但是用户权限、操作日志及快速回滚等操作仍不够便捷。Jenkins 是一款 Web 化的持续集成发布工具，被广泛应用于业务应用的发布，拥有超过 1000 个插件，用户无须额外开发就可快速完成代码从代码仓库到运行部署的整个流程，同时还支持用户权限、操作日志及快速回滚等操作。</p>
<p>根据上述 4 个方面的规划，通过 Jenkins 与 GitLab 及 Ansible 的配合使用，无须复杂编程就可以快速搭建一套 Web 化的 Nginx 配置管理系统。应用架构如下图所示。</p>
<p><img src="https://www.w3ccoo.com/wp-content/uploads/nginx/8-200Z91F25X32.gif" alt="应用架构图"></p>
<p>关于上图，有以下几点需要说明:</p>
<ul>
<li>Jenkins 通过 GitLab 获取 Git 仓库中的 Nginx 文件。</li>
<li>Ansible 根据 Jenkins Web 界面输入的参数与对应配置模板生成配置文件，更新本地的 Nginx 配置文件。</li>
<li>Ansible 将更新后的配置文件同步到 Nginx 集群的所有 Nginx 服务器，并对 Nginx 进程执行 reload 操作，以加载更新后的配置。</li>
<li>Jenkins 将更新后的 Nginx 配置文件以 Git 标签的方式进行归档。</li>
<li>用户可以通过 Jenkins 获取对应 Git 仓库的所有 Git 标签，并根据需求选择对应的 Git 标签代码执行回滚操作。</li>
</ul>
<hr>
<h3 id="GitLab（配置归档工具）配置"><a href="#GitLab（配置归档工具）配置" class="headerlink" title="GitLab（配置归档工具）配置"></a><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/nginx_cluster_gitlab.html">GitLab（配置归档工具）配置</a></h3><p>GitLab 是使用 Ruby 语言编写的 Git 仓库管理工具，以 Git 作为代码管理工具，并提供了 Web 管理、WIKI 及 Issue 等功能。GitLab 是按照 MIT 许可证分发的开源软件，已被很多知名公司使用，目前由 GitLabInc. 开发维护。</p>
<p>GitLab 可以搭建在私有服务器上，被授权的用户可以创建自己的代码仓库，并可授权给多人协作进行维护。GitLab 拥有与 GitHub 类似的功能，可以通过 Web 浏览器浏览代码、管理缺陷和注释。通过 GitLab 管理 Nginx 配置文件可以从 Web 浏览器中非常方便地浏览到提交过的历史变更，也可以利用 Git 相关命令实现 Nginx 配置的快速回滚操作。</p>
<p>GitLab 同样支持以 Docker 方式部署，官方在 Docker Hub 中也提供了可直接使用的镜像，通过编写相应的 docker-compose 脚本，可以快速搭建 GitLab 服务器。</p>
<hr>
<h3 id="配置修改工具Ansible"><a href="#配置修改工具Ansible" class="headerlink" title="配置修改工具Ansible"></a><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/nginx_cluster_ansible.html">配置修改工具Ansible</a></h3><p>Ansible 是一款自动化的运维工具，是基于 Python 开发的。Ansible 提供了一种自动化执行框架，其可以按照用户设计的剧本自动化执行相关操作。Ansible 是基于模块工作的，其可以实现使用各种模块，并按照设计的剧本，批量对多个目标执行相同的操作。Ansible 集合了众多运维工具的优点，配置更加简单方便。</p>
<hr>
<h3 id="Jenkins安装与配置简述"><a href="#Jenkins安装与配置简述" class="headerlink" title="Jenkins安装与配置简述"></a><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/nginx_cluster_jenkins.html">Jenkins安装与配置简述</a></h3><p>Jenkins 是基于 Java 开发的一个开源的持续集成项目，其提供了一个可扩展的可对代码持续集成、发布（代码编译、打包、部署）及交付的 Web 化操作平台。Jenkins 拥有超过 1000 个插件，使其支持包括 SVN、Git 等多种版本的管理工具（SCM）的代码管理，也可以快速实现 Java、Node.js、.Net 等语言项目的编译构建，并支持包括 Docker 在内的多种形式的部署交付。通过 Jenkins 的 Web 化管理界面，依赖各种强大的插件功能，可以使 Nginx 的配置变更管理变得更加便捷和安全。</p>
<hr>
<h3 id="集群配置管理实例"><a href="#集群配置管理实例" class="headerlink" title="集群配置管理实例"></a><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/nginx/nginx_cluster_example.html">集群配置管理实例</a></h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog2025.github.io/2025/07/31/JavaScript/" rel="prev" title="JavaScript">
                  <i class="fa fa-angle-left"></i> JavaScript
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog2025.github.io/2025/07/31/Python/" rel="next" title="Python">
                  Python <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    
    <!-- 去除心形图案
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    -->
    <span class="post-meta-divider">|</span>

    <span class="author" itemprop="copyrightHolder">lsdyun</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--隐藏网页底部powered by Hexo 强力驱动-->
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
<script src="/blog2025.github.io/js/comments.js"></script><script src="/blog2025.github.io/js/utils.js"></script><script src="/blog2025.github.io/js/motion.js"></script><script src="/blog2025.github.io/js/sidebar.js"></script><script src="/blog2025.github.io/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/blog2025.github.io/js/third-party/search/local-search.js"></script>




  <script src="/blog2025.github.io/js/third-party/fancybox.js"></script>

  <script src="/blog2025.github.io/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
