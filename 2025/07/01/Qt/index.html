<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/blog2025.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog2025.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog2025.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog2025.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog2025.github.io/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lsdyun.github.io","root":"/blog2025.github.io/","images":"/blog2025.github.io/images","scheme":"Pisces","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog2025.github.io/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog2025.github.io/js/config.js"></script>

    <meta name="description" content="QtQt 6.4 LTS + 《Qt5开发及实例精解》 + QWidgetDemo项目实践 1个月：掌握信号槽和基础控件 → 实现计算器3个月：融合数据库&#x2F;多线程 → 开发数据管理工具6个月：专攻方向（如网络&#x2F;3D渲染）→ 参与开源项目 类别传统窗口界面 Qt Widgets">
<meta property="og:type" content="article">
<meta property="og:title" content="Qt">
<meta property="og:url" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/index.html">
<meta property="og:site_name" content="记录博客">
<meta property="og:description" content="QtQt 6.4 LTS + 《Qt5开发及实例精解》 + QWidgetDemo项目实践 1个月：掌握信号槽和基础控件 → 实现计算器3个月：融合数据库&#x2F;多线程 → 开发数据管理工具6个月：专攻方向（如网络&#x2F;3D渲染）→ 参与开源项目 类别传统窗口界面 Qt Widgets">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250701110009085.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250701110205966.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250701110331263.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250701110347079.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250701110551420.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250701110925041.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250701111151615.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250701112134493.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702090949241.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702091553931.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702091828705.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702091941495.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702092133338.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702092150983.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702092645440.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702093150177.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702093237540.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702093255483.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702093559552.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702093643543.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702093807279.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702093914487.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702094451943.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702094542108.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702094715884.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702094800507.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702094937419.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702095048923.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702095201834.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702095259794.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702095324269.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702095530146.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702100144444.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702100634164.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702100815557.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702100942031.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702101329071.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702101605963.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702102141055.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702102858354.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702102923669.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702102950901.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702103307980.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702103608988.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702103624820.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702103702079.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702103830854.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702104118092.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702103925318.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702104227884.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702105151427.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702105208139.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702105635690.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/image-20250702110034652.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702110226483.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702111404706.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702111453105.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702111558298.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702111712666.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702111745137.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702111815583.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702113217709.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702113253119.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702115819875.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702115644608.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702114050873.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702114738209.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702115721031.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702124032141.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702115839179.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702124309965.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702124248760.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702125752025.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702130213973.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702130300686.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702130332445.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702130405184.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702131357485.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702131646060.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702131809125.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702132012571.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702132822656.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702132933568.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/image-20250702134609797.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702135546039.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702135851629.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702140523257.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702140534796.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702142804883.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702143013251.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702143109403.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702143253346.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702143313953.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250702145211422.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703080208368.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703080251360.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703080427331.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703080820185.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703080849592.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703080947235.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703081147629.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703081220543.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703081241543.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703081954439.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703082223181.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703082245878.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703082309077.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703083723796.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703083807157.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703085100434.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703085249477.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703085455605.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703090122712.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703090143922.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703091138789.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703091357380.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703091420220.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703091533219.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703091647726.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703092011407.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703092142033.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703092217575.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703092227727.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703092433219.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703092611005.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703094046795.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703094104298.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703094650178.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703094719458.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703094759928.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703095129676.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703095227144.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703100619152.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703095454398.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703102452921.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703102526302.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_3-7-2025_103745_.jpeg">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703104406206.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703105455003.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703105355816.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703110425968.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703110927994.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703111440374.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703112405685.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703112254166.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703112808703.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703113135346.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703113605700.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703114923880.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703115432356.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703115648399.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703120325241.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703120810288.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703121026551.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703121535646.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703121633815.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703121827103.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703122257231.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703122554689.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703122927737.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703123911721.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703123945973.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703124041372.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703124015396.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703124417656.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703124842403.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703123437429.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703125300008.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703133604445.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703134005421.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703134021639.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703134041624.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703134112384.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703134415708.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703134513775.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250703134625438.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704081003834.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704081256902.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704082806087.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704082746823.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704082818430.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704082835228.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704082852902.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704082918889.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704082932341.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704082944781.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704082956367.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704090436994.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704090605019.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704091730768.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704092328352.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704092714327.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704092948545.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704093325502.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704093746139.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704093955925.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704094808457.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704102751201.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704102816433.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704104027424.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704105322645.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704105424621.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704104607400.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704105931392.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704105906309.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704113952019.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704110813357.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704111204803.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704111544869.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704111730642.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704115153635.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704115417015.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704115607482.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704115755510.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704123627684.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704123830863.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704123901114.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704124058323.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704124113434.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704125657393.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250704130113755.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705090133927.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705090308657.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705090453928.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705090911738.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705090949711.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705094110247.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705091322794.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705093916161.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705091638895.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705093308259.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705092618235.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705095847444.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705094444741.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705100608502.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705100023541.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705101909902.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705102754439.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705104119828.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705104137561.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705094807386.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705095006836.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705095121261.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705110158779.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705110501864.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705110552808.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705110651830.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705110800983.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705111017425.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705111256021.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705111321466.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705111548836.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705112436553.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705112844503.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705113708462.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705115053914.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705121932397.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705115211171.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705115301893.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705122342716.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705122656955.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705123010092.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705123251138.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705123704524.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705124539668.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705124753261.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705124901446.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705125121172.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705125229012.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705130128818.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250705130518231.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706091825747.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706092152119.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706084956256.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706092525601.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706085727589.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706092624433.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706092645352.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706090046142.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706090339430.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706090433501.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706092937572.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706101047675.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706101253197.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706102831096.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706101507482.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706102906672.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706102945999.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706103144536.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706103208863.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706103259335.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706103315839.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706102313505.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706102340864.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706104329390.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706104541206.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706104707810.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706104731517.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706105048277.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706105136660.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706110228853.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706110718663.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706110801810.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706110825418.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706111034371.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706111052753.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706111113361.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706111154154.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706112138651.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706113511463.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706114104340.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/imgsignal.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706120539897.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706122722660.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706123422387.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706124307266.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706124352957.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706124729892.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250706124839116.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707081203786.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707081531444.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707081720282.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707081904291.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707082022938.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707082123865.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707082255638.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707082715858.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707082732986.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707082825603.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707083319707.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707083358035.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707083717476.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707084034944.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707084115899.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707085245181.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707084629212.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707085340243.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707085949284.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707090118217.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707090425056.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707091053391.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707091749434.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707092007888.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707092516645.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707092546745.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707093035439.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707094954568.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707095528490.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707095901282.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707100944931.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707104507757.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707104653621.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707104912358.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707110643789.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707110806277.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707111136861.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707111748182.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707111815799.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707112302889.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707112218286.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707112400375.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707112438796.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707112830471.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707113154193.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707113648872.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707114640760.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250707114816392.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250708090313395.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250708091624766.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250708111107945.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250708112358156.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250708122745555.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250708123349347.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250709091425248.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250709092552178.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250709095638251.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250709101146870.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250709101450746.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250709101705047.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250709102304718.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250709103443721.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250709104215642.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710090159828.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710092504633.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710094813930.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710094831080.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710094847972.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710094936964.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710095318404.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710095446947.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710101819707.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710110341555.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710112140514.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710113131001.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710120226181.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710120714008.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710120801379.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710120940592.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250710121025061.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711085456826.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711090558672.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711092210171.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711092844588.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711094522476.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711095539152.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711095555888.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711095926287.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711110039212.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711110152280.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711110648300.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711113200532.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711113857785.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250711115006887.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712090009509.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712090106267.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712090610564.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712090640464.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712090719825.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712090743496.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712094449363.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712095147103.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712100220177.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712100645716.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712100759795.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712100814042.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712100858580.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250712114044546.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095520949.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095534057.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095604154.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095050305.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095615823.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095147991.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095626652.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095637460.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095650829.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095325256.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095732963.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095749337.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095802300.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095814397.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095921899.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713095956557.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713100019653.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713100119683.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713100157410.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713100226033.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713100259028.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713100332874.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713100402436.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713100443486.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250713100501502.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250714084222261.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250714084319702.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250714084345066.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250714084353947.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250714084452845.png">
<meta property="og:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250714085025044.png">
<meta property="article:published_time" content="2025-07-01T01:57:42.877Z">
<meta property="article:modified_time" content="2025-07-29T07:02:05.636Z">
<meta property="article:author" content="lsdyun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/image-20250701110009085.png">


<link rel="canonical" href="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/","path":"2025/07/01/Qt/","title":"Qt"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Qt | 记录博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/blog2025.github.io/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog2025.github.io/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">记录博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog2025.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog2025.github.io/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/blog2025.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/blog2025.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Qt"><span class="nav-number">1.</span> <span class="nav-text">Qt</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%AA%97%E5%8F%A3%E7%95%8C%E9%9D%A2-Qt-Widgets"><span class="nav-number">1.1.1.</span> <span class="nav-text">传统窗口界面 Qt Widgets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF-Qt-Quick"><span class="nav-number">1.1.2.</span> <span class="nav-text">移动端 Qt Quick</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Widgets-vs-Qt-Quick"><span class="nav-number">1.1.3.</span> <span class="nav-text">Qt Widgets vs Qt Quick</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qt-6%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">Qt 6的下载和安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD"><span class="nav-number">1.2.1.</span> <span class="nav-text">下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.2.</span> <span class="nav-text">安装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qt-Creator"><span class="nav-number">1.3.</span> <span class="nav-text">Qt Creator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">示例程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Qt-Widgets"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Qt Widgets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Qt-Quick"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">Qt Quick</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qt%E5%B7%A5%E5%85%B7"><span class="nav-number">1.4.</span> <span class="nav-text">Qt工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA-Qt-%E5%BA%94%E7%94%A8"><span class="nav-number">1.5.</span> <span class="nav-text">第一个 Qt 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.5.1.</span> <span class="nav-text">创建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95"><span class="nav-number">1.5.2.</span> <span class="nav-text">项目目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE-UI-%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.5.3.</span> <span class="nav-text">项目 UI 设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.4.</span> <span class="nav-text">项目模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.5.5.</span> <span class="nav-text">项目文件介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C"><span class="nav-number">1.5.6.</span> <span class="nav-text">项目运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8F%91%E5%B8%83"><span class="nav-number">1.5.7.</span> <span class="nav-text">项目的发布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="nav-number">1.5.7.1.</span> <span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="nav-number">1.5.7.2.</span> <span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%BA%90%E7%A0%81%E4%B8%8E%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.8.</span> <span class="nav-text">程序源码与编译过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%AF%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99"><span class="nav-number">1.5.8.1.</span> <span class="nav-text">使用纯代码编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E5%86%99%E5%86%8D%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%EF%BC%88%E5%A4%AA%E9%BA%BB%E7%83%A6%EF%BC%89"><span class="nav-number">1.5.8.2.</span> <span class="nav-text">使用其他编译器编写再通过命令行编译运行（太麻烦）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ui-%E8%A1%A8%E5%8D%95%E6%96%87%E4%BB%B6%E5%A4%B9%E7%94%9F%E6%88%90%E7%95%8C%E9%9D%A2"><span class="nav-number">1.5.8.3.</span> <span class="nav-text">使用 .ui 表单文件夹生成界面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89C-%E7%AA%97%E5%8F%A3%E7%B1%BB"><span class="nav-number">1.5.8.4.</span> <span class="nav-text">使用自定义C++窗口类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%B0%E6%88%90%E7%9A%84Qt%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%95%8C%E9%9D%A2%E7%B1%BB"><span class="nav-number">1.5.8.5.</span> <span class="nav-text">使用现成的Qt设计师界面类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">1.5.8.6.</span> <span class="nav-text">注意</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA-Qt-Quick-%E5%BA%94%E7%94%A8"><span class="nav-number">1.6.</span> <span class="nav-text">第一个 Qt Quick 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE-1"><span class="nav-number">1.6.1.</span> <span class="nav-text">创建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAQuick%E5%BA%94%E7%94%A8%EF%BC%88qmake%EF%BC%89"><span class="nav-number">1.6.2.</span> <span class="nav-text">创建Quick应用（qmake）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-number">1.6.3.</span> <span class="nav-text">Qt 资源文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8F%91%E5%B8%83-1"><span class="nav-number">1.6.4.</span> <span class="nav-text">项目的发布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">方式一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">方式二</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAQt-Quick-UI%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.6.5.</span> <span class="nav-text">创建Qt Quick UI项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Qt-Quick%E8%AE%BE%E8%AE%A1%E5%99%A8"><span class="nav-number">1.6.6.</span> <span class="nav-text">使用Qt Quick设计器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QML%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">1.6.7.</span> <span class="nav-text">QML语法基础</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87"><span class="nav-number">1.7.</span> <span class="nav-text">设置应用程序图标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qt-Widgets%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6"><span class="nav-number">1.8.</span> <span class="nav-text">Qt Widgets窗口部件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#QWidget-%E5%9F%BA%E7%A1%80%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6"><span class="nav-number">1.8.1.</span> <span class="nav-text">QWidget 基础窗口部件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%AD%90%E7%AA%97%E5%8F%A3"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">窗口与子窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">窗口类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">窗口布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QFrame-%E7%B1%BB%E6%97%8F"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">QFrame 类族</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A"><span class="nav-number">1.8.1.4.1.</span> <span class="nav-text">示例一：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A"><span class="nav-number">1.8.1.4.2.</span> <span class="nav-text">示例二：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A"><span class="nav-number">1.8.1.4.3.</span> <span class="nav-text">示例三：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E9%92%AE%E7%BB%84%E4%BB%B6"><span class="nav-number">1.8.1.5.</span> <span class="nav-text">按钮组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QLineEdit"><span class="nav-number">1.8.1.6.</span> <span class="nav-text">QLineEdit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QAbstractSpinBox"><span class="nav-number">1.8.1.7.</span> <span class="nav-text">QAbstractSpinBox</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QAbstractSlider"><span class="nav-number">1.8.1.8.</span> <span class="nav-text">QAbstractSlider</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="nav-number">1.8.1.8.1.</span> <span class="nav-text">关联信号和槽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#QAbstractSlider-%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.1.8.2.</span> <span class="nav-text">QAbstractSlider 的属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Slider%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.1.8.3.</span> <span class="nav-text">Slider属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dial%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.1.8.4.</span> <span class="nav-text">Dial属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QDialog-%E5%AF%B9%E8%AF%9D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.8.2.</span> <span class="nav-text">QDialog 对话空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%80%81%E5%92%8C%E9%9D%9E%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">模态和非模态对话框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">标准对话框</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qt-Quick-%E9%83%A8%E4%BB%B6"><span class="nav-number">1.9.</span> <span class="nav-text">Qt Quick 部件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Quick-%E5%9F%BA%E7%A1%80%E5%8F%AF%E8%A7%86%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.9.1.</span> <span class="nav-text">Qt Quick 基础可视项目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">Item 项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rectangle"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">Rectangle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Text"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">Text</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TextInput"><span class="nav-number">1.9.1.4.</span> <span class="nav-text">TextInput</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TextEdit"><span class="nav-number">1.9.1.5.</span> <span class="nav-text">TextEdit</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Quick-%E6%8E%A7%E4%BB%B6"><span class="nav-number">1.9.2.</span> <span class="nav-text">Qt Quick 控件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E4%BB%B6%E5%9F%BA%E7%B1%BB%E5%9E%8BControl"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">控件基类型Control</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E9%92%AE%E7%B1%BB%E6%8E%A7%E4%BB%B6"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">按钮类控件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E7%A4%BA%E5%99%A8%E7%B1%BB%E6%8E%A7%E4%BB%B6"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">指示器类控件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E7%B1%BB%E6%8E%A7%E4%BB%B6"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">输入类控件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E6%8E%A7%E4%BB%B6%EF%BC%88%E5%B7%B2%E5%BC%83%EF%BC%89"><span class="nav-number">1.9.2.5.</span> <span class="nav-text">日期类控件（已弃）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Quick%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">1.9.3.</span> <span class="nav-text">Qt Quick系统对话框</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E5%AF%B9%E8%AF%9D%E6%A1%86ColorDialog"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">颜色对话框ColorDialog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86FileDialog"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">文件对话框FileDialog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86MessageDialog"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">消息对话框MessageDialog</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95"><span class="nav-number">1.10.</span> <span class="nav-text">程序调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BC%8F%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.10.1.</span> <span class="nav-text">调式模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95"><span class="nav-number">1.10.2.</span> <span class="nav-text">单步调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#qDeBug"><span class="nav-number">1.10.3.</span> <span class="nav-text">qDeBug()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-log"><span class="nav-number">1.10.4.</span> <span class="nav-text">console.log()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86"><span class="nav-number">1.11.</span> <span class="nav-text">布局管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Widgets-%E5%B8%83%E5%B1%80"><span class="nav-number">1.11.1.</span> <span class="nav-text">Qt Widgets 布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">布局管理器系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">布局管理器简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">基本布局管理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%83%A8%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.11.1.4.</span> <span class="nav-text">设置部件大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E7%AA%97%E5%8F%A3"><span class="nav-number">1.11.1.5.</span> <span class="nav-text">可扩展窗口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Quick-%E5%B8%83%E5%B1%80"><span class="nav-number">1.11.2.</span> <span class="nav-text">Qt Quick 布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E5%99%A8"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">定位器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%9A%EF%BC%88anchors%EF%BC%89%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">基于锚（anchors）的布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">1.11.2.3.</span> <span class="nav-text">布局管理器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="nav-number">1.12.</span> <span class="nav-text">信号与槽</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Widgets-%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="nav-number">1.12.1.</span> <span class="nav-text">Qt Widgets 中的信号与槽</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E8%AF%86%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">认识信号与槽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">1.12.1.2.</span> <span class="nav-text">自定义对话框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E7%95%8C%E9%9D%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">1.12.1.3.</span> <span class="nav-text">在主界面中使用自定义的对话框</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.12.2.</span> <span class="nav-text">信号与槽详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">应用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%85%B3%E8%81%94"><span class="nav-number">1.12.2.3.</span> <span class="nav-text">自动关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E5%BC%80%E5%85%B3%E8%81%94"><span class="nav-number">1.12.2.4.</span> <span class="nav-text">断开关联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8"><span class="nav-number">1.12.2.5.</span> <span class="nav-text">高级应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Quick-%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.12.3.</span> <span class="nav-text">Qt Quick 中的信号与信号处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.12.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%BF%A1%E5%8F%B7"><span class="nav-number">1.12.3.2.</span> <span class="nav-text">声明信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.12.3.3.</span> <span class="nav-text">信号处理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Connections%E7%B1%BB%E5%9E%8B%E5%92%8Cconnect-%E5%87%BD%E6%95%B0"><span class="nav-number">1.12.3.4.</span> <span class="nav-text">使用Connections类型和connect()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-number">1.12.4.</span> <span class="nav-text">Qt 核心机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.12.4.1.</span> <span class="nav-text">对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.12.4.2.</span> <span class="nav-text">元对象系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.12.4.3.</span> <span class="nav-text">属性系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%A0%91%E4%B8%8E%E6%8B%A5%E6%9C%89%E6%9D%83"><span class="nav-number">1.12.4.4.</span> <span class="nav-text">对象树与拥有权</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%BB%E7%AA%97%E5%8F%A3"><span class="nav-number">1.13.</span> <span class="nav-text">应用程序主窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Widget-%E4%B8%BB%E7%AA%97%E5%8F%A3"><span class="nav-number">1.13.1.</span> <span class="nav-text">Qt Widget 主窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">菜单栏和工具栏</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95"><span class="nav-number">1.13.1.1.1.</span> <span class="nav-text">1.设计模式添加菜单</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E6%96%B9%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95"><span class="nav-number">1.13.1.1.2.</span> <span class="nav-text">2.编写代码方式添加菜单</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8F%9C%E5%8D%95%E6%A0%8F"><span class="nav-number">1.13.1.1.3.</span> <span class="nav-text">菜单栏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="nav-number">1.13.1.1.4.</span> <span class="nav-text">工具栏</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BF%83%E9%83%A8%E4%BB%B6"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">中心部件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dock%E9%83%A8%E4%BB%B6"><span class="nav-number">1.13.1.3.</span> <span class="nav-text">Dock部件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="nav-number">1.13.1.4.</span> <span class="nav-text">状态栏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95"><span class="nav-number">1.13.1.5.</span> <span class="nav-text">自定义菜单</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Quick-%E4%B8%BB%E7%AA%97%E5%8F%A3"><span class="nav-number">1.13.2.</span> <span class="nav-text">Qt Quick 主窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3Window"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">窗口Window</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%BB%E7%AA%97%E5%8F%A3-1"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">应用程序主窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8F%9C%E5%8D%95%E7%B1%BB%E6%8E%A7%E4%BB%B6"><span class="nav-number">1.13.2.3.</span> <span class="nav-text">菜单类控件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%8E%A7%E4%BB%B6"><span class="nav-number">1.13.2.4.</span> <span class="nav-text">容器类控件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B9%E5%87%BA%E7%B1%BB%E7%A9%BA%E9%97%B4"><span class="nav-number">1.13.2.5.</span> <span class="nav-text">弹出类空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.14.</span> <span class="nav-text">事件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Widget-%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.14.1.</span> <span class="nav-text">Qt Widget 事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">1.14.1.1.</span> <span class="nav-text">事件的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-number">1.14.1.2.</span> <span class="nav-text">事件的传递</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A-1"><span class="nav-number">1.14.1.2.1.</span> <span class="nav-text">示例一：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A-1"><span class="nav-number">1.14.1.2.2.</span> <span class="nav-text">示例二：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E3%80%81%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.14.1.3.</span> <span class="nav-text">鼠标事件、滚轮事件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.14.1.3.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.14.1.4.</span> <span class="nav-text">键盘事件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="nav-number">1.14.1.4.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">1.14.1.5.</span> <span class="nav-text">定时器事件与随机数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="nav-number">1.14.1.5.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%96%E6%94%BE%E6%93%8D%E4%BD%9C"><span class="nav-number">1.14.1.6.</span> <span class="nav-text">拖放操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A-2"><span class="nav-number">1.14.1.6.1.</span> <span class="nav-text">示例一：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A-2"><span class="nav-number">1.14.1.6.2.</span> <span class="nav-text">示例二：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Quick-%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.14.2.</span> <span class="nav-text">Qt Quick 事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MouseArea"><span class="nav-number">1.14.2.1.</span> <span class="nav-text">MouseArea</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MouseEvent%E5%92%8CWheelEvent"><span class="nav-number">1.14.2.2.</span> <span class="nav-text">MouseEvent和WheelEvent</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A-3"><span class="nav-number">1.14.2.2.1.</span> <span class="nav-text">示例一：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A-3"><span class="nav-number">1.14.2.2.2.</span> <span class="nav-text">示例二：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DragEvent"><span class="nav-number">1.14.2.3.</span> <span class="nav-text">DragEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KeyEvent"><span class="nav-number">1.14.2.4.</span> <span class="nav-text">KeyEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Timer-%E5%92%8C-Random"><span class="nav-number">1.14.2.5.</span> <span class="nav-text">Timer 和 Random</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%95%8C%E9%9D%A2%E5%A4%96%E8%A7%82%E4%B8%8E%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">1.15.</span> <span class="nav-text">界面外观与国际化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Widgets%E5%A4%96%E8%A7%82%E6%A0%B7%E5%BC%8F"><span class="nav-number">1.15.1.</span> <span class="nav-text">Qt Widgets外观样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%AE%80%E4%BB%8B"><span class="nav-number">1.15.2.</span> <span class="nav-text">Qt样式表简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE%E6%A0%B7%E5%BC%8F%E8%A1%A8"><span class="nav-number">1.15.2.1.</span> <span class="nav-text">使用代码设置样式表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%A0%B7%E5%BC%8F%E8%A1%A8"><span class="nav-number">1.15.2.2.</span> <span class="nav-text">在设计模式中设置样式表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Qt%E6%A0%B7%E5%BC%8F%E8%A1%A8%E8%AF%AD%E6%B3%95"><span class="nav-number">1.15.2.3.</span> <span class="nav-text">Qt样式表语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E4%BB%B6%E5%A4%96%E8%A7%82"><span class="nav-number">1.15.2.4.</span> <span class="nav-text">自定义部件外观</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Qt-Quick%E6%8E%A7%E4%BB%B6%E6%A0%B7%E5%BC%8F"><span class="nav-number">1.15.3.</span> <span class="nav-text">Qt Quick控件样式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A7%E4%BB%B6%E6%A0%B7%E5%BC%8F"><span class="nav-number">1.15.3.1.</span> <span class="nav-text">使用控件样式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="nav-number">1.15.3.2.</span> <span class="nav-text">自定义控件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">1.15.4.</span> <span class="nav-text">国际化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB"><span class="nav-number">1.16.</span> <span class="nav-text">动画</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Widgets"><span class="nav-number">1.16.1.</span> <span class="nav-text">Widgets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.16.1.1.</span> <span class="nav-text">基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6"><span class="nav-number">1.16.1.2.</span> <span class="nav-text">框架</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quick"><span class="nav-number">1.16.2.</span> <span class="nav-text">Quick</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80-1"><span class="nav-number">1.16.2.1.</span> <span class="nav-text">基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BF%87%E6%B8%A1"><span class="nav-number">1.16.2.2.</span> <span class="nav-text">动画与过渡</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">1.17.</span> <span class="nav-text">数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Widgets-1"><span class="nav-number">1.17.1.</span> <span class="nav-text">Widgets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-number">1.17.1.1.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8"><span class="nav-number">1.17.1.2.</span> <span class="nav-text">数据库应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML%E5%BA%94%E7%94%A8"><span class="nav-number">1.17.1.3.</span> <span class="nav-text">XML应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quick-1"><span class="nav-number">1.17.2.</span> <span class="nav-text">Quick</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84-1"><span class="nav-number">1.17.2.1.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.17.2.2.</span> <span class="nav-text">数据模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.17.3.</span> <span class="nav-text">视图类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%A1%A8"><span class="nav-number">1.18.</span> <span class="nav-text">图表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#widgets"><span class="nav-number">1.18.1.</span> <span class="nav-text">widgets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quick-2"><span class="nav-number">1.18.2.</span> <span class="nav-text">Quick</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-number">1.19.</span> <span class="nav-text">数据可视化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Widgets-2"><span class="nav-number">1.19.1.</span> <span class="nav-text">Widgets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quick-3"><span class="nav-number">1.19.2.</span> <span class="nav-text">Quick</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BA%94%E7%94%A8"><span class="nav-number">1.20.</span> <span class="nav-text">多媒体应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Widgets-3"><span class="nav-number">1.20.1.</span> <span class="nav-text">Widgets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quick-4"><span class="nav-number">1.20.2.</span> <span class="nav-text">Quick</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QML-%E4%B8%8E-C-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91"><span class="nav-number">1.21.</span> <span class="nav-text">QML 与 C++ 混合开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">1.21.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8CC-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.21.2.</span> <span class="nav-text">注册C++类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QML%E6%A8%A1%E5%9D%97%E6%8F%90%E4%BE%9B%E7%9A%84C-%E7%B1%BB"><span class="nav-number">1.21.3.</span> <span class="nav-text">QML模块提供的C++类</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lsdyun"
      src="/blog2025.github.io/images/avatar.png">
  <p class="site-author-name" itemprop="name">lsdyun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog2025.github.io/archives/">
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog2025.github.io/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lsdyun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lsdyun" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lsdyun.github.io/blog2025.github.io/2025/07/01/Qt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog2025.github.io/images/avatar.png">
      <meta itemprop="name" content="lsdyun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记录博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Qt | 记录博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Qt
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-01 09:57:42" itemprop="dateCreated datePublished" datetime="2025-07-01T09:57:42+08:00">2025-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-07-29 15:02:05" itemprop="dateModified" datetime="2025-07-29T15:02:05+08:00">2025-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog2025.github.io/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


		<!--  设置置顶图标  -->
		        
		<!--  设置置顶图标  -->
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a><a target="_blank" rel="noopener" href="https://www.qter.org/">Qt</a></h1><p><strong>Qt 6.4 LTS</strong> + 《Qt5开发及实例精解》 + QWidgetDemo项目实践</p>
<p>1个月：掌握信号槽和基础控件 → 实现计算器<br>3个月：融合数据库&#x2F;多线程 → 开发数据管理工具<br>6个月：专攻方向（如网络&#x2F;3D渲染）→ 参与开源项目</p>
<h2 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h2><h3 id="传统窗口界面-Qt-Widgets"><a href="#传统窗口界面-Qt-Widgets" class="headerlink" title="传统窗口界面 Qt Widgets"></a><strong>传统窗口界面 Qt Widgets</strong></h3><p>C++开发，</p>
<h3 id="移动端-Qt-Quick"><a href="#移动端-Qt-Quick" class="headerlink" title="移动端 Qt Quick"></a><strong>移动端 Qt Quick</strong></h3><p>Qt Quick技术 + Qt QML语言</p>
<ul>
<li><p>Qt Quick：</p>
<ul>
<li><p>基于 QML 语言的一种用户界面技术。</p>
</li>
<li><p>由QML、JavaScript、C++等多种技术组成。</p>
</li>
<li><p>Qt Quick 模块是 QML 类型和功能的标准库，包含了可视化类型、交互类型、动画、模型和视图、粒子特效和渲染特效等。</p>
</li>
<li><p>QML 应用程序可以通过 <strong>import</strong> 语句来使用 Qt Quick 模块提供的所有功能。</p>
</li>
<li><p>提供了 QML 创建用户界面所需要的所有基本类型。</p>
</li>
</ul>
</li>
<li><p>Qt QML：</p>
<ul>
<li>声明式编程语言。</li>
<li>使用可视化组件以及组件间的交互和关联来描述用户界面。</li>
<li>类似于JSON的声明式语法，提供了必要的JavaScript语句和动态属性绑定。</li>
<li>提供了QML 的引擎和语言基础。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th>Qt Quick</th>
<th align="left">Qt QML</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>定位</strong></td>
<td><strong>UI 框架 &#x2F; 标准库</strong> (基于 QML 的 UI 组件和功能)</td>
<td align="left"><strong>编程语言</strong> (语法、引擎、基础)</td>
</tr>
<tr>
<td align="left"><strong>核心提供</strong></td>
<td>丰富的可视化组件、交互元素、动画系统、布局、视图等</td>
<td align="left">QML 语言规范、引擎、基础类型、C++ 集成</td>
</tr>
<tr>
<td align="left"><strong>语法</strong></td>
<td>使用 QML 语法来定义 UI</td>
<td align="left">定义了 QML 的声明式语法规则</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td><strong>构建于</strong> Qt QML 之上</td>
<td align="left">是 Qt Quick 的<strong>基础</strong></td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td>提供构建实际用户界面的<strong>具体工具和组件库</strong></td>
<td align="left">描述界面结构、行为、数据绑定的<strong>语言能力</strong></td>
</tr>
<tr>
<td align="left"><strong>引用方式</strong></td>
<td>在 QML 文件中显式 <code>import QtQuick</code></td>
<td align="left">(隐式使用，语言本身)</td>
</tr>
<tr>
<td align="left"><strong>类比</strong></td>
<td>类似 React &#x2F; Vue.js <em>框架</em> (提供UI组件库)</td>
<td align="left">类似 JavaScript <em>语言本身</em></td>
</tr>
</tbody></table>
<hr>
<h3 id="Qt-Widgets-vs-Qt-Quick"><a href="#Qt-Widgets-vs-Qt-Quick" class="headerlink" title="Qt Widgets vs Qt Quick"></a>Qt Widgets vs Qt Quick</h3><table>
<thead>
<tr>
<th><strong>对比内容</strong></th>
<th><strong>Qt  Quick、Qt Quick Controls</strong></th>
<th><strong>Qt  Widgets</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>使用的语言</strong></td>
<td><strong>QML&#x2F;JS</strong></td>
<td><strong>C++</strong></td>
<td></td>
</tr>
<tr>
<td><strong>原生外观和视觉</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>Qt  Widgets和Qt Quick Controls在目标平台上都支持原生的外观。</strong></td>
</tr>
<tr>
<td><strong>自定义样式</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>Qt  Widgets可以通过样式表进行样式自定义；Qt Quick Controls具有可自定义样式的选择。</strong></td>
</tr>
<tr>
<td><strong>流畅的动画UI</strong></td>
<td><strong>√</strong></td>
<td></td>
<td><strong>Qt  Widgets不能很好地缩放来进行动画；而Qt Quick提供了一种方便且自然的方法通过声明方式来实现动画。</strong></td>
</tr>
<tr>
<td><strong>触摸屏支持</strong></td>
<td><strong>√</strong></td>
<td></td>
<td><strong>Qt  Widgets通常需要使用鼠标指针来进行良好的交互；而Qt Quick提供了QML类型来完成触摸交互。</strong></td>
</tr>
<tr>
<td><strong>标准行业小部件</strong></td>
<td></td>
<td><strong>√</strong></td>
<td><strong>Qt  Widgets提供了构建标准行业类型应用程序所需的丰富部件和功能。</strong></td>
</tr>
<tr>
<td><strong>模型&#x2F;视图编程</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>Qt  Quick提供了方便的视图，但是Qt Widgets提供了更方便和完整的框架。除了Qt Quick视图外，Qt Quick  Controls还提供了TableView控件。</strong></td>
</tr>
<tr>
<td><strong>快速UI开发</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>Qt  Quick是快速UI原型制作和开发的最佳选择。</strong></td>
</tr>
<tr>
<td><strong>硬件图形加速</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>Qt为Qt  Quick界面提供了完整的硬件加速，而Qt Widgets界面通过软件进行渲染。</strong></td>
</tr>
<tr>
<td><strong>图形效果</strong></td>
<td><strong>√</strong></td>
<td></td>
<td><strong>一些Qt  Quick模块提供了图形效果，而Qt Widgets界面可以使用Qt GUI模块来实现一些效果。</strong></td>
</tr>
<tr>
<td><strong>富文本处理</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>Qt  Widgets为实现文本编辑器提供了全面的基础支持，Qt的富文本文档类也可以在Qt Quick和Qt Quick  Controls的TextArea控件中使用，但可能需要一些C++实现。</strong></td>
</tr>
</tbody></table>
<p><strong>选择：</strong></p>
<ul>
<li><p><strong>Qt Widgets</strong></p>
<ul>
<li><p>是大型标准工业应用；</p>
</li>
<li><p>仅在桌面上运行；</p>
</li>
<li><p>类似于本地Linux、macOS和Windows应用程序；</p>
</li>
<li><p>需要很好地集成到底层平台中。</p>
</li>
</ul>
</li>
<li><p><strong>Qt Quick</strong></p>
<ul>
<li>使用短周期原型化设计；</li>
<li>在移动、嵌入式设备或MCU上运行；</li>
<li>在触摸屏上工作；</li>
<li>包含大量动画和图形效果。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Qt-6的下载和安装"><a href="#Qt-6的下载和安装" class="headerlink" title="Qt 6的下载和安装"></a>Qt 6的下载和安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><strong>需要下载</strong> <strong>Qt Online Installer</strong> <strong>进行在线安装，</strong></p>
<p><strong>下载地址：<a target="_blank" rel="noopener" href="https://download.qt.io/official_releases/online_installers/">https://download.qt.io/official_releases/online_installers/</a></strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250701110009085.png" alt="image-20250701110009085"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>1.注册账户</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250701110205966.png" alt="image-20250701110205966"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250701110331263.png" alt="image-20250701110331263"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250701110347079.png" alt="image-20250701110347079"></p>
<p><em>开头大写，最后跟个点。</em></p>
<p>点击注册后需要去邮箱验证。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250701110551420.png" alt="image-20250701110551420"></p>
<p>验证结束后：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250701110925041.png" alt="image-20250701110925041"></p>
<p>这个自定义实在不行，别选，默认下一步即可</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250701111151615.png" alt="image-20250701111151615"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250701112134493.png" alt="image-20250701112134493"></p>
<p>接下来一直下一步即可。</p>
<hr>
<p>如果上述出现问题，参考这个里面的安装：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62888264/article/details/132645054">https://blog.csdn.net/qq_62888264/article/details/132645054</a></p>
<hr>
<hr>
<h2 id="Qt-Creator"><a href="#Qt-Creator" class="headerlink" title="Qt Creator"></a>Qt Creator</h2><p><strong>Qt Creator</strong>是一个跨平台的、完整的 Qt 集成开发环境，其中包括了 C++ 和 QML 代码编辑器、项目和生成管理工具、集成的上下文相关的帮助系统、图形化调试器、代码管理和浏览工具等。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702090949241.png" alt="image-20250702090949241"></p>
<hr>
<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><h4 id="Qt-Widgets"><a href="#Qt-Widgets" class="headerlink" title="Qt Widgets"></a>Qt Widgets</h4><p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702091553931.png" alt="image-20250702091553931"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702091828705.png" alt="image-20250702091828705"></p>
<p>进入代码界面</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702091941495.png" alt="image-20250702091941495"></p>
<p>运行</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702092133338.png" alt="image-20250702092133338"></p>
<p>效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702092150983.png" alt="image-20250702092150983"></p>
<p>关闭项目：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702092645440.png" alt="image-20250702092645440"></p>
<h4 id="Qt-Quick"><a href="#Qt-Quick" class="headerlink" title="Qt Quick"></a>Qt Quick</h4><p>与上述相同，只不过搜索的是Quick</p>
<hr>
<hr>
<h2 id="Qt工具"><a href="#Qt工具" class="headerlink" title="Qt工具"></a>Qt工具</h2><p>在 <strong>X:\Qt\6.x.x\mingw_64\bin</strong> 中</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702093150177.png" alt="image-20250702093150177"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702093237540.png" alt="image-20250702093237540"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702093255483.png" alt="image-20250702093255483"></p>
<ul>
<li><p><strong>Qt Assistant</strong>：</p>
<p>文档阅读器，类似于<strong>Readme.md</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702093559552.png" alt="image-20250702093559552"></p>
</li>
<li><p><strong>Qt Designer</strong>：</p>
<p>GUI布局和格式构建器，可以使用屏幕上的格式快速设计、创建部件以及对话框。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702093643543.png" alt="image-20250702093643543"></p>
</li>
<li><p><strong>Qt Linguist</strong>：</p>
<p>加速应用程序翻译和国际化的工具。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702093807279.png" alt="image-20250702093807279"></p>
</li>
<li><p><strong>Qt Design Studio</strong>：</p>
<p>可视化的用户界面 UI 设计构成工具，设计师可以通过该工具将设计的 2D 或 3D 界面直接转换为 QML 代码。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702093914487.png" alt="image-20250702093914487"></p>
</li>
</ul>
<hr>
<hr>
<h2 id="第一个-Qt-应用"><a href="#第一个-Qt-应用" class="headerlink" title="第一个 Qt 应用"></a>第一个 Qt 应用</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702094451943.png" alt="image-20250702094451943"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702094542108.png" alt="image-20250702094542108"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702094715884.png" alt="image-20250702094715884"></p>
<p><strong>qmake是Qt提供的一个编译工具，它可以生成与平台无关的.pro文件，然后利用该文件生成与平台相关的Makefile文件。</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702094800507.png" alt="image-20250702094800507"></p>
<p><strong>基类选择QDialog，表明该类继承自QDialog类，使用这个类可以生成一个对话框界面。</strong><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702094937419.png" alt="image-20250702094937419"></p>
<p><strong>选择翻译文件。因为现在不需要进行界面翻译，直接跳过即可。</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702095048923.png" alt="image-20250702095048923"></p>
<p><strong>选择构建套件。现在只有一个Desktop Qt 6.5.0 MinGW 64-bit可用，会默认为Debug、Release等版本分别设置不同的目录。</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702095201834.png" alt="image-20250702095201834"></p>
<p><strong>设置项目管理。在这里可以看到这个项目的汇总信息，还可以使用版本控制系统。单击“完成”按钮完成项目创建。</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702095259794.png" alt="image-20250702095259794"></p>
<p>项目界面：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702095324269.png" alt="image-20250702095324269"></p>
<hr>
<h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702095530146.png" alt="image-20250702095530146"></p>
<ul>
<li><strong>hellodialog.cpp</strong>：新建的 HellowDialog 类的源文件</li>
<li><strong>hellodialog.h</strong>：新建的 HelloDialog 类的头文件</li>
<li><strong>hellodialog.ui</strong>：设计师设计的界面对应的表单文件</li>
<li><strong>helloworld.pro</strong>：项目文件，其中包含了项目相关信息。</li>
<li><strong>helloworld.pro.user</strong>：包含了与用户有关的项目信息</li>
<li><strong>main.cpp</strong>：包含了 <code>main()</code> 主函数</li>
</ul>
<hr>
<h3 id="项目-UI-设计"><a href="#项目-UI-设计" class="headerlink" title="项目 UI 设计"></a>项目 UI 设计</h3><p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702100144444.png" alt="image-20250702100144444"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702100634164.png" alt="image-20250702100634164"></p>
<hr>
<h3 id="项目模式"><a href="#项目模式" class="headerlink" title="项目模式"></a>项目模式</h3><p>按下快捷键 <strong>Ctrl+5</strong>，或者点击<strong>项目</strong>图标，进入项目模式。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702100815557.png" alt="image-20250702100815557"></p>
<p><strong>项目模式分为构建和运行、编辑器、代码风格、依赖关系等多个设置页面。</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702100942031.png" alt="image-20250702100942031"></p>
<ul>
<li><p><strong>Debug</strong>：</p>
<p>调试信息，生成的可执行文件很大。</p>
</li>
<li><p><strong>Profile</strong></p>
<p>概述版本，带有部分调试符号信息，在 Debug 和 Release 之间取一个平衡，兼顾性能和调试，性能更优但又方便调试。</p>
</li>
<li><p><strong>Release</strong></p>
<p>真正发布程序时要使用该版本，不带任何调试符号信息，并且进行了多种优化。</p>
</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702101329071.png" alt="image-20250702101329071"></p>
<p><strong>Shadow build</strong>：</p>
<p><strong>就是所谓的“影子构建”，作用是将项目的源码和编译生成的文件分别存放，就像前面创建项目时看到的，helloworld项目经编译构建为Debug版本后会生成build-helloworld-Desktop_Qt_6_5_0_MinGW_64_bit-Debug文件夹，里面放着编译生成的所有文件。</strong></p>
<hr>
<h3 id="项目文件介绍"><a href="#项目文件介绍" class="headerlink" title="项目文件介绍"></a>项目文件介绍</h3><p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702101605963.png" alt="image-20250702101605963"></p>
<p>代码解释：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702102141055.png" alt="image-20250702102141055"></p>
<hr>
<h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3><p>使用快捷键 <strong>Ctrl+R</strong> 或者左下角的<strong>绿色三角</strong>按钮来编译运行程序</p>
<p>进入<strong>项目目录&#x2F;build</strong>中，既可看到Debug、Profile、Release版本下的文件夹。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702102858354.png" alt="image-20250702102858354"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702102923669.png" alt="image-20250702102923669"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702102950901.png" alt="image-20250702102950901"></p>
<p>这些文件都是编译生成的中间文件，helloworld.exe 为可执行文件。</p>
<p>执行helloworld.exe 文件报错：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702103307980.png" alt="image-20250702103307980"></p>
<p>可以通过在Qt安装目录找到缺失的文件来解决，或者在环境变量中通过添加系统变量解决</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702103608988.png" alt="image-20250702103608988"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702103624820.png" alt="image-20250702103624820"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702103702079.png" alt="image-20250702103702079"></p>
<hr>
<h3 id="项目的发布"><a href="#项目的发布" class="headerlink" title="项目的发布"></a>项目的发布</h3><p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702103830854.png" alt="image-20250702103830854"></p>
<p>或者：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702104118092.png" alt="image-20250702104118092"></p>
<p>进入<strong>项目&#x2F;build</strong>目录中。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702103925318.png" alt="image-20250702103925318"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702104227884.png" alt="image-20250702104227884"></p>
<hr>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>打包项目</strong>：</p>
<p>下列的文件需要和和helloworld.exe放一起打包。</p>
<blockquote>
<p><strong>X:&#x2F;…&#x2F;Qt:&#x2F;6.x.x&#x2F;mingw_64&#x2F;bin</strong></p>
</blockquote>
<ul>
<li><strong>libgcc_s_seh-1.dll</strong></li>
<li><strong>libstdc++-6.dll</strong></li>
<li><strong>libwinpthread-1.dll</strong></li>
<li><strong>Qt6Core.dll</strong></li>
<li><strong>Qt6Gui.dll</strong></li>
<li><strong>Qt6Widgets.dll</strong></li>
</ul>
<blockquote>
<p><strong>X:&#x2F;…&#x2F;Qt:&#x2F;6.x.x&#x2F;mingw_64&#x2F;plugins</strong></p>
</blockquote>
<ul>
<li>保留<strong>platforms文件夹&#x2F;qwindows.dll文件</strong></li>
</ul>
<p>效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702105151427.png" alt="image-20250702105151427"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702105208139.png" alt="image-20250702105208139"></p>
<hr>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>使用Qt 提供的 windeployqt 工具自动创建可部署的文件夹。</p>
<p>在开始菜单启动<strong>Qt 6.x.x (MinGW x.x.x 64-bit)</strong>，</p>
<blockquote>
<p>或者直接使用cmd就行。</p>
</blockquote>
<p>进入项目的release文件夹，复制路径</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702105635690.png" alt="image-20250702105635690"></p>
<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windeployqt D:\blog\code\blog2025.github.io\qt\demo1\helloworld\build\Desktop_Qt_6_9_1_MinGW_64_bit-Release\release</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/image-20250702110034652.png" alt="image-20250702110034652"></p>
<p>效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702110226483.png" alt="image-20250702110226483"></p>
<hr>
<p>补充：</p>
<ul>
<li><strong>动态编译</strong>：Qt Creator在默认的情况下，编译的程序要想发布就需要<strong>包含dll</strong>文件，这种编译方式被称为动态编译。</li>
<li><strong>静态编译</strong>：将Qt的库进行重新编译，用静态编译的Qt库来链接程序，这样生成的目标文件就可以直接运行，而<strong>不再需要dll文件</strong>的支持。<br>不过这样生成的可执行文件会很大，而且静态编译缺乏灵活性，也不能部署插件。</li>
</ul>
<hr>
<h3 id="程序源码与编译过程"><a href="#程序源码与编译过程" class="headerlink" title="程序源码与编译过程"></a>程序源码与编译过程</h3><h4 id="使用纯代码编写"><a href="#使用纯代码编写" class="headerlink" title="使用纯代码编写"></a><strong>使用纯代码编写</strong></h4><p>直接在 Qt Creator 中使用纯代码编写程序并编译运行。</p>
<ul>
<li><p><strong>第一步，新建空项目。</strong></p>
<p>打开 Qt Creator，并使用 <strong>Ctrl+Shift+N</strong> 快捷键新建项目，模板选择“<strong>其它项目</strong>”中的 <strong>Empty qmake Project</strong>。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702111404706.png" alt="image-20250702111404706"></p>
<p>然后将项目命名为 helloworld 并设置路径。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702111453105.png" alt="image-20250702111453105"></p>
<p>完成后，双击 helloworld.pro 文件，添加一行代码，并保存该文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702111558298.png" alt="image-20250702111558298"></p>
</li>
<li><p><strong>第二步，往项目中添加 main.cpp 文件。</strong></p>
<p>在编辑模式左侧的项目树形视图中的项目目录 helloworld 上右击，在弹出的级联菜单中选择“添加新文件”项（也可以在编辑模式直接按下 Ctrl +N 快捷键），在弹出的新建文件对话框选择 C&#x2F;C++ Source File 模板。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702111712666.png" alt="image-20250702111712666"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702111745137.png" alt="image-20250702111745137"></p>
<p>一路下一步即可。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702111815583.png" alt="image-20250702111815583"></p>
</li>
<li><p><strong>在 main.cpp 中编写源代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QDialog w;</span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">    label.<span class="built_in">setText</span>(<span class="string">&quot;Hello World! 你好Qt！&quot;</span>);</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>QApplication a(argc, argv);</code></strong></p>
<p>新建了QApplication类对象，用于管理应用程序的资源，任何一个Qt Widgets程序都要有一个QApplication对象。</p>
</li>
<li><p><strong><code>QDialog w;</code></strong></p>
<p>新建了一个QDialog对象，QDialog类用来实现一个对话框界面。</p>
</li>
<li><p><strong><code>QLabel label(&amp;w);</code></strong></p>
<p>新建了一个QLabel对象，并将QDialog对象作为参数，表明了对话框是它的父窗口。</p>
</li>
<li><p><strong><code>label.setText(&quot;Hello World! 你好Qt！&quot;);</code></strong></p>
<p>给标签设置要显示的字符。</p>
</li>
<li><p><strong><code>w.show();</code></strong></p>
<p>让对话框显示出来。</p>
</li>
<li><p><strong><code>return a.exec();</code></strong></p>
</li>
</ul>
<p>  让QApplication对象进入事件循环。</p>
<p><strong>效果：</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702113217709.png" alt="image-20250702113217709"></p>
<p><strong>改变对话框大小</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QDialog w;</span><br><span class="line">    w.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);		<span class="comment">//设置对话框宽度为400，高为300</span></span><br><span class="line">    <span class="function">QLabel <span class="title">label</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">    label.<span class="built_in">move</span>(<span class="number">120</span>, <span class="number">120</span>);<span class="comment">//设置label在对话框中的位置，默认左上角的(0,0)</span></span><br><span class="line">    label.<span class="built_in">setText</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;Hello World! 你好Qt！&quot;</span>));</span><br><span class="line">    <span class="comment">//添加的QObject::tr()函数可以实现多语言支持，建议程序中所有要显示到界面上的字符串都使用tr()函数括起来</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702113253119.png" alt="image-20250702113253119"></p>
</li>
</ul>
<hr>
<h4 id="使用其他编译器编写再通过命令行编译运行（太麻烦）"><a href="#使用其他编译器编写再通过命令行编译运行（太麻烦）" class="headerlink" title="使用其他编译器编写再通过命令行编译运行（太麻烦）"></a><strong>使用其他编译器编写再通过命令行编译运行</strong>（太麻烦）</h4><p>这种方法要求必须使用Qt自带的mingw64，否则会报兼容错误。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702115819875.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">:: 设置 Qt 自带 MinGW 优先(关键)</span><br><span class="line"><span class="built_in">set</span> PATH=I:\C\Qt\Tools\mingw1310_64\bin;%PATH%</span><br><span class="line"></span><br><span class="line">:: 验证工具链</span><br><span class="line">g++ --version</span><br><span class="line">:: 应显示 gcc 13.10 或类似版本</span><br><span class="line"></span><br><span class="line">:: 清理旧文件</span><br><span class="line">del Makefile* *.o *.exe /Q</span><br><span class="line"></span><br><span class="line">:: 生成项目文件</span><br><span class="line">qmake -project <span class="string">&quot;QT += core gui widgets&quot;</span></span><br><span class="line"></span><br><span class="line">:: 生成 Makefile</span><br><span class="line">qmake</span><br><span class="line"></span><br><span class="line">:: 编译项目</span><br><span class="line">mingw32-make</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一步，使用 vsCode 编写 main.cpp 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">剩下的代码直接复制上面的main.cpp。</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702115644608.png" alt="image-20250702115644608"></p>
</li>
<li><p>第二步，使用开始菜单的**Qt 6.x.x (MinGW x.x.x 64-bit)**命令行编译程序。</p>
<blockquote>
<p><strong>或者干脆直接用系统的cmd就行。</strong></p>
</blockquote>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702114050873.png" alt="image-20250702114050873"></p>
<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qmake -project</span><br><span class="line"><span class="comment">#或者使用下列的，这样就省得自己进文件补充</span></span><br><span class="line">qmake -project <span class="string">&quot;QT += core gui widgets&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702114738209.png" alt="image-20250702114738209"></p>
<p>生成 helloworld3.pro 文件</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702115721031.png" alt="image-20250702115721031"></p>
<p>在 helloworld3.pro 文件中填写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br></pre></td></tr></table></figure>

<p>继续在命令框中输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 Qt 自带 MinGW 优先</span></span><br><span class="line"><span class="built_in">set</span> PATH=I:\C\Qt\Tools\mingw1310_64\bin;%PATH%</span><br><span class="line">qmake</span><br><span class="line">mingw32-make</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702124032141.png" alt="image-20250702124032141"></p>
<p>生成：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702115839179.png" alt="image-20250702115839179"></p>
</li>
<li><p>第三步，运行程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> release</span><br><span class="line">helloworld.exe</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702124309965.png" alt="image-20250702124309965"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702124248760.png" alt="image-20250702124248760"></p>
</li>
</ul>
<p><strong>原理</strong>：</p>
<ul>
<li><strong>qmake是Qt提供的一个编译工具，它可以生成与平台无关的.pro文件，然后利用该文件生成与平台相关的Makefile文件。</strong><br><strong>Makefile文件中包含了要创建的目标文件或可执行文件、创建目标文件所依赖的文件和创建每个目标文件时需要运行的命令等信息。</strong></li>
<li><strong>最后使用mingw32-make工具来完成自动编译，mingw32-make就是通过读入Makefile文件的内容来执行编译工作的。</strong><br><strong>使用mingw32-make命令时会为每一个源文件生成一个对应的.o目标文件，最后将这些目标文件进行链接来生成最终的可执行文件。</strong></li>
<li><strong>qmake.exe工具在Qt安装目录的bin目录中，而mingw32-make.exe工具在MinGW编译器目录的bin目录中。</strong></li>
</ul>
<hr>
<h4 id="使用-ui-表单文件夹生成界面"><a href="#使用-ui-表单文件夹生成界面" class="headerlink" title="使用 .ui 表单文件夹生成界面"></a><strong>使用 .ui 表单文件夹生成界面</strong></h4><p>采用上个方法创建空白项目</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702125752025.png" alt="image-20250702125752025"></p>
<ul>
<li><p>第一步，创建 .ui 文件</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702130213973.png" alt="image-20250702130213973"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702130300686.png" alt="image-20250702130300686"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702130332445.png" alt="image-20250702130332445"></p>
<p>一路下一步即可。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702130405184.png" alt="image-20250702130405184"></p>
</li>
<li><p>第二步，设计界面。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702131357485.png" alt="image-20250702131357485"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702131646060.png" alt="image-20250702131646060"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702131809125.png" alt="image-20250702131809125"></p>
</li>
<li><p>第三步，借助ui表单文件生成界面。</p>
<p>ui 表单</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702132012571.png" alt="image-20250702132012571"></p>
<p>点击右下角的锤子，构建工程。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702132822656.png" alt="image-20250702132822656"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702132933568.png" alt="image-20250702132933568"></p>
<p>生成<strong>ui_hellodialog.h</strong></p>
<p><img src="/blog2025.github.io/image-20250702134609797.png" alt="image-20250702134609797"></p>
</li>
<li><p>第四步，编写 main.cpp 文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_hellodialog.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QDialog w;</span><br><span class="line">    Ui::HelloDialog ui;</span><br><span class="line">    ui.<span class="built_in">setupUi</span>(&amp;w);</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击运行，效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702135546039.png" alt="image-20250702135546039"></p>
</li>
</ul>
<p><strong>使用命令行编译ui界面</strong></p>
<ul>
<li><p>第一步，新建文件夹helloworld5，将上面项目的hellodialog.ui和main.cpp复制进去。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702135851629.png" alt="image-20250702135851629"></p>
</li>
<li><p>第二步，编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uic -o ui_hellodialog.h hellodialog.ui</span><br><span class="line"><span class="comment"># 生成ui_hellodialog.h</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qmake -project	<span class="comment">#生成.pro文件</span></span><br><span class="line"><span class="comment">#在.pro文件中添加</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">qmake</span><br><span class="line"><span class="comment"># 设置 Qt 自带 MinGW 优先(兼容问题)</span></span><br><span class="line"><span class="built_in">set</span> PATH=I:\C\Qt\Tools\mingw1310_64\bin;%PATH%</span><br><span class="line">mingw32-make</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> release</span><br><span class="line">helloworld5.exe</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702140523257.png" alt="image-20250702140523257"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702140534796.png" alt="image-20250702140534796"></p>
</li>
</ul>
<hr>
<h4 id="使用自定义C-窗口类"><a href="#使用自定义C-窗口类" class="headerlink" title="使用自定义C++窗口类"></a><strong>使用自定义C++窗口类</strong></h4><ul>
<li><p>第一步，创建空白Qt项目</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702142804883.png" alt="image-20250702142804883"></p>
<p>往.pro文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，添加文件。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702143013251.png" alt="image-20250702143013251"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702143109403.png" alt="image-20250702143109403"></p>
</li>
<li><p>第三步，添加main.cpp文件</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702143253346.png" alt="image-20250702143253346"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702143313953.png" alt="image-20250702143313953"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hellodialog.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    HelloDialog w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四步，将之前的hellodialog.ui文件复制到当前目录下，再在Qt Creator编辑器helloworld6上右击添加现有文件，将hellodialog.ui引入。</p>
</li>
<li><p>第五步，修改hellodialog.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLODIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLODIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了命名空间Ui，并在其中前置声明了HelloDialog类。</span></span><br><span class="line"><span class="keyword">namespace</span> Ui&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloDialog</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新定义的HelloDialog类，继承自QDialog类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloDialog</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Q_OBJECT宏，扩展了普通C++类的功能，比如信号和槽功能，注意必须在类定义最开始的私有部分添加这个宏。</span></span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//显式构造函数，参数是用来指定父窗口的，默认是没有父窗口。</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HelloDialog</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="comment">//析构函数。</span></span><br><span class="line">    ~<span class="built_in">HelloDialog</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::HelloDialog *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELLODIALOG_H</span></span></span><br></pre></td></tr></table></figure>

<p>修改hellodialog.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hellodialog.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_hellodialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">HelloDialog::<span class="built_in">HelloDialog</span>(QWidget *parent):<span class="built_in">QDialog</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui = <span class="keyword">new</span> Ui::HelloDialog;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);	<span class="comment">//设置setupUi()函数的参数为this，表示为现在这个类所代表的对话框创建界面。</span></span><br><span class="line">&#125;</span><br><span class="line">HelloDialog::~<span class="built_in">HelloDialog</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250702145211422.png" alt="image-20250702145211422"></p>
</li>
</ul>
<hr>
<h4 id="使用现成的Qt设计师界面类"><a href="#使用现成的Qt设计师界面类" class="headerlink" title="使用现成的Qt设计师界面类"></a><strong>使用现成的Qt设计师界面类</strong></h4><p>省略。。。</p>
<hr>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><strong>上述的过程，只是让理解；实际开发，老老实实采用<a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">创建项目</a></strong></p>
<p>默认的创建，会把所有需要的都给准备好，省的自己麻烦。</p>
<hr>
<hr>
<h2 id="第一个-Qt-Quick-应用"><a href="#第一个-Qt-Quick-应用" class="headerlink" title="第一个 Qt Quick 应用"></a>第一个 Qt Quick 应用</h2><p>Qt Quick 可以像HTML代码一样声明界面，后端使用C++代码。</p>
<h3 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703080208368.png" alt="image-20250703080208368"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703080251360.png" alt="image-20250703080251360"></p>
<p>剩下的默认下一步即可，如果有选择构建系统时，默认选择<strong>CMake</strong>。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703080427331.png" alt="image-20250703080427331"></p>
<hr>
<h3 id="创建Quick应用（qmake）"><a href="#创建Quick应用（qmake）" class="headerlink" title="创建Quick应用（qmake）"></a>创建Quick应用（qmake）</h3><ul>
<li><p>第一步，使用快捷键<strong>Ctrl+Shift+N</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703080820185.png" alt="image-20250703080820185"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703080849592.png" alt="image-20250703080849592"></p>
<p>默认下一步即可。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703080947235.png" alt="image-20250703080947235"></p>
<p>在**.pro**文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += quick</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，使用快捷键 <strong>Ctrl+N</strong> 添加 <strong>main.qml</strong> 文件</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703081147629.png" alt="image-20250703081147629"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703081220543.png" alt="image-20250703081220543"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703081241543.png" alt="image-20250703081241543"></p>
<p>修改<strong>main.qml</strong>文件</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.15</span></span><br><span class="line"></span><br><span class="line"><span class="title">Window</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">640</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">480</span></span><br><span class="line">    <span class="attribute">visible</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attribute">title</span>: qsTr(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title">Text</span> &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> text1</span></span><br><span class="line">        <span class="attribute">text</span>: qsTr(<span class="string">&quot;HEllo World! 你好QT！&quot;</span>)</span><br><span class="line">        <span class="attribute">anchors.centerIn</span>: <span class="built_in">parent</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703081954439.png" alt="image-20250703081954439"></p>
</li>
<li><p>第三步，使用快捷键 <strong>Ctrl+N</strong>，添加 <strong>main.cpp</strong> 文件，</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703082223181.png" alt="image-20250703082223181"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703082245878.png" alt="image-20250703082245878"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703082309077.png" alt="image-20250703082309077"></p>
<p>修改 <strong>main.cpp</strong> 文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQmlApplicationEngine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QQmlApplicationEngine engine;</span><br><span class="line">    engine.<span class="built_in">load</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;../../main.qml&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703083723796.png" alt="image-20250703083723796"></p>
</li>
<li><p>第四步，运行项目：快捷键<strong>Ctrl+R</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703083807157.png" alt="image-20250703083807157"></p>
</li>
</ul>
<hr>
<h3 id="Qt-资源文件"><a href="#Qt-资源文件" class="headerlink" title="Qt 资源文件"></a>Qt 资源文件</h3><p>Qt中的资源系统（The Qt Resource System）是一个独立于平台的机制，可以将资源文件打包到应用程序可执行文件中，并且使用特定的路径来访问它们。如果在应用程序中经常使用一些文件（例如图标、翻译文件、图片等），而且不想使用系统特定的方式来打包和定位这些资源，那么就可以将它们放入资源文件中。</p>
<ul>
<li><p>第一步，在helloworld2项目中添加新文件夹images，并放入一张测试图片logo.png。</p>
<p><strong>Ctrl+N</strong> 添加新文件</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703085100434.png" alt="image-20250703085100434"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703085249477.png" alt="image-20250703085249477"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703085455605.png" alt="image-20250703085455605"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703090122712.png" alt="image-20250703090122712"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703090143922.png" alt="image-20250703090143922"></p>
</li>
<li><p>第二步，通过 <strong>main.qml</strong> 代码使用图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 640</span><br><span class="line">    height: 480</span><br><span class="line">    visible: true</span><br><span class="line">    title: qsTr(&quot;Hello World&quot;)</span><br><span class="line"></span><br><span class="line">    Text &#123;</span><br><span class="line">        id: text1</span><br><span class="line">        text: qsTr(&quot;HEllo World! 你好QT！&quot;)</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Image &#123;</span><br><span class="line">        id: logo</span><br><span class="line">        width :100</span><br><span class="line">        height: 100</span><br><span class="line">        source: &quot;qrc:/images/test.png&quot;</span><br><span class="line">        anchors.horizontalCenter: text1.horizontalCenter</span><br><span class="line">        anchors.top: text1.bottom</span><br><span class="line">        anchors.topMargin: 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703091138789.png" alt="image-20250703091138789"></p>
</li>
<li><p>第三步，继续创建新的qml文件，自动关联到资源文件。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703091357380.png" alt="image-20250703091357380"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703091420220.png" alt="image-20250703091420220"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703091533219.png" alt="image-20250703091533219"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703091647726.png" alt="image-20250703091647726"></p>
<p>修改<strong>MyText.qml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick</span><br><span class="line"></span><br><span class="line">Text &#123;</span><br><span class="line">        text: qsTr((&quot;欢迎使用！！！&quot;))</span><br><span class="line">        color: &quot;green&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<strong>main.qml</strong>文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 640</span><br><span class="line">    height: 480</span><br><span class="line">    visible: true</span><br><span class="line">    title: qsTr(&quot;Hello World&quot;)</span><br><span class="line"></span><br><span class="line">    Text &#123;</span><br><span class="line">        id: text1</span><br><span class="line">        text: qsTr(&quot;HEllo World! 你好QT！&quot;)</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Image &#123;</span><br><span class="line">        id: logo</span><br><span class="line">        width :100</span><br><span class="line">        height: 100</span><br><span class="line">        source: &quot;qrc:/images/test.png&quot;</span><br><span class="line">        anchors.horizontalCenter: text1.horizontalCenter</span><br><span class="line">        anchors.top: text1.bottom</span><br><span class="line">        anchors.topMargin: 10</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyText&#123;</span><br><span class="line">        anchors.top: logo.bottom</span><br><span class="line">        anchors.horizontalCenter: logo.horizontalCenter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703092011407.png" alt="image-20250703092011407"></p>
</li>
</ul>
<p><strong>注意：实际编程中一般需要将所有.qml文件都放到资源文件中。</strong></p>
<p><strong>在项目树形视图中resource.qrc文件上右击，在弹出的级联菜单中选择“用…打开→资源编辑器”菜单项，然后通过“添加文件”按钮将main.qml文件添加进来，按下Ctrl+S保存修改。</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703092142033.png" alt="image-20250703092142033"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703092217575.png" alt="image-20250703092217575"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703092227727.png" alt="image-20250703092227727"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703092433219.png" alt="image-20250703092433219"></p>
<p><strong>然后打开main.cpp文件，将加载QML文件的代码修改为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine.load(QUrl(&quot;qrc:/main.qml&quot;));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="项目的发布-1"><a href="#项目的发布-1" class="headerlink" title="项目的发布"></a>项目的发布</h3><p><strong>首先需要使用Release方式编译程序，然后将生成的.exe可执行文件和需要的库文件放在一起打包进行发布。</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703092611005.png" alt="image-20250703092611005"></p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p><strong>要确定发布时需要哪些动态库文件，可以直接双击.exe文件，提示缺少哪个dll文件，就到Qt安装目录的bin目录中将该dll文件复制过来。</strong></p>
<p>类似于上面的widget项目的发布：<a href="#%E6%96%B9%E6%B3%95%E4%B8%80"><strong>方法一</strong></a></p>
<p>本地计算机如果设置了环境变量则直接就能运行</p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p><strong>使用windeployqt.exe工具。</strong></p>
<p>首先对helloworld程序进行<strong>Release版本的编译</strong>，然后将生成的helloworld.exe<strong>复制</strong>到要发布的<strong>新建文件夹</strong>中，然后在新建文件夹中cmd，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">windeployqt  --qmldir  E:\app\src\02\2-7\helloworld  D:\myapp</span><br><span class="line"><span class="comment"># 对于使用了QML文件的程序，需要使用--qmldir指定项目中QML文件的路径，最后是可执行文件所在的目录路径。</span></span><br><span class="line"><span class="comment"># 即</span></span><br><span class="line">windeployqt --qmldir .qml文件所在源文件夹路径 .exe文件所在新建文件夹路径</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703094046795.png" alt="image-20250703094046795"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703094104298.png" alt="image-20250703094104298"></p>
<hr>
<h3 id="创建Qt-Quick-UI项目"><a href="#创建Qt-Quick-UI项目" class="headerlink" title="创建Qt Quick UI项目"></a>创建Qt Quick UI项目</h3><p>有些时候可能只想测试QML相关内容，希望可以快速显示界面效果，这时可以创建Qt Quick UI项目，该项目中只包含QML和JavaScript代码，没有添加任何C++代码。对于QML文件，无需编译就可以直接在预览工具中显示界面效果。</p>
<ul>
<li><p>使用快捷键<strong>Ctrl+Shift+N</strong>快捷键创建新项目。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703094650178.png" alt="image-20250703094650178"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703094719458.png" alt="image-20250703094719458"></p>
<p>默认下一步即可。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703094759928.png" alt="image-20250703094759928"></p>
<ul>
<li><p><strong>helloqml.qmlproject</strong>：项目文件，其中包含配置信息，包括QML、JavaScript和图片等文件所在的目录。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703095129676.png" alt="image-20250703095129676"></p>
</li>
<li><p>按下<strong>Ctrl+R</strong>快捷键，程序会立即运行并显示界面，查看下面的编译输出窗口和应用程序输出窗口，可以看到，项目并没有编译，而只是启动了<strong>qml.exe</strong>工具。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703095227144.png" alt="image-20250703095227144"></p>
<p>这就是说，单独的QML文件并不需要进行编译，就能够直接进行预览。</p>
<p>效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703100619152.png" alt="image-20250703100619152"></p>
</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h3 id="使用Qt-Quick设计器"><a href="#使用Qt-Quick设计器" class="headerlink" title="使用Qt Quick设计器"></a>使用Qt Quick设计器</h3><p>Qt Quick项目也有相应的Qt Quick Designer设计器，只是它作为插件，在现在的版本中没有默认开启。可以通过**“帮助→关于插件”**菜单项打开已安装的插件对话框，然后在其中勾选QmlDesigner项，完成后重启Qt Creator即可。读者可以自行开启测试效果。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703095454398.png" alt="image-20250703095454398"></p>
<hr>
<hr>
<h3 id="QML语法基础"><a href="#QML语法基础" class="headerlink" title="QML语法基础"></a>QML语法基础</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick		</span><br><span class="line"></span><br><span class="line">Rectangle &#123;</span><br><span class="line">    id: root</span><br><span class="line">    width: 400</span><br><span class="line">    height: 400</span><br><span class="line">    color: &quot;blue&quot;</span><br><span class="line"></span><br><span class="line">    Image &#123;</span><br><span class="line">        source: &quot;pics/logo.png&quot;</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>import QtQuick</code>：导入<strong>QtQuick</strong>模块，其包含各种<strong>QML</strong>类型。</p>
</li>
<li><p><strong>对象（object）和属性（property）</strong></p>
<ul>
<li><p>QML文档就是一个QML对象树。在这段代码中，创建了两个对象，分别是<strong>Rectangle根对象</strong>及其<strong>子对象Image</strong>。</p>
</li>
<li><p>QML对象通过对象声明来定义，对象声明由对象类型（type）的名称和一对大括号组成，括号中包含了对象的特性定义，比如这个对象的<strong>id、属性值</strong>等，还可以使用嵌套对象声明的方式来声明子对象。</p>
</li>
<li><p>一个对象声明一般都会在<strong>开始指定一个id</strong>，可以通过它在其他对象中识别并<strong>引用</strong>该对象，其值在一个组件的作用域中必须是唯一的。id看起来像是一个属性，但id特性并不是一个属性。<strong>（如：root.bottom：渲染到root的下方）</strong></p>
</li>
<li><p>一般对象都会指定具体的属性值，例如矩形要设置宽、高、颜色等，这里Rectangle对象定义了width、height和color等属性。</p>
</li>
<li><p>属性通过“属性：值”语法进行初始化，属性和它的值使用一个冒号隔开。属性可以分行写，此时，每行末尾的分号不是必须的。也可以将多个属性写在一行，它们之间必须使用分号分隔。</p>
</li>
</ul>
</li>
<li><p><strong>布局</strong></p>
<p>Image的<strong>anchors.centerIn</strong>起到了布局的作用。它会使Image处于一个对象的<strong>中心</strong>位置，比如这里就是处于其parent父对象即Rectangle的中心。除了anchors，QML还提供了很多其它布局方式。</p>
</li>
<li><p><strong>注释</strong></p>
<p><strong>QML的注释和C++是相似的：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*多行注释*/</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>表达式和属性绑定</strong></p>
<p>JavaScript表达式可以用于设置属性的值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span> * <span class="number">3</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">50</span> + <span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这些表达式中可以包含其它对象或属性的引用，这样做便创建了一个绑定：</p>
<p>当表达式的值改变时，以该表达式为值的属性会自动更新为新的值。</p>
<p>例如：<strong>Rectangle对象的width属性</strong>被设置为与它的<strong>父对象的width属性</strong>相关，只要父对象的width属性发生改变，Rectangle的width就会自动更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">300</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">300</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">        <span class="attr">width</span>: parent.<span class="property">width</span> - <span class="number">50</span></span><br><span class="line">        <span class="attr">height</span>: <span class="number">100</span></span><br><span class="line">        <span class="attr">color</span>: <span class="string">&quot;yellow&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<hr>
<h2 id="设置应用程序图标"><a href="#设置应用程序图标" class="headerlink" title="设置应用程序图标"></a>设置应用程序图标</h2><p>将 <strong>.ico</strong> 文件复制到项目的源码目录中。<font color="red"><strong>要求与.pro文件同级</strong></font></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703102452921.png" alt="image-20250703102452921"></p>
<p>在.pro文件中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RC_ICONS = favicon.ico</span><br></pre></td></tr></table></figure>

<p>运行项目：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703102526302.png" alt="image-20250703102526302"></p>
<hr>
<hr>
<h2 id="Qt-Widgets窗口部件"><a href="#Qt-Widgets窗口部件" class="headerlink" title="Qt Widgets窗口部件"></a>Qt Widgets窗口部件</h2><ul>
<li><p>对于Qt Widgets程序来说，<strong>窗口部件</strong>（Widgets）是图形用户界面（GUI）应用程序的基本构建块，而QWidget是所有窗口部件的基类。</p>
</li>
<li><p>对于Qt Quick程序，Qt Quick Controls模块提供了一组丰富的<strong>UI控件</strong>，基本覆盖了最常见的用例，可用于构建完整的应用界面。</p>
</li>
</ul>
<h3 id="QWidget-基础窗口部件"><a href="#QWidget-基础窗口部件" class="headerlink" title="QWidget 基础窗口部件"></a>QWidget 基础窗口部件</h3><p><strong>所有的窗口部件都继承自QWidget</strong></p>
<p>QWidget类是所有用户界面类的基类，被称为基础窗口部件，继承自QObject类和QPaintDevice类。</p>
<p>其中，QObject类是所有支持Qt对象模型的对象的基类，QPaintDevice类是所有可以绘制的对象的基类。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_3-7-2025_103745_.jpeg" alt="屏幕截图_3-7-2025_103745_"></p>
<ul>
<li><p>窗口部件是Qt中建立用户界面的主要元素。像主窗口、对话框、标签、还有以后要介绍到的按钮、文本输入框等都是窗口部件。这些部件可以接收用户输入，显示数据和状态信息，并且在屏幕上绘制自己。有些也可以作为一个容器来放置其他部件。</p>
</li>
<li><p>Qt中把没有嵌入到其他部件中的部件称为窗口，一般窗口都有边框和标题栏。QMainWindow和大量的QDialog子类是最一般的窗口类型。窗口是没有父部件的部件，所以又称为顶级部件（top-level widget）。</p>
</li>
<li><p>与其相对的是非窗口部件，又称为子部件（child widget）。在Qt中大部分部件被用作子部件，嵌入在别的窗口中。</p>
</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703104406206.png" alt="image-20250703104406206"></p>
<hr>
<h4 id="窗口与子窗口"><a href="#窗口与子窗口" class="headerlink" title="窗口与子窗口"></a>窗口与子窗口</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QWidget *widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>();       <span class="comment">// 新建QWidget类对象，默认parent参数是nullptr，所以它是个窗口</span></span><br><span class="line">    widget-&gt;<span class="built_in">setWindowTitle</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;我是widget&quot;</span>));      <span class="comment">// 设置窗口标题</span></span><br><span class="line"></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>();        <span class="comment">// 新建QLabel对象，默认parent参数是nullptr，所以它是个窗口</span></span><br><span class="line">    label-&gt;<span class="built_in">setWindowTitle</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;我是label&quot;</span>));</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;label:我是个窗口&quot;</span>));        <span class="comment">// 设置要显示的信息</span></span><br><span class="line">    label-&gt;<span class="built_in">resize</span>(<span class="number">180</span>, <span class="number">20</span>);        <span class="comment">// 改变部件大小，以便能显示出完整的内容</span></span><br><span class="line"></span><br><span class="line">    QLabel *label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(widget);         <span class="comment">// label2指定了父窗口为widget，所以不是窗口</span></span><br><span class="line">    label2-&gt;<span class="built_in">setText</span>(QObject::<span class="built_in">tr</span>(<span class="string">&quot;label2:我不是独立窗口，只是widget的子部件&quot;</span>));</span><br><span class="line">    label2-&gt;<span class="built_in">resize</span>(<span class="number">250</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    label-&gt;<span class="built_in">show</span>();    <span class="comment">// 在屏幕上显示出来</span></span><br><span class="line">    widget-&gt;<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703105455003.png" alt="image-20250703105455003"></p>
<p><strong>改良的完整代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口（没有父对象，所以是独立窗口）</span></span><br><span class="line">    QWidget *widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line">    widget-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;我是widget&quot;</span>);</span><br><span class="line">    widget-&gt;<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>); <span class="comment">// 设置窗口大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建独立标签窗口（没有父对象，所以是独立窗口）</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">    label-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;我是label&quot;</span>);</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;label: 我是个独立窗口&quot;</span>);</span><br><span class="line">    label-&gt;<span class="built_in">resize</span>(<span class="number">250</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子部件（指定父窗口为widget，所以是子部件）</span></span><br><span class="line">    QLabel *label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(widget);</span><br><span class="line">    label2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;label2: 我是widget的子部件&quot;</span>);</span><br><span class="line">    label2-&gt;<span class="built_in">resize</span>(<span class="number">250</span>, <span class="number">30</span>);</span><br><span class="line">    label2-&gt;<span class="built_in">move</span>(<span class="number">25</span>, <span class="number">70</span>); <span class="comment">// 在父窗口中的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    widget-&gt;<span class="built_in">show</span>();</span><br><span class="line">    label-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703105355816.png" alt="image-20250703105355816"></p>
<hr>
<h4 id="窗口类型"><a href="#窗口类型" class="headerlink" title="窗口类型"></a>窗口类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">QWidget</span>(QWidget *parent = <span class="literal">nullptr</span>, Qt::WindowFlags f = Qt::<span class="built_in">WindowFlags</span>())</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>parent</code></strong>：父窗口部件，默认值为nullptr，表明没有父窗口；</p>
</li>
<li><p><strong><code>f</code></strong>：该参数是<code>Qt::WindowFlags</code>类型的，它是<code>Qt::WindowType</code>枚举类型值的按位或组合。</p>
<p><code>Qt::WindowType</code>枚举类型用来为部件指定各种窗口系统属性，</p>
<p>比如<code>f=0</code>表明窗口类型的值为<code>Qt::Widget</code>，这是<strong>QWidget</strong>的默认类型，这种类型的部件如果有父窗口，那么它就是子部件，否则就是独立窗口。</p>
<p><strong><code>Qt::WindowFlags</code>可以是多个窗口类型枚举值进行按位或操作：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QWidget *widget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(<span class="literal">nullptr</span>,Qt::Dialog | Qt::FramelessWindowHint);</span><br><span class="line"></span><br><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="literal">nullptr</span>,Qt::SplashScreen | Qt::WindowStaysOnTopHint);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>QWidget</strong>中还有一个<code>setWindowState()</code>函数用来设置窗口的状态，其参数由<code>Qt::WindowStates</code>指定，是<code>Qt::WindowState</code>枚举类型值的按位或组合。</p>
<p><code>Qt::WindowState</code>包括：</p>
<ul>
<li>最大化<code>Qt::WindowMaximized</code></li>
<li>最小化<code>Qt::WindowMinimized</code></li>
<li>全屏显示<code>Qt::WindowFullScreen</code></li>
<li>活动窗口<code>Qt::WindowActive</code>等</li>
<li>默认值为正常状态<code>Qt::WindowNoState</code>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h4><p>对于窗口的大小和位置，根据是否包含边框和标题栏两种情况，要用不同的函数来获取。这里的函数分为两类，一类是<strong>包含框架</strong>的，一类是<strong>不包含框架</strong>的：</p>
<ul>
<li>包含框架：<code>x()</code>、<code>y()</code>、<code>frameGeometry()</code>、<code>pos()</code>和<code>move()</code>等函数；</li>
<li>不包含框架：<code>geometry()</code>、<code>width()</code>、<code>height()</code>、<code>rect()</code>和<code>size()</code>等函数。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703110425968.png" alt="image-20250703110425968"></p>
<hr>
<h4 id="QFrame-类族"><a href="#QFrame-类族" class="headerlink" title="QFrame 类族"></a>QFrame 类族</h4><p>QFrame类是带有边框的部件的基类。</p>
<p>它的子类包括部分：</p>
<ul>
<li>标签部件<strong>QLabel</strong></li>
<li><strong>QLCDNumber</strong></li>
<li><strong>QSplitter</strong></li>
<li><strong>QStackedWidget</strong></li>
<li><strong>QToolBox</strong></li>
<li><strong>QAbstractScrollArea</strong>：<ul>
<li>所有带有滚动区域的部件类的抽象基类。</li>
<li>其子类中包含常用的文本编辑器<strong>QTextEdit</strong>类和各种项目视图类。</li>
</ul>
</li>
</ul>
<p><strong>QFrame</strong>类的一项主要功能就是用来实现不同的边框效果，这主要是由边框形状（Shape）和边框阴影（Shadow）组合来形成的。</p>
<p><strong>QFrame</strong>类中定义的主要边框形状包括部分：</p>
<ul>
<li><strong><code>QFrame::Box</code></strong></li>
<li><strong><code>QFrame::Panel</code></strong></li>
<li><strong><code>QFrame::StyledPanel</code></strong></li>
<li><strong><code>QFrame::HLine</code></strong></li>
<li><strong><code>QFrame::VLine</code></strong></li>
<li><strong><code>QFrame::WinPanel</code></strong></li>
</ul>
<p>边框阴影主要包括部分：</p>
<ul>
<li><strong><code>QFrame::Plain</code></strong></li>
<li><strong><code>QFrame::Raised</code></strong></li>
<li><strong><code>QFrame::Sunken</code></strong></li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703110927994.png" alt="image-20250703110927994"></p>
<h5 id="示例一："><a href="#示例一：" class="headerlink" title="示例一："></a><strong>示例一：</strong></h5><p>在设计模式从部件列表里拖入一个Frame到界面上，然后在右下方的<strong>属性编辑器</strong>中更改其<strong>frameShape</strong>为Box，<strong>frameShadow</strong>为Sunken，<strong>lineWidth</strong>为5，<strong>midLineWidth</strong>为10。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703111440374.png" alt="image-20250703111440374"></p>
<p>也可以通过代码进行设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;frame-&gt;<span class="built_in">setFrameShape</span>(QFrame::Box);</span><br><span class="line">ui-&gt;frame-&gt;<span class="built_in">setFrameShadow</span>(QFrame::Sunken);</span><br><span class="line">ui-&gt;frame-&gt;<span class="built_in">setLineWidth</span>(<span class="number">5</span>);</span><br><span class="line">ui-&gt;frame-&gt;<span class="built_in">setMidLineWidth</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFrame&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QFrame 简单示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建QFrame并设置样式</span></span><br><span class="line">    QFrame *frame = <span class="keyword">new</span> <span class="built_in">QFrame</span>(&amp;window);</span><br><span class="line">    frame-&gt;<span class="built_in">setGeometry</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">100</span>); <span class="comment">// 位置和大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置框架样式（核心代码）</span></span><br><span class="line">    frame-&gt;<span class="built_in">setFrameShape</span>(QFrame::Box);      <span class="comment">// 方框形状</span></span><br><span class="line">    frame-&gt;<span class="built_in">setFrameShadow</span>(QFrame::Sunken);  <span class="comment">// 凹陷阴影效果</span></span><br><span class="line">    frame-&gt;<span class="built_in">setLineWidth</span>(<span class="number">5</span>);                 <span class="comment">// 边框宽度</span></span><br><span class="line">    frame-&gt;<span class="built_in">setMidLineWidth</span>(<span class="number">10</span>);             <span class="comment">// 中线宽度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703112405685.png" alt="image-20250703112405685"></p>
<p>改善后的完整代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFrame&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QFrame 样式设置示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建垂直布局</span></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建标题标签</span></span><br><span class="line">    QLabel *title = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;QFrame::Box 与 QFrame::Sunken 样式&quot;</span>);</span><br><span class="line">    title-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    title-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QLabel &#123; font-size: 18px; font-weight: bold; margin: 10px; &#125;&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(title);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建QFrame并设置样式</span></span><br><span class="line">    QFrame *frame = <span class="keyword">new</span> <span class="built_in">QFrame</span>();</span><br><span class="line">    frame-&gt;<span class="built_in">setFrameShape</span>(QFrame::Box);</span><br><span class="line">    frame-&gt;<span class="built_in">setFrameShadow</span>(QFrame::Sunken);</span><br><span class="line">    frame-&gt;<span class="built_in">setLineWidth</span>(<span class="number">5</span>);</span><br><span class="line">    frame-&gt;<span class="built_in">setMidLineWidth</span>(<span class="number">10</span>);</span><br><span class="line">    frame-&gt;<span class="built_in">setMinimumSize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在框架内添加标签</span></span><br><span class="line">    QLabel *frameLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(frame);</span><br><span class="line">    frameLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;这是一个带有边框的框架\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;FrameShape: Box\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;FrameShadow: Sunken\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;LineWidth: 5\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;MidLineWidth: 10&quot;</span>);</span><br><span class="line">    frameLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    frameLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QLabel &#123; font-size: 14px; &#125;&quot;</span>);</span><br><span class="line">    frameLabel-&gt;<span class="built_in">setGeometry</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">260</span>, <span class="number">110</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加框架到布局</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(frame, <span class="number">0</span>, Qt::AlignCenter);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加说明标签</span></span><br><span class="line">    QLabel *description = <span class="keyword">new</span> <span class="built_in">QLabel</span>();</span><br><span class="line">    description-&gt;<span class="built_in">setText</span>(<span class="string">&quot;QFrame样式说明：\n&quot;</span></span><br><span class="line">                         <span class="string">&quot;- Box: 围绕内容绘制一个方框\n&quot;</span></span><br><span class="line">                         <span class="string">&quot;- Sunken: 使框架看起来凹陷\n&quot;</span></span><br><span class="line">                         <span class="string">&quot;- LineWidth: 边框宽度\n&quot;</span></span><br><span class="line">                         <span class="string">&quot;- MidLineWidth: 中线宽度（在Box形状中可见）&quot;</span>);</span><br><span class="line">    description-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QLabel &#123; font-size: 14px; margin: 15px; &#125;&quot;</span>);</span><br><span class="line">    description-&gt;<span class="built_in">setAlignment</span>(Qt::AlignLeft);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(description);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703112254166.png" alt="image-20250703112254166"></p>
<hr>
<h5 id="示例二："><a href="#示例二：" class="headerlink" title="示例二："></a>示例二：</h5><p>标签QLabel部件用来显示文本或者图片。在设计器中向界面拖入一个Label，并在属性编辑器中设置其宽度为170，高度为30。然后修改font属性对字体进行设置。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703112808703.png" alt="image-20250703112808703"></p>
<p>也可以通过代码进行设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QFont font;</span><br><span class="line">font.<span class="built_in">setFamily</span>(<span class="string">&quot;华文行楷&quot;</span>);</span><br><span class="line">font.<span class="built_in">setPointSize</span>(<span class="number">10</span>);</span><br><span class="line">font.<span class="built_in">setBold</span>(<span class="literal">true</span>);</span><br><span class="line">ui-&gt;label-&gt;<span class="built_in">setFont</span>(font);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFont&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;字体设置示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建标签</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(&amp;window);</span><br><span class="line">    label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;这是一个设置字体的标签&quot;</span>);</span><br><span class="line">    label-&gt;<span class="built_in">setGeometry</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">50</span>); <span class="comment">// 位置和大小</span></span><br><span class="line">    label-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter); <span class="comment">// 文本居中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置字体属性（核心代码）</span></span><br><span class="line">    QFont font;</span><br><span class="line">    font.<span class="built_in">setFamily</span>(<span class="string">&quot;华文行楷&quot;</span>);  <span class="comment">// 设置字体为华文行楷</span></span><br><span class="line">    font.<span class="built_in">setPointSize</span>(<span class="number">15</span>);       <span class="comment">// 设置字体大小为15</span></span><br><span class="line">    font.<span class="built_in">setBold</span>(<span class="literal">true</span>);          <span class="comment">// 设置为粗体</span></span><br><span class="line">    label-&gt;<span class="built_in">setFont</span>(font);        <span class="comment">// 应用字体到标签</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703113135346.png" alt="image-20250703113135346"></p>
<hr>
<h5 id="示例三："><a href="#示例三：" class="headerlink" title="示例三："></a>示例三：</h5><p>QLabel部件用来显示图片，只需要指定路径即可：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703113605700.png" alt="image-20250703113605700"></p>
<p>这里的pixmap有两者选择，直接获取文件，或者先[**添加resource.qrc**](#Qt 资源文件)再获取文件。</p>
<p>也可以通过代码进行设置：</p>
<p>要求先<strong>添加resource.qrc</strong>再操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;label-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;../logo.png&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFont&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;插入图片示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">500</span>, <span class="number">450</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建标签</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(&amp;window);</span><br><span class="line">    label-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:images/test.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703114923880.png" alt="image-20250703114923880"></p>
<hr>
<h4 id="按钮组件"><a href="#按钮组件" class="headerlink" title="按钮组件"></a>按钮组件</h4><p><strong>QAbstractButton</strong>类是按钮部件的抽象基类，提供了按钮的通用功能。它的子类包括：</p>
<ul>
<li>复选框<strong>QCheckBox</strong></li>
<li>标准按钮<strong>QPushButton</strong></li>
<li>单选框按钮<strong>QRadioButton</strong></li>
<li>工具按钮<strong>QToolButton</strong></li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703115432356.png" alt="image-20250703115432356"></p>
<p>按钮最常见的应用就是通过单击或双击来实现一些功能，在Qt中，这种应用是通过<font color="red"><strong>信号和槽</strong></font>的机制来实现的。</p>
<ul>
<li><p>首先在设计模式向主界面上拖入<strong>Push Button</strong>按钮部件。然后在按钮上右击，在弹出的级联菜单中选择**“转到槽”<strong>，然后在弹出的转到槽对话框中选择</strong>toggled(bool)**信号。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703115648399.png" alt="image-20250703115648399"></p>
</li>
<li><p>这时会自动切换到编辑模式并添加该信号对应的槽函数<code>on_pushBtn1_toggled(bool checked)</code></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703120325241.png" alt="image-20250703120325241"></p>
<p>下面在其中添加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_toggled</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;按钮是否按下：&quot;</span>) &lt;&lt; checked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到设计界面，勾选checkable</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703120810288.png" alt="image-20250703120810288"></p>
</li>
<li><p>运行，点击按钮</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703121026551.png" alt="image-20250703121026551"></p>
</li>
<li><p>或者直接代码层面解决checkable问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键步骤1：将按钮设置为可检查（checkable）</span></span><br><span class="line">    ui-&gt;pushButton-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键步骤2：确保按钮名称匹配（可选检查）</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;按钮对象名称:&quot;</span> &lt;&lt; ui-&gt;pushButton-&gt;<span class="built_in">objectName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：设置按钮文本以显示状态</span></span><br><span class="line">    ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;点击我&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_toggled</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 关键步骤3：使用qDebug输出调试信息</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;按钮是否按下：&quot;</span> &lt;&lt; checked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：在按钮上显示状态</span></span><br><span class="line">    <span class="keyword">if</span>(checked) &#123;</span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;已按下&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;已释放&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：添加其他视觉反馈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(checked) &#123;</span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: green;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="QLineEdit"><a href="#QLineEdit" class="headerlink" title="QLineEdit"></a>QLineEdit</h4><p>行编辑器<strong>QLineEdit</strong>部件是一个单行的文本编辑器，它允许用户输入和编辑单行的纯文本内容，而且提供了一系列有用的功能，包括撤销与恢复、剪切和拖放等操作。</p>
<p>其中，剪切复制等功能是行编辑自带的，不用自己编码实现。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703121535646.png" alt="image-20250703121535646"></p>
<ul>
<li><p>显示模式：</p>
<p><strong>QLineEdit</strong>有4种显示模式（echoMode），可以通过echoMode属性更改它们：</p>
<ul>
<li><strong>Normal</strong>正常显示输入的信息；</li>
<li><strong>NoEcho</strong>不显示任何输入，这样可以保证不泄露输入的字符位数；</li>
<li><strong>Password</strong>显示为密码样式，就是以小黑点或星号之类的字符代替输入的字符；</li>
<li><strong>PasswordEchoOnEdit</strong>在编辑时显示正常字符，其他情况下显示为密码样式。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703121633815.png" alt="image-20250703121633815"></p>
</li>
<li><p>输入掩码：</p>
<p><strong>QLineEdit</strong>提供了输入掩码（setInputMask()）来限制输入的内容。</p>
<p>可以使用一些特殊的字符来设置输入的格式和内容，这些字符中有的起限制作用且必须要输入一个字符，有的只是起限制作用，但可以不输入字符而是以空格代替。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703121827103.png" alt="image-20250703121827103"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：“&gt;AA-90-bb-!aa\#H;*”，它表示的含义为：</span><br><span class="line">“&gt;”号表明后面输入的字母自动转为大写；</span><br><span class="line">“AA”表明开始必须输入两个字母，因为有前面的“&gt;”号的作用，所以输入的这两个字母会自动变为大写；</span><br><span class="line">“-”号为分隔符，直接显示，该位不可输入；</span><br><span class="line">“9”表示必须输入一个数字；</span><br><span class="line">“0”表示输入一个数字，或者留空；</span><br><span class="line">“bb”表示这两位可以留空，或者输入两个二进制字符，即0或1；</span><br><span class="line">“！”表明停止大小写转换，就是在最开始的“&gt;”号不再起作用；</span><br><span class="line">“aa”表示可以留空，或者输入两个字母；</span><br><span class="line">“\#”表示将“#”号作为分隔符，因为“#”号在这里有特殊含义，所以前面要加上“\”号；</span><br><span class="line">“H”表明必须输入一个十六进制的字符；</span><br><span class="line">“;*”表示用“*”号来填充空格。</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入验证：</p>
<p><strong>QLineEdit</strong>中可以使用验证器（validator）来对输入进行约束。还可以使用正则表达式来设置更强大的字符约束。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建验证器，指定范围为100~999</span></span><br><span class="line">QValidator *validator = <span class="keyword">new</span> <span class="built_in">QIntValidator</span>(<span class="number">100</span>, <span class="number">999</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 在行编辑器中使用验证器</span></span><br><span class="line">ui-&gt;lineEdit3-&gt;<span class="built_in">setValidator</span>(validator);</span><br></pre></td></tr></table></figure>

<p>使用正则表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRegularExpression <span class="title">rx</span><span class="params">(<span class="string">&quot;-?\\d&#123;1,3&#125;&quot;</span>)</span></span>;</span><br><span class="line">QValidator *validator = <span class="keyword">new</span> <span class="built_in">QRegularExpressionValidator</span>(rx, <span class="keyword">this</span>);</span><br><span class="line">ui-&gt;lineEdit3-&gt;<span class="built_in">setValidator</span>(validator);</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QIntValidator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QLineEdit验证器示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建垂直布局</span></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加说明标签</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;请输入100-999之间的整数:&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建带有验证器的行编辑器</span></span><br><span class="line">    QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">    QValidator *validator = <span class="keyword">new</span> <span class="built_in">QIntValidator</span>(<span class="number">100</span>, <span class="number">999</span>, lineEdit); <span class="comment">// 创建验证器</span></span><br><span class="line">    lineEdit-&gt;<span class="built_in">setValidator</span>(validator); <span class="comment">// 应用验证器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置占位文本</span></span><br><span class="line">    lineEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;输入100-999之间的整数&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加状态标签</span></span><br><span class="line">    QLabel *statusLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;等待输入...&quot;</span>);</span><br><span class="line">    statusLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(statusLabel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接textChanged信号来更新状态</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(lineEdit, &amp;QLineEdit::textChanged, [=](<span class="type">const</span> QString &amp;text)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            statusLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;等待输入...&quot;</span>);</span><br><span class="line">            statusLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color: gray;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        QString currentText = text;</span><br><span class="line">        QValidator::State state = validator-&gt;<span class="built_in">validate</span>(currentText, pos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(state == QValidator::Acceptable) &#123;</span><br><span class="line">            statusLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;有效输入: &quot;</span> + text);</span><br><span class="line">            statusLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color: green;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(state == QValidator::Intermediate) &#123;</span><br><span class="line">            statusLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;输入中...&quot;</span>);</span><br><span class="line">            statusLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color: blue;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            statusLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;无效输入! 请输入100-999之间的整数&quot;</span>);</span><br><span class="line">            statusLabel-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color: red;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703122257231.png" alt="image-20250703122257231"></p>
<p><strong>极简示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QIntValidator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;简单输入验证&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建行编辑器</span></span><br><span class="line">    QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(&amp;window);</span><br><span class="line">    lineEdit-&gt;<span class="built_in">setGeometry</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="number">160</span>, <span class="number">30</span>); <span class="comment">// 设置位置和大小</span></span><br><span class="line">    lineEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;输入100-999&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并设置验证器（核心代码）</span></span><br><span class="line">    QIntValidator *validator = <span class="keyword">new</span> <span class="built_in">QIntValidator</span>(<span class="number">100</span>, <span class="number">999</span>, &amp;window);</span><br><span class="line">    lineEdit-&gt;<span class="built_in">setValidator</span>(validator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动补全：</p>
<p><strong>QLineEdit</strong>中也提供了强大的自动补全功能，这是利用QCompleter类实现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QStringList wordList;</span><br><span class="line">wordList &lt;&lt; <span class="string">&quot;Qt&quot;</span> &lt;&lt; <span class="string">&quot;Qt Creator&quot;</span> &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">QCompleter *completer = <span class="keyword">new</span> <span class="built_in">QCompleter</span>(wordList, <span class="keyword">this</span>);   <span class="comment">// 新建自动完成器</span></span><br><span class="line">completer-&gt;<span class="built_in">setCaseSensitivity</span>(Qt::CaseInsensitive);       <span class="comment">// 设置大小写不敏感</span></span><br><span class="line">ui-&gt;lineEdit4-&gt;<span class="built_in">setCompleter</span>(completer);</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCompleter&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;自动补全示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建垂直布局</span></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加说明标签</span></span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;输入以下内容试试：&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建列表显示可用选项</span></span><br><span class="line">    QLabel *options = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Qt, Qt Creator, 你好&quot;</span>);</span><br><span class="line">    options-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color: gray; font-style: italic;&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建行编辑器</span></span><br><span class="line">    QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>();</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建补全列表（核心代码）</span></span><br><span class="line">    QStringList wordList;</span><br><span class="line">    wordList &lt;&lt; <span class="string">&quot;Qt&quot;</span> &lt;&lt; <span class="string">&quot;Qt Creator&quot;</span> &lt;&lt; <span class="string">&quot;你好&quot;</span>; <span class="comment">// 添加补全选项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建自动补全器</span></span><br><span class="line">    QCompleter *completer = <span class="keyword">new</span> <span class="built_in">QCompleter</span>(wordList, &amp;window);</span><br><span class="line">    completer-&gt;<span class="built_in">setCaseSensitivity</span>(Qt::CaseInsensitive); <span class="comment">// 设置大小写不敏感</span></span><br><span class="line">    lineEdit-&gt;<span class="built_in">setCompleter</span>(completer); <span class="comment">// 应用补全器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703122554689.png" alt="image-20250703122554689"></p>
<p><strong>极简示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCompleter&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;自动补全示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">250</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(&amp;window);</span><br><span class="line">    lineEdit-&gt;<span class="built_in">setGeometry</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="number">210</span>, <span class="number">30</span>);</span><br><span class="line">    lineEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;输入 Qt 或 你好&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心自动补全代码</span></span><br><span class="line">    QStringList wordList;</span><br><span class="line">    wordList &lt;&lt; <span class="string">&quot;Qt&quot;</span> &lt;&lt; <span class="string">&quot;Qt Creator&quot;</span> &lt;&lt; <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    QCompleter *completer = <span class="keyword">new</span> <span class="built_in">QCompleter</span>(wordList, &amp;window);</span><br><span class="line">    completer-&gt;<span class="built_in">setCaseSensitivity</span>(Qt::CaseInsensitive);</span><br><span class="line">    lineEdit-&gt;<span class="built_in">setCompleter</span>(completer);</span><br><span class="line">    </span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703122927737.png" alt="image-20250703122927737"></p>
</li>
</ul>
<hr>
<h4 id="QAbstractSpinBox"><a href="#QAbstractSpinBox" class="headerlink" title="QAbstractSpinBox"></a>QAbstractSpinBox</h4><p>QAbstractSpinBox类是一个抽象基类，提供了一个数值设定框和一个行编辑器来显示设定值。包含3个子类：时间、整数、浮点数</p>
<ul>
<li><p><strong>QDateTimeEdit</strong>：完成<strong>日期时间</strong>的设定，拥有两个子类：</p>
<ul>
<li><p><strong>QDateEdit</strong>：设置时间</p>
<p>使用<code>setCalendarPopup(true)</code>可以使用<strong>弹出的日历部件</strong>来设置日期。</p>
<p>或者直接在设计模式中设置：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703123911721.png" alt="image-20250703123911721"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703123945973.png" alt="image-20250703123945973"></p>
<p>效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703124041372.png" alt="image-20250703124041372"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703124015396.png" alt="image-20250703124015396"></p>
</li>
<li><p><strong>QTimeEdit</strong>：设置显示格式</p>
<p>可以使用<code>setDisplayFormat()</code>来设置显示格式，例如<code>“h:mm:ssA”</code></p>
</li>
<li><p>时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">y：年；</span><br><span class="line">M：月；</span><br><span class="line">d：日；</span><br><span class="line">ddd：星期；</span><br><span class="line">H：小时，使用24小时制显示；</span><br><span class="line">h：小时，如果最后有AM或者PM的，则是12小时制显示，否则使用24小时制；</span><br><span class="line">m：分；</span><br><span class="line">s：秒；</span><br><span class="line">z：毫秒。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置时间为现在的系统时间</span></span><br><span class="line">ui-&gt;dateTimeEdit-&gt;<span class="built_in">setDateTime</span>(QDateTime::<span class="built_in">currentDateTime</span>());</span><br><span class="line"><span class="comment">// 设置时间的显示格式</span></span><br><span class="line">ui-&gt;dateTimeEdit-&gt;<span class="built_in">setDisplayFormat</span>(<span class="built_in">tr</span>(<span class="string">&quot;yyyy年MM月dd日ddd HH时mm分ss秒&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>完整示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTimeEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;日期时间显示示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建垂直布局</span></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加标题</span></span><br><span class="line">    QLabel *title = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;当前系统时间:&quot;</span>);</span><br><span class="line">    title-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    title-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;font-size: 18px; font-weight: bold;&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(title);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建日期时间编辑器</span></span><br><span class="line">    QDateTimeEdit *dateTimeEdit = <span class="keyword">new</span> <span class="built_in">QDateTimeEdit</span>();</span><br><span class="line">    dateTimeEdit-&gt;<span class="built_in">setCalendarPopup</span>(<span class="literal">true</span>); <span class="comment">// 启用日历弹出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心设置代码</span></span><br><span class="line">    dateTimeEdit-&gt;<span class="built_in">setDateTime</span>(QDateTime::<span class="built_in">currentDateTime</span>()); <span class="comment">// 设置为当前系统时间</span></span><br><span class="line">    dateTimeEdit-&gt;<span class="built_in">setDisplayFormat</span>(<span class="string">&quot;yyyy年MM月dd日 ddd HH时mm分ss秒&quot;</span>); <span class="comment">// 设置显示格式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置样式</span></span><br><span class="line">    dateTimeEdit-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QDateTimeEdit &#123;&quot;</span></span><br><span class="line">                                <span class="string">&quot;font-size: 16px;&quot;</span></span><br><span class="line">                                <span class="string">&quot;padding: 10px;&quot;</span></span><br><span class="line">                                <span class="string">&quot;border: 2px solid #3498db;&quot;</span></span><br><span class="line">                                <span class="string">&quot;border-radius: 5px;&quot;</span></span><br><span class="line">                                <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(dateTimeEdit);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加说明</span></span><br><span class="line">    QLabel *info = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;格式说明:\n&quot;</span></span><br><span class="line">                              <span class="string">&quot;yyyy=年, MM=月, dd=日, ddd=星期\n&quot;</span></span><br><span class="line">                              <span class="string">&quot;HH=时(24小时制), mm=分, ss=秒&quot;</span>);</span><br><span class="line">    info-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;color: #7f8c8d; font-size: 12px;&quot;</span>);</span><br><span class="line">    info-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(info);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703124417656.png" alt="image-20250703124417656"></p>
<p><strong>极简版本：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTimeEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;日期时间示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    QDateTimeEdit *dateTimeEdit = <span class="keyword">new</span> <span class="built_in">QDateTimeEdit</span>(&amp;window);</span><br><span class="line">    dateTimeEdit-&gt;<span class="built_in">setCalendarPopup</span>(<span class="literal">true</span>); <span class="comment">// 启用日历弹出</span></span><br><span class="line">    dateTimeEdit-&gt;<span class="built_in">setGeometry</span>(<span class="number">20</span>, <span class="number">30</span>, <span class="number">260</span>, <span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心设置代码</span></span><br><span class="line">    dateTimeEdit-&gt;<span class="built_in">setDateTime</span>(QDateTime::<span class="built_in">currentDateTime</span>());</span><br><span class="line">    dateTimeEdit-&gt;<span class="built_in">setDisplayFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703124842403.png" alt="image-20250703124842403"></p>
</li>
<li><p><strong>QSpinBox</strong>：完成<strong>整数和</strong>的设定</p>
</li>
<li><p><strong>QDoubleSpinBox</strong>：完成<strong>浮点数</strong>的设定</p>
</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703123437429.png" alt="image-20250703123437429"></p>
<hr>
<h4 id="QAbstractSlider"><a href="#QAbstractSlider" class="headerlink" title="QAbstractSlider"></a>QAbstractSlider</h4><p>QAbstractSlider类用于提供区间内的一个整数值，它有一个滑块，可以定位到一个整数区间的任意值。该类是一个抽象基类，它有3个子类：</p>
<ul>
<li><strong>QScrollBar</strong></li>
<li><strong>QSlider</strong></li>
<li><strong>QDial</strong></li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703125300008.png" alt="image-20250703125300008"></p>
<h5 id="关联信号和槽"><a href="#关联信号和槽" class="headerlink" title="关联信号和槽"></a><strong>关联信号和槽</strong></h5><ul>
<li><p>到设计模式，从部件栏中分别将Dial、Horizontal Scroll Bar拖入到界面上。再往界面上拖入一个Spin Box。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703133604445.png" alt="image-20250703133604445"></p>
</li>
<li><p>然后按下F4或者单击图标进入信号和槽编辑模式，将刻度表盘部件Dial的sliderMoved(int)信号分别与其他各个部件的setValue(int)槽相连接。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703134005421.png" alt="image-20250703134005421"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703134021639.png" alt="image-20250703134021639"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703134041624.png" alt="image-20250703134041624"></p>
</li>
<li><p>运行程序，然后使用鼠标拖动Dial刻度盘部件的滑块，可以看到其他所有的部件都跟着变化了。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703134112384.png" alt="image-20250703134112384"></p>
</li>
</ul>
<hr>
<h5 id="QAbstractSlider-的属性"><a href="#QAbstractSlider-的属性" class="headerlink" title="QAbstractSlider 的属性"></a>QAbstractSlider 的属性</h5><ul>
<li><strong>maximum</strong>：设置最大值，<strong>minimum</strong>为最小值；</li>
<li><strong>singleStep</strong>：每步的步长，默认是1，就是按下方向键后其数值增加或者减少1；</li>
<li><strong>pageStep</strong>：每页的步长，默认是10，就是按下<strong>PageUp</strong>或者<strong>PageDown</strong>按键后，其数值增加或者减少10；</li>
<li><strong>value</strong>与<strong>sliderPosition</strong>是当前值；</li>
<li><strong>tracking</strong>：设置是否跟踪，默认为是，就是在拖动滑块时，每移动一个刻度，都会发射**valueChanged()**信号，如果选择否，则只有拖动滑块释放时才发射该信号；</li>
<li><strong>orientation</strong>：设置部件的方向，有水平和垂直两种选择；</li>
<li><strong>invertedAppearance</strong>：设置滑块所在的位置，选中后，滑块默认会在最右端。</li>
<li><strong>invertedControls</strong>：反向控制，比如默认是向上方向键是增大，向下方向键是减小，如果选中这个属性，那么控制就会正好反过来。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703134415708.png" alt="image-20250703134415708"></p>
<hr>
<h5 id="Slider属性"><a href="#Slider属性" class="headerlink" title="Slider属性"></a>Slider属性</h5><ul>
<li><strong>tickPosition</strong>：设置显示刻度的位置，默认是不显示刻度；</li>
<li><strong>tickInterval</strong>：设置刻度的间隔。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703134513775.png" alt="image-20250703134513775"></p>
<hr>
<h5 id="Dial属性"><a href="#Dial属性" class="headerlink" title="Dial属性"></a>Dial属性</h5><ul>
<li><strong>wrapping</strong>：用来设置是否首尾相连</li>
<li><strong>notchTarget</strong>：用来设置刻度之间的间隔</li>
<li><strong>notchesVisible</strong>：用来设置是否显示刻度。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250703134625438.png" alt="image-20250703134625438"></p>
<hr>
<hr>
<h3 id="QDialog-对话空间"><a href="#QDialog-对话空间" class="headerlink" title="QDialog 对话空间"></a>QDialog 对话空间</h3><h4 id="模态和非模态对话框"><a href="#模态和非模态对话框" class="headerlink" title="模态和非模态对话框"></a>模态和非模态对话框</h4><p><strong>QDialog</strong> 类是所有对话框窗口类的基类。对话框窗口是一个经常用来完成短小任务或者和用户进行简单交互的顶层窗口。</p>
<p>按照运行对话框时<strong>是否还可以和该程序的其他窗口进行交互</strong>，对话框常被分为两类：</p>
<ul>
<li><p><strong>模态的（modal）</strong>：</p>
<p>即在没有关闭它之前，不能再与同一个应用程序的其他窗口进行交互，比如新建项目时弹出的对话框。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QDialog dialog(this);</span><br><span class="line">dialog.exec();</span><br><span class="line">或者：</span><br><span class="line">QDialog *dialog = new QDialog(this);</span><br><span class="line">dialog-&gt;setModal(true);</span><br><span class="line">dialog-&gt;show();</span><br></pre></td></tr></table></figure>

<p>完整代码示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QMainWindow mainWindow;</span><br><span class="line">    mainWindow.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;模态对话框示例&quot;</span>);</span><br><span class="line">    mainWindow.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建中央部件</span></span><br><span class="line">    QWidget centralWidget;</span><br><span class="line">    mainWindow.<span class="built_in">setCentralWidget</span>(&amp;centralWidget);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建布局和按钮</span></span><br><span class="line">    QVBoxLayout layout;</span><br><span class="line">    centralWidget.<span class="built_in">setLayout</span>(&amp;layout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按钮1：使用exec()创建模态对话框</span></span><br><span class="line">    <span class="function">QPushButton <span class="title">btn1</span><span class="params">(<span class="string">&quot;exec()方法&quot;</span>)</span></span>;</span><br><span class="line">    layout.<span class="built_in">addWidget</span>(&amp;btn1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按钮2：使用setModal(true)创建模态对话框</span></span><br><span class="line">    <span class="function">QPushButton <span class="title">btn2</span><span class="params">(<span class="string">&quot;setModal(true)方法&quot;</span>)</span></span>;</span><br><span class="line">    layout.<span class="built_in">addWidget</span>(&amp;btn2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示主窗口</span></span><br><span class="line">    mainWindow.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理按钮点击 - 方法1</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;btn1, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QDialog <span class="built_in">dialog</span>(&amp;mainWindow);</span><br><span class="line">        dialog.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;exec()对话框&quot;</span>);</span><br><span class="line">        QLabel <span class="built_in">label</span>(<span class="string">&quot;这是模态对话框\n主窗口被锁定&quot;</span>, &amp;dialog);</span><br><span class="line">        dialog.<span class="built_in">exec</span>(); <span class="comment">// 阻塞执行直到对话框关闭</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理按钮点击 - 方法2</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;btn2, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QDialog *dialog = <span class="keyword">new</span> <span class="built_in">QDialog</span>(&amp;mainWindow);</span><br><span class="line">        dialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;setModal(true)对话框&quot;</span>);</span><br><span class="line">        dialog-&gt;<span class="built_in">setModal</span>(<span class="literal">true</span>); <span class="comment">// 关键设置</span></span><br><span class="line">        QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;这也是模态对话框\n主窗口被锁定&quot;</span>, dialog);</span><br><span class="line">        dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">        <span class="comment">// 对话框关闭时自动删除</span></span><br><span class="line">        dialog-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704081003834.png" alt="image-20250704081003834"></p>
<p>点后面的窗口会振动，且无法操作后面的窗口。</p>
</li>
<li><p><strong>非模态的（modeless）</strong>：</p>
<p>既可以与它交互，也可以与同一程序中的其他窗口交互，如一些软件中的查找替换对话框。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QDialog *dialog = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">dialog-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<p>完整代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;主窗口&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建按钮</span></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;显示非模态对话框&quot;</span>, &amp;window)</span></span>;</span><br><span class="line">    button.<span class="built_in">setGeometry</span>(<span class="number">50</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">40</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接按钮点击事件 - 创建非模态对话框</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;button, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QDialog *dialog = <span class="keyword">new</span> <span class="built_in">QDialog</span>(&amp;window);  <span class="comment">// 在堆上创建</span></span><br><span class="line">        dialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;非模态对话框&quot;</span>);</span><br><span class="line">        QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;主窗口仍可操作&quot;</span>, dialog);</span><br><span class="line">        label-&gt;<span class="built_in">setGeometry</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">        dialog-&gt;<span class="built_in">show</span>();  <span class="comment">// 关键：非阻塞显示</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704081256902.png" alt="image-20250704081256902"></p>
<p>可以选中并操作后面的窗口，能反复弹出非模态对话框。</p>
</li>
</ul>
<hr>
<h4 id="标准对话框"><a href="#标准对话框" class="headerlink" title="标准对话框"></a>标准对话框</h4><table>
<thead>
<tr>
<th align="left">对话框类型</th>
<th align="left">核心功能</th>
<th align="left">关键代码片段</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>QColorDialog</strong></td>
<td align="left">选择颜色</td>
<td align="left"><code>QColorDialog::getColor()</code></td>
</tr>
<tr>
<td align="left"><strong>QErrorMessage</strong></td>
<td align="left">显示错误信息</td>
<td align="left"><code>QErrorMessage::qtHandler()-&gt;showMessage()</code></td>
</tr>
<tr>
<td align="left"><strong>QInputDialog</strong></td>
<td align="left">获取用户输入</td>
<td align="left"><code>QInputDialog::getText()</code></td>
</tr>
<tr>
<td align="left"><strong>QFontDialog</strong></td>
<td align="left">选择字体</td>
<td align="left"><code>QFontDialog::getFont()</code></td>
</tr>
<tr>
<td align="left"><strong>QFileDialog</strong></td>
<td align="left">选择文件&#x2F;目录</td>
<td align="left"><code>QFileDialog::getOpenFileName()</code></td>
</tr>
<tr>
<td align="left"><strong>QMessageBox</strong></td>
<td align="left">显示消息、警告、错误等</td>
<td align="left"><code>QMessageBox::information()</code></td>
</tr>
<tr>
<td align="left"><strong>QProgressDialog</strong></td>
<td align="left">显示进度条</td>
<td align="left"><code>QProgressDialog</code> + <code>setValue()</code></td>
</tr>
<tr>
<td align="left"><strong>QWizard</strong></td>
<td align="left">创建向导式多步骤对话框</td>
<td align="left"><code>QWizard</code> + <code>addPage()</code></td>
</tr>
</tbody></table>
<p>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColorDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QErrorMessage&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QInputDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFontDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFileDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QProgressDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWizard&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span> <span class="comment">// 使用定时器替代线程睡眠</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Qt标准对话框示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 颜色对话框</span></span><br><span class="line">    QPushButton *colorBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;QColorDialog&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(colorBtn);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(colorBtn, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QColor color = QColorDialog::<span class="built_in">getColor</span>(Qt::white, &amp;window, <span class="string">&quot;选择颜色&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (color.<span class="built_in">isValid</span>()) colorBtn-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: &quot;</span> + color.<span class="built_in">name</span>());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 错误信息对话框</span></span><br><span class="line">    QPushButton *errorBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;QErrorMessage&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(errorBtn);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(errorBtn, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QErrorMessage::<span class="built_in">qtHandler</span>()-&gt;<span class="built_in">showMessage</span>(<span class="string">&quot;这是一个错误信息示例&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 输入对话框</span></span><br><span class="line">    QPushButton *inputBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;QInputDialog&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(inputBtn);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(inputBtn, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        <span class="type">bool</span> ok;</span><br><span class="line">        QString text = QInputDialog::<span class="built_in">getText</span>(&amp;window, <span class="string">&quot;输入对话框&quot;</span>, <span class="string">&quot;请输入内容:&quot;</span>, QLineEdit::Normal, <span class="string">&quot;&quot;</span>, &amp;ok);</span><br><span class="line">        <span class="keyword">if</span> (ok) inputBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;输入内容: &quot;</span> + text);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 字体对话框</span></span><br><span class="line">    QPushButton *fontBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;QFontDialog&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(fontBtn);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(fontBtn, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        <span class="type">bool</span> ok;</span><br><span class="line">        QFont font = QFontDialog::<span class="built_in">getFont</span>(&amp;ok, <span class="built_in">QFont</span>(<span class="string">&quot;Arial&quot;</span>, <span class="number">12</span>), &amp;window);</span><br><span class="line">        <span class="keyword">if</span> (ok) fontBtn-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 文件对话框</span></span><br><span class="line">    QPushButton *fileBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;QFileDialog&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(fileBtn);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(fileBtn, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QString file = QFileDialog::<span class="built_in">getOpenFileName</span>(&amp;window, <span class="string">&quot;选择文件&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;文本文件 (*.txt);;所有文件 (*)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">isEmpty</span>()) fileBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;选择文件: &quot;</span> + <span class="built_in">QFileInfo</span>(file).<span class="built_in">fileName</span>());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 消息对话框</span></span><br><span class="line">    QPushButton *msgBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;QMessageBox&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(msgBtn);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(msgBtn, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">information</span>(&amp;window, <span class="string">&quot;消息对话框&quot;</span>, <span class="string">&quot;这是一个信息提示框&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 修复后的进度对话框（使用定时器）</span></span><br><span class="line">    QPushButton *progressBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;QProgressDialog&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(progressBtn);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(progressBtn, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QProgressDialog *progress = <span class="keyword">new</span> <span class="built_in">QProgressDialog</span>(<span class="string">&quot;处理中...&quot;</span>, <span class="string">&quot;取消&quot;</span>, <span class="number">0</span>, <span class="number">100</span>, &amp;window);</span><br><span class="line">        progress-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;进度对话框&quot;</span>);</span><br><span class="line">        <span class="comment">//progress-&gt;setWindowModality(Qt::WindowModal);</span></span><br><span class="line">        <span class="comment">// 关键设置：使对话框非模态</span></span><br><span class="line">        progress-&gt;<span class="built_in">setModal</span>(<span class="literal">false</span>); <span class="comment">// 设置为非模态</span></span><br><span class="line">        progress-&gt;<span class="built_in">setWindowModality</span>(Qt::NonModal); <span class="comment">// 非模态窗口</span></span><br><span class="line">        </span><br><span class="line">        progress-&gt;<span class="built_in">setMinimumDuration</span>(<span class="number">0</span>); <span class="comment">// 立即显示</span></span><br><span class="line">        progress-&gt;<span class="built_in">setValue</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用成员变量替代局部变量</span></span><br><span class="line">        QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(progress);</span><br><span class="line">        <span class="type">int</span> *progressValue = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>); <span class="comment">// 在堆上分配进度值</span></span><br><span class="line"></span><br><span class="line">        QObject::<span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">            *progressValue += <span class="number">2</span>;</span><br><span class="line">            progress-&gt;<span class="built_in">setValue</span>(*progressValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (*progressValue &gt;= <span class="number">100</span> || progress-&gt;<span class="built_in">wasCanceled</span>()) &#123;</span><br><span class="line">                timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">                <span class="keyword">delete</span> progressValue; <span class="comment">// 释放内存</span></span><br><span class="line">                progress-&gt;<span class="built_in">deleteLater</span>(); <span class="comment">// 安全删除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        timer-&gt;<span class="built_in">start</span>(<span class="number">50</span>); <span class="comment">// 每50毫秒更新一次</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 8. 向导对话框</span></span><br><span class="line">    QPushButton *wizardBtn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;QWizard&quot;</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(wizardBtn);</span><br><span class="line">    QObject::<span class="built_in">connect</span>(wizardBtn, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">        QWizard <span class="built_in">wizard</span>(&amp;window);</span><br><span class="line">        wizard.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;向导对话框&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加页面</span></span><br><span class="line">        QWizardPage *page1 = <span class="keyword">new</span> QWizardPage;</span><br><span class="line">        page1-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;第一步&quot;</span>);</span><br><span class="line">        page1-&gt;<span class="built_in">setSubTitle</span>(<span class="string">&quot;这是向导的第一步&quot;</span>);</span><br><span class="line"></span><br><span class="line">        QWizardPage *page2 = <span class="keyword">new</span> QWizardPage;</span><br><span class="line">        page2-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;第二步&quot;</span>);</span><br><span class="line">        page2-&gt;<span class="built_in">setSubTitle</span>(<span class="string">&quot;这是向导的第二步&quot;</span>);</span><br><span class="line"></span><br><span class="line">        wizard.<span class="built_in">addPage</span>(page1);</span><br><span class="line">        wizard.<span class="built_in">addPage</span>(page2);</span><br><span class="line"></span><br><span class="line">        wizard.<span class="built_in">exec</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704082806087.png" alt="image-20250704082806087"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704082746823.png" alt="image-20250704082746823"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704082818430.png" alt="image-20250704082818430"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704082835228.png" alt="image-20250704082835228"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704082852902.png" alt="image-20250704082852902"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704082918889.png" alt="image-20250704082918889"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704082932341.png" alt="image-20250704082932341"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704082944781.png" alt="image-20250704082944781"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704082956367.png" alt="image-20250704082956367"></p>
<hr>
<hr>
<h2 id="Qt-Quick-部件"><a href="#Qt-Quick-部件" class="headerlink" title="Qt Quick 部件"></a>Qt Quick 部件</h2><h3 id="Qt-Quick-基础可视项目"><a href="#Qt-Quick-基础可视项目" class="headerlink" title="Qt Quick 基础可视项目"></a>Qt Quick 基础可视项目</h3><p><strong>（需要创建quick项目）</strong></p>
<p>Qt Quick 编程中的 <strong>QtQuick</strong> 模块是编写 QML 应用程序的<strong>标准库</strong>，提供了用于创建用户界面的所有基本类型，使用这些类型可以创建动态可视化组件、接收用户输入、创建数据模型和视图。</p>
<p>其中提供的 <strong>Item</strong> 类型，是所有其他可视化类型的<strong>基类型</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Qt Quick 可视化类型层次结构</span><br><span class="line">┌──────────────────────────┐</span><br><span class="line">│          Item            │ ← 所有可视化类型的基类</span><br><span class="line">│ (不可见容器，提供基础功能)  │</span><br><span class="line">└──────────────────────────┘</span><br><span class="line">             △</span><br><span class="line">             │</span><br><span class="line">             ├───────────────────┐</span><br><span class="line">             │                   │</span><br><span class="line">┌─────────────────────┐  ┌─────────────────────┐</span><br><span class="line">│      Rectangle      │  │        Text         │ ← 文本显示</span><br><span class="line">│ (矩形，可设置颜色/边框) │  └─────────────────────┘</span><br><span class="line">└─────────────────────┘</span><br><span class="line">             △                   △</span><br><span class="line">             │                    │</span><br><span class="line">┌─────────────────────┐  ┌─────────────────────┐</span><br><span class="line">│      Image          │  │     TextInput       │ ← 文本输入框</span><br><span class="line">│    (图像显示元素)     │  └─────────────────────┘</span><br><span class="line">└─────────────────────┘</span><br><span class="line">             △</span><br><span class="line">             │</span><br><span class="line">┌─────────────────────┐</span><br><span class="line">│     MouseArea       │ ← 鼠标交互区域</span><br><span class="line">└─────────────────────┘</span><br></pre></td></tr></table></figure>

<p>Qt Quick模块既提供了QML 语言接口，可以使用QML类型来创建用户界面，也提供了C++语言接口，可以使用C++代码来扩展 QML 应用。</p>
<p><strong>Qt Quick 模块的子模块</strong>：</p>
<ul>
<li>Local Storage</li>
<li>Particles</li>
<li>Controls</li>
<li>Layouts</li>
<li>Tests</li>
<li>Effects</li>
</ul>
<hr>
<h4 id="Item-项目"><a href="#Item-项目" class="headerlink" title="Item 项目"></a>Item 项目</h4><p><strong>在Qt Quick中所有可视化类型都基于Item</strong>，它们都被称为可视化项目（visual items）。</p>
<p><strong>单独的Item对象没有可视化外观</strong>，但是它定义了可视化项目所有通用的特性。</p>
<p>例如关于位置的x和y属性，关于大小的width和height属性，关于布局的anchors相关属性，以及关于按键处理的Keys附加属性等等。</p>
<ul>
<li><p><strong>容器</strong></p>
<p>Item 常用于对项目进行分组，在一个根项目下，使用 Item 项目组织其它的项目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    Image &#123;</span><br><span class="line">        x: <span class="number">80</span></span><br><span class="line">        width: <span class="number">100</span>; height: <span class="number">100</span></span><br><span class="line">        source: <span class="string">&quot;tile.png&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        x: <span class="number">190</span></span><br><span class="line">        width: <span class="number">100</span>; height: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认属性</strong></p>
<p>Item 有一个<strong>children</strong>属性和一个<strong>resources</strong>属性，前者包含了可见的子项目列表，后者包含了不可见的资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    children: [</span><br><span class="line">        Text &#123;&#125;,</span><br><span class="line">        Rectangle &#123;&#125;</span><br><span class="line">    ]</span><br><span class="line">    resources: [</span><br><span class="line">        Timer &#123;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Item 还有一个 <strong>data</strong> 默认属性，允许在一个项目中将<strong>可见的子项目</strong>和<strong>不可见的资源</strong>进行自由混合。</p>
<p>也就是说，如果向 <strong>data</strong>列表中添加一个可视项目，那么该项目将作为一个孩子进行添加；如果添加任何其它的对象类型，则会作为资源进行添加。</p>
<p>因为 <strong>data</strong> 是默认属性，所以可以省略 <strong>data</strong> 标签，这样前面的代码可以改写为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    Text &#123;&#125;</span><br><span class="line">    Rectangle &#123;&#125;</span><br><span class="line">    Timer &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不透明度</strong></p>
<p>Item 有一个 <strong>opacity</strong> 属性，可以用来设置<strong>不透明度</strong>。</p>
<p>该属性可选值为0.0（完全透明）和1.0（完全不透明）之间的任意数字，默认值为1.0。</p>
<p>opacity 是一个继承属性，也就是说，父项目的透明度也会应用到子项目上。</p>
<p>例如：两个相互重叠的不透明矩形，通过设置父项目的opacity属性，会使两个矩形都变成透明的。</p>
<p><strong>helloqml.qml</strong>（需要创建quick项目）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.15</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: <span class="number">300</span></span><br><span class="line">    height: <span class="number">200</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    title: <span class="string">&quot;嵌套矩形透明度&quot;</span></span><br><span class="line">    color: <span class="string">&quot;white&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层红色矩形 (50%透明度)</span></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        width: <span class="number">100</span></span><br><span class="line">        height: <span class="number">100</span></span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">        opacity: <span class="number">0.5</span>   <span class="comment">// 设置透明度为50%</span></span><br><span class="line">        color: <span class="string">&quot;red&quot;</span>   <span class="comment">// 红色</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层蓝色矩形 (完全不透明)</span></span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            x: <span class="number">50</span>      <span class="comment">// 向右偏移50像素</span></span><br><span class="line">            y: <span class="number">50</span>      <span class="comment">// 向下偏移25像素</span></span><br><span class="line">            width: <span class="number">100</span></span><br><span class="line">            height: <span class="number">100</span></span><br><span class="line">            color: <span class="string">&quot;blue&quot;</span> <span class="comment">// 蓝色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704090436994.png" alt="image-20250704090436994"></p>
</li>
<li><p><strong>可见与启用</strong></p>
<p>Item 的 <strong>visible</strong> 属性用来设置项目是否可见，其默认值为 <strong>true</strong>。</p>
<p>如果将该属性设置为false，那么项目将不再接收鼠标事件，但是可以继续接收键盘事件。</p>
<p>如果在设置visible属性之前，项目被设置了键盘焦点，那么焦点依然会保留。</p>
<p>Item还有一个 <strong>enabled</strong> 属性，它可以设置项目是否接收鼠标和键盘事件，其值默认为true。</p>
<p>设置一个项目的 <strong>enabled</strong> 属性也会直接影响其子项目的 <strong>enabled</strong> 值，除非对其子项目的 <strong>enabled</strong> 属性进行单独设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.15</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: <span class="number">300</span></span><br><span class="line">    height: <span class="number">200</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    title: <span class="string">&quot;嵌套矩形透明度&quot;</span></span><br><span class="line">    color: <span class="string">&quot;white&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层红色矩形 (50%透明度)</span></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        width: <span class="number">100</span></span><br><span class="line">        height: <span class="number">100</span></span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">        opacity: <span class="number">0.5</span>   <span class="comment">// 设置透明度为50%</span></span><br><span class="line">        color: <span class="string">&quot;red&quot;</span>   <span class="comment">// 红色</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层蓝色矩形 (完全不透明)</span></span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            x: <span class="number">50</span>      <span class="comment">// 向右偏移50像素</span></span><br><span class="line">            y: <span class="number">50</span>      <span class="comment">// 向下偏移25像素</span></span><br><span class="line">            width: <span class="number">100</span></span><br><span class="line">            height: <span class="number">100</span></span><br><span class="line">            color: <span class="string">&quot;blue&quot;</span> <span class="comment">// 蓝色</span></span><br><span class="line">            visible: <span class="literal">false</span>	<span class="comment">//可视</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704090605019.png" alt="image-20250704090605019"></p>
</li>
<li><p><strong>定位子项目和坐标映射</strong></p>
<p>Item中提供了 <strong>childAt(real x, real y)</strong> 函数来返回在点 <strong>(x, y)</strong> 处的第一个可视子项目，如果没有这样的项目则返回null。</p>
<p>Item的 <strong>mapFromItem(Item item, real x, real y)</strong> 函数会将item坐标系统中点**(x, y)**映射到该项目的坐标系统上，该函数会返回一个包含映射后的x和y属性的对象。</p>
<p>对应的还有一个 <strong>mapToItem(Item item, real x, real y)</strong> 函数，可以从当前项目坐标系统的**(x, y)**点映射到item的坐标系统。</p>
</li>
<li><p><strong>堆叠顺序</strong></p>
<p>Item拥有一个 <strong>z</strong> 属性，可以用来设置兄弟项目间的堆叠顺序。默认的堆叠顺序为<strong>0</strong>。</p>
<p>拥有<strong>较大 <strong>z 值的项目会出现在 z 值</strong>较小</strong>的兄弟项目<strong>之上</strong>。</p>
<p>拥有<strong>相同</strong>的 z 属性值的项目会以<strong>代码中出现的顺序由下向上</strong>进行绘制。</p>
<p>如果项目的 z 属性值为<strong>负</strong>，那么它会被绘制在其父项目的下面。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 200</span><br><span class="line">    height: 150</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;Z序控制演示&quot;</span><br><span class="line"></span><br><span class="line">    // 蓝色矩形 (默认在底层)</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        z:1  // 关键属性：设置更高堆叠顺序</span><br><span class="line">        x: 50; y: 50</span><br><span class="line">        width: 100; height: 100</span><br><span class="line">        color: &quot;blue&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 红色矩形 (z:1 在顶层)</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        z: 2  // 关键属性：设置更高堆叠顺序</span><br><span class="line">        width: 100; height: 100</span><br><span class="line">        color: &quot;red&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704091730768.png" alt="image-20250704091730768"></p>
</li>
</ul>
<hr>
<h4 id="Rectangle"><a href="#Rectangle" class="headerlink" title="Rectangle"></a>Rectangle</h4><p><strong>Rectangle</strong> 项目<strong>继承</strong>自 Item，被用来使用<strong>纯色</strong>或者<strong>渐变</strong>填充一个矩形区域，并提供一个边框。</p>
<p><strong>Rectangle</strong> 项目可以使用 <strong>color</strong> 属性指定一个<strong>纯色</strong>来填充，或者使用 <strong>gradient</strong> 属性指定一个Gradient类型定义的渐变来填充。</p>
<p><strong>Rectangle</strong> 添加一个可选的边框，并通过 <strong>border.color</strong> 和 <strong>border.width</strong> 为其指定颜色和宽度。也可以使用 <strong>radius</strong> 属性来产生一个圆角矩形。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: 100; height: 100</span><br><span class="line">    color: &quot;lightgrey&quot;</span><br><span class="line">    border.color: &quot;black&quot;; border.width: 5; radius: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704092328352.png" alt="image-20250704092328352"></p>
<hr>
<h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><p><strong>Text</strong> 项目可以显示纯文本或者富文本，类似于 <strong>Qt Widgets</strong> 中的 <strong>QLabel</strong>。</p>
<p><strong>Text</strong> 支持有限的HTML子集。</p>
<p>如果在文本中包含 HTML 的 <strong>img</strong> 标签加载远程的图片，文本会被重载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 1000</span><br><span class="line">    height: 1000</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    Column &#123;</span><br><span class="line">        x:300;y:300</span><br><span class="line">        Text &#123;</span><br><span class="line">            text: &quot;Hello World!&quot;</span><br><span class="line">            font.family: &quot;Helvetica&quot;; font.pointSize: 50</span><br><span class="line">            color: &quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        Text &#123;</span><br><span class="line">            text: &quot;&lt;b&gt;Hello&lt;/b&gt; &lt;i&gt;World!&lt;/i&gt;&quot;</span><br><span class="line">            font.pointSize: 30</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704092714327.png" alt="image-20250704092714327"></p>
<p><strong>Text</strong> 是只读文本，如果要使用可编辑文本，可以使用 <strong>TextEdit</strong> 项目。</p>
<ul>
<li><strong>wrapMode</strong>属性设置换行</li>
<li><strong>elide</strong>属性设置自动省略显示</li>
<li><strong>textFormat</strong>属性设置文本格式</li>
<li>**horizontalAlignment **和 <strong>verticalAlignment</strong> 分别用来设置文本在 <strong>Text</strong> 项目区域中的水平对齐方式和垂直对齐方式。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 1000</span><br><span class="line">    height: 1000</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;Z序控制演示&quot;</span><br><span class="line"></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        width: 200; height: 200; color: &quot;lightgrey&quot;</span><br><span class="line"></span><br><span class="line">        Text &#123;</span><br><span class="line">            width: 200; height: 200</span><br><span class="line">            horizontalAlignment: Text.AlignHCenter</span><br><span class="line">            verticalAlignment: Text.AlignVCenter</span><br><span class="line">            text: qsTr(&quot;中心&quot;)</span><br><span class="line">            font.pointSize: 20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704092948545.png" alt="image-20250704092948545"></p>
<hr>
<h4 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h4><p><strong>TextInput</strong> 项目用来显示单行可编辑的纯文本。</p>
<p><strong>TextInput</strong> 与 Qt Widgets 中的 <strong>QLineEdit</strong> 相似，用于接收单行文本输入。</p>
<ul>
<li>验证器：整数验证器 <strong>IntValidator</strong>、<strong>DoubleValidator</strong>（非整数验证器）和 <strong>RegularExpressionValidator</strong>（正则表达式验证器）。</li>
<li>掩码 <strong>inputMask</strong>，可以参考前面 <strong><a href="#QLineEdit">QLineEdit</a></strong> 部分的内容。</li>
<li>回显方式与 <strong><a href="#QLineEdit">QLineEdit</a></strong> 一样，也有4种显示模式（echoMode）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 700</span><br><span class="line">    height: 700</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    Item &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            id: rect</span><br><span class="line">            width: input.contentWidth&lt;100 ? 100 : input.contentWidth + 10</span><br><span class="line">            height: input.contentHeight + 5</span><br><span class="line">            color: &quot;lightgrey&quot;; border.color: &quot;grey&quot;</span><br><span class="line"></span><br><span class="line">            TextInput &#123;</span><br><span class="line">                id: input</span><br><span class="line">                anchors.fill: parent; anchors.margins: 2</span><br><span class="line">                font.pointSize: 15; focus: true</span><br><span class="line"></span><br><span class="line">                inputMask: &quot;&gt;AA_9_a&quot;</span><br><span class="line">                onEditingFinished: text2.text = text</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Text &#123; id: text2; anchors.top: rect.bottom&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704093325502.png" alt="image-20250704093325502"></p>
<hr>
<h4 id="TextEdit"><a href="#TextEdit" class="headerlink" title="TextEdit"></a>TextEdit</h4><p>TextEdit 与 TextInput类似，不同之处在于，TextEdit 用来显示<strong>多行</strong>的可编辑的格式化文本。</p>
<p>TextEdit 与Qt中的 QTextEdit 很相似，它既可以显示纯文本也可以显示<strong>富文本</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 700</span><br><span class="line">    height: 700</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    TextEdit &#123;</span><br><span class="line">        width: 240; height: 400</span><br><span class="line">        wrapMode: Text.WordWrap</span><br><span class="line">        text: &quot;&lt;b&gt;Hello&lt;/b&gt; &lt;i&gt;World!&lt;/i&gt; Note that the TextEdit does not implement scrolling,</span><br><span class="line">                following the cursor, or other behaviors specific to a look and feel. For example,</span><br><span class="line">                to add flickable scrolling that follows the cursor&quot;</span><br><span class="line">        textFormat: Text.RichText</span><br><span class="line">        font.family: &quot;Helvetica&quot;</span><br><span class="line">        font.pointSize: 20</span><br><span class="line">        color: &quot;blue&quot;</span><br><span class="line">        focus: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704093746139.png" alt="image-20250704093746139"></p>
<hr>
<hr>
<h3 id="Qt-Quick-控件"><a href="#Qt-Quick-控件" class="headerlink" title="Qt Quick 控件"></a>Qt Quick 控件</h3><p><strong>Qt Quick Controls</strong> 模块是 <strong>Qt Quick</strong> 模块的子模块，包含了一组丰富的 <strong>UI</strong> 控件，迎合了最常见的用例，并且提供了定制选项，可用于在 <strong>Qt Quick</strong> 中构建完整的应用界面。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704093955925.png" alt="image-20250704093955925"></p>
<hr>
<hr>
<h4 id="控件基类型Control"><a href="#控件基类型Control" class="headerlink" title="控件基类型Control"></a>控件基类型Control</h4><p>Control是用户界面控件的基类型，Qt Quick Controls模块中的大部分控件都继承自Control，而 <strong>Control继承自Item</strong>，一般不直接使用该类型，而是使用它的众多子控件类型。</p>
<p>Control 从窗口系统接收输入事件并在屏幕上绘制自身，一个典型的 Control 控件布局如图所示。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704094808457.png" alt="image-20250704094808457"></p>
<p>控件的隐式大小 <strong>implicitWidth</strong> 和 <strong>implicitHeight</strong> 通常基于背景 <strong>background</strong> 和内容项 <strong>contentItem</strong> 的隐式大小以及四周的 <strong>insets</strong> 和 <strong>paddings</strong> 等属性的值，当没有明确指定控件的 <strong>width</strong> 和 <strong>height</strong> 属性时，会通过这些值来决定控件的大小。<strong>（自适应大小）</strong></p>
<p>背景的 <strong>insets</strong> 相关属性可以在不影响控件的视觉外观的情况下扩展其可交互区域，这对于较小的控件非常有用。</p>
<hr>
<h4 id="按钮类控件"><a href="#按钮类控件" class="headerlink" title="按钮类控件"></a>按钮类控件</h4><p>在Qt Quick Controls模块中提供了一组按钮类控件，包括 <strong>AbstractButton</strong> 及其子孙类型 <strong>Button</strong>、 <strong>CheckBox</strong>、<strong>DelayButton</strong>、<strong>RadioButton</strong>、<strong>RoundButton</strong>、<strong>Switch</strong> 和 <strong>ToolButton</strong> 等，每种类型的按钮都有自己的特定用例。</p>
<ul>
<li><p><strong>Button 控件</strong></p>
<p>实现了一个通用的按钮控件，一般用来执行一个动作或者回答一个问题，比如“确定”“取消”等。Button在AbstractButton的基础上添加了flat和highlighted两个属性。</p>
</li>
<li><p><strong>RoundButton 控件</strong></p>
<p>作为Button的子类型，在其基础上添加了一个radius属性，可以设置圆角，将按钮的implicitWidth和implicitHeight设置为同一值，并将radius设置为width &#x2F; 2，可以创建一个圆形按钮。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 700</span><br><span class="line">    height: 700</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    // 使用行布局</span><br><span class="line">    RowLayout &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        spacing: 10</span><br><span class="line">        anchors.margins: 10</span><br><span class="line"></span><br><span class="line">        // 1. 普通按钮</span><br><span class="line">        Button &#123;</span><br><span class="line">            text: qsTr(&quot;普通按钮&quot;)</span><br><span class="line">            onClicked: &#123;</span><br><span class="line">                console.log(&quot;普通按钮被点击&quot;);</span><br><span class="line">                close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 扁平按钮</span><br><span class="line">        Button &#123;</span><br><span class="line">            text: qsTr(&quot;扁平按钮&quot;)</span><br><span class="line">            flat: true</span><br><span class="line">            onClicked: console.log(&quot;扁平按钮被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 高亮按钮</span><br><span class="line">        Button &#123;</span><br><span class="line">            text: qsTr(&quot;高亮按钮&quot;)</span><br><span class="line">            highlighted: true</span><br><span class="line">            onClicked: console.log(&quot;高亮按钮被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4. 圆角按钮</span><br><span class="line">        RoundButton &#123;</span><br><span class="line">            text: qsTr(&quot;圆角按钮&quot;)</span><br><span class="line">            radius: 10</span><br><span class="line">            onClicked: console.log(&quot;圆角按钮被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 5. 圆形按钮</span><br><span class="line">        RoundButton &#123;</span><br><span class="line">            text: qsTr(&quot;圆形&quot;)</span><br><span class="line">            implicitWidth: 60</span><br><span class="line">            implicitHeight: 60</span><br><span class="line">            radius: width / 2</span><br><span class="line">            onClicked: console.log(&quot;圆形按钮被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704102751201.png" alt="image-20250704102751201"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704102816433.png" alt="image-20250704102816433"></p>
</li>
<li><p><strong>CheckBox 控件</strong></p>
<p>复选框用来创建一个选项按钮，可以在“选中”和“未选中”两种状态间切换。</p>
<p>如果将 <strong>tristate</strong> 属性设置为true，则复选框可以拥有第3种状态“部分选中”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 700</span><br><span class="line">    height: 700</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    // 使用列布局</span><br><span class="line">    ColumnLayout &#123;</span><br><span class="line">        ButtonGroup &#123;</span><br><span class="line">            id: childGroup      // 按钮组ID</span><br><span class="line">            // 关键属性1：是否互斥（这里设置为false表示可以多选）</span><br><span class="line">            exclusive: false;</span><br><span class="line">            // 关键属性2：绑定父复选框的状态</span><br><span class="line">            // 当子复选框状态变化时，这个属性会自动更新</span><br><span class="line">            checkState: parentBox.checkState</span><br><span class="line">        &#125;</span><br><span class="line">        // 父复选框</span><br><span class="line">        CheckBox &#123;</span><br><span class="line">            id: parentBox;      // 父复选框ID</span><br><span class="line">            text: qsTr(&quot;Parent&quot;);   // 显示文本</span><br><span class="line">            // 关键属性：绑定到子按钮组的状态</span><br><span class="line">            // 当父复选框被点击时，这个绑定会更新所有子复选框</span><br><span class="line">            checkState: childGroup.checkState</span><br><span class="line">            // 设置字体加粗</span><br><span class="line">            font.bold: true</span><br><span class="line">        &#125;</span><br><span class="line">        // 子复选框1</span><br><span class="line">        CheckBox &#123;</span><br><span class="line">            checked: true       // 默认选中</span><br><span class="line">            text: qsTr(&quot;Child 1&quot;)    // 显示文本</span><br><span class="line">            // 关键属性1：左侧缩进（缩进量等于复选框宽度，创建层次感）</span><br><span class="line">            leftPadding: indicator.width;</span><br><span class="line">            // 关键属性2：指定所属按钮组</span><br><span class="line">            ButtonGroup.group: childGroup</span><br><span class="line">        &#125;</span><br><span class="line">        // 子复选框2</span><br><span class="line">        CheckBox &#123;</span><br><span class="line">            text: qsTr(&quot;Child 2&quot;);</span><br><span class="line">            leftPadding: indicator.width</span><br><span class="line">            ButtonGroup.group: childGroup</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704104027424.png" alt="image-20250704104027424"></p>
</li>
<li><p><strong>RadioButton 控件</strong></p>
<p>单选按钮通常用于从一组选项中选择一个选项。</p>
<p>单选按钮的 <strong>autoExclusive</strong> 属性默认为 <strong>true</strong>，在属于同一父项的单选按钮中，任何时候只能选中一个按钮，选中另一个按钮会自动取消选中先前选中的按钮。</p>
</li>
<li><p><strong>ButtonGroup 控件</strong></p>
<p>可以包含一组互斥的按钮，该控件本身是不可见的，一般与 <strong>RadioButton</strong> 等控件一起使用。</p>
<p>如果需要 <strong>ButtonGroup</strong> 中的按钮不再互斥，可以设置 <strong>exclusive</strong> 属性为 <strong>false</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 300</span><br><span class="line">    height: 200</span><br><span class="line">    visible: true</span><br><span class="line"></span><br><span class="line">    Column &#123;</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">        spacing: 10</span><br><span class="line"></span><br><span class="line">        ButtonGroup &#123; id: group &#125;</span><br><span class="line"></span><br><span class="line">        RadioButton &#123; </span><br><span class="line">            text: &quot;选项1&quot;</span><br><span class="line">            ButtonGroup.group: group</span><br><span class="line">        &#125;</span><br><span class="line">        RadioButton &#123;</span><br><span class="line">            text: &quot;选项2&quot;</span><br><span class="line">            ButtonGroup.group: group</span><br><span class="line">            checked: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704105322645.png" alt="image-20250704105322645"></p>
<p>改善代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 700</span><br><span class="line">    height: 700</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    // 使用列布局</span><br><span class="line">    ColumnLayout &#123;</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">        spacing: 15</span><br><span class="line"></span><br><span class="line">        // 创建按钮组</span><br><span class="line">        ButtonGroup &#123;</span><br><span class="line">            id: radioGroup</span><br><span class="line">            // 选中项改变时触发</span><br><span class="line">            onClicked: console.log(&quot;当前选择:&quot;, button.text)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 创建单选按钮</span><br><span class="line">        RadioButton &#123;</span><br><span class="line">            text: &quot;选项1&quot;</span><br><span class="line">            ButtonGroup.group: radioGroup</span><br><span class="line">        &#125;</span><br><span class="line">        RadioButton &#123;</span><br><span class="line">            text: &quot;选项2&quot;</span><br><span class="line">            ButtonGroup.group: radioGroup</span><br><span class="line">            checked: true // 默认选中</span><br><span class="line">        &#125;</span><br><span class="line">        RadioButton &#123;</span><br><span class="line">            text: &quot;选项3&quot;</span><br><span class="line">            ButtonGroup.group: radioGroup</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 显示当前选择</span><br><span class="line">        Label &#123;</span><br><span class="line">            text: &quot;当前选择: &quot; + (radioGroup.checkedButton ? radioGroup.checkedButton.text : &quot;无&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704105424621.png" alt="image-20250704105424621"></p>
</li>
<li><p><strong>DelayButton 控件</strong></p>
<p>是一个可被选中的按钮，在被选中并发出**activated()**信号之前，有一个延迟，用来防止意外按压。</p>
<p><strong>progress</strong>属性可返回当前进度，介于<strong>0.0~1.0</strong>之间，延迟时间以<strong>毫秒</strong>为单位，通过<strong>delay</strong>属性进行设置。</p>
</li>
<li><p><strong>Switch 控件</strong></p>
<p>开关按钮可以在“打开”和“关闭”之间进行切换，该按钮通常用于在两种状态之间进行选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 700</span><br><span class="line">    height: 700</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    // 使用行布局</span><br><span class="line">    RowLayout &#123;</span><br><span class="line">        DelayButton &#123;</span><br><span class="line">            text: qsTr(&quot;延迟按钮&quot;); delay: 5000</span><br><span class="line">            onActivated: text = qsTr(&quot;已启动&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Switch &#123;</span><br><span class="line">            text: qsTr(&quot;Wi-Fi&quot;)</span><br><span class="line">            onToggled: console.log(checked)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704104607400.png" alt="image-20250704104607400"></p>
</li>
</ul>
<hr>
<h4 id="指示器类控件"><a href="#指示器类控件" class="headerlink" title="指示器类控件"></a>指示器类控件</h4><p>在Qt Quick Controls提供了一系列类似指示器的控件，它们均直接<strong>继承自Control</strong>。包括：</p>
<ul>
<li><p><strong>BusyIndicator</strong></p>
<p>用来显示一个忙碌指示器控件，用来指示正在加载内容或 <strong>UI</strong> 被阻止需等待资源等情况。</p>
</li>
<li><p><strong>ProgressBar</strong></p>
<p>用来显示一个进度条指示器控件，可以指示操作的进度。进度值由 <strong>value</strong> 属性指定，需要定期进行更新来显示进度，其范围由 <strong>from</strong> 属性（默认值为0.0）和 <strong>to</strong> 属性（默认值为1.0）指定。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: <span class="number">700</span></span><br><span class="line">    height: <span class="number">700</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    title: <span class="string">&quot;演示&quot;</span></span><br><span class="line"></span><br><span class="line">    Pane &#123;</span><br><span class="line">        width: <span class="number">400</span>; height: <span class="number">300</span></span><br><span class="line">        Image &#123;</span><br><span class="line">            id: image; anchors.fill: parent</span><br><span class="line">            source: <span class="string">&quot;https://www.qter.org/temp/back.png&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        BusyIndicator &#123;</span><br><span class="line">            id:busy</span><br><span class="line">            anchors.horizontalCenter:</span><br><span class="line">                            parent.horizontalCenter</span><br><span class="line">            anchors.verticalCenter:</span><br><span class="line">                            parent.verticalCenter</span><br><span class="line">            running: image.status === Image.Loading</span><br><span class="line">        &#125;</span><br><span class="line">        ProgressBar &#123;</span><br><span class="line">            visible: image.status === Image.Loading</span><br><span class="line">            value: image.progress</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704105931392.png" alt="image-20250704105931392"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704105906309.png" alt="image-20250704105906309"></p>
<ul>
<li><p><strong>PageIndicator</strong></p>
<p>一般与 <strong>StackLayout</strong> 这样包含多个页面的容器控件一起使用来指示当前的活动页面；</p>
</li>
<li><p><strong>ScrollBar</strong></p>
<p>一般用于 <strong>Flickable</strong> 及其子类型，用于显示滚动条和滚动位置。</p>
</li>
<li><p><strong>ScrollIndicator</strong> 等</p>
<p>一般用于 <strong>Flickable</strong> 及其子类型，用于显示滚动条和滚动位置。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: <span class="number">500</span></span><br><span class="line">    height: <span class="number">700</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    title: <span class="string">&quot;演示&quot;</span></span><br><span class="line">    Column &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        anchors.margins: <span class="number">20</span></span><br><span class="line">        spacing: <span class="number">30</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 页面指示器 (PageIndicator)</span></span><br><span class="line">        Text &#123;</span><br><span class="line">            text: <span class="string">&quot;1. 页面指示器 (PageIndicator)&quot;</span>;</span><br><span class="line">            font.bold: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SwipeView &#123;</span><br><span class="line">            id: swipeView</span><br><span class="line">            width: parent.width</span><br><span class="line">            height: <span class="number">150</span></span><br><span class="line"></span><br><span class="line">            Rectangle &#123; color: <span class="string">&quot;#e3f2fd&quot;</span>; Text &#123; anchors.centerIn: parent; text: <span class="string">&quot;页面1&quot;</span> &#125; &#125;</span><br><span class="line">            Rectangle &#123; color: <span class="string">&quot;#e8f5e9&quot;</span>; Text &#123; anchors.centerIn: parent; text: <span class="string">&quot;页面2&quot;</span> &#125; &#125;</span><br><span class="line">            Rectangle &#123; color: <span class="string">&quot;#fff3e0&quot;</span>; Text &#123; anchors.centerIn: parent; text: <span class="string">&quot;页面3&quot;</span> &#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PageIndicator &#123;</span><br><span class="line">            anchors.horizontalCenter: parent.horizontalCenter</span><br><span class="line">            count: swipeView.count</span><br><span class="line">            currentIndex: swipeView.currentIndex</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 滚动条 (ScrollBar)</span></span><br><span class="line">        Text &#123;</span><br><span class="line">            text: <span class="string">&quot;2. 滚动条 (ScrollBar)&quot;</span>;</span><br><span class="line">            font.bold: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ScrollView &#123;</span><br><span class="line">            width: parent.width</span><br><span class="line">            height: <span class="number">150</span></span><br><span class="line">            <span class="comment">// 正确设置滚动条策略</span></span><br><span class="line">            ScrollBar.vertical.policy: ScrollBar.AlwaysOn</span><br><span class="line"></span><br><span class="line">            TextArea &#123;</span><br><span class="line">                text: <span class="string">&quot;这是一个带有滚动条(ScrollBar)的文本区域\n\n&quot;</span> +</span><br><span class="line">                      <span class="string">&quot;向下滚动查看更多内容...\n\n&quot;</span>.<span class="built_in">repeat</span>(<span class="number">10</span>)</span><br><span class="line">                readOnly: <span class="literal">true</span></span><br><span class="line">                wrapMode: Text.Wrap</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 滚动指示器 (ScrollIndicator) - 修正版</span></span><br><span class="line">        Text &#123;</span><br><span class="line">            text: <span class="string">&quot;3. 滚动指示器 (ScrollIndicator)&quot;</span>;</span><br><span class="line">            font.bold: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Flickable 而不是 ScrollView 来正确使用 ScrollIndicator</span></span><br><span class="line">        Flickable &#123;</span><br><span class="line">            width: parent.width</span><br><span class="line">            height: <span class="number">150</span></span><br><span class="line">            contentWidth: width</span><br><span class="line">            contentHeight: textContent.height</span><br><span class="line">            clip: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 滚动指示器</span></span><br><span class="line">            ScrollIndicator.vertical: ScrollIndicator &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 可滚动内容</span></span><br><span class="line">            Text &#123;</span><br><span class="line">                id: textContent</span><br><span class="line">                width: parent.width</span><br><span class="line">                text: <span class="string">&quot;这是一个带有滚动指示器(ScrollIndicator)的文本区域\n\n&quot;</span> +</span><br><span class="line">                      <span class="string">&quot;向下滚动查看更多内容...\n\n&quot;</span>.<span class="built_in">repeat</span>(<span class="number">10</span>)</span><br><span class="line">                wrapMode: Text.Wrap</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704113952019.png" alt="image-20250704113952019"></p>
<hr>
<h4 id="输入类控件"><a href="#输入类控件" class="headerlink" title="输入类控件"></a>输入类控件</h4><p>Qt Quick Controls模块中为<strong>数字和文本</strong>输入提供了多种输入控件，包括：</p>
<ul>
<li><p><strong>ComboBox</strong> 下拉框</p>
<p>ComboBox <strong>继承</strong>自 Control，是一个组合按钮和弹出列表的组合框控件，提供了一种以占用最小屏幕空间的方式向用户呈现选项列表的方法。</p>
<p>填充到ComboBox的数据模型通常是 JavaScript数组、ListModel或整数。</p>
<p>将 <strong>editable</strong> 属性设置为<strong>true</strong>时，可以对 ComboBox 进行编辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 700</span><br><span class="line">    height: 700</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line">    </span><br><span class="line">    Item &#123;</span><br><span class="line">        width: 200; height: 300</span><br><span class="line"></span><br><span class="line">        ComboBox &#123;</span><br><span class="line">            x:10; y:10</span><br><span class="line">            editable: true</span><br><span class="line">            model: ListModel &#123;</span><br><span class="line">                id: model</span><br><span class="line">                ListElement &#123; text: &quot;Banana&quot; &#125;</span><br><span class="line">                ListElement &#123; text: &quot;Apple&quot; &#125;</span><br><span class="line">                ListElement &#123; text: &quot;Coconut&quot; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            onAccepted: &#123;</span><br><span class="line">                if (find(editText) === -1)</span><br><span class="line">                    model.append(&#123;text: editText&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704110813357.png" alt="image-20250704110813357"></p>
</li>
<li><p><strong>Dial</strong></p>
<p>Dial继承自Control，实现类似于传统的音响上拨号旋钮样式的控件，可以用来指定范围内的值。</p>
<p>通过from和to属性来指定开始和结束的值，value属性设置当前值。</p>
<p>可以使用<strong>stepSize</strong>设置步长，将<strong>wrap</strong>设置为<strong>true</strong>，可以到终点后直接跳到起始点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 700</span><br><span class="line">    height: 700</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    Item &#123;</span><br><span class="line">        width: 100; height: 120</span><br><span class="line"></span><br><span class="line">        Dial &#123;</span><br><span class="line">            id: dial</span><br><span class="line">            from: 1; to: 10</span><br><span class="line">            stepSize: 1; wrap: true</span><br><span class="line">        &#125;</span><br><span class="line">        Label &#123;</span><br><span class="line">            anchors.top: dial.bottom</span><br><span class="line">            text: dial.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704111204803.png" alt="image-20250704111204803"></p>
</li>
<li><p><strong>TextArea</strong></p>
<p>TextArea<strong>继承自</strong> TextEdit，提供了一个多行文本编辑器，在TextEdit之上添加了占位符文本功能，并进行了一些装饰。</p>
<p>TextArea本身不可以滚动，可以将其放入ScrollView中来实现滚动条。</p>
<p>通过<strong>placeholderText</strong>属性可以设置占位符文本，它是在用户输入之前显示在文本区域中的简短提示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 200</span><br><span class="line">    height: 200</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    ScrollView &#123;</span><br><span class="line">        id: view</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        TextArea &#123;</span><br><span class="line">            placeholderText: qsTr(&quot;可以在这里输入内容&quot;)</span><br><span class="line">            wrapMode: Text.WordWrap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704111544869.png" alt="image-20250704111544869"></p>
</li>
<li><p><strong>SpinBox</strong></p>
<p>允许用户通过单击向上或向下指示器按钮，或通过键盘向上或向下键来选择整数值。</p>
<p>可以通过editable属性将SpinBox设置为可编辑。</p>
<p>默认情况下，SpinBox提供0~99范围内的离散值，步长为1，可以通过from和to设置起始值和结束值，通过value设置当前值。</p>
<p>尽管SpinBox默认只可以处理整数值，通过validator、textFromValue和valueFromText等属性也可以自定义让其接受任意输入值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 2.15</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 200</span><br><span class="line">    height: 200</span><br><span class="line">    visible: true</span><br><span class="line">    title: &quot;演示&quot;</span><br><span class="line"></span><br><span class="line">    SpinBox &#123;</span><br><span class="line">        id: spinBox</span><br><span class="line">        from: 0; to: items.length - 1</span><br><span class="line">        value: 1 // &quot;Medium&quot;</span><br><span class="line">        property var items: [&quot;Small&quot;, &quot;Medium&quot;, &quot;Large&quot;]</span><br><span class="line"></span><br><span class="line">        validator: RegularExpressionValidator &#123;</span><br><span class="line">            regularExpression: new RegExp(&quot;(Small|Medium|Large)&quot;, &quot;i&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        textFromValue: function(value) &#123;</span><br><span class="line">            return items[value];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        valueFromText: function(text) &#123;</span><br><span class="line">            for (var i = 0; i &lt; items.length; ++i) &#123;</span><br><span class="line">                if (items[i].toLowerCase().indexOf(text.toLowerCase())</span><br><span class="line">                                                                  === 0)</span><br><span class="line">                    return i</span><br><span class="line">            &#125;</span><br><span class="line">            return spinBox.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704111730642.png" alt="image-20250704111730642"></p>
</li>
<li><p><strong>RangeSlider</strong></p>
<p><strong>功能特性</strong>：</p>
<ul>
<li>允许选择值范围（最小值和最大值）</li>
<li><code>first.value</code> 和 <code>second.value</code> 表示范围边界</li>
<li>可自定义轨道和手柄样式</li>
<li>支持步长设置</li>
</ul>
<p><strong>常用场景</strong>：</p>
<ul>
<li>价格范围选择</li>
<li>时间范围设置</li>
<li>数据过滤条件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: <span class="number">500</span></span><br><span class="line">    height: <span class="number">700</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    title: <span class="string">&quot;演示&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RangeSlider 控件 (范围滑块)</span></span><br><span class="line">    GroupBox &#123;</span><br><span class="line">        title: <span class="string">&quot;RangeSlider (范围滑块)&quot;</span></span><br><span class="line">        Layout.fillWidth: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        ColumnLayout &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            spacing: <span class="number">15</span></span><br><span class="line"></span><br><span class="line">            RangeSlider &#123;</span><br><span class="line">                id: rangeSlider</span><br><span class="line">                Layout.fillWidth: <span class="literal">true</span></span><br><span class="line">                from: <span class="number">0</span></span><br><span class="line">                to: <span class="number">100</span></span><br><span class="line">                stepSize: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                first.value: <span class="number">25</span></span><br><span class="line">                second.value: <span class="number">75</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自定义轨道样式</span></span><br><span class="line">                background: Rectangle &#123;</span><br><span class="line">                    height: <span class="number">6</span></span><br><span class="line">                    radius: <span class="number">3</span></span><br><span class="line">                    color: <span class="string">&quot;#E0E0E0&quot;</span></span><br><span class="line"></span><br><span class="line">                    Rectangle &#123;</span><br><span class="line">                        x: rangeSlider.first.visualPosition * parent.width</span><br><span class="line">                        width: rangeSlider.second.visualPosition * parent.width - x</span><br><span class="line">                        height: parent.height</span><br><span class="line">                        color: <span class="string">&quot;#4CAF50&quot;</span></span><br><span class="line">                        radius: <span class="number">3</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RowLayout &#123;</span><br><span class="line">                Layout.fillWidth: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">                Text &#123;</span><br><span class="line">                    text: `最小值: $&#123;rangeSlider.first.value.<span class="built_in">toFixed</span>(<span class="number">0</span>)&#125;`</span><br><span class="line">                    Layout.alignment: Qt.AlignLeft</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Text &#123;</span><br><span class="line">                    text: `最大值: $&#123;rangeSlider.second.value.<span class="built_in">toFixed</span>(<span class="number">0</span>)&#125;`</span><br><span class="line">                    Layout.alignment: Qt.AlignRight</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Text &#123;</span><br><span class="line">                Layout.alignment: Qt.AlignHCenter</span><br><span class="line">                text: `范围: $&#123;rangeSlider.first.value.<span class="built_in">toFixed</span>(<span class="number">0</span>)&#125; - $&#123;rangeSlider.second.value.<span class="built_in">toFixed</span>(<span class="number">0</span>)&#125;`</span><br><span class="line">                font.bold: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704115153635.png" alt="image-20250704115153635"></p>
</li>
<li><p><strong>Slider</strong></p>
<p><strong>功能特性</strong>：</p>
<ul>
<li>线性值选择器</li>
<li>支持水平和垂直方向</li>
<li>可自定义轨道和手柄</li>
<li>支持步长设置</li>
</ul>
<p><strong>常用场景</strong>：</p>
<ul>
<li>亮度&#x2F;音量调节</li>
<li>进度控制</li>
<li>参数调整</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: <span class="number">500</span></span><br><span class="line">    height: <span class="number">700</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    title: <span class="string">&quot;演示&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Slider 控件 (滑块)</span></span><br><span class="line">    GroupBox &#123;</span><br><span class="line">        title: <span class="string">&quot;3. Slider (滑块)&quot;</span></span><br><span class="line">        Layout.fillWidth: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        ColumnLayout &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            spacing: <span class="number">15</span></span><br><span class="line"></span><br><span class="line">            Slider &#123;</span><br><span class="line">                id: slider</span><br><span class="line">                Layout.fillWidth: <span class="literal">true</span></span><br><span class="line">                value: <span class="number">50</span></span><br><span class="line">                from: <span class="number">0</span></span><br><span class="line">                to: <span class="number">100</span></span><br><span class="line">                stepSize: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自定义滑块样式</span></span><br><span class="line">                handle: Rectangle &#123;</span><br><span class="line">                    x: slider.visualPosition * (slider.width - width)</span><br><span class="line">                    y: (slider.height - height) / <span class="number">2</span></span><br><span class="line">                    width: <span class="number">20</span></span><br><span class="line">                    height: <span class="number">20</span></span><br><span class="line">                    radius: <span class="number">10</span></span><br><span class="line">                    color: slider.pressed ? <span class="string">&quot;#4CAF50&quot;</span> : <span class="string">&quot;#FFFFFF&quot;</span></span><br><span class="line">                    border.color: <span class="string">&quot;#9E9E9E&quot;</span></span><br><span class="line">                    border.width: <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Text &#123;</span><br><span class="line">                Layout.alignment: Qt.AlignHCenter</span><br><span class="line">                text: `当前值: $&#123;slider.value.<span class="built_in">toFixed</span>(<span class="number">0</span>)&#125;`</span><br><span class="line">                font.bold: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704115417015.png" alt="image-20250704115417015"></p>
</li>
<li><p><strong>TextField</strong></p>
<p><strong>功能特性</strong>：</p>
<ul>
<li>单行文本输入</li>
<li>支持文本选择、复制、粘贴</li>
<li>输入验证（数字、正则表达式等）</li>
<li>占位文本提示</li>
<li>密码模式</li>
</ul>
<p><strong>常用场景</strong>：</p>
<ul>
<li>表单输入</li>
<li>搜索框</li>
<li>登录界面</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: <span class="number">500</span></span><br><span class="line">    height: <span class="number">700</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    title: <span class="string">&quot;演示&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. TextField 控件 (文本输入框)</span></span><br><span class="line">    GroupBox &#123;</span><br><span class="line">        title: <span class="string">&quot;4. TextField (文本输入框)&quot;</span></span><br><span class="line">        Layout.fillWidth: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        ColumnLayout &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            spacing: <span class="number">15</span></span><br><span class="line"></span><br><span class="line">            TextField &#123;</span><br><span class="line">                id: textField</span><br><span class="line">                Layout.fillWidth: <span class="literal">true</span></span><br><span class="line">                placeholderText: <span class="string">&quot;请输入文本...&quot;</span></span><br><span class="line">                selectByMouse: <span class="literal">true</span> <span class="comment">// 允许鼠标选择文本</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输入验证（只允许数字）</span></span><br><span class="line">                validator: IntValidator &#123;</span><br><span class="line">                    bottom: <span class="number">0</span></span><br><span class="line">                    top: <span class="number">100</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自定义背景</span></span><br><span class="line">                background: Rectangle &#123;</span><br><span class="line">                    border.color: textField.focus ? <span class="string">&quot;#4CAF50&quot;</span> : <span class="string">&quot;#9E9E9E&quot;</span></span><br><span class="line">                    border.width: <span class="number">2</span></span><br><span class="line">                    radius: <span class="number">5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RowLayout &#123;</span><br><span class="line">                Layout.fillWidth: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">                Button &#123;</span><br><span class="line">                    text: <span class="string">&quot;复制&quot;</span></span><br><span class="line">                    onClicked: textField.<span class="built_in">selectAll</span>()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Button &#123;</span><br><span class="line">                    text: <span class="string">&quot;粘贴&quot;</span></span><br><span class="line">                    onClicked: textField.<span class="built_in">paste</span>()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Button &#123;</span><br><span class="line">                    text: <span class="string">&quot;清空&quot;</span></span><br><span class="line">                    onClicked: textField.<span class="built_in">clear</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Text &#123;</span><br><span class="line">                Layout.alignment: Qt.AlignHCenter</span><br><span class="line">                text: `输入内容: $&#123;textField.text&#125;`</span><br><span class="line">                font.bold: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704115607482.png" alt="image-20250704115607482"></p>
</li>
<li><p><strong>Tumbler</strong></p>
<p><strong>功能特性</strong>：</p>
<ul>
<li>旋转式选择界面</li>
<li><code>model</code> 定义选项数量或内容</li>
<li><code>visibleItemCount</code> 设置可见项目数</li>
<li>支持自定义项目样式</li>
<li>平滑滚动效果</li>
</ul>
<p><strong>常用场景</strong>：</p>
<ul>
<li>日期&#x2F;时间选择</li>
<li>数值选择器</li>
<li>选项列表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">2.15</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: <span class="number">500</span></span><br><span class="line">    height: <span class="number">700</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    title: <span class="string">&quot;演示&quot;</span></span><br><span class="line"></span><br><span class="line">    GroupBox &#123;</span><br><span class="line">        title: <span class="string">&quot;5. Tumbler (旋转选择器)&quot;</span></span><br><span class="line">        Layout.fillWidth: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        ColumnLayout &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            spacing: <span class="number">15</span></span><br><span class="line"></span><br><span class="line">            Tumbler &#123;</span><br><span class="line">                id: tumbler</span><br><span class="line">                Layout.alignment: Qt.AlignHCenter</span><br><span class="line">                model: <span class="number">10</span></span><br><span class="line">                visibleItemCount: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自定义样式</span></span><br><span class="line">                delegate: Text &#123;</span><br><span class="line">                    text: index + <span class="number">1</span></span><br><span class="line">                    font.pixelSize: <span class="number">20</span></span><br><span class="line">                    horizontalAlignment: Text.AlignHCenter</span><br><span class="line">                    verticalAlignment: Text.AlignVCenter</span><br><span class="line">                    opacity: <span class="number">0.4</span> + Math.<span class="built_in">max</span>(<span class="number">0</span>, <span class="number">1</span> - Math.<span class="built_in">abs</span>(Tumbler.displacement)) * <span class="number">0.6</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 背景样式</span></span><br><span class="line">                background: Rectangle &#123;</span><br><span class="line">                    color: <span class="string">&quot;#E0E0E0&quot;</span></span><br><span class="line">                    radius: <span class="number">5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Text &#123;</span><br><span class="line">                Layout.alignment: Qt.AlignHCenter</span><br><span class="line">                text: `当前选择: $&#123;tumbler.currentIndex + <span class="number">1</span>&#125;`</span><br><span class="line">                font.bold: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704115755510.png" alt="image-20250704115755510"></p>
</li>
</ul>
<hr>
<h4 id="日期类控件（已弃）"><a href="#日期类控件（已弃）" class="headerlink" title="日期类控件（已弃）"></a>日期类控件（已弃）</h4><p><strong>（Qt6.x版本貌似用不了）</strong></p>
<p><strong>（import Qt.labs.calendar 1.0 不可用）</strong></p>
<p>日期类控件都<strong>继承</strong>自Control，包括：</p>
<ul>
<li><p><strong>DayOfWeekRow</strong>：</p>
<p>会将星期几的名称显示为一行，日期的名称使用指定的 locale 区域设置进行排序和格式化。</p>
</li>
<li><p><strong>WeekNumberColumn</strong>：</p>
<p>在一列中显示给定year年份、month月份的周数。</p>
</li>
<li><p><strong>MonthGrid</strong></p>
<p>和上述两个搭配使用，通过计算给定月份和年份实现在网格中显示日历月。</p>
</li>
</ul>
<hr>
<hr>
<h3 id="Qt-Quick系统对话框"><a href="#Qt-Quick系统对话框" class="headerlink" title="Qt Quick系统对话框"></a>Qt Quick系统对话框</h3><p>从Qt 6.2开始引入了Qt Quick Dialogs模块，可以从QML创建系统对话框并与之交互。</p>
<p>常用的系统对话框类型包括ColorDialog、FileDialog、FolderDialog、FontDialog和MessageDialog等。</p>
<hr>
<h4 id="颜色对话框ColorDialog"><a href="#颜色对话框ColorDialog" class="headerlink" title="颜色对话框ColorDialog"></a>颜色对话框ColorDialog</h4><p>ColorDialog类型为系统颜色对话框提供了QML API。</p>
<p>要显示颜色对话框，可以先创建ColorDialog的实例，设置所需的属性，然后调用**open()**方法。</p>
<p>通过selectedColor属性可用于获取对话框选定的颜色，通过options属性可以启用一些选项，比如显示Alpha通道。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick</span><br><span class="line">import QtQuick.Dialogs</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 800; height: 600; visible: true</span><br><span class="line"></span><br><span class="line">    RowLayout &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            text: qsTr(&quot;颜色对话框&quot;)</span><br><span class="line">            onClicked: colorDialog.open()</span><br><span class="line">        &#125;</span><br><span class="line">        Label &#123; id: label; text: qsTr(&quot;颜色展示&quot;)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ColorDialog &#123;</span><br><span class="line">        id: colorDialog</span><br><span class="line">        selectedColor: label.color</span><br><span class="line">        options: ColorDialog.ShowAlphaChannel</span><br><span class="line">        onAccepted: label.color = selectedColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704123627684.png" alt="image-20250704123627684"></p>
<hr>
<h4 id="文件对话框FileDialog"><a href="#文件对话框FileDialog" class="headerlink" title="文件对话框FileDialog"></a>文件对话框FileDialog</h4><p>FileDialog类型为系统文件对话框提供了QML API。</p>
<ul>
<li>通过 <strong>selectedFile</strong> 和 <strong>selectedFiles</strong> 属性可以获取选择的文件；</li>
<li>通过 <strong>nameFilters</strong> 属性可以设置类型过滤器，只显示指定类型的文件；</li>
<li>通过 <strong>currentFolder</strong> 属性可以指定打开的默认目录；</li>
<li>通过 <strong>acceptLabel</strong> 和 <strong>rejectLabel</strong> 可以设置两个按钮的显示文本；</li>
<li>通过 <strong>fileMode</strong> 属性可以设置对话框模式，默认是 <strong>FileDialog.OpenFile</strong> 选择一个文件，另外还有 <strong>FileDialog.OpenFiles</strong> 选择多个文件，<strong>FileDialog.SaveFile</strong> 保存文件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick</span><br><span class="line">import QtQuick.Dialogs</span><br><span class="line">import QtQuick.Window 2.15</span><br><span class="line">import QtQuick.Controls 2.15</span><br><span class="line">import QtQuick.Layouts 1.15</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 640; height: 480; visible: true</span><br><span class="line"></span><br><span class="line">    Image &#123;</span><br><span class="line">        id: image; anchors.fill: parent</span><br><span class="line">        fillMode: Image.PreserveAspectFit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Button &#123;</span><br><span class="line">        text: qsTr(&quot;Choose Image...&quot;)</span><br><span class="line">        onClicked: fileDialog.open()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FileDialog &#123;</span><br><span class="line">        id: fileDialog</span><br><span class="line">        nameFilters: [&quot;Image files (*.png *.jpg)&quot;]</span><br><span class="line">        currentFolder: StandardPaths.writableLocation</span><br><span class="line">                       (StandardPaths.PicturesLocation)</span><br><span class="line">        acceptLabel: qsTr(&quot;选择图片&quot;)</span><br><span class="line">        onAccepted: image.source = selectedFile</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704123830863.png" alt="image-20250704123830863"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704123901114.png" alt="image-20250704123901114"></p>
<hr>
<h4 id="消息对话框MessageDialog"><a href="#消息对话框MessageDialog" class="headerlink" title="消息对话框MessageDialog"></a>消息对话框MessageDialog</h4><p>MessageDialog类型为系统消息对话框提供了QML API。</p>
<ul>
<li>text属性，作为主要文本用来提醒用户注意的情况；</li>
<li>informativeText属性，作为信息性文本以进一步解释警报或向用户提问；</li>
<li>detailedText属性，作为可选的详细文本用于用户请求时提供更多数据；</li>
<li>buttons属性用来设置按钮，例如MessageDialog.Ok、MessageDialog.Cancel等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Window &#123;</span><br><span class="line">    width: 640; height: 480; visible: true</span><br><span class="line"></span><br><span class="line">    Button &#123;</span><br><span class="line">        text: qsTr(&quot;消息对话框&quot;)</span><br><span class="line">        onClicked: dlg.open()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MessageDialog &#123;</span><br><span class="line">        id: dlg</span><br><span class="line">        title: qsTr(&quot;消息对话框&quot;)</span><br><span class="line">        text: qsTr(&quot;这里是text的内容&quot;)</span><br><span class="line">        informativeText: qsTr(&quot;这里是informativeText的内容&quot;)</span><br><span class="line">        detailedText: qsTr(&quot;这里是detailedText的内容&quot;)</span><br><span class="line">        buttons: MessageDialog.Ok | MessageDialog.Cancel</span><br><span class="line">        onAccepted: console.log(&quot;ok&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704124058323.png" alt="image-20250704124058323"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704124113434.png" alt="image-20250704124113434"></p>
<hr>
<hr>
<h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><h3 id="调式模式"><a href="#调式模式" class="headerlink" title="调式模式"></a>调式模式</h3><p>Qt Creator中提供的调试模式可以对<strong>Qt Widgets</strong>和<strong>Qt Quick</strong>程序进行调试，其中的调试器可以查看应用程序在运行或崩溃时内部发生的情况，它可以通过如下方式来查找应用中的问题：</p>
<ul>
<li>使用指定的参数启动应用程序；</li>
<li>在满足条件时停止应用程序；</li>
<li>检查应用程序停止时会发生什么；</li>
<li>修复错误后对应用程序进行更改，然后继续查找下一个错误。</li>
</ul>
<p>开始调试前一般在需要调试的代码标号前面单击来设置<strong>断点</strong>。</p>
<p>所谓<strong>断点</strong>，就是程序运行到该行代码时会暂停下来，从而可以查看一些信息。</p>
<p>要取消<strong>断点</strong>，只要在那个断点上再单击一下就可以了。</p>
<p>设置好<strong>断点</strong>后便可以按下<strong>F5</strong>或者**左下角的调试按钮(带虫子的那个三角形)**开始调试。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704125657393.png" alt="image-20250704125657393"></p>
<ul>
<li><strong>继续</strong>按钮。程序在断点处停了下来，按下继续按钮后，程序便会像正常运行一样。</li>
<li><strong>停止</strong>调试按钮。按下该按钮后结束调试。</li>
<li><strong>单步跳过</strong>按钮。直接执行本行代码，然后指向下一行代码。</li>
<li><strong>单步进入</strong>按钮。进入调用的函数内部。</li>
<li><strong>单步跳出</strong>按钮。当进入函数内部时，跳出该函数，一般与单步进入配合使用。</li>
<li><strong>重新启动</strong>调试会话。</li>
<li><strong>显示源码</strong>对应的汇编指令，并可以单步调试</li>
<li><strong>堆栈视图</strong>。这里显示了从程序开始到断点处，所有嵌套调用的函数所在的源文件名和行号。</li>
<li><strong>其它视图</strong>。这里可以选择多种视图，主要有局部变量（Locals）和表达式（Expressions）视图、断点（Breakpoints）视图、线程视图（Threads）等。</li>
</ul>
<hr>
<h3 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h3><p>一直单击“单步跳过”按钮，单步执行程序并查看右上角局部变量视图中相应变量值的变化情况。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250704130113755.png" alt="image-20250704130113755"></p>
<hr>
<h3 id="qDeBug"><a href="#qDeBug" class="headerlink" title="qDeBug()"></a>qDeBug()</h3><p><strong>在Qt Widgets程序中使用qDebug()函数</strong></p>
<ul>
<li><p>程序调试过程中常用的是**qDebug()、qInfo()、qCritical()、qWarning()和qFatal()**等函数，它们由Qt Core模块提供，可以将调试信息直接输出到控制台。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int x = widget.x();</span><br><span class="line">   qDebug(&quot;x: %d&quot;, x);           </span><br><span class="line">   int y = widget.y();</span><br><span class="line">   qDebug(&quot;y: %d&quot;, y);</span><br><span class="line">   QRect geometry = a.geometry();</span><br><span class="line">   QRect frame = widget.frameGeometry();</span><br><span class="line">   qDebug() &lt;&lt; &quot;geometry: &quot; &lt;&lt; geometry </span><br><span class="line">                &lt;&lt; &quot;frame: &quot; &lt;&lt; frame;</span><br></pre></td></tr></table></figure>

<p>Qt Creator中是输出到下方应用程序输出栏。</p>
<p>在Qt Widgets程序中，调试信息一般<strong>常用qDebug()</strong>。</p>
</li>
<li><p>这里使用了两种输出方法，一种是<strong>直接将字符串当做参数传给qDebug()函数</strong>，例如上面使用这种方法输出x和y的值。</p>
<p>另一种方法是使用<strong>输出流的方式</strong>一次输出多个值，它们的类型可以不同，如程序中输出geometry和frame的值。实际编程中经常使用第二种方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qDebug() &lt;&lt; &quot;pos:&quot; &lt;&lt; widget.pos() &lt;&lt; Qt::endl </span><br><span class="line">         &lt;&lt; &quot;rect:&quot; &lt;&lt; widget.rect()&lt;&lt; Qt::endl </span><br><span class="line">         &lt;&lt; &quot;size:&quot; &lt;&lt; widget.size() &lt;&lt; Qt::endl </span><br><span class="line">         &lt;&lt; &quot;width:&quot;&lt;&lt; widget.width() &lt;&lt; Qt::endl </span><br><span class="line">         &lt;&lt; &quot;height:&quot; &lt;&lt; widget.height();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="console-log"><a href="#console-log" class="headerlink" title="console.log()"></a>console.log()</h3><p>**在Qt Quick程序中使用console.log()函数 **</p>
<p>Qt Quick程序也可以使用调试模式，而且QML中也提供了<strong>console.log()、 console.debug()、console.info()、 console.warn()和console.error()<strong>等调试输出函数，比较</strong>常用的是console.log()</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: 200</span><br><span class="line">    height: 200</span><br><span class="line">    color: &quot;blue&quot;</span><br><span class="line">    </span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill:parent</span><br><span class="line">        onClicked: console.log(&quot;矩形的颜色：&quot;, parent.color)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h2><p>无论是想要界面中部件有一个<strong>整齐</strong>的排列，还是想要界面能<strong>适应窗口的大小变化</strong>，都要进行布局管理。</p>
<h3 id="Qt-Widgets-布局"><a href="#Qt-Widgets-布局" class="headerlink" title="Qt Widgets 布局"></a>Qt Widgets 布局</h3><p>使用<strong>布局管理器</strong>。</p>
<p>Qt 包含了一组布局管理类，从而在应用程序的用户界面中对部件进行布局，比如 <strong>QLayout</strong> 的几个子类，这里将它们称作<strong>布局管理器</strong>。</p>
<h4 id="布局管理器系统"><a href="#布局管理器系统" class="headerlink" title="布局管理器系统"></a>布局管理器系统</h4><p>所有的 QWidget 的子类的实例都可以使用布局管理器管理位于它们之中的子部件，**<code>QWidget::setLayout()</code>**函数可以在一个部件上应用布局管理器。</p>
<p>一旦一个部件上设置了布局管理器，那么它会完成以下几种任务：</p>
<ul>
<li>定位子部件；</li>
<li>感知窗口默认大小；</li>
<li>感知窗口最小大小；</li>
<li>窗口大小变化时进行处理；</li>
<li>当内容改变时自动更新：<ul>
<li>字体大小、文本或子部件的其他内容随之改变；</li>
<li>隐藏或显示子部件；</li>
<li>移除一个子部件。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="布局管理器简介"><a href="#布局管理器简介" class="headerlink" title="布局管理器简介"></a>布局管理器简介</h4><p><strong>QLayout</strong> 类是布局管理器的基类，它是一个抽象基类，继承自 <strong>QObject</strong> 和 <strong>QLayoutItem</strong> 类，其中 <strong>QLayoutItem</strong> 类提供了一个供 <strong>QLayout</strong> 操作的抽象项目。</p>
<p><strong>QLayout</strong> 和 <strong>QLayoutItem</strong> 都是在设计自己的布局管理器时才使用的，一般只需要使用 <strong>QLayout</strong> 的几个子类即可：</p>
<ul>
<li>QBoxLayout（基本布局管理器）</li>
<li>QGridLayout（栅格布局管理器）</li>
<li>QFormLayout（窗体布局管理器）</li>
<li>QStackedLayout（栈布局管理器）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class QObject &#123;</span><br><span class="line">        + 对象树管理</span><br><span class="line">        + 父子关系</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class QLayoutItem &#123;</span><br><span class="line">        &lt;&lt;abstract&gt;&gt;</span><br><span class="line">        + sizeHint() QSize</span><br><span class="line">        + minimumSize() QSize</span><br><span class="line">        + maximumSize() QSize</span><br><span class="line">        + setGeometry(QRect)</span><br><span class="line">        + geometry() QRect</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class QLayout &#123;</span><br><span class="line">        &lt;&lt;abstract&gt;&gt;</span><br><span class="line">        + addWidget(QWidget*)</span><br><span class="line">        + addItem(QLayoutItem*)</span><br><span class="line">        + setSpacing(int)</span><br><span class="line">        + activate()</span><br><span class="line">        + update()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class QBoxLayout &#123;</span><br><span class="line">        + 线性排列控件</span><br><span class="line">        + 方向：左→右/上→下/右→左/下→上</span><br><span class="line">        + addStretch()</span><br><span class="line">        + insertSpacing()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class QGridLayout &#123;</span><br><span class="line">        + 网格状布局</span><br><span class="line">        + 行列管理</span><br><span class="line">        + addWidget(widget, row, col)</span><br><span class="line">        + setRowStretch()</span><br><span class="line">        + setColumnMinimumWidth()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class QFormLayout &#123;</span><br><span class="line">        + 两列表单布局</span><br><span class="line">        + 标签 + 输入控件</span><br><span class="line">        + addRow(label, widget)</span><br><span class="line">        + setFieldGrowthPolicy()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class QStackedLayout &#123;</span><br><span class="line">        + 层叠布局（类似选项卡）</span><br><span class="line">        + 同一区域显示一个控件</span><br><span class="line">        + setCurrentIndex()</span><br><span class="line">        + addWidget(widget)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    QObject &lt;|-- QLayout</span><br><span class="line">    QLayoutItem &lt;|-- QLayout</span><br><span class="line">    QLayout &lt;|-- QBoxLayout</span><br><span class="line">    QLayout &lt;|-- QGridLayout</span><br><span class="line">    QLayout &lt;|-- QFormLayout</span><br><span class="line">    QLayout &lt;|-- QStackedLayout</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[QLayout 抽象基类] --&gt; B[QBoxLayout]</span><br><span class="line">A --&gt; C[QGridLayout]</span><br><span class="line">A --&gt; D[QFormLayout]</span><br><span class="line">A --&gt; E[QStackedLayout]</span><br><span class="line"></span><br><span class="line">B --&gt;|水平/垂直| F[线性排列]</span><br><span class="line">C --&gt;|行+列| G[网格单元格]</span><br><span class="line">D --&gt;|标签+字段| H[表单样式]</span><br><span class="line">E --&gt;|Z轴堆叠| I[单区域多页面]</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<ul>
<li><p>在设计模式中向界面上拖入一个字体选择框<strong>Font Combo Box</strong>和一个文本编辑器<strong>Text Edit</strong>部件。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705090133927.png" alt="image-20250705090133927"></p>
</li>
<li><p>设置顶层布局管理器</p>
<ul>
<li><p><strong>方法一</strong>：单击主界面并按下Ctrl+L快捷键。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705090308657.png" alt="image-20250705090308657"></p>
</li>
<li><p><strong>方法二</strong>：单击设计器上部边栏中的图标来对主界面进行垂直布局管理。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705090453928.png" alt="image-20250705090453928"></p>
</li>
<li><p><strong>方法三</strong>：在主界面上右击，在弹出的级联菜单中选择“布局→垂直布局”。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705090911738.png" alt="image-20250705090911738"></p>
</li>
</ul>
</li>
<li><p>运行</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705090949711.png" alt="image-20250705090949711"></p>
</li>
</ul>
<hr>
<h4 id="基本布局管理器"><a href="#基本布局管理器" class="headerlink" title="基本布局管理器"></a>基本布局管理器</h4><ul>
<li><p>基本布局管理器 <strong>QBoxLayout</strong> 类：</p>
<p>可以使子部件在<strong>水平方向</strong>或者<strong>垂直方向</strong>排成一列，将所有的空间<strong>分成一行盒子</strong>，然后<strong>将每个部件放入对应盒子中</strong>。它有两个子类：</p>
<ul>
<li><p><strong>QHBoxLayout</strong> 水平布局管理器</p>
</li>
<li><p><strong>QVBoxLayout</strong> 垂直布局管理器</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705094110247.png" alt="image-20250705094110247"></p>
</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705091322794.png" alt="image-20250705091322794"></p>
<p><strong>示例：</strong></p>
<p>可以使用**<code>addWidget()</code><strong>函数向布局管理器的末尾添加部件，还有一个</strong><code>insertWidget()</code>**函数可以实现向指定位置添加部件，</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705093916161.png" alt="image-20250705093916161"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QHBoxLayout *layout = new QHBoxLayout;       </span><br><span class="line">layout-&gt;addWidget(ui-&gt;fontComboBox);         </span><br><span class="line">layout-&gt;addWidget(ui-&gt;textEdit);</span><br><span class="line">layout-&gt;setSpacing(50);                       </span><br><span class="line">layout-&gt;setContentsMargins(0, 0, 50, 100);  </span><br><span class="line">setLayout(layout);                          </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QHBoxLayout 示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建水平布局</span></span><br><span class="line">    QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个控件</span></span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;点击我&quot;</span>);</span><br><span class="line">    QTextEdit *textEdit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    textEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;输入文本...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将控件添加到布局</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(textEdit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置布局参数</span></span><br><span class="line">    layout-&gt;<span class="built_in">setSpacing</span>(<span class="number">50</span>);         <span class="comment">// 控件间距</span></span><br><span class="line">    layout-&gt;<span class="built_in">setContentsMargins</span>(<span class="number">30</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>);  <span class="comment">// 边距(左,上,右,下)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将布局设置到窗口</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705091638895.png" alt="image-20250705091638895"></p>
</li>
<li><p>栅格布局管理器 <strong>QGridLayout</strong> 类：</p>
<p>使部件在网格中进行布局，它将所有的空间分隔成一些行和列，行和列的交叉处就形成了单元格，然后将部件放入一个确定的单元格中。</p>
<p><strong>示例：</strong></p>
<p>设置部件在栅格布局管理器中的位置，将 <strong>fontComboBox</strong> 部件设置为占据1行2列，而 <strong>pushButton</strong> 部件占据1行1列，这主要是为了将 <strong>fontComboBox</strong> 部件和 <strong>pushButton</strong> 部件的长度设置为 <strong>2:1</strong>。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705093308259.png" alt="image-20250705093308259"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QGridLayout *layout = new QGridLayout;</span><br><span class="line">// 添加部件，从第0行0列开始，占据1行2列</span><br><span class="line">layout-&gt;addWidget(ui-&gt;fontComboBox, 0, 0, 1, 2);</span><br><span class="line">// 添加部件，从第0行2列开始，占据1行1列</span><br><span class="line">layout-&gt;addWidget(ui-&gt;pushButton, 0, 2, 1, 1);</span><br><span class="line">// 添加部件，从第1行0列开始，占据1行3列</span><br><span class="line">layout-&gt;addWidget(ui-&gt;textEdit, 1, 0, 1, 3);</span><br><span class="line">setLayout(layout);                          </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGridLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QGridLayout 示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">300</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建网格布局</span></span><br><span class="line">    QGridLayout *layout = <span class="keyword">new</span> QGridLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建控件</span></span><br><span class="line">    QComboBox *comboBox = <span class="keyword">new</span> QComboBox;</span><br><span class="line">    comboBox-&gt;<span class="built_in">addItems</span>(&#123;<span class="string">&quot;Arial&quot;</span>, <span class="string">&quot;Times New Roman&quot;</span>, <span class="string">&quot;Verdana&quot;</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;确认&quot;</span>);</span><br><span class="line">    QTextEdit *textEdit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    textEdit-&gt;<span class="built_in">setPlaceholderText</span>(<span class="string">&quot;在此输入文本...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加控件到网格布局</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(comboBox, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 第0行0列，占据1行2列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button,   <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 第0行2列，占据1行1列</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(textEdit, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 第1行0列，占据1行3列</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可选：设置间距和边距</span></span><br><span class="line">    layout-&gt;<span class="built_in">setSpacing</span>(<span class="number">10</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">setContentsMargins</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将布局设置到窗口</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705092618235.png" alt="image-20250705092618235"></p>
</li>
<li><p>窗体布局管理器 <strong>QFormLayout</strong> 类：</p>
<p>用来管理表单的输入部件以及与它们相关的标签。</p>
<p>窗体布局管理器将它的子部件分为两列，<strong>左边</strong>是一些<strong>标签</strong>，<strong>右边</strong>是一些<strong>输入部件</strong>，比如行编辑器或者数字选择框等。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705095847444.png" alt="image-20250705095847444"></p>
<p><strong>示例一：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &lt;QFormLayout&gt;</span><br><span class="line">#include &lt;QLineEdit&gt;</span><br><span class="line">#include &lt;QComboBox&gt;</span><br><span class="line">#include &lt;QSpinBox&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QLabel&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line">    </span><br><span class="line">    // 创建主窗口</span><br><span class="line">    QWidget window;</span><br><span class="line">    window.setWindowTitle(&quot;QFormLayout 示例&quot;);</span><br><span class="line">    window.resize(400, 200);</span><br><span class="line">    </span><br><span class="line">    // 创建表单布局</span><br><span class="line">    QFormLayout *layout = new QFormLayout;</span><br><span class="line">    </span><br><span class="line">    // 创建表单控件</span><br><span class="line">    QLineEdit *nameEdit = new QLineEdit;</span><br><span class="line">    nameEdit-&gt;setPlaceholderText(&quot;输入姓名&quot;);</span><br><span class="line">    </span><br><span class="line">    QSpinBox *ageSpin = new QSpinBox;</span><br><span class="line">    ageSpin-&gt;setRange(1, 120);</span><br><span class="line">    ageSpin-&gt;setValue(25);</span><br><span class="line">    </span><br><span class="line">    QComboBox *genderCombo = new QComboBox;</span><br><span class="line">    genderCombo-&gt;addItems(&#123;&quot;男&quot;, &quot;女&quot;, &quot;其他&quot;&#125;);</span><br><span class="line">    </span><br><span class="line">    QPushButton *submitButton = new QPushButton(&quot;提交&quot;);</span><br><span class="line">    </span><br><span class="line">    // 添加表单项（标签 + 控件）</span><br><span class="line">    layout-&gt;addRow(&quot;姓名:&quot;, nameEdit);</span><br><span class="line">    layout-&gt;addRow(&quot;年龄:&quot;, ageSpin);</span><br><span class="line">    layout-&gt;addRow(&quot;性别:&quot;, genderCombo);</span><br><span class="line">    </span><br><span class="line">    // 添加按钮（跨两列）</span><br><span class="line">    layout-&gt;addRow(submitButton);</span><br><span class="line">    </span><br><span class="line">    // 设置布局参数</span><br><span class="line">    layout-&gt;setSpacing(15);  // 行间距</span><br><span class="line">    layout-&gt;setContentsMargins(30, 20, 30, 20);</span><br><span class="line">    </span><br><span class="line">    // 设置标签对齐方式</span><br><span class="line">    layout-&gt;setLabelAlignment(Qt::AlignRight);</span><br><span class="line">    </span><br><span class="line">    // 将布局设置到窗口</span><br><span class="line">    window.setLayout(layout);</span><br><span class="line">    window.show();</span><br><span class="line">    </span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705094444741.png" alt="image-20250705094444741"></p>
</li>
<li><p>栈布局管理器 <strong>QStackedLayout</strong> 类：</p>
<p>堆叠布局，管理多个重叠的页面</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705100608502.png" alt="image-20250705100608502"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStackedLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;QStackedLayout 示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主垂直布局（用于放置切换按钮和堆叠布局）</span></span><br><span class="line">    QVBoxLayout *mainLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建按钮布局（水平布局）</span></span><br><span class="line">    QHBoxLayout *buttonLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建切换按钮</span></span><br><span class="line">    QPushButton *page1Button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;显示页面 1&quot;</span>);</span><br><span class="line">    QPushButton *page2Button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;显示页面 2&quot;</span>);</span><br><span class="line">    QPushButton *page3Button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;显示页面 3&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buttonLayout-&gt;<span class="built_in">addWidget</span>(page1Button);</span><br><span class="line">    buttonLayout-&gt;<span class="built_in">addWidget</span>(page2Button);</span><br><span class="line">    buttonLayout-&gt;<span class="built_in">addWidget</span>(page3Button);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建堆叠布局</span></span><br><span class="line">    QStackedLayout *stackedLayout = <span class="keyword">new</span> QStackedLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建三个不同颜色的页面</span></span><br><span class="line">    QWidget *page1 = <span class="keyword">new</span> QWidget;</span><br><span class="line">    page1-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: #FFCCCC;&quot;</span>);</span><br><span class="line">    QLabel *label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;&lt;h1&gt;页面 1&lt;/h1&gt;&lt;p&gt;这是堆叠布局的第一个页面&lt;/p&gt;&quot;</span>);</span><br><span class="line">    label1-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    QVBoxLayout *page1Layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(page1);</span><br><span class="line">    page1Layout-&gt;<span class="built_in">addWidget</span>(label1);</span><br><span class="line">    </span><br><span class="line">    QWidget *page2 = <span class="keyword">new</span> QWidget;</span><br><span class="line">    page2-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: #CCFFCC;&quot;</span>);</span><br><span class="line">    QLabel *label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;&lt;h1&gt;页面 2&lt;/h1&gt;&lt;p&gt;这是堆叠布局的第二个页面&lt;/p&gt;&quot;</span>);</span><br><span class="line">    label2-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    QVBoxLayout *page2Layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(page2);</span><br><span class="line">    page2Layout-&gt;<span class="built_in">addWidget</span>(label2);</span><br><span class="line">    </span><br><span class="line">    QWidget *page3 = <span class="keyword">new</span> QWidget;</span><br><span class="line">    page3-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background-color: #CCCCFF;&quot;</span>);</span><br><span class="line">    QLabel *label3 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;&lt;h1&gt;页面 3&lt;/h1&gt;&lt;p&gt;这是堆叠布局的第三个页面&lt;/p&gt;&quot;</span>);</span><br><span class="line">    label3-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">    QVBoxLayout *page3Layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(page3);</span><br><span class="line">    page3Layout-&gt;<span class="built_in">addWidget</span>(label3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将页面添加到堆叠布局</span></span><br><span class="line">    stackedLayout-&gt;<span class="built_in">addWidget</span>(page1);</span><br><span class="line">    stackedLayout-&gt;<span class="built_in">addWidget</span>(page2);</span><br><span class="line">    stackedLayout-&gt;<span class="built_in">addWidget</span>(page3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接按钮信号到切换槽函数</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(page1Button, &amp;QPushButton::clicked, [stackedLayout]() &#123;</span><br><span class="line">        stackedLayout-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);  <span class="comment">// 切换到页面1</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    QObject::<span class="built_in">connect</span>(page2Button, &amp;QPushButton::clicked, [stackedLayout]() &#123;</span><br><span class="line">        stackedLayout-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">1</span>);  <span class="comment">// 切换到页面2</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    QObject::<span class="built_in">connect</span>(page3Button, &amp;QPushButton::clicked, [stackedLayout]() &#123;</span><br><span class="line">        stackedLayout-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">2</span>);  <span class="comment">// 切换到页面3</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将按钮布局和堆叠布局添加到主布局</span></span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(buttonLayout);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(stackedLayout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置主布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(mainLayout);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击不同按钮时，主体区域会切换到对应的页面：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705100023541.png" alt="image-20250705100023541"></p>
</li>
</ul>
<hr>
<p><strong>综合使用布局管理器：代码</strong></p>
<p>综合使用QFormLayout、QGridLayout和QBoxLayout</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFormLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGridLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QComboBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRadioButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGroupBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;综合布局示例&quot;</span>);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主布局 - 垂直布局</span></span><br><span class="line">    QVBoxLayout *mainLayout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 表单布局部分 (个人信息)</span></span><br><span class="line">    QGroupBox *formGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;个人信息&quot;</span>);</span><br><span class="line">    QFormLayout *formLayout = <span class="keyword">new</span> QFormLayout;</span><br><span class="line">    </span><br><span class="line">    QLineEdit *nameEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    QSpinBox *ageSpin = <span class="keyword">new</span> QSpinBox;</span><br><span class="line">    ageSpin-&gt;<span class="built_in">setRange</span>(<span class="number">1</span>, <span class="number">120</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 性别单选按钮</span></span><br><span class="line">    QHBoxLayout *genderLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    QRadioButton *maleRadio = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    QRadioButton *femaleRadio = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    genderLayout-&gt;<span class="built_in">addWidget</span>(maleRadio);</span><br><span class="line">    genderLayout-&gt;<span class="built_in">addWidget</span>(femaleRadio);</span><br><span class="line">    maleRadio-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 邮箱组合控件</span></span><br><span class="line">    QHBoxLayout *emailLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    QLineEdit *emailEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">    QComboBox *emailCombo = <span class="keyword">new</span> QComboBox;</span><br><span class="line">    emailCombo-&gt;<span class="built_in">addItems</span>(&#123;<span class="string">&quot;@qq.com&quot;</span>, <span class="string">&quot;@163.com&quot;</span>, <span class="string">&quot;@gmail.com&quot;</span>, <span class="string">&quot;@outlook.com&quot;</span>&#125;);</span><br><span class="line">    emailLayout-&gt;<span class="built_in">addWidget</span>(emailEdit);</span><br><span class="line">    emailLayout-&gt;<span class="built_in">addWidget</span>(emailCombo);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加表单行</span></span><br><span class="line">    formLayout-&gt;<span class="built_in">addRow</span>(<span class="string">&quot;姓名:&quot;</span>, nameEdit);</span><br><span class="line">    formLayout-&gt;<span class="built_in">addRow</span>(<span class="string">&quot;性别:&quot;</span>, genderLayout);</span><br><span class="line">    formLayout-&gt;<span class="built_in">addRow</span>(<span class="string">&quot;年龄:&quot;</span>, ageSpin);</span><br><span class="line">    formLayout-&gt;<span class="built_in">addRow</span>(<span class="string">&quot;邮箱:&quot;</span>, emailLayout);</span><br><span class="line">    formGroup-&gt;<span class="built_in">setLayout</span>(formLayout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 网格布局部分 (内容编辑)</span></span><br><span class="line">    QGroupBox *gridGroup = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;内容编辑&quot;</span>);</span><br><span class="line">    QGridLayout *gridLayout = <span class="keyword">new</span> QGridLayout;</span><br><span class="line">    </span><br><span class="line">    QComboBox *fontCombo = <span class="keyword">new</span> QComboBox;</span><br><span class="line">    fontCombo-&gt;<span class="built_in">addItems</span>(&#123;<span class="string">&quot;Arial&quot;</span>, <span class="string">&quot;Times New Roman&quot;</span>, <span class="string">&quot;Verdana&quot;</span>&#125;);</span><br><span class="line">    QPushButton *fontButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;设置字体&quot;</span>);</span><br><span class="line">    QTextEdit *textEdit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    </span><br><span class="line">    gridLayout-&gt;<span class="built_in">addWidget</span>(fontCombo, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    gridLayout-&gt;<span class="built_in">addWidget</span>(fontButton, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    gridLayout-&gt;<span class="built_in">addWidget</span>(textEdit, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 占据1行2列</span></span><br><span class="line">    gridGroup-&gt;<span class="built_in">setLayout</span>(gridLayout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 按钮布局 (水平布局)</span></span><br><span class="line">    QHBoxLayout *buttonLayout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    QPushButton *submitButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;提交&quot;</span>);</span><br><span class="line">    QPushButton *cancelButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;取消&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    buttonLayout-&gt;<span class="built_in">addStretch</span>(); <span class="comment">// 添加弹性空间</span></span><br><span class="line">    buttonLayout-&gt;<span class="built_in">addWidget</span>(submitButton);</span><br><span class="line">    buttonLayout-&gt;<span class="built_in">addWidget</span>(cancelButton);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 组合所有布局</span></span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(formGroup);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addWidget</span>(gridGroup);</span><br><span class="line">    mainLayout-&gt;<span class="built_in">addLayout</span>(buttonLayout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置主布局</span></span><br><span class="line">    window.<span class="built_in">setLayout</span>(mainLayout);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705101909902.png" alt="image-20250705101909902"></p>
<hr>
<p><strong>综合使用布局管理器：设计模式</strong></p>
<ul>
<li><p><strong>格栅布局：</strong></p>
<p>拉入 <strong>Font Combo Box</strong> 和 <strong>Push Button</strong>，然后<strong>全选</strong>这两部件，<strong>右击</strong>选择布局，选择<strong>水平布局</strong>。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705102754439.png" alt="image-20250705102754439"></p>
<p>再拉入 <strong>Text Eidt</strong> 部件，<strong>全选</strong>所有部件，<strong>右击</strong>选择<strong>布局</strong>，选择<strong>格栅分布</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705104119828.png" alt="image-20250705104119828"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705104137561.png" alt="image-20250705104137561"></p>
</li>
<li><p><strong>窗体布局</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705094807386.png" alt="image-20250705094807386"></p>
<p><strong>1.<strong>在</strong>标签文字</strong>对话框中填入<strong>姓名(&amp;N)：</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705095006836.png" alt="image-20250705095006836"></p>
<p>效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705095121261.png" alt="image-20250705095121261"></p>
<p><strong>2.SpinBox：</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705110158779.png" alt="image-20250705110158779"></p>
<p><strong>3.制作邮箱：</strong></p>
<p>拉入<strong>Label、Line Edit、Combo Box</strong>部件，</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705110501864.png" alt="image-20250705110501864"></p>
<p>再<strong>全选</strong>这三个部件，<strong>右击</strong>选择<strong>布局</strong>，选择<strong>水平</strong>，</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705110552808.png" alt="image-20250705110552808"></p>
<p><strong>4.组合：</strong> <strong>全选</strong>这两个大部件，<strong>右击</strong>选择<strong>布局</strong>，选择<strong>格栅</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705110651830.png" alt="image-20250705110651830"></p>
<p><strong>5.效果：</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705110800983.png" alt="image-20250705110800983"></p>
</li>
<li><p>拉入 <strong>Vertical Layout垂直布局</strong>，要求<strong>Vertical Layout垂直布局</strong> 位于两个之间，起到隔断作用。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705111017425.png" alt="image-20250705111017425"></p>
</li>
<li><p>综合垂直：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705111256021.png" alt="image-20250705111256021"></p>
<p>效果：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705111321466.png" alt="image-20250705111321466"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705111548836.png" alt="image-20250705111548836"></p>
</li>
<li><p>设置大小：</p>
<p>单击主界面并按下Ctrl+L快捷键，让整个界面处于一个垂直布局管理器中。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705112436553.png" alt="image-20250705112436553"></p>
<p>可以在这里设置布局的大小：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705112844503.png" alt="image-20250705112844503"></p>
</li>
</ul>
<hr>
<hr>
<h4 id="设置部件大小"><a href="#设置部件大小" class="headerlink" title="设置部件大小"></a>设置部件大小</h4><p>大小提示（<strong>sizeHint</strong>）和最小大小提示（<strong>minimumSizeHint</strong>）</p>
<p>凡是继承自<strong>QWidget</strong>的类都有这两个属性。</p>
<ul>
<li>其中<strong>sizeHint</strong>属性保存了部件的建议大小，对于不同的部件，默认拥有不同的<strong>sizeHint</strong>。</li>
<li>而<strong>minimumSizeHint</strong>保存了一个建议的最小大小提示。</li>
<li>可以使用**<code>sizeHint()</code><strong>函数来获取</strong>sizeHint<strong>的值，使用</strong><code>minimumSizeHint()</code>函<strong>数获取</strong>minimumSizeHint**的值。</li>
</ul>
<p>需要说明的是，如果使用**<code>setMinimumSize()</code>**函数设置了部件的最小大小，那么最小大小提示将会被忽略。</p>
<p>大小策略（<strong>sizePolicy</strong>）属性，也是<strong>QWidget</strong>类的属性。这个属性保存了部件的默认布局行为，在<strong>水平</strong>和<strong>垂直</strong>两个方向分别起作用，控制着部件在布局管理器中的大小变化行为。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705113708462.png" alt="image-20250705113708462"></p>
<hr>
<h4 id="可扩展窗口"><a href="#可扩展窗口" class="headerlink" title="可扩展窗口"></a>可扩展窗口</h4><p>一个窗口可能很多选项是扩充的，只有在必要的时候才显示出来，这时就可以使用一个按钮，用来隐藏或者显示多余的内容，就是所谓的可扩展窗口。要实现可扩展窗口，就要得力于布局管理器的特性，那就是当子部件隐藏时，布局管理器自动缩小，当子部件重新显示时，布局管理器再次放大。</p>
<p><strong>示例：</strong></p>
<p>设计模式拉入<strong>Font Combo Box、Push Button、Text Edit</strong>，<strong>全选</strong>，<strong>右击选择布局</strong>：<strong>垂直</strong>或者<strong>格栅</strong>。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705115053914.png" alt="image-20250705115053914"></p>
<p>要勾选按钮的<strong>checkable</strong>，使按钮起效。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705121932397.png" alt="image-20250705121932397"></p>
<p>选中<strong>PushButton</strong>，<strong>右击</strong>选择<strong>转到槽</strong>，选择**<code>toggled(bool)</code>**</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705115211171.png" alt="image-20250705115211171"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705115301893.png" alt="image-20250705115301893"></p>
<p><strong>完善代码：widget.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始状态设置</span></span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">    ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;显示扩展区域&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动连接信号槽（如果自动连接失效）</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pushButton, &amp;QPushButton::toggled,</span><br><span class="line">            <span class="keyword">this</span>, &amp;Widget::on_pushButton_toggled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_pushButton_toggled</span><span class="params">(<span class="type">bool</span> checked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;textEdit-&gt;<span class="built_in">setVisible</span>(checked);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(checked) &#123;</span><br><span class="line">        <span class="comment">// 根据UI中控件的实际高度设置</span></span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;隐藏扩展区域&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;pushButton-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;显示扩展区域&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Qt-Quick-布局"><a href="#Qt-Quick-布局" class="headerlink" title="Qt Quick 布局"></a>Qt Quick 布局</h3><p>使用<strong>布局管理器</strong>或<strong>基于锚的布局</strong>。</p>
<p>Qt Quick 还提供了<strong>定位器</strong>，可以用来为多个项目进行常规的布局；如果需要同时管理项目的位置和大小，可以使用布局管理器。</p>
<h4 id="定位器"><a href="#定位器" class="headerlink" title="定位器"></a>定位器</h4><p>定位器是一个容器，可以管理其中子项目的布局，包括<strong>Column、Row、Grid</strong>和<strong>Flow</strong>。如果它们的子项目不可见（visible为false）、宽度或者高度为0，那么该子项目不会显示也不会被布局。</p>
<ul>
<li><p><strong>Column和Row</strong></p>
<p>Column项目可以将其子项目垂直排成一列。</p>
<p><strong>示例：</strong></p>
<p>使用了Column定位几个形状不同的Rectangle。Column的属性：</p>
<ul>
<li><strong>spacing</strong>属性用来为这几个Rectangle添加<strong>竖向</strong>间距，</li>
<li><strong>padding</strong>属性用来设置Column子项目和边界之间的距离，</li>
<li>也可以通过<strong>topPadding、bottomPadding、leftPadding、rightPadding</strong>分别进行设置。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 640</span><br><span class="line">    height: 480</span><br><span class="line">    visible: true</span><br><span class="line">    title: qsTr(&quot;Hello World&quot;)</span><br><span class="line"></span><br><span class="line">    Column &#123;</span><br><span class="line">        spacing: 2; padding: 5</span><br><span class="line"></span><br><span class="line">        Rectangle &#123; color: &quot;white&quot;; border.width: 1;</span><br><span class="line">                                  width: 50; height: 50 &#125;</span><br><span class="line">        Rectangle &#123; color: &quot;green&quot;; width: 20; height: 50 &#125;</span><br><span class="line">        Rectangle &#123; color: &quot;lightgrey&quot;; width: 50; height: 20 &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705122342716.png" alt="image-20250705122342716"></p>
<p><strong>Row项目与Column用法相似，可以将其子项目水平排列成一行。</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705122656955.png" alt="image-20250705122656955"></p>
</li>
<li><p><strong>Grid</strong></p>
<p>Grid项目可以将其子项目排列在一个网格中。Grid会计算一个足够大的矩形网格来容纳所有的子项目。</p>
<p>向网格中添加项目，会按照<strong>从左向右、从上向下</strong>的顺序进行排列。</p>
<p>每一个项目都会被放置在网格左上角(0, 0)的位置。</p>
<p>一个Grid默认有<strong>四列</strong>，可以有无限多的行容纳所有的子项目。</p>
<p>行数和列数也可以通过<strong>rows</strong>和<strong>columns</strong>属性指定。</p>
<p>另外，Grid也可以通过<strong>spacing</strong>属性设置子项目之间的间距，此时，水平方向和垂直方向会使用相同的间距，如果需要分别设置，可以使用<strong>rowSpacing</strong>和<strong>columnSpacing</strong>属性。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Grid &#123;</span><br><span class="line">    columns: 3; spacing: 2; padding: 5</span><br><span class="line">    Rectangle &#123; color: &quot;white&quot;; border.width: 1; </span><br><span class="line">                width: 50; height: 50 &#125;</span><br><span class="line">    Rectangle &#123; color: &quot;green&quot;; width: 20; height: 50 &#125;</span><br><span class="line">    Rectangle &#123; color: &quot;lightgrey&quot;; width: 50; height: 20 &#125;</span><br><span class="line">    Rectangle &#123; color: &quot;cyan&quot;; width: 50; height: 50 &#125;</span><br><span class="line">    Rectangle &#123; color: &quot;magenta&quot;; width: 10; height: 10 &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705123010092.png" alt="image-20250705123010092"></p>
</li>
<li><p><strong>Flow</strong></p>
<p>Flow项目可以从前向后，像<strong>流</strong>一样布局其子项目，如同单词放置在页面上一样，通过换行，使这些子项目排列成多行或列。</p>
<p><strong>Flow排列项目的规则与Grid相似</strong>，它们的主要区别是，<strong>Flow的子项目会在超出边界后自动换行，每行的子项目数不一定相同</strong>。</p>
<p>Flow有一个<strong>flow</strong>属性，包含两个值：</p>
<ul>
<li><p><strong>Flow.LeftToRight（默认）</strong>：</p>
<p>按照<strong>从左向右</strong>的顺序排列子项目，直到超出Flow的宽度，然后换到下一行</p>
</li>
<li><p><strong>Flow.TopToBottom</strong>：</p>
<p>按照<strong>从上到下</strong>的顺序排列其子项目，直到超出Flow的高度，然后换到下一列。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    color: &quot;lightblue&quot;; width: 300; height: 200</span><br><span class="line">    Flow &#123;</span><br><span class="line">        anchors.fill: parent; </span><br><span class="line">        anchors.margins: 4; spacing: 10</span><br><span class="line"></span><br><span class="line">        Text &#123; text: &quot;Text&quot;; font.pixelSize: 40 &#125;</span><br><span class="line">        Text &#123; text: &quot;items&quot;; font.pixelSize: 40 &#125;</span><br><span class="line">        Text &#123; text: &quot;flowing&quot;; font.pixelSize: 40 &#125;</span><br><span class="line">        Text &#123; text: &quot;inside&quot;; font.pixelSize: 40 &#125;</span><br><span class="line">        Text &#123; text: &quot;a&quot;; font.pixelSize: 40 &#125;</span><br><span class="line">        Text &#123; text: &quot;Flow&quot;; font.pixelSize: 40 &#125;</span><br><span class="line">        Text &#123; text: &quot;item&quot;; font.pixelSize: 40 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705123251138.png" alt="image-20250705123251138"></p>
</li>
<li><p><strong>使用过渡</strong></p>
<p>定位器添加或删除一个子项目时，可以使用一个过渡（<strong>Transition</strong>），使这些操作具有<strong>动画效果</strong>。</p>
<p>上述四个定位器都有add、move和populate属性，它们需要分配一个Transition对象。</p>
<ul>
<li><p><strong>add</strong>：</p>
<p>应用在定位器创建完毕后，向定位器中添加一个子项目，或者将子项目通过更换父对象的方式变为定位器的孩子时。</p>
<p><strong>当项目的透明度为非0时，会使用add过渡显示项目。</strong></p>
</li>
<li><p><strong>move</strong></p>
<p>应用在删除定位器中的一个子项目，或者通过更换父对象方式从定位器中移除对象时。</p>
<p><strong>此外，将项目的透明度更改为0时，会使用move过渡隐藏项目。</strong></p>
</li>
<li><p><strong>populate</strong></p>
<p>应用在定位器第一次创建时，只会运行一次。</p>
</li>
</ul>
<p><strong>定位器过渡只会影响项目的位置(x, y)。</strong></p>
<p><strong>示例：按下空格产生动画</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Column &#123;  // 垂直布局容器</span><br><span class="line">    spacing: 2  // 子项间距</span><br><span class="line">    Rectangle &#123; color: &quot;red&quot;; width: 50; height: 50 &#125;</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        id: greenRect    // 标识符用于引用</span><br><span class="line">        color: &quot;green&quot;</span><br><span class="line">        width: 20; height: 50</span><br><span class="line">    &#125;</span><br><span class="line">    Rectangle &#123; color: &quot;blue&quot;; width: 50; height: 20 &#125;</span><br><span class="line"></span><br><span class="line">    move: Transition &#123;  // 移动动画效果</span><br><span class="line">        NumberAnimation &#123; properties: &quot;x,y&quot;; duration: 1000 &#125;   // 1秒动画</span><br><span class="line">&#125;</span><br><span class="line">    focus: true  // 获取键盘焦点</span><br><span class="line">    Keys.onSpacePressed: greenRect.visible = !greenRect.visible  // 空格切换可见性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705123704524.png" alt="image-20250705123704524"></p>
</li>
<li><p><strong>Positioner</strong></p>
<p>在<strong>Column、Row、Grid</strong>和<strong>Flow</strong>中会附加一个<strong>Positioner</strong>类型的对象作为顶层子项目，它可以为定位器中的子项目提供索引等信息。</p>
<p><strong>示例：</strong></p>
<p>Grid通过Repeater创建了16个子矩形，每一个子矩形都使用<strong>Positioner.index</strong>显示了它在Grid中的索引，而第一个矩形使用了不同颜色进行绘制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Grid &#123;</span><br><span class="line">    padding: 5</span><br><span class="line"></span><br><span class="line">    Repeater &#123;</span><br><span class="line">        model: 16</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            id: rect; width: 40; height: 40; border.width: 1</span><br><span class="line">            color: Positioner.isFirstItem ? </span><br><span class="line">                             &quot;yellow&quot; : &quot;lightsteelblue&quot;</span><br><span class="line"></span><br><span class="line">            Text &#123; text: rect.Positioner.index;</span><br><span class="line">                   anchors.centerIn: parent &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705124539668.png" alt="image-20250705124539668"></p>
</li>
<li><p><strong>Repeater</strong></p>
<p>Repeater类型用来创建大量<strong>相似</strong>的项目。</p>
<p>一个Repeater包含一个模型<strong>model</strong>属性和一个委托<strong>delegate</strong>属性。</p>
<p>委托用来将模型中的每一个条目进行可视化显示。一个Repeater通常会包含在一个定位器中，用于直观地对Repeater产生的众多委托项目进行布局。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: 400; height: 240; color: &quot;black&quot;</span><br><span class="line">    Grid &#123;</span><br><span class="line">        x: 5; y: 5; rows: 5; columns: 5; spacing: 10</span><br><span class="line">        Repeater &#123; </span><br><span class="line">            model: 12</span><br><span class="line">            Rectangle &#123; </span><br><span class="line">                width: 70; height: 70; color: &quot;lightgreen&quot;</span><br><span class="line">                Text &#123; </span><br><span class="line">                    text: index; font.pointSize: 30</span><br><span class="line">                    anchors.centerIn: parent </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705124753261.png" alt="image-20250705124753261"></p>
</li>
</ul>
<hr>
<h4 id="基于锚（anchors）的布局"><a href="#基于锚（anchors）的布局" class="headerlink" title="基于锚（anchors）的布局"></a>基于锚（anchors）的布局</h4><p>每一个项目都可以认为有一组无形的“锚线”：<strong>left、horizontalCenter、right、top、verticalCenter、baseline和bottom，</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705124901446.png" alt="image-20250705124901446"></p>
<p>图中没有显示baseline，它是一条假想的线，文本坐落在这条线上，对于没有文本的项目，它与top相同。</p>
<p><strong>7条锚线分别对应了Item项目中的anchors属性组的相关属性。</strong></p>
<p>因为Qt Quick中所有可视项目都继承自<strong>Item</strong>，所以所有可视项目都可以使用锚进行布局。</p>
<p><strong>Qt Quick的锚定系统允许不同项目的锚线之间建立关系</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    width: 250; height: 300</span><br><span class="line"></span><br><span class="line">    Rectangle&#123;</span><br><span class="line">        id: rect1; x:10; y:20</span><br><span class="line">        width: 100; height: 100; color: &quot;lightgrey&quot;</span><br><span class="line">        Text &#123; text: &quot;rect1&quot;; anchors.centerIn: parent &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Rectangle&#123;</span><br><span class="line">        id: rect2</span><br><span class="line">        width: 100; height: 100; color: &quot;black&quot;</span><br><span class="line">        anchors.left: rect1.right</span><br><span class="line">        Text &#123; text: &quot;rect2&quot;; color: &quot;white&quot;; anchors.centerIn: parent &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705125121172.png" alt="image-20250705125121172"></p>
<ul>
<li><p><strong>锚边距和偏移</strong></p>
<p>锚定系统也允许为一个项目的锚指定边距（margin）和偏移（offset）。</p>
<p>边距指定了项目锚到外边界的<strong>空间量</strong>，而偏移则允许使用中心锚线进行定位。</p>
<p>一个项目可以通过<strong>leftMargin、rightMargin、topMargin和bottomMargin</strong>独立指定锚边距。</p>
<p>如图所示。也可以使用<strong>anchor.margins</strong>同时为4个边指定相同的边距。</p>
<p>锚偏移可以使用<strong>horizontalCenterOffset、verticalCenterOffset和baselineOffset</strong>来指定。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705125229012.png" alt="image-20250705125229012"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123; id: rect1; ... &#125;</span><br><span class="line">Rectangle &#123;</span><br><span class="line">    id: rect2;</span><br><span class="line">    anchors.left: rect1.right; anchors.leftMargin: 5; </span><br><span class="line">    anchors.top: rect1.top</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h4><p>Qt Quick布局管理器是一组用于在用户界面中排列项目的类型。</p>
<p>与前面讲到的定位器不同，<strong>布局管理器不仅进行布局，而且会改变项目的大小</strong>，所以更适用于需要<strong>改变用户界面大小</strong>的应用。</p>
<p>因为布局管理器也是继承自Item，所以它们可以嵌套。</p>
<p>Qt Quick布局管理器与Qt Widgets应用中的布局管理器很相似。</p>
<p><strong>Qt Quick Layouts模块在Qt 5.1中引入，使用时需要进行导入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick.Layouts</span><br></pre></td></tr></table></figure>

<p><strong>Qt Quick布局管理器主要包括：</strong></p>
<ul>
<li><strong>RowLayout</strong></li>
<li><strong>ColumnLayout</strong></li>
<li><strong>GridLayout</strong></li>
<li><strong>StackLayout</strong></li>
</ul>
<p>Qt Quick Layouts拥有下面几个主要特色：</p>
<ul>
<li><p>项目的对齐方式可以使用<strong>Layout.alignment</strong>属性指定，主要有：</p>
<ul>
<li><strong>Qt::AlignLeft</strong></li>
<li><strong>Qt::AlignHCenter</strong></li>
<li><strong>Qt::AlignRight</strong></li>
<li><strong>Qt::AlignTop</strong></li>
<li><strong>Qt::AlignVCenter</strong></li>
<li><strong>Qt::AlignBottom</strong></li>
<li><strong>Qt::AlignBaseline</strong></li>
</ul>
</li>
<li><p>可变大小的项目可以使用<strong>Layout.fillWidth</strong>和<strong>Layout.fillHeight</strong>属性指定，当将其值设置为<strong>true</strong>时会根据约束条件变宽或变高。</p>
</li>
<li><p>大小约束可以通过<strong>Layout.minimumWidth</strong>、<strong>Layout.preferredWidth</strong>和<strong>Layout.maximumWidth</strong>属性（另外还有相对height的类似属性）指定。</p>
</li>
<li><p>间距可以通过<strong>spacing、rowSpacing和columnSpacing</strong>属性指定。</p>
<p><strong>除了上面所述的这些特色，在GridLayout中还添加了如下特色：</strong></p>
</li>
<li><p>网格中的坐标可以通过<strong>Layout.row和Layout.column</strong>指定。</p>
</li>
<li><p>自动网格坐标同时使用了<strong>flow、rows、column</strong>属性。</p>
</li>
<li><p>行或列的跨度可以通过<strong>Layout.rowSpan和Layout.columnSpan</strong>属性来指定。</p>
</li>
</ul>
<hr>
<p><strong>大小约束：</strong></p>
<p>要想使一个项目可以通过布局管理器调整大小，需要指定其</p>
<ul>
<li><p><strong>最小宽高（minimumWidth和minimumHeight）</strong></p>
</li>
<li><p><strong>最佳宽高（preferredWidth和preferredHeight）</strong></p>
</li>
<li><p><strong>最大宽高（maximumWidth和maximumHeight）</strong>，</p>
<p>并将对应的<strong>Layout.fillWidth或Layout.fillHeight</strong>设置为<strong>true</strong>。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RowLayout &#123;</span><br><span class="line">    id: layout; anchors.fill: parent; spacing: 6</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        color: &#x27;lightgrey&#x27;</span><br><span class="line">        Layout.fillWidth: true; Layout.minimumWidth: 50</span><br><span class="line">        Layout.preferredWidth: 100; Layout.maximumWidth: 300</span><br><span class="line">        Layout.minimumHeight: 150</span><br><span class="line">        Text &#123;</span><br><span class="line">            anchors.centerIn: parent</span><br><span class="line">            text: parent.width + &#x27;x&#x27; + parent.height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        color: &#x27;black&#x27;</span><br><span class="line">        Layout.fillWidth: true; Layout.minimumWidth: 100</span><br><span class="line">        Layout.preferredWidth: 200; Layout.preferredHeight: 100</span><br><span class="line">        Text &#123;</span><br><span class="line">            anchors.centerIn: parent; color: &quot;white&quot;</span><br><span class="line">            text: parent.width + &#x27;x&#x27; + parent.height</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705130128818.png" alt="image-20250705130128818"></p>
<p>有效的最佳（preferred）属性的值，可能来自几个候选属性。要决定有效的最佳属性，会对这些候选属性以下面的顺序进行查询，使用第一个有效的值。</p>
<ul>
<li><strong>Layout.preferredWidth或Layout.preferredHeight</strong></li>
<li><strong>implicitWidth或implicitHeight</strong></li>
<li><strong>width或height</strong></li>
</ul>
<p>一个项目可以仅指定<strong>Layout.preferredWidth</strong>而不指定<strong>Layout.preferredHeight</strong>，此时，有效的最佳高度会从<strong>implicitHeight</strong>或最终的<strong>height</strong>中选取。</p>
<p>为了将布局管理器与窗口进行关联，可以为布局管理器添加锚<strong>anchors.fill</strong>，确保布局管理器能够跟随窗口一起改变大小。</p>
<p>布局管理器的大小约束可以用来确保窗口大小不会超过约束条件，还可以将布局管理器的约束设置到窗口项目的<strong>minimumWidth、minimumHeight、maxmumWidth和maximumHeight</strong>等属性。</p>
<hr>
<p><strong>StackLayout</strong></p>
<p>StackLayout栈布局管理器可以管理多个项目，但只能显示一个项目。</p>
<p>可以通过<strong>currentIndex</strong>属性来设置当前显示的项目，索引号对应布局管理器中子项目的顺序，从0开始。另外，<strong>StackLayout</strong>还包含<strong>index</strong>和<strong>isCurrentItem</strong>等附加属性。</p>
<p><strong>示例：点击会变色</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StackLayout &#123;</span><br><span class="line">    id: layout; anchors.fill: parent; currentIndex: 1</span><br><span class="line"></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        color: &#x27;teal&#x27;; implicitWidth: 200; implicitHeight: 200</span><br><span class="line">    &#125;</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        color: &#x27;plum&#x27;; implicitWidth: 300; implicitHeight: 200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MouseArea &#123;</span><br><span class="line">    anchors.fill: parent</span><br><span class="line">    onClicked: &#123;</span><br><span class="line">        if (layout.currentIndex === 1)</span><br><span class="line">            layout.currentIndex = 0;</span><br><span class="line">        else</span><br><span class="line">            layout.currentIndex = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250705130518231.png" alt="image-20250705130518231"></p>
<hr>
<hr>
<h2 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h2><p>信号和槽用于<strong>两个对象之间的通信</strong>。</p>
<p>信号和槽机制是Qt的核心特征，也是Qt不同于其他开发框架的最突出特征。</p>
<p>Qt Quick中信号和信号处理器与Qt Widgets中信号和槽的概念类似，只是用法稍有不同。</p>
<h3 id="Qt-Widgets-中的信号与槽"><a href="#Qt-Widgets-中的信号与槽" class="headerlink" title="Qt Widgets 中的信号与槽"></a>Qt Widgets 中的信号与槽</h3><p>由多个窗口组成且各窗口之间可以切换的实例。</p>
<p>自定义对话框和自定义信号和槽的内容。</p>
<h4 id="认识信号与槽"><a href="#认识信号与槽" class="headerlink" title="认识信号与槽"></a>认识信号与槽</h4><p>Qt中使用信号和槽机制来完成对象之间的协同操作。</p>
<p>简单来说，<strong>信号和槽都是函数</strong>，比如单击窗口上的一个按钮后想要弹出一个对话框，那么可以将这个按钮的单击信号和自定义的槽关联起来，在这个槽中创建一个对话框并且显示它。</p>
<p>这样，单击这个按钮时就会发射信号，进而执行槽来显示一个对话框。</p>
<p>（其实这个在设计模式中<strong>除了信号与槽的关联代码和核心逻辑代码外</strong>，其余直接就能生成，）</p>
<p><strong>widget.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类定义的最后添加槽的声明：</span></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showChildDialog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>widget.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类的构造函数添加信号和槽的关联：</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;showChildButton, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MyWidget::showChildDialog);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在源文件中添加showChildDialog()槽的实现：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::showChildDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDialog *dialog = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义对话框"><a href="#自定义对话框" class="headerlink" title="自定义对话框"></a>自定义对话框</h4><p><strong>新建Dialog项目</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706091825747.png" alt="image-20250706091825747"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706092152119.png" alt="image-20250706092152119"></p>
<ul>
<li><p>第一步，进入设计模式，拉入两个 <strong>push button</strong> 组件，更改文本为“进入主界面”和“退出程序”。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706084956256.png" alt="image-20250706084956256"></p>
</li>
<li><p>第二步，单击设计器上方的**“编辑信号&#x2F;槽”图标**，或者按下快捷键<strong>F4</strong>，则进入了部件的信号和槽的编辑模式。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706092525601.png" alt="image-20250706092525601"></p>
</li>
<li><p>第三步，在“退出程序”按钮上按住鼠标左键，然后拖动到主窗口界面上，这时松开鼠标左键。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706085727589.png" alt="image-20250706085727589"></p>
<p>在弹出的窗口选择</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706092624433.png" alt="image-20250706092624433"></p>
<p>这时“退出程序”按钮的单击信号就和对话框的关闭操作槽进行了关联。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706092645352.png" alt="image-20250706092645352"></p>
<p>要想取消这个关联，只须在信号和槽编辑模式中选择这个关联，当它变为红色时，按下键盘Delete键，或者右击选择“删除”</p>
</li>
<li><p>第四步，勾选按钮的checkable</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706090046142.png" alt="image-20250706090046142"></p>
</li>
<li><p>第五步，进入编辑界面，右击“退出程序”按钮，选择转到槽</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706090339430.png" alt="image-20250706090339430"></p>
<p>弹出的窗口选择**<code>click()</code>**</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706090433501.png" alt="image-20250706090433501"></p>
<p>自动进入代码编辑界面</p>
</li>
<li><p>第六步，自动进入<strong>dialog.cpp</strong>代码界面后，完善代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dialog::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>dialog.h</strong>代码界面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pushButton_2_clicked</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个**<code>accept()</code><strong>函数是QDialog类中的一个槽，对于一个使用</strong><code>exec()</code><strong>函数实现的模态对话框，执行了这个槽，就会隐藏这个模态对话框，并返回</strong><code>QDialog::Accepted</code>**值，后面就是要使用这个值来判断是哪个按钮被按下了。</p>
<p>与其对应的还有一个**<code>reject()</code><strong>槽，它可以返回一个</strong><code>QDialog::Rejected</code>**值，前面的“退出程序”按钮也可以关联这个槽。</p>
</li>
<li><p>第七步，运行</p>
<p>点击<strong>退出程序</strong>按钮，即可退出窗口。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706092937572.png" alt="image-20250706092937572"></p>
</li>
</ul>
<hr>
<h4 id="在主界面中使用自定义的对话框"><a href="#在主界面中使用自定义的对话框" class="headerlink" title="在主界面中使用自定义的对话框"></a>在主界面中使用自定义的对话框</h4><p>下来实现一个登录类似物：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Dialog作为自定义窗口：等价于登录窗口</span><br><span class="line">- Widget作为主窗口：等价于主界面</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一步，<strong>新建widget项目</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706101047675.png" alt="image-20250706101047675"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706101253197.png" alt="image-20250706101253197"></p>
</li>
<li><p>第二步，<strong>开始自定义界面</strong>，右击项目的<strong>界面文件</strong>，选择添加新文件<strong>MyDialog.ui</strong>。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706102831096.png" alt="image-20250706102831096"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706101507482.png" alt="image-20250706101507482"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706102906672.png" alt="image-20250706102906672"></p>
<p><strong>项目结构：</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706102945999.png" alt="image-20250706102945999"></p>
</li>
<li><p>第三步，在mydialog.ui界面拉入两个 <strong>push button</strong> 部件，修改名称为“进入主界面”和“退出程序”。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706103144536.png" alt="image-20250706103144536"></p>
</li>
<li><p>第四步，进入<strong>信号与槽</strong>编辑模式，</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706103208863.png" alt="image-20250706103208863"></p>
<p>在**“退出程序”**按钮上按住鼠标左键，然后拖动到主窗口界面上，这时松开鼠标左键。</p>
<p>在弹出的窗口选择：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706103259335.png" alt="image-20250706103259335"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706103315839.png" alt="image-20250706103315839"></p>
</li>
<li><p>第五步，进入<strong>编辑控件</strong>界面，右击**“进入主界面”**按钮，选择转到槽。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706102313505.png" alt="image-20250706102313505"></p>
<p>选择：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706102340864.png" alt="image-20250706102340864"></p>
<p>编写<strong>mydialog.cpp</strong>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">accept</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mydialog.h</strong>槽代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_pushButton_clicked</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>至此，主界面编写完成。</p>
</li>
<li><p>第六步，<strong>开始编写主界面</strong>，编写<strong>main.cpp</strong>界面代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mywidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mydialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MyDialog dialog;</span><br><span class="line">    <span class="keyword">if</span>(dialog.<span class="built_in">exec</span>() == QDialog::Accepted)&#123;</span><br><span class="line">        MyWidget w;</span><br><span class="line">        w.<span class="built_in">show</span>();</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第七步，进入<strong>mywidget.ui</strong>文件，添加两个<strong>Push Button</strong>按钮，分别更改它们的显示文本为**“重新登录”<strong>和</strong>“退出”**。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706104329390.png" alt="image-20250706104329390"></p>
<p>按下<strong>F4</strong>进入<strong>编辑信号\槽</strong>模式，左击<strong>退出</strong>按钮，<strong>按住拉到主界面</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706104541206.png" alt="image-20250706104541206"></p>
<p>按下<strong>F3</strong>进入<strong>编辑</strong>模式，右击<strong>重新登录</strong>按钮，选择<strong>转到槽</strong>。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706104707810.png" alt="image-20250706104707810"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706104731517.png" alt="image-20250706104731517"></p>
<p>编写<strong>mywidget.cpp</strong>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mydialog.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">    MyDialog dialog;</span><br><span class="line">    <span class="keyword">if</span>(dialog.<span class="built_in">exec</span>() == QDialog::Accepted)&#123;</span><br><span class="line">        <span class="built_in">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行：</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706105048277.png" alt="image-20250706105048277"></p>
<ul>
<li>点击<strong>退出程序</strong>，退出程序</li>
<li>点击<strong>进入主界面</strong>，弹出：</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706105136660.png" alt="image-20250706105136660"></p>
<ul>
<li>点击<strong>重新登录</strong>，返回到<strong>Dialog</strong>界面</li>
<li>点击<strong>退出</strong>，退出程序</li>
</ul>
</li>
</ul>
<p><strong>tip：调用close()后程序退出了吗？</strong></p>
<p>提示：调用close()槽，它不一定使程序退出，只有当剩下最后一个主界面了（就是没有父窗口的界面），这时调用close()槽，程序才会退出；而其他情况下界面只是隐藏起来了，并没有被销毁。</p>
<hr>
<h3 id="信号与槽详解"><a href="#信号与槽详解" class="headerlink" title="信号与槽详解"></a>信号与槽详解</h3><p>在GUI编程中，当改变了一个部件时，总希望其他部件也能了解到该变化。</p>
<p>一般来说，我们希望任何对象都可以和其他对象进行通信。</p>
<p>例如，用户单击了关闭按钮，则希望可以执行窗口的close()函数来关闭窗口。</p>
<p>在Qt中使用了信号和槽来进行对象间的通信，当一个特殊的<strong>事件发生</strong>时便可以发射一个<strong>信号</strong>，比如<strong>按钮被单击</strong>就<strong>发射clicked()<strong>信号；而</strong>槽就是一个函数</strong>，它在<strong>信号发射后被调用来响应这个信号</strong>。</p>
<p>在Qt的部件类中已经定义了一些信号和槽，但是<strong>更常用的做法是子类化部件，然后添加自定义的信号和槽来实现想要的功能。</strong></p>
<ul>
<li><strong>一个信号对应一个槽</strong>，</li>
<li><strong>一个信号可以关联到多个槽上</strong>，</li>
<li><strong>多个信号也可以关联到同一个槽上</strong>，</li>
<li><strong>一个信号还可以关联到另一个信号上。</strong></li>
<li><strong>如果存在多个槽与某个信号相关联，那么，当这个信号被发射时，这些槽将会一个接一个地执行，执行顺序与关联顺序相同。</strong></li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706110228853.png" alt="image-20250706110228853"></p>
<hr>
<h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>在主界面中创建一个对话框，在这个对话框中可以输入数值，当单击“确定”按钮时关闭对话框并且将输入的数值通过信号发射出去，最后在主界面中接收该信号并且显示数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对话框-输入数值--&gt;发射信号——&gt;主界面接收信号-&gt;显示数值</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>新建 Widgets 应用</strong>：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706110718663.png" alt="image-20250706110718663"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706110801810.png" alt="image-20250706110801810"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706110825418.png" alt="image-20250706110825418"></p>
</li>
<li><p><strong>向项目中添加新文件</strong>：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706111034371.png" alt="image-20250706111034371"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706111052753.png" alt="image-20250706111052753"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706111113361.png" alt="image-20250706111113361"></p>
</li>
<li><p><strong>项目结构</strong>：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706111154154.png" alt="image-20250706111154154"></p>
</li>
<li><p><strong>编写信号代码</strong>：</p>
<p><strong>mydialog.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYDIALOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYDIALOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDialog</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDialog</span> : <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">// 必须在开始处添加该宏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyDialog</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MyDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MyDialog *ui;</span><br><span class="line">    </span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dlgReturn</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">// 自定义的信号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这个是后续会自动生成的槽</span></span><br><span class="line"><span class="comment">private slots:</span></span><br><span class="line"><span class="comment">    void on_pushButton_clicked();</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYDIALOG_H</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <strong>signals</strong> 关键字<strong>声明信号</strong>，在signals前面不能用public、private或protected等关键字；</li>
<li>信号默认是public函数，可以从任何地方进行发射，但是建议只在声明该信号的类及其子类中发射该信号；</li>
<li>信号只用<strong>声明</strong>，不需要也不能对它进行定义实现；</li>
<li>信号<strong>没有返回值</strong>，只能是<strong>void</strong>类型的。</li>
</ul>
</li>
<li><p><strong>点击mydialog.ui，进入设计模式</strong></p>
<p>往界面中拉入 <strong>Spin Box</strong> 和 <strong>Push Button</strong> 部件，修改按钮文本为**“确定“**。</p>
<p>右击pushButton 按钮，选择<strong>转到槽</strong>，选择<strong>clicked()</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706112138651.png" alt="image-20250706112138651"></p>
<p>补充<strong>mydialog.cpp</strong>的槽函数代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDialog::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = ui-&gt;spinBox-&gt;<span class="built_in">value</span>();</span><br><span class="line">    <span class="function">emit <span class="title">dlgReturn</span><span class="params">(value)</span></span>;  <span class="comment">//发送信号</span></span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;signal is emitted&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编写widget.h文件</strong></p>
<p>添加<strong>自定义槽</strong>的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>槽就是普通的C++函数，可以像一般的函数一样使用。</p>
<p>声明槽建议使用<strong>slots</strong>关键字，一个槽可以是private、public或者protected类型的，槽也可以被声明为虚函数，这与普通的成员函数是一样的。</p>
</li>
<li><p><strong>点击 widget.ui 文件，进入设计模式</strong></p>
<p>向界面上拖入一个<strong>Label</strong>部件，更改其文本为**“获取的值是：”**</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706113511463.png" alt="image-20250706113511463"></p>
</li>
<li><p>编写 <strong>widget.cpp</strong> 文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mydialog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    MyDialog *dlg = <span class="keyword">new</span> <span class="built_in">MyDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将对话框中的自定义信号与主界面中的自定义槽进行关联</span></span><br><span class="line">    <span class="built_in">connect</span>(dlg, <span class="built_in">SIGNAL</span>(<span class="built_in">dlgReturn</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">showValue</span>(<span class="type">int</span>)));</span><br><span class="line">    dlg-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::showValue</span><span class="params">(<span class="type">int</span> value)</span>   <span class="comment">//自定义槽</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;获取的值是：%1&quot;</span>).<span class="built_in">arg</span>(value));</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;setText:&quot;</span> &lt;&lt; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706114104340.png" alt="image-20250706114104340"></p>
</li>
</ul>
<p><strong>原理：</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/imgsignal.png" alt="imgsignal"></p>
<hr>
<h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *signal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> *method, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::ConnectionType type = Qt::AutoConnection)</span>                   </span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyDialog *dlg = <span class="keyword">new</span> <span class="built_in">MyDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">// 将对话框中的自定义信号与主界面中的自定义槽进行关联</span></span><br><span class="line">   <span class="built_in">connect</span>(dlg, <span class="built_in">SIGNAL</span>(<span class="built_in">dlgReturn</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">showValue</span>(<span class="type">int</span>)));</span><br><span class="line">   dlg-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<p>这是Qt 5之前默认使用的形式。</p>
<ul>
<li><p>第一个参数为发射信号的对象，例如前面例子中的<code>dlg</code>；</p>
</li>
<li><p>第二个参数是要发射的信号，比如**<code>SIGNAL(dlgReturn(int))</code>**；</p>
</li>
<li><p>第三个参数是接收信号的对象，当这个参数为<code>this</code>时，也可以将这个参数省略掉；</p>
</li>
<li><p>第四个参数是要执行的槽，比如**<code>SLOT(showValue(int))</code>**。</p>
<p>对于这种形式中的信号和槽，必须使用**<code>SIGNAL()</code><strong>和</strong><code>SLOT()</code><strong>宏，它们可以将其参数转化为</strong><code>const char*</code>** 类型，另外，第四个参数指定的槽在声明时必须使用<strong>slots</strong>关键字；</p>
</li>
<li><p><code>connect()</code>函数的返回值为**<code>QMetaObject::Connection</code><strong>类型，该返回值可以用于</strong><code>QObject::disconnect()</code>**函数来断开该关联。</p>
<p>需要注意，在调用该**connect()**函数时信号和槽的参数只能有类型，不能有变量名；</p>
</li>
<li><p><code>connect()</code>函数的最后一个参数type表明了关联的方式，由**<code>Qt::ConnectionType</code><strong>枚举类型指定，其默认值是</strong><code>Qt::AutoConnection</code>**。</p>
<p>在编程中一般使用默认值，例如前面的例子中，在MyDialog类中使用emit发射了信号之后，就会立即执行槽，只有等槽执行完了以后，才会执行emit语句后面的代码。</p>
</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706120539897.png" alt="image-20250706120539897"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">static</span>] <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, </span></span></span><br><span class="line"><span class="params"><span class="function">    PointerToMemberFunction signal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver,</span></span></span><br><span class="line"><span class="params"><span class="function">    PointerToMemberFunction method, </span></span></span><br><span class="line"><span class="params"><span class="function">    Qt::ConnectionType type = Qt::AutoConnection)</span>                   </span></span><br></pre></td></tr></table></figure>

<p>这是Qt 5中加入的一种重载形式，与前者最大的不同就是，指定信号和槽两个参数时<strong>不用再使用<code>SIGNAL()</code>和<code>SLOT()</code>宏</strong>，并且槽函数不再必须使用<strong>slots</strong>关键字声明的函数，而可以是任意能和信号关联的成员函数。</p>
<p>要使一个成员函数可以和信号关联，那么这个函数的参数数目不能超过信号的参数数目，但是并不要求该函数拥有的参数类型与信号中对应的参数类型完全一致，只需要可以进行隐式转换即可。</p>
<p>使用这种重载形式，前面程序中的关联可以使用如下代码代替：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(dlg, &amp;MyDialog::dlgReturn, <span class="keyword">this</span>, &amp;Widget::showValue);</span><br><span class="line"><span class="comment">//原</span></span><br><span class="line"><span class="built_in">connect</span>(dlg, <span class="built_in">SIGNAL</span>(<span class="built_in">dlgReturn</span>(<span class="type">int</span>)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">showValue</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>

<p>该方式另一个优点是可以在编译时进行检查，信号或槽的拼写错误、槽函数参数数目多于信号的参数数目等错误在编译时就能够被发现。建议在编写代码时使用这种关联形式。</p>
<p>另外，这种形式还支持C++11中的Lambda表达式，可以在关联时直接编写信号发射后要执行的代码，例如，前面示例程序中的关联可以写为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(dlg, &amp;MyDialog::dlgReturn, <span class="keyword">this</span>, [=](<span class="type">int</span> value)&#123;</span><br><span class="line">        ui-&gt;label-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;获取的值是：%1&quot;</span>).<span class="built_in">arg</span>(value));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="自动关联"><a href="#自动关联" class="headerlink" title="自动关联"></a>自动关联</h4><p>信号和槽还有一种自动关联方式。</p>
<p>例如，前面程序在设计模式直接生成的**“确定”**按钮的单击信号的槽，就是使用的这种方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">on_pushButton_clicked</span>()</span><br></pre></td></tr></table></figure>

<p>由<strong>字符串on、部件的objectName和信号名称</strong>三部分组成，中间用<strong>下划线</strong>隔开。</p>
<p>这种形式命名的槽就可以直接和信号关联，而不用再使用<code>connect()</code>函数。</p>
<p>如果要使用信号和槽的自动关联，就必须在<code>connectSlotsByName()</code>函数之前进行部件的定义，而且还要指定部件的<code>objectName</code>。</p>
<hr>
<h4 id="断开关联"><a href="#断开关联" class="headerlink" title="断开关联"></a>断开关联</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">bool</span> <span class="title">QObject::disconnect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method)</span>          </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>断开与一个对象所有信号的所有关联：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(myObject, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);   </span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">myObject-&gt;<span class="built_in">disconnect</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开与一个指定信号的所有关联：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(myObject, <span class="built_in">SIGNAL</span>(<span class="built_in">mySignal</span>()), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">myObject-&gt;<span class="built_in">disconnect</span>(<span class="built_in">SIGNAL</span>(<span class="built_in">mySignal</span>()));</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开与一个指定的receiver的所有关联：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(myObject, <span class="literal">nullptr</span>, myReceiver, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">myObject-&gt;<span class="built_in">disconnect</span>(myReceiver);</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开一个指定信号和槽的关联：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(myObject, <span class="built_in">SIGNAL</span>(<span class="built_in">mySignal</span>()),myReceiver, <span class="built_in">SLOT</span>(<span class="built_in">mySlot</span>()));</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line">myObject-&gt;<span class="built_in">disconnect</span>(<span class="built_in">SIGNAL</span>(<span class="built_in">mySignal</span>()),myReceiver, <span class="built_in">SLOT</span>(<span class="built_in">mySlot</span>()));</span><br><span class="line"><span class="comment">//也等价于：</span></span><br><span class="line">disconnect（myConnection）；<span class="comment">// myConnection是进行关联时connect()的返回值</span></span><br></pre></td></tr></table></figure>

<p>另外，与<code>connect()</code>函数一样，<code>disconnect()</code>函数也有<strong>基于函数指针的重载形式</strong>。</p>
</li>
</ul>
<hr>
<h4 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h4><p>有时希望获得信号发送者的信息，Qt提供了**<code>QObject::sender()</code>**函数来返回发送该信号的对象的指针。</p>
<p>但是如果有多个信号关联到了同一个槽上，而在该槽中需要对每一个信号进行不同的处理，使用这种方法就很麻烦了。对于这种情况，可以使用<code>QSignalMapper</code>类。</p>
<p><code>QSignalMapper</code>被叫做<strong>信号映射器</strong>，可以实现对多个相同部件的相同信号进行映射，为其添加字符串或者数值参数，然后再发射出去，有这方面需求的读者可以自行学习该类。</p>
<p>信号和槽机制的特色和优越性:</p>
<ul>
<li>信号和槽机制是<strong>类型安全</strong>的，相关联的信号和槽的参数必须匹配；</li>
<li>信号和槽是<strong>松耦合</strong>的，信号发送者不知道也不需要知道接受者的信息；</li>
<li>信号和槽可以使用任意类型的任意数量的参数。</li>
</ul>
<hr>
<h3 id="Qt-Quick-中的信号与信号处理器"><a href="#Qt-Quick-中的信号与信号处理器" class="headerlink" title="Qt Quick 中的信号与信号处理器"></a>Qt Quick 中的信号与信号处理器</h3><p>在Qt Quick中也实现了与Qt Widgets中相似的信号和槽机制，只不过这里的槽被称为<strong>信号处理器（Signal Handler）</strong>。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>信号是发生事件（例如属性更改、动画状态变化、图片下载完成等）的对象发射的通知，</p>
<p>比如MouseArea类型有一个clicked信号，当用户在MouseArea部件上单击时，该信号就会发射。特定的信号发射后，可以通过相应的信号处理器获得通知。</p>
<p>信号处理器的声明语法为：<code>on&lt;Signal&gt;</code>，其中<code>&lt;Signal&gt;</code>是信号的名字（首字母需要大写）。</p>
<p>信号处理器必须在发射信号的对象的定义中进行声明，其中包含调用时要执行的JavaScript代码块。</p>
<p><strong>实例：</strong></p>
<p>QtQuick模块中的MouseArea类型有一个clicked信号。因为信号的名称为clicked，所以对应的信号处理器的名称就是onClicked。</p>
<p>新建<strong>Quick</strong>项目：</p>
<p>每当单击MouseArea，都会调用onClicked处理器，从而使Rectangle变换随机的颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    id: rect; width: 400; height: 300</span><br><span class="line"></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            rect.color = Qt.rgba(Math.random(),</span><br><span class="line">                           Math.random(), Math.random())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                      </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706122722660.png" alt="image-20250706122722660"></p>
<hr>
<h4 id="声明信号"><a href="#声明信号" class="headerlink" title="声明信号"></a>声明信号</h4><p>信号可以在C++中使用<strong>Q_SIGNAL</strong>宏声明，也可以在QML文档中<strong>直接声明</strong>。</p>
<p>如果在QML对象声明时声明一个信号，可以使用如下语法：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signal</span><span class="string"> &lt;signalName&gt;[</span>([<span class="language-xml"><span class="tag">&lt;<span class="name">parameterName</span>&gt;</span>: <span class="tag">&lt;<span class="name">parameterType</span>&gt;</span>[, ...]])]</span></span><br></pre></td></tr></table></figure>

<p>同一作用域中<strong>不能有两个同名的信号或方法</strong>。但是，<strong>新的信号可以重用已有信号的名字</strong>，这意味着，原来的信号会被新的信号隐藏，变得不可访问。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Item</span> &#123;</span><br><span class="line">    <span class="keyword">signal</span><span class="string"> clicked</span></span><br><span class="line">    <span class="keyword">signal</span><span class="string"> hovered</span>()</span><br><span class="line">    <span class="keyword">signal</span><span class="string"> actionPerformed</span>(<span class="attribute">action</span>: <span class="built_in">string</span>, </span><br><span class="line">                         <span class="attribute">actionResult</span>: <span class="keyword">var</span>)</span><br><span class="line">&#125;                     </span><br></pre></td></tr></table></figure>

<p>如果信号没有参数，小括号<code>()</code>可以省略，就像代码中clicked信号那样。</p>
<p>如果有参数，参数类型必须声明，比如上面代码中<code>actionPerformed</code>信号的两个参数分别是string和var类型的。</p>
<p>另外，还可以使用属性样式语法来指定信号参数：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signal</span><span class="string"> actionCanceled</span>(<span class="built_in">string</span> action)</span><br></pre></td></tr></table></figure>

<p><strong>发射一个信号和调用一个方法的方式相同</strong>。当一个信号发射后，其对应的信号处理器就会被调用，在处理器中可以使用信号的参数名称来访问相应的参数。</p>
<hr>
<h4 id="信号处理器"><a href="#信号处理器" class="headerlink" title="信号处理器"></a>信号处理器</h4><p>信号处理器是一类特殊的方法特性。当对应的信号发射时，信号处理器会被QML引擎自动调用。</p>
<p>在QML的对象定义中添加一个信号，会自动在对象定义中添加一个相应的信号处理器，只不过其中没有具体的实现代码。</p>
<p>例如，新建qml文件：<strong>SquareButton.qml</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706123422387.png" alt="image-20250706123422387"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706124307266.png" alt="image-20250706124307266"></p>
<p><strong>SquareButton.qml</strong>文件中定义了一个SquareButton类型，其中包含<code>activated</code>和<code>deactivated</code>两个信号：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SquareButton.qml</span></span><br><span class="line"><span class="keyword">import</span> QtQuick</span><br><span class="line"></span><br><span class="line"><span class="title">Rectangle</span> &#123;</span><br><span class="line">    <span class="attribute">id:</span><span class="string"> root</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">signal</span><span class="string"> activated</span>(<span class="attribute">xPosition</span>: <span class="built_in">real</span>, <span class="attribute">yPosition</span>: <span class="built_in">real</span>)</span><br><span class="line">    <span class="keyword">signal</span><span class="string"> deactivated</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">property</span><span class="string"> int side</span>: <span class="number">100</span></span><br><span class="line">    <span class="attribute">width</span>: side; <span class="attribute">height</span>: side; <span class="attribute">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="title">MouseArea</span> &#123;</span><br><span class="line">        <span class="attribute">anchors.fill</span>: <span class="built_in">parent</span></span><br><span class="line">        <span class="attribute">onReleased</span>: root.deactivated()</span><br><span class="line">        <span class="attribute">onPressed</span>: (mouse)=&gt; root.activated(mouse.x, mouse.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                   </span><br></pre></td></tr></table></figure>

<p><strong>SquareButton.qml</strong>声明的信号可以被<strong>同目录下</strong>的其它QML文件接收，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Main.qml</span><br><span class="line">import QtQuick</span><br><span class="line"></span><br><span class="line">Rectangle &#123;</span><br><span class="line">    width: 400; height: 300</span><br><span class="line"></span><br><span class="line">    SquareButton &#123;</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">        onDeactivated: console.log(&quot;Deactivated!&quot;)</span><br><span class="line">        onActivated: (xPosition, yPosition)</span><br><span class="line">                     =&gt; console.log(&quot;Activated at &quot; </span><br><span class="line">                               + xPosition + &quot;,&quot; + yPosition)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                  </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706124352957.png" alt="image-20250706124352957"></p>
<p>在信号处理器中可以通过分配一个函数来访问信号中的参数，有两种方式：</p>
<ul>
<li><p>使用示例中的这种箭头函数，</p>
</li>
<li><p>可以使用匿名函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onActivated: function (xPos, yPos) &#123; console.log(xPos + &quot;,&quot; + yPos) &#125;</span><br></pre></td></tr></table></figure>

<p>无论使用哪种形式的函数，其中形式参数的名称都<strong>不必</strong>与信号中的名称匹配。</p>
</li>
</ul>
<hr>
<h4 id="使用Connections类型和connect-函数"><a href="#使用Connections类型和connect-函数" class="headerlink" title="使用Connections类型和connect()函数"></a>使用Connections类型和connect()函数</h4><p>有时候可能需要在发射信号的对象外部使用这个信号。为了达到这一目的，QtQuick模块提供了Connections类型，用于连接外部对象的信号。</p>
<p>Connections对象可以接收指定目标（target）的任意信号。</p>
<p>例如，在下面的代码中没有在发出clicked信号的MouseArea内响应这个信号，而是通过Connections对象，在MouseArea外部处理信号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    id: rect; width: 400; height: 300</span><br><span class="line"></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        id: mouseArea</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Connections &#123;</span><br><span class="line">        target: mouseArea</span><br><span class="line">        function onClicked() &#123;</span><br><span class="line">            rect.color = &quot;red&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，使用信号处理器已经能够满足大多数应用。但是，如果要把一个信号与一个或多个方法或者信号关联起来，这种语法就无能为力了。</p>
<p>为此，QML的信号对象提供了<code>connect()</code>函数，支持将信号与一个方法或者另外的信号连接起来，这与Qt Widgets中是类似的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    id: relay</span><br><span class="line"></span><br><span class="line">    signal messageReceived(string person, string notice)</span><br><span class="line"></span><br><span class="line">    Component.onCompleted: &#123;</span><br><span class="line">        relay.messageReceived.connect(sendToPost)</span><br><span class="line">        relay.messageReceived.connect(sendToTelegraph)</span><br><span class="line">        relay.messageReceived(&quot;Tom&quot;, &quot;Happy Birthday&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendToPost(person, notice) &#123;</span><br><span class="line">        console.log(&quot;Sending to post: &quot; + person + &quot;, &quot; + notice)</span><br><span class="line">    &#125;</span><br><span class="line">    function sendToTelegraph(person, notice) &#123;</span><br><span class="line">        console.log(&quot;Sending to telegraph: &quot; + person + &quot;, &quot; + notice)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706124729892.png" alt="image-20250706124729892"></p>
<p>更常见的需求是：将信号与动态创建的对象关联起来，此时就不得不使用connect()函数进行连接。如果需要解除连接，可以调用信号对象的disconnect()函数。</p>
<p>不仅如此，使用connect()函数还可以构成一个信号链。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    id: forwarder; width: 400; height: 300</span><br><span class="line"></span><br><span class="line">    signal send()</span><br><span class="line">    onSend: console.log(&quot;Send clicked&quot;)</span><br><span class="line"></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        id: mouseArea; anchors.fill: parent</span><br><span class="line">        onClicked: console.log(&quot;MouseArea clicked&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Component.onCompleted: &#123;</span><br><span class="line">        mouseArea.clicked.connect(send)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250706124839116.png" alt="image-20250706124839116"></p>
<hr>
<h3 id="Qt-核心机制"><a href="#Qt-核心机制" class="headerlink" title="Qt 核心机制"></a>Qt 核心机制</h3><h4 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h4><p>标准C++对象模型可以在运行时非常有效地支持对象范式（object paradigm），但是它的静态特性在一些问题上不够灵活。</p>
<p>图形用户界面编程不仅需要运行时的高效性，还需要高度的灵活性。</p>
<p>为此，Qt在标准C++对象模型的基础上添加了一些特性，形成了自己的对象模型。这些特性有：</p>
<ul>
<li>一个强大的无缝对象通信机制——信号和槽（signals and slots）；</li>
<li>可查询、可设计的对象属性系统（object properties）；</li>
<li>强大的事件和事件过滤器（events and event filters）；</li>
<li>基于上下文的国际化字符串翻译机制（string translation for internationalization）；</li>
<li>完善的定时器（timers）驱动，可以在一个事件驱动的GUI中处理多个任务；</li>
<li>分层结构的、可查询的对象树（object trees），它使用一种很自然的方式来组织对象拥有权（object ownership）；</li>
<li>守卫指针即QPointer，它在引用对象被销毁时自动将其设置为0；</li>
<li>动态的对象转换机制（dynamic cast）；</li>
<li>支持创建自定义类型（custom type）。</li>
</ul>
<p>Qt的这些特性大多是在遵循标准C++规范内实现的，使用这些特性都必须要继承自QObject类。</p>
<p>其中，对象通信机制和动态属性系统，还需要元对象系统（Meta-Object System）的支持。</p>
<hr>
<h4 id="元对象系统"><a href="#元对象系统" class="headerlink" title="元对象系统"></a>元对象系统</h4><p>Qt中的元对象系统（Meta-Object System）是对C++的扩展，使其更适合真正的组件图形用户界面编程，提供了对象间通信的信号和槽机制、运行时类型信息和动态属性系统。</p>
<p>元对象系统是基于以下3个条件的：</p>
<ul>
<li>该类必须继承自QObject类；</li>
<li>必须在类定义的私有部分添加Q_OBJECT宏（在类定义时，如果没有指定public或者private关键字，则默认为private）；</li>
<li>元对象编译器Meta-Object Compiler（moc）为QObject的子类实现元对象特性提供必要的代码。</li>
<li>元对象系统主要是为了实现信号和槽机制才被引入的，不过除了信号和槽机制以外，元对象系统还提供了其他一些特性：</li>
<li><code>QObject::metaObject()</code>函数可以返回一个类的元对象QMetaObject；</li>
<li><code>QMetaObject::className()</code>可以在运行时以字符串形式返回类名，而不需要C++编辑器原生的运行时类型信息（RTTI）的支持；</li>
<li><code>QObject::inherits()</code>函数返回一个对象是否是QObject继承树上一个类的实例的信息；</li>
<li><code>QObject::tr()</code>进行字符串翻译来实现国际化；</li>
<li><code>QObject::setProperty()</code>和<code>QObject::property()</code>通过名字来动态设置或者获取对象属性；</li>
<li><code>QMetaObject::newInstance()</code>构造类的一个新实例。</li>
</ul>
<p>除了前面这些特性，还可以使用<code>qobject_cast()</code>函数对QObject类进行动态类型转换，这个函数的功能类似于标准C++中的<code>dynamic_cast()</code>函数，但它不再需要RTTI的支持。</p>
<p>这个函数尝试将它的参数转换为尖括号中的类型的指针，如果是正确的类型则返回一个非零的指针，如果类型不兼容则返回nullptr。</p>
<p>例如，假设MyWidget类继承自QWidget，并且在定义中使用了Q_OBJECT宏，那么可以使用下面的代码进行类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QObject *obj = new MyWidget;</span><br><span class="line">QWidget *widget = qobject_cast&lt;QWidget *&gt;(obj);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="属性系统"><a href="#属性系统" class="headerlink" title="属性系统"></a>属性系统</h4><p>Qt提供了强大的基于元对象系统的属性系统，可以在运行Qt的平台上支持标准C++编译器。要在一个类中声明属性，该类必须继承自QObject类，而且还要在声明前使用<code>Q_PROPERTY()</code>宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Q_PROPERTY(type name</span><br><span class="line">           (READ getFunction [WRITE setFunction] |</span><br><span class="line">	   MEMBER memberName [(READ getFunction | WRITE setFunction)])</span><br><span class="line">            [RESET resetFunction]</span><br><span class="line">            [NOTIFY notifySignal]</span><br><span class="line">            [REVISION int | REVISION(int[, int])]</span><br><span class="line">            [DESIGNABLE bool]</span><br><span class="line">            [SCRIPTABLE bool]</span><br><span class="line">            [STORED bool]</span><br><span class="line">            [USER bool]</span><br><span class="line">            [BINDABLE bindableProperty]</span><br><span class="line">            [CONSTANT]</span><br><span class="line">            [FINAL]</span><br><span class="line">            [REQUIRED])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中type表示属性的类型，可以是QVariant所支持的类型或者是用户自定义的类型。如果是枚举类型，还需要使用<code>Q_ENUMS()</code>宏在元对象系统中进行注册，这样以后才可以使用<code>QObject::setProperty()</code>函数来使用该属性。name就是属性的名称。READ后面是读取该属性的函数，这个函数是必须有的，而后面带有“[ ]”号的选项表示这些函数是可选的。</p>
</li>
<li><p>一个属性类似于一个数据成员，不过它添加了一些可以通过元对象系统访问的附加功能：</p>
<ul>
<li><p><strong>一个可选的写（WRITE）操作函数。</strong></p>
<p>它用来设置属性的值。这个函数必须只有一个参数，而且它的返回值必须为空void。例如，<code>QWidget::enabled</code>的WRITE函数是<code>QWidget::setEnabled()</code>。</p>
</li>
<li><p>如果没有指定READ操作函数，那么必须指定一个MEMBER变量关联，这样会使给定的成员变量变为可读写的而不用创建READ和WRITE操作函数。</p>
</li>
<li><p><strong>一个可选的重置（RESET）函数。</strong></p>
<p>它用来将属性恢复到一个默认的值。这个函数不能有参数，而且返回值必须为空void。例如，<code>QWidget::cursor</code>的RESET函数是<code>QWidget::unsetCursor()</code>。</p>
</li>
<li><p><strong>一个读（READ）操作函数。</strong></p>
<p>如果MEMBER变量没有指定，那么该函数是必须有的，它用来读取属性的值。这个函数一般是const类型的，它的返回值类型必须是该属性的类型，或者是该属性类型的指针或者引用。例如，<code>QWidget::focus</code>是一个只读属性，其READ函数是<code>QWidget::hasFocus()</code>。</p>
</li>
<li><p><strong>一个可选的通知（NOTIFY）信号。</strong></p>
<p>如果使用该选项，那么需要指定类中一个已经存在的信号，每当该属性的值改变时都会发射该信号。如果使用MEMBER变量时指定NOTIFY信号，那么信号最多只能有一个参数，并且参数的类型必须与属性的类型相同。</p>
</li>
<li><p><strong>一个可选的版本（REVISION）号或REVISION()宏。</strong></p>
<p>如果包含了该版本号，它会定义属性及其通知信号只用于特定版本的API（通常暴露给QML），如果不包含，则默认为0。</p>
</li>
<li><p><strong>可选的DESIGNABLE</strong>：</p>
<p>表明这个属性在GUI设计器（例如Qt Designer）的属性编辑器中是否可见。大多数属性的该值为true，即可见。</p>
</li>
<li><p><strong>可选的SCRIPTABLE</strong>：</p>
<p>表明这个属性是否可以被脚本引擎（scripting engine）访问，默认值为true。</p>
</li>
<li><p><strong>可选的STORED</strong>：</p>
<p>表明该属性应该被认为是独立存在的还是依赖于其他值，也表明是否在当对象的状态被存储时也必须存储这个属性的值，大部分属性的该值为true。</p>
</li>
<li><p><strong>可选的BINDABLE表明这个属性支持绑定。</strong></p>
<p>该特性从Qt 6.0开始引入。关于属性绑定的更多内容可以在帮助中通过Qt Bindable Properties和QObjectBindableProperty关键字查看。</p>
</li>
<li><p><strong>可选的USER：</strong></p>
<p>表明这个属性是否被设计为该类的面向用户或者用户可编辑的属性。一般，每一个类中只有一个USER属性，它的默认值为false。例如，<code>QAbstractButton::checked</code>是按钮的用户可编辑属性。</p>
</li>
<li><p><strong>可选的CONSTANT：</strong></p>
<p>表明这个属性的值是一个常量。对于给定的一个对象实例，每一次使用常量属性的READ方法都必须返回相同的值，但对于类的不同的实例，这个常量可以不同。一个常量属性不可以有WRITE方法和NOTIFY信号。</p>
</li>
<li><p><strong>可选的FINAL：</strong></p>
<p>表明这个属性不能被派生类重写。</p>
</li>
<li><p><strong>可选的REQUIRED：</strong></p>
<p>表明该属性应该由用户来设置，这个对于暴露给QML的类非常有用。在QML中，类如果有REQUIRED属性，就必须全部进行设置，否则无法实例化。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="对象树与拥有权"><a href="#对象树与拥有权" class="headerlink" title="对象树与拥有权"></a>对象树与拥有权</h4><p><strong>Qt中使用对象树（object tree）来组织和管理所有的QObject类及其子类的对象。</strong></p>
<p>当创建一个QObject对象时，如果使用了其他的对象作为其父对象（parent），那么这个对象就会被添加到父对象的children()列表中，这样当父对象被销毁时，这个对象也会被销毁。</p>
<p>实践表明，这个机制非常适合于管理GUI对象。</p>
<p>例如，一个QShortcut（键盘快捷键）对象是相应窗口的一个子对象，当用户关闭这个窗口时，快捷键对象也会被销毁。</p>
<p><strong>QWidget作为Qt Widgets模块的基础类，扩展了对象间的父子关系。</strong></p>
<p>一个子对象一般也就是一个子部件，因为它们要显示在父部件的坐标系统之中。</p>
<p>例如，当关闭一个消息对话框（message box）后要销毁它时，消息对话框中的按钮和标签也会被销毁，这也正是我们所希望的，因为按钮和标签是消息对话框的子部件。</p>
<p>当然，也可以自己手动来销毁一个子对象，这时会将它们从其父对象中移除。</p>
<hr>
<hr>
<h2 id="应用程序主窗口"><a href="#应用程序主窗口" class="headerlink" title="应用程序主窗口"></a>应用程序主窗口</h2><p>Qt Widgets编程中提供了以<strong>QMainWindow</strong>类为核心的主窗口框架；</p>
<p>Qt Quick编程中的Qt Quick Controls模块提供了以<strong>ApplicationWindow</strong>控件为核心的众多控件，用来创建完整的主窗口应用程序。</p>
<hr>
<h3 id="Qt-Widget-主窗口"><a href="#Qt-Widget-主窗口" class="headerlink" title="Qt Widget 主窗口"></a>Qt Widget 主窗口</h3><p><strong>QMainWindow</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707081203786.png" alt="image-20250707081203786"></p>
<ul>
<li>①菜单栏（QMenuBar）。包含了一个下拉菜单的列表，这些菜单项由QAction动作类实现。位于主窗口的顶部，主窗口只能有一个菜单栏。</li>
<li>②工具栏（QToolBar）。一般用于显示一些常用的菜单项目，也可以插入其他窗口部件，并且是可以移动的。主窗口可以拥有多个工具栏。</li>
<li>③中心部件（Central Widget）。在主窗口的中心区域可以放入一个部件作为中心部件。一个主窗口只能拥有一个中心部件。</li>
<li>④Dock部件（QDockWidget）。Dock部件常被称为停靠窗口，因为可以停靠在中心部件的四周，用来放置一些部件来实现一些常用功能，就像个工具箱一样。主窗口可以拥有多个Dock部件。</li>
<li>⑤状态栏（QStatusBar）。状态栏用于显示程序的一些状态信息，在主窗口的最底部。主窗口只能拥有一个状态栏。</li>
</ul>
<hr>
<h4 id="菜单栏和工具栏"><a href="#菜单栏和工具栏" class="headerlink" title="菜单栏和工具栏"></a>菜单栏和工具栏</h4><p>新建Qt Widget项目，Base Class选择<strong>QMainWindows</strong></p>
<h5 id="1-设计模式添加菜单"><a href="#1-设计模式添加菜单" class="headerlink" title="1.设计模式添加菜单"></a><strong>1.设计模式添加菜单</strong></h5><ul>
<li><p>双击左上角的**“在这里输入”<strong>，修改为“<strong>文件(&amp;F)</strong>”，“</strong>&amp;F**”被称为<strong>加速键</strong>，表明<strong>程序运行时</strong>。</p>
<p>（如果没有**“从这里输入”**这几个字，可以先点中心空白处。）</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707081531444.png" alt="image-20250707081531444"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707081720282.png" alt="image-20250707081720282"></p>
</li>
<li><p>修改第一项为”<strong>新建文件(&amp;N)</strong>”</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707081904291.png" alt="image-20250707081904291"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707082022938.png" alt="image-20250707082022938"></p>
</li>
<li><p>在主窗口窗体上右击，从弹出的级联菜单中选择“<strong>添加工具栏</strong>”。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707082123865.png" alt="image-20250707082123865"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707082255638.png" alt="image-20250707082255638"></p>
</li>
<li><p>打开Action编辑器</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707082715858.png" alt="image-20250707082715858"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707082732986.png" alt="image-20250707082732986"></p>
<p>然后将Action编辑器中的action_N动作拖入菜单栏下面的工具栏中。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707082825603.png" alt="image-20250707082825603"></p>
</li>
<li><p>添加<strong>Qt资源文件myimages.qrc</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707083319707.png" alt="image-20250707083319707"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707083358035.png" alt="image-20250707083358035"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707083717476.png" alt="image-20250707083717476"></p>
</li>
<li><p>然后回到设计模式，在Action编辑器中双击“新建文件”动作，这时会弹出编辑动作对话框。</p>
<p>将对象名称改为action_New，然后按下“图标”后面的…按钮，进入选择资源界面并选择new.png图片。<br>最后在快捷方式后面的输入栏上单击并按下Ctrl+N组合键。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707084034944.png" alt="image-20250707084034944"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707084115899.png" alt="image-20250707084115899"></p>
</li>
<li><p>运行：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707085245181.png" alt="image-20250707085245181"></p>
</li>
</ul>
<hr>
<h5 id="2-编写代码方式添加菜单"><a href="#2-编写代码方式添加菜单" class="headerlink" title="2.编写代码方式添加菜单"></a>2.编写代码方式添加菜单</h5><ul>
<li><p>在设计模式中，选中<strong>QMenuBar</strong>对象，并在属性编辑器中修改objectName为menuBar</p>
<p>选中<strong>QToolBar</strong>对象，并在属性编辑器中修改objectName为mainToolBar。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707084629212.png" alt="image-20250707084629212"></p>
<p>然后回到编辑模式，在mainwindow.cpp文件的MainWindow类<strong>构造函数</strong>中添加代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//需要添加的代码</span></span><br><span class="line">    QMenu *editMenu = ui-&gt;menuBar-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;编辑(&amp;E)&quot;</span>));</span><br><span class="line">    QAction *action_Open = editMenu-&gt;<span class="built_in">addAction</span>(  <span class="built_in">QIcon</span>(<span class="string">&quot;:/images/open.png&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;打开文件(&amp;O)&quot;</span>));</span><br><span class="line">    action_Open-&gt;<span class="built_in">setShortcut</span>(<span class="built_in">QKeySequence</span>(<span class="string">&quot;Ctrl+O&quot;</span>));</span><br><span class="line">    ui-&gt;mainToolBar-&gt;<span class="built_in">addAction</span>(action_Open);</span><br><span class="line">&#125;                            </span><br></pre></td></tr></table></figure>

<p>这里使用ui-&gt;menuBar来获取QMainWindow的菜单栏，使用ui-&gt;mainToolBar来获取QMainWindow的工具栏，然后分别使用相应的函数添加菜单和动作。就像前面提到过的，在菜单中的各种菜单项都是一个QAction类对象。</p>
</li>
<li><p>运行：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707085340243.png" alt="image-20250707085340243"></p>
</li>
</ul>
<hr>
<h5 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h5><ul>
<li>QMenuBar类提供了一个水平的菜单栏，在QMainWindow中可以直接获取<strong>默认</strong>的菜单栏，向其中添加QMenu类型的菜单对象，然后向弹出菜单中添加QAction类型的动作对象作为菜单项。</li>
<li>在QMenu中还提供了间隔器，可以在设计器中向添加菜单那样直接添加<strong>间隔器</strong>，或者在代码中使用**addSeparator()**函数来添加，它是一条水平线，可以将菜单进行分组。</li>
<li>应用程序中很多普通的命令都是通过菜单来实现的，也可以将这些菜单命令放到工具栏中以方便使用。QAction就是这样一种命令动作，可以同时放在菜单和工具栏中。一个QAction动作包含了图标、菜单显示文本、快捷键、状态栏显示文本、“What’s This？”显示文本和工具提示文本。这些都可以在构建QAction类对象时在构造函数中指定。</li>
<li>另外还可以设置QAction的<strong>checkable</strong>属性，如果指定这个动作的checkable为true，那么当选中这个菜单时就会在它的前面**显示“√”**之类的表示选中状态的符号；<strong>如果该菜单有图标，那么就会用线框将图标围住</strong>，用来表示该动作被选中了。</li>
</ul>
<p><strong>QActionGroup类</strong></p>
<p>它可以包含一组动作QAction，可以设置这组动作中是否<strong>只能有一个动作处于选中</strong>状态，这对于互斥型动作很有用。</p>
<p>例如，在前面程序的MainWindow类<strong>构造函数</strong>中继续添加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QActionGroup&quot;</span>	<span class="comment">//先引入</span></span></span><br><span class="line">&#123;	</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"> 	<span class="comment">/*代码*/</span></span><br><span class="line">    QActionGroup *group = <span class="keyword">new</span> <span class="built_in">QActionGroup</span>(<span class="keyword">this</span>);            </span><br><span class="line">    QAction *action_L = group-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;左对齐(&amp;L)&quot;</span>)); </span><br><span class="line">    action_L-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);                  </span><br><span class="line">    QAction *action_R = group-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;右对齐(&amp;R)&quot;</span>));</span><br><span class="line">    action_R-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    QAction *action_C = group-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;居中(&amp;C)&quot;</span>));</span><br><span class="line">    action_C-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">    action_L-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);         </span><br><span class="line"></span><br><span class="line">    editMenu-&gt;<span class="built_in">addSeparator</span>();                      </span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(action_L);               </span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(action_R);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(action_C);     </span><br><span class="line">&#125;</span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707085949284.png" alt="image-20250707085949284"></p>
<hr>
<h5 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h5><p>工具栏QToolBar类提供了一个包含了一组控件的、可以移动的<strong>面板</strong>。前面已经看到可以将QAction对象添加到工具栏中，默认只是显示一个动作的图标，可以在QToolBar的属性编辑器中进行更改。</p>
<p>在设计器中查看QToolBar的属性编辑器，</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707090118217.png" alt="image-20250707090118217"></p>
<ul>
<li>toolButtonStyle属性就是设置图标和相应文本的显示及其相对位置的；</li>
<li>movabel属性设置状态栏是否可以移动；</li>
<li>allowedArea设置允许停靠的位置；</li>
<li>iconsize属性设置图标的大小；</li>
<li>floatable属性设置是否可以悬浮。</li>
</ul>
<p>工具栏中除了可以添加动作外，还可以添加其他的窗口部件，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QToolButton *toolBtn = <span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);         </span><br><span class="line">toolBtn-&gt;<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;颜色&quot;</span>));</span><br><span class="line">QMenu *colorMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>(<span class="keyword">this</span>);               </span><br><span class="line">colorMenu-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;红色&quot;</span>));</span><br><span class="line">colorMenu-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;绿色&quot;</span>));</span><br><span class="line">toolBtn-&gt;<span class="built_in">setMenu</span>(colorMenu);</span><br><span class="line">toolBtn-&gt;<span class="built_in">setPopupMode</span>(QToolButton::MenuButtonPopup);</span><br><span class="line">ui-&gt;mainToolBar-&gt;<span class="built_in">addWidget</span>(toolBtn);              </span><br><span class="line">QSpinBox *spinBox = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(<span class="keyword">this</span>);             </span><br><span class="line">ui-&gt;mainToolBar-&gt;<span class="built_in">addWidget</span>(spinBox);              </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707090425056.png" alt="image-20250707090425056"></p>
<hr>
<h4 id="中心部件"><a href="#中心部件" class="headerlink" title="中心部件"></a>中心部件</h4><ul>
<li><p>主窗口的中心区域可以放置一个中心部件，它一般是一个<strong>编辑器或者浏览器</strong>。这里支持单文档部件，也支持多文档部件。一般的，会使用布局管理器使中心部件充满整个中心区域，并可以随着窗口的大小变化而变化。例如，在设计模式中，往中心区域拖入一个Text Edit，然后单击界面，按下Ctrl+G快捷键，使其处于一个栅格布局中。</p>
</li>
<li><p><strong>QTextEdit</strong>是一个高级的WYSIWYG（所见即所得）浏览器和编辑器，支持富文本的处理，为用户提供了强大的文本编辑功能。而与QTextEdit对应的是QPlainTextEdit类，它提供了一个纯文本编辑器，这个类与QTextEdit类的很多功能都很相似，只不过无法处理富文本。还有一个QTextBrowser类，它是一个富文本浏览器，可以看做是QTextEdit的只读模式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依旧在构造函数中添加</span></span><br><span class="line"><span class="comment">// 新增QTextEdit作为中央部件</span></span><br><span class="line">    QTextEdit *textEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(textEdit); <span class="comment">// 设置为中央部件</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707091053391.png" alt="image-20250707091053391"></p>
<p>或者可以直接设计模式拉入一个TextEdit部件，然后Ctrl+L自适应大小即可。</p>
</li>
<li><p>中心区域还可以<strong>使用多文档部件</strong>。Qt中的QMdiArea部件就是用来提供一个可以显示MDI（Multiple Document Interface）多文档界面的区域，从而有效地管理多个窗口。QMdiArea中的子窗口由QMdiSubWindow类提供，这个类有自己的布局，包含一个标题栏和一个中心区域，可以向它的中心区域添加部件。<br>实例：</p>
<ul>
<li><p>在设计模式拖入一个MDI Area部件。</p>
</li>
<li><p>在Action编辑器中的“新建文件”动作上右击，在弹出的级联菜单中选择“转到槽”，然后在弹出的对话框中选择**<code>triggered()</code>**触发信号，单击“确定”按钮后跳转mainwindow.cpp文件中该信号的槽的定义处，进行更改。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707091749434.png" alt="image-20250707091749434"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QMdiSubWindow&quot;</span>	<span class="comment">//先引入</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_action_New_triggered</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTextEdit *edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>); </span><br><span class="line">    QMdiSubWindow *child = ui-&gt;mdiArea-&gt;<span class="built_in">addSubWindow</span>(edit);</span><br><span class="line">    child-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;多文档编辑器子窗口&quot;</span>));</span><br><span class="line">    child-&gt;<span class="built_in">show</span>();  </span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>
</li>
<li><p>运行：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707092007888.png" alt="image-20250707092007888"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Dock部件"><a href="#Dock部件" class="headerlink" title="Dock部件"></a>Dock部件</h4><p>QDockWidget类提供了这样一个部件，可以停靠在QMainWindow中也可以悬浮起来作为桌面顶级窗口，被称为Dock部件或者<strong>停靠</strong>窗口。</p>
<p>Dock部件一般用于存放一些其他小部件来实现特殊功能，就像一个工具箱。在主窗口中可以停靠在中心部件的四周，也可以悬浮起来被拖动到任意的地方，还可以被关闭或隐藏起来。</p>
<p>一个Dock部件包含一个标题栏和一个内容区域，可以向Dock部件中放入任何部件。</p>
<p>实例：</p>
<ul>
<li><p>在设计模式中向中心区域拖入一个Dock Widget部件，然后再向Dock中随意拖入几个部件，比如这里拖入一个Push Button和一个Font Combo Box。</p>
</li>
<li><p>在属性编辑器中，将dockWidget的windowTitle修改为“工具箱”，可以设置它的属性：</p>
<ul>
<li>features属性，包含是否可以关闭、移动和悬浮等；</li>
<li>allowedArea属性，用来设置可以停靠的区域。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707092516645.png" alt="image-20250707092516645"></p>
</li>
<li><p>运行：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707092546745.png" alt="image-20250707092546745"></p>
</li>
<li><p>当关闭了Dock部件后，可以通过如下代码重新显示Dock：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;dockWidget-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h4><p><strong>目前的设计器还不支持直接向状态栏中拖放部件，所以需要使用代码来生成。</strong></p>
<ul>
<li><p>先在设计模式右上角的对象查看器中选中QStatusBar对象，在下面更改其objectName属性为statusBar。(如果没有objectName属性，那就看看名称和是否是statusBar，后面的代码根据你的QStatusBar对象名称进行编写，我的这里是<strong>statusbar</strong>)</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707093035439.png" alt="image-20250707093035439"></p>
</li>
<li><p>然后转到编辑模式，在mainwindow.cpp文件中的构造函数里添加代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;statusbar-&gt;<span class="built_in">showMessage</span>(<span class="built_in">tr</span>(<span class="string">&quot;欢迎使用多文档编辑器&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">QLabel *permanent = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">permanent-&gt;<span class="built_in">setFrameStyle</span>(QFrame::Box | QFrame::Sunken);</span><br><span class="line">permanent-&gt;<span class="built_in">setText</span>(<span class="string">&quot;www.qter.org&quot;</span>);</span><br><span class="line">ui-&gt;statusbar-&gt;<span class="built_in">addPermanentWidget</span>(permanent);</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707094954568.png" alt="image-20250707094954568"></p>
</li>
</ul>
<hr>
<h4 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h4><p>菜单中也可以使用其他部件，Qt中的QWidgetAction类就提供了这样的功能。</p>
<p>为了实现自定义菜单，需要新建一个类，它继承自QWidgetAction类，并且在其中重新实现createWidget()函数。</p>
<p>添加C++新文件。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707095528490.png" alt="image-20250707095528490"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custommenuaction.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CUSTOMMENUACTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CUSTOMMENUACTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidgetAction&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomMenuAction</span> : <span class="keyword">public</span> QWidgetAction</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CustomMenuAction</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">QWidget *<span class="title">createWidget</span><span class="params">(QWidget *parent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">textEntered</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleReturnPressed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CUSTOMMENUACTION_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custommenuaction.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;custommenuaction.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">CustomMenuAction::<span class="built_in">CustomMenuAction</span>(QObject *parent)</span><br><span class="line">    : <span class="built_in">QWidgetAction</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QWidget *<span class="title">CustomMenuAction::createWidget</span><span class="params">(QWidget *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QWidget *container = <span class="keyword">new</span> <span class="built_in">QWidget</span>(parent);</span><br><span class="line">    QHBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(container);</span><br><span class="line">    layout-&gt;<span class="built_in">setContentsMargins</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>); <span class="comment">// 调整边距使其更紧凑</span></span><br><span class="line">    </span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;输入文本:&quot;</span>, container);</span><br><span class="line">    QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(container);</span><br><span class="line">    </span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(lineEdit);</span><br><span class="line">    container-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">connect</span>(lineEdit, &amp;QLineEdit::returnPressed, <span class="keyword">this</span>, &amp;CustomMenuAction::handleReturnPressed);</span><br><span class="line">    <span class="built_in">connect</span>(lineEdit, &amp;QLineEdit::returnPressed, lineEdit, &amp;QLineEdit::clear);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CustomMenuAction::handleReturnPressed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QLineEdit *lineEdit = <span class="built_in">qobject_cast</span>&lt;QLineEdit*&gt;(<span class="built_in">sender</span>());</span><br><span class="line">    <span class="keyword">if</span> (lineEdit) &#123;</span><br><span class="line">        <span class="function">emit <span class="title">textEntered</span><span class="params">(lineEdit-&gt;text())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.cpp</span></span><br><span class="line"><span class="comment">// 在文件顶部添加包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;custommenuaction.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在MainWindow构造函数中添加自定义菜单项</span></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 原有代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建自定义菜单项并添加到编辑菜单</span></span><br><span class="line">    CustomMenuAction *customAction = <span class="keyword">new</span> <span class="built_in">CustomMenuAction</span>(<span class="keyword">this</span>);</span><br><span class="line">    editMenu-&gt;<span class="built_in">addAction</span>(customAction);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接信号到槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(customAction, &amp;CustomMenuAction::textEntered, </span><br><span class="line">            <span class="keyword">this</span>, &amp;MainWindow::insertTextToActiveEditor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在MainWindow类中添加新的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::insertTextToActiveEditor</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前活动的MDI子窗口</span></span><br><span class="line">    QMdiSubWindow *activeSubWindow = ui-&gt;mdiArea-&gt;<span class="built_in">activeSubWindow</span>();</span><br><span class="line">    <span class="keyword">if</span> (activeSubWindow) &#123;</span><br><span class="line">        <span class="comment">// 获取子窗口中的文本编辑器</span></span><br><span class="line">        QTextEdit *textEdit = <span class="built_in">qobject_cast</span>&lt;QTextEdit*&gt;(activeSubWindow-&gt;<span class="built_in">widget</span>());</span><br><span class="line">        <span class="keyword">if</span> (textEdit) &#123;</span><br><span class="line">            <span class="comment">// 插入文本到光标位置</span></span><br><span class="line">            textEdit-&gt;<span class="built_in">insertPlainText</span>(text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.h</span></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertTextToActiveEditor</span><span class="params">(<span class="type">const</span> QString &amp;text)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707095901282.png" alt="image-20250707095901282"></p>
<hr>
<h3 id="Qt-Quick-主窗口"><a href="#Qt-Quick-主窗口" class="headerlink" title="Qt Quick 主窗口"></a>Qt Quick 主窗口</h3><p>Qt Quick Controls模块最开始就是为了简化Qt Quick桌面程序开发而诞生的，提供了很多桌面应用程序主窗口相关的控件，其中核心类型是<strong>ApplicationWindow</strong>，该类型继承自Window类型。</p>
<p>本节将通过实例对Window、ApplicationWindow以及菜单类、容器类、弹出窗口类等众多相关类型进行介绍。</p>
<hr>
<h4 id="窗口Window"><a href="#窗口Window" class="headerlink" title="窗口Window"></a>窗口Window</h4><p>Window对象可以为Qt Quick场景创建一个新的顶级窗口，一般的Qt Quick项目都可以将Window作为根对象。</p>
<p><strong>Window属性：</strong></p>
<ul>
<li><p><strong>width</strong>和<strong>height</strong>属性来设置的大小</p>
</li>
<li><p><strong>x、y属性</strong>来设置窗口在屏幕上的坐标位置，</p>
</li>
<li><p><strong>title</strong>属性设置窗口标题，</p>
</li>
<li><p><strong>color</strong>属性设置窗口背景色，</p>
</li>
<li><p><strong>opacity</strong>属性设置窗口透明效果。</p>
</li>
</ul>
<p><strong>窗口默认是不显示的，需要设置visible属性为true来显示窗口。</strong></p>
<p>Window类型中还提供了多个方法来进行常用操作：</p>
<table>
<thead>
<tr>
<th><strong>显示窗口</strong></th>
<th><strong>show()</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>全屏显示</strong></td>
<td><strong>showFullScreen()</strong></td>
</tr>
<tr>
<td><strong>最大化显示</strong></td>
<td><strong>showMaximized()</strong></td>
</tr>
<tr>
<td><strong>最小化显示</strong></td>
<td><strong>showMinimized()</strong></td>
</tr>
<tr>
<td><strong>正常显示</strong></td>
<td><strong>showNormal()</strong></td>
</tr>
<tr>
<td><strong>隐藏窗口</strong></td>
<td><strong>hide()</strong></td>
</tr>
<tr>
<td><strong>关闭窗口</strong></td>
<td><strong>close()</strong></td>
</tr>
</tbody></table>
<p>另外，当关闭窗口时会发射**closing(CloseEvent close)<strong>信号，可以在onClosing信号处理器中设置</strong><code>close.accepted = false</code>**来强制窗口保持显示，从而在关闭窗口前完成一些操作。</p>
<hr>
<p>Window窗口也可以嵌套使用，或者声明在一个Item对象中，这时在大多数平台上内部的Window会显示在外部界面的中心。</p>
<ul>
<li><p><strong>还可以通过flags属性来指定窗口的类型，比如<code>Qt.Dialog</code>或<code>Qt.Popup</code>，可以通过<code>Qt::WindowType</code>关键字查看全部类型。</strong></p>
</li>
<li><p><strong>使用modality属性可以指定窗口是否为模态，默认为<code>Qt.NonModal</code>非模态，另外还有<code>Qt.WindowModal</code>和<code>Qt.ApplicationModal</code>两种模态形式，前者会阻塞其父窗口，后者会阻塞整个应用，使它们无法接收输入事件。</strong></p>
</li>
<li><p><strong>使用模板新创建的Qt Quick Application项目默认使用Window作为根对象，例如：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="应用程序主窗口-1"><a href="#应用程序主窗口-1" class="headerlink" title="应用程序主窗口"></a>应用程序主窗口</h4><p><strong>ApplicationWindow</strong></p>
<p>为了方便实现主窗口程序，可以使用Window的子类型ApplicationWindow，该类型在Window的基础上增加了<strong>菜单栏menuBar、头部header、脚部footer</strong>这3个属性，可以指定自定义的项目。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707100944931.png" alt="image-20250707100944931"></p>
<p>一般的Qt Quick Controls项目都会使用ApplicationWindow作为根对象，其典型用法如下面代码片段所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ApplicationWindow &#123;</span><br><span class="line">    visible: true</span><br><span class="line"></span><br><span class="line">    menuBar: MenuBar &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    header: ToolBar &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    footer: TabBar &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StackView &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在QML中，可以在子对象的任意位置引用根对象的id，这种方式一般情况下都很好用，但是对于可重用的独立QML组件来说，这种方式却不再好用。</p>
<p>为了解决这个问题，ApplicationWindow提供了一组附加属性，可以从无法直接访问窗口的位置访问窗口及其组成部分，而不需要指定窗口的id。这些附加属性包括：</p>
<ul>
<li>ApplicationWindow.window</li>
<li>ApplicationWindow.menuBar</li>
<li>ApplicationWindow.header</li>
<li>ApplicationWindow.footer</li>
<li>ApplicationWindow.contentItem</li>
<li>ApplicationWindow.activeFocusControl</li>
</ul>
<p>实例：<strong>创建菜单栏</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ApplicationWindow &#123;</span><br><span class="line">    title: &quot;My Application&quot;; width: 600; height: 450; visible: true</span><br><span class="line"></span><br><span class="line">    menuBar: MenuBar &#123;</span><br><span class="line">        id: menuBar</span><br><span class="line"></span><br><span class="line">        Menu &#123;</span><br><span class="line">            id: fileMenu; title: qsTr(&quot;文件&quot;)</span><br><span class="line">            MenuItem &#123;</span><br><span class="line">                text: qsTr(&quot;关闭&quot;); icon.source: &quot;qrc:/images/close.png&quot;; onTriggered: close()</span><br><span class="line">            &#125;</span><br><span class="line">            MenuSeparator &#123;&#125;</span><br><span class="line">            MenuItem &#123;</span><br><span class="line">                text: qsTr(&quot;关于&quot;); icon.source: &quot;qrc:/images/about.png&quot;; onTriggered: popup.open()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>头部工具栏</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick.Layouts</span><br><span class="line"></span><br><span class="line">header: ToolBar &#123;</span><br><span class="line">        RowLayout &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            ToolButton &#123;</span><br><span class="line">                text: qsTr(&quot;&lt;&quot;); visible: footerbar.currentIndex === 0</span><br><span class="line">                enabled: stack.depth &gt; 1; onClicked: stack.pop()</span><br><span class="line">            &#125;</span><br><span class="line">            ToolButton &#123;</span><br><span class="line">                text: qsTr(&quot;&gt;&quot;); visible: footerbar.currentIndex === 0</span><br><span class="line">                enabled: stack.depth &lt; 3; onClicked: stack.push(mainView)</span><br><span class="line">            &#125;</span><br><span class="line">            PageIndicator &#123;</span><br><span class="line">                id: indicator; visible: footerbar.currentIndex === 0</span><br><span class="line">                count: stack.depth; currentIndex: stack.depth</span><br><span class="line">            &#125;</span><br><span class="line">            Label &#123;</span><br><span class="line">                text: &quot;工具栏&quot;; elide: Label.ElideRight</span><br><span class="line">                horizontalAlignment: Qt.AlignHCenter; verticalAlignment: Qt.AlignVCenter</span><br><span class="line">                Layout.fillWidth: true</span><br><span class="line">            &#125;</span><br><span class="line">            ToolButton &#123;</span><br><span class="line">                text: qsTr(&quot;...&quot;); onClicked: popup.open()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707104507757.png" alt="image-20250707104507757"></p>
<p><strong>弹出窗口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Popup &#123;</span><br><span class="line">    id: popup; width: 250; height: 150</span><br><span class="line">    parent: Overlay.overlay; modal: true; focus: true</span><br><span class="line">    x: Math.round((parent.width - width) / 2)</span><br><span class="line">    y: Math.round((parent.height - height) / 2)</span><br><span class="line"></span><br><span class="line">    Label &#123;</span><br><span class="line">        id: label; text: &quot;这是个Popup&quot;</span><br><span class="line">        font.pixelSize: 16; font.italic: true</span><br><span class="line">        x: Math.round((parent.width - width) / 2)</span><br><span class="line">        y: Math.round((parent.height - height) / 2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Button &#123;</span><br><span class="line">        text: &quot;Ok&quot;; onClicked: popup.close()</span><br><span class="line">        anchors.top: label.bottom; anchors.topMargin: 10</span><br><span class="line">        anchors.horizontalCenter: label.horizontalCenter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707104653621.png" alt="image-20250707104653621"></p>
<p><strong>脚步控件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">footer: TabBar &#123;</span><br><span class="line">    id: footerbar</span><br><span class="line">    width: parent.width</span><br><span class="line"></span><br><span class="line">    TabButton &#123; text: qsTr(&quot;图片&quot;) &#125;</span><br><span class="line">    TabButton &#123; text: qsTr(&quot;音乐&quot;) &#125;</span><br><span class="line">    TabButton &#123; text: qsTr(&quot;视频&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StackLayout &#123;</span><br><span class="line">    id: view</span><br><span class="line">    currentIndex: footerbar.currentIndex</span><br><span class="line">    anchors.fill: parent</span><br><span class="line"></span><br><span class="line">    StackView &#123; id: stack; initialItem: mainView &#125;</span><br><span class="line">    Rectangle &#123; id: secondPage; color: &quot;lightyellow&quot; &#125;</span><br><span class="line">    Rectangle &#123; id: thirdPage; color: &quot;lightblue&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707104912358.png" alt="image-20250707104912358"></p>
<p>StackView栈视图类型用于一组内部链接的页面，支持3种主要导航操作：<strong>push()、pop()和replace()</strong>，这些操作对应经典的栈操作。</p>
<p>栈视图中最上面的项对应于当前在屏幕上可见的项，可以使用<strong>initialItem</strong>属性指定初始化显示的项目，<strong>depth</strong>属性可以返回栈视图中项目的数量。</p>
<p>这里使用组件Component来提供栈视图的页面，通过前面添加的工具按钮ToolButton来完成**push()和pop()**操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Component &#123;</span><br><span class="line">    id: mainView</span><br><span class="line">    Item &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            Image &#123; anchors.fill: parent; source: &quot;qrc:/images/&quot; + stack.depth + &quot;.png&quot; &#125;</span><br><span class="line">            Text &#123; text: qsTr(&quot;页面&quot;) + stack.depth &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="菜单类控件"><a href="#菜单类控件" class="headerlink" title="菜单类控件"></a>菜单类控件</h4><p>Qt Quick Controls模块中提供了一些菜单相关的控件来完成一个完整菜单的创建，包括:</p>
<ul>
<li>菜单栏MenuBar</li>
<li>菜单栏项目MenuBarItem</li>
<li>菜单Menu</li>
<li>菜单项目MenuItem</li>
</ul>
<p>在前面的示例中已经使用过MenuBar、Menu和MenuItem等控件。</p>
<p>MenuBarItem用作MenuBar的默认委托类型，在使用MenuBar时，不必手动声明MenuBarItem实例，将Menu声明为MenuBar的子对象时，会自动创建相应项目。</p>
<p>Menu菜单控件继承自Popup，主要用来实现上下文菜单（例如，右击鼠标后显示的菜单）和弹出菜单（例如，单击按钮后显示的菜单）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick.Controls</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 400; height: 300; visible: true</span><br><span class="line"></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        acceptedButtons: Qt.LeftButton | Qt.RightButton</span><br><span class="line">        onClicked: (mouse) =&gt; &#123;</span><br><span class="line">            if (mouse.button === Qt.RightButton)</span><br><span class="line">                contextMenu.popup()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Menu &#123;</span><br><span class="line">            id: contextMenu</span><br><span class="line">            MenuItem &#123; text: qsTr(&quot;Cut&quot;) &#125;</span><br><span class="line">            MenuItem &#123; text: qsTr(&quot;Copy&quot;) &#125;</span><br><span class="line">            MenuItem &#123; text: qsTr(&quot;Paste&quot;) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707110643789.png" alt="image-20250707110643789"></p>
<p>当用作弹出菜单时，一般相对于使用者来指定位置，然后调用open()打开菜单，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Button &#123;</span><br><span class="line">    id: fileButton</span><br><span class="line">    text: &quot;File&quot;; x: 0; y: 0</span><br><span class="line">    onClicked: menu.open()</span><br><span class="line">    </span><br><span class="line">    Menu &#123;</span><br><span class="line">        id: menu</span><br><span class="line">        y: fileButton.height</span><br><span class="line">        </span><br><span class="line">        MenuItem &#123; text: qsTr(&quot;New...&quot;) &#125;</span><br><span class="line">        MenuItem &#123; text: qsTr(&quot;Open...&quot;) &#125;</span><br><span class="line">        MenuItem &#123; text: qsTr(&quot;Save&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707110806277.png" alt="image-20250707110806277"></p>
<hr>
<h4 id="容器类控件"><a href="#容器类控件" class="headerlink" title="容器类控件"></a>容器类控件</h4><p>容器类控件主要包括<strong>ApplicationWindow、Container、Frame、GroupBox、HorizontalHeaderView、VerticalHeaderView、Page、Pane、ScrollView、SplitView、StackView、SwipeView、TabBar和ToolBar</strong>等。</p>
<ul>
<li><p>其中<strong>ApplicationWindow、ToolBar、StackView和TabBar</strong>在前面示例中已经介绍过了。</p>
</li>
<li><p><strong>HorizontalHeaderView和VerticalHeaderView</strong>主要为TableView提供水平和垂直表头，</p>
</li>
</ul>
<hr>
<p><strong>Pane、Frame和GroupBox</strong></p>
<ul>
<li><p>Pane直接继承自Control，是其他几个面板容器的基类型，提供了与应用程序样式和主题相匹配的背景色，但没有提供自己的布局，需要通过创建RowLayout或ColumnLayout等来手动布局。</p>
<p>如果Pane中仅有一个项目，它会<strong>调整大小以适应</strong>其所包含项目的隐式大小，当包含两个以上项目时，需要通过<strong>contentWidth和contentHeight</strong>来指定大小。</p>
</li>
<li><p>Frame继承自Pane，区别是Frame提供了一个边框。而GroupBox继承自Frame，它在Frame的基础上又添加了一个标题。</p>
<p>可以通过<strong>title</strong>属性来设置GroupBox的标题，也可以通过<strong>label</strong>属性来设置显示标题的项目，比如使用CheckBox来创建GroupBox的标题项目，这样可以实现打开或关闭GroupBox复选框时，启用或禁用所有子项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GroupBox &#123;</span><br><span class="line">    contentWidth: 150; contentHeight: 80</span><br><span class="line">    </span><br><span class="line">    label: CheckBox &#123;</span><br><span class="line">        id: checkBox</span><br><span class="line">        checked: true; text: qsTr(&quot;Synchronize&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    ColumnLayout &#123;</span><br><span class="line">        anchors.fill: parent; anchors.topMargin: 10</span><br><span class="line">        enabled: checkBox.checked</span><br><span class="line">        CheckBox &#123; text: qsTr(&quot;E-mail&quot;) &#125;</span><br><span class="line">        CheckBox &#123; text: qsTr(&quot;Calendar&quot;) &#125;</span><br><span class="line">        CheckBox &#123; text: qsTr(&quot;Contacts&quot;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707111136861.png" alt="image-20250707111136861"></p>
</li>
</ul>
<hr>
<p><strong>Page</strong></p>
<p>Page继承自Pane，在其基础上添加了<strong>header和footer</strong>属性，可以指定项目作为头部和脚部，所以Page一般用在ApplicationWindow中间显示多个不同的页面。</p>
<p>另外，Page还有一个<strong>title</strong>属性，可以设置页面标题，但是Page无法直接显示该标题，需要手动设置项目来进行显示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick</span><br><span class="line">import QtQuick.Controls</span><br><span class="line">import QtQuick.Layouts</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: 640</span><br><span class="line">    height: 480</span><br><span class="line">    visible: true</span><br><span class="line">    title: qsTr(&quot;Hello World&quot;)</span><br><span class="line"></span><br><span class="line">    SwipeView &#123;</span><br><span class="line">        id: view; anchors.fill: parent</span><br><span class="line"></span><br><span class="line">        Page &#123;</span><br><span class="line">            title: qsTr(&quot;页面1&quot;)</span><br><span class="line">            header: ToolBar&#123;</span><br><span class="line">                RowLayout &#123;</span><br><span class="line">                    anchors.fill: parent;</span><br><span class="line">                    ToolButton &#123; text: qsTr(&quot;按钮1&quot;) &#125;</span><br><span class="line">                    ToolButton &#123; text: qsTr(&quot;按钮2&quot;) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            footer: ToolBar&#123;</span><br><span class="line">                Label &#123; text: qsTr(&quot;工具栏&quot;);</span><br><span class="line">                    anchors.horizontalCenter: parent.horizontalCenter</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Page &#123;</span><br><span class="line">            title: qsTr(&quot;页面2&quot;)</span><br><span class="line">            //...</span><br><span class="line">            header: ToolBar&#123;</span><br><span class="line">                RowLayout &#123;</span><br><span class="line">                    anchors.fill: parent;</span><br><span class="line">                    ToolButton &#123; text: qsTr(&quot;选项1&quot;) &#125;</span><br><span class="line">                    ToolButton &#123; text: qsTr(&quot;选项2&quot;) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            footer: ToolBar&#123;</span><br><span class="line">                Label &#123; text: qsTr(&quot;工具栏&quot;);</span><br><span class="line">                    anchors.horizontalCenter: parent.horizontalCenter</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PageIndicator &#123;</span><br><span class="line">            currentIndex: view.currentIndex;  count: view.count</span><br><span class="line">            anchors.bottom: view.bottom; anchors.bottomMargin: 30</span><br><span class="line">            anchors.horizontalCenter: view.horizontalCenter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707111748182.png" alt="image-20250707111748182"></p>
<p>在移动设备上，一般多个页面常会使用PageIndicator以小点的形式在下方显示页面个数和当前活动页面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageIndicator &#123;</span><br><span class="line">        currentIndex: view.currentIndex;  count: view.count</span><br><span class="line">        anchors.bottom: view.bottom; anchors.bottomMargin: 30</span><br><span class="line">        anchors.horizontalCenter: view.horizontalCenter</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707111815799.png" alt="image-20250707111815799"></p>
<hr>
<p><strong>Container、SwipeView和TabBar</strong></p>
<ul>
<li>Container是允许动态插入和移除项的容器类控件的基本类型。一般可以将项目作为Container的子对象直接进行声明，也可以通过<strong>addItem()、insertItem()、moveItem()和removeItem()<strong>等方法来动态管理项目，可以通过</strong>itemAt()或者contentChildren</strong>属性来访问容器中的项目。大多数容器都有一个“当前项目”的概念，当前项可以通过<strong>currentIndex</strong>属性指定。在实际编程时，通常会使用多个容器类控件，并将它们的<strong>currentIndex</strong>属性相互绑定以保持同步切换。</li>
<li>SwipeView作为Container的子类型，提供了基于<strong>滑动</strong>的导航模型。SwipeView由一组页面进行填充，一次只能看到一页，可以通过横向滑动在页面之间导航。由于SwipeView本身是非可视的，所以一般会与PageIndicator结合使用，以向用户提供存在多个页面的视觉提示。</li>
<li>TabBar作为Container的子类型，提供了一个<strong>基于选项卡</strong>的导航模型。TabBar一般与SwipeView或者StackLayout等提供了<strong>currentIndex</strong>属性的类型同时使用，这个在前面的示例中已经多次见过。</li>
</ul>
<p><strong>ScrollView</strong></p>
<p>ScrollView也继承自Pane，并在其基础上提供了<strong>垂直滚动条和水平滚动条</strong>，从而可以展示更多内容。</p>
<ul>
<li>最简单的使用方法就是在ScrollView中显示比其尺寸更大的内容。</li>
<li>另外一种常用的情况是通过ScrollView来修饰Flickable及其子类型（例如ListView）。Flickable用来提供一个可以拖拽和弹动的界面，但是其本身没有提供滚动条，可以借助ScrollView来提供滚动条。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ScrollView &#123;</span><br><span class="line">    width: 200; height: 200</span><br><span class="line">    Label &#123; text: &quot;ABC&quot;; font.pixelSize: 224 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707112302889.png" alt="image-20250707112302889"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ScrollView &#123;</span><br><span class="line">    width: 200; height: 200</span><br><span class="line"></span><br><span class="line">    ListView &#123;</span><br><span class="line">        model: 20</span><br><span class="line">        delegate: ItemDelegate &#123;</span><br><span class="line">            text: &quot;Item &quot; + index</span><br><span class="line">            required property int index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707112218286.png" alt="image-20250707112218286"></p>
<hr>
<p><strong>SplitView</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SplitView &#123;</span><br><span class="line">        id: splitView</span><br><span class="line">        anchors.fill: parent; orientation: Qt.Horizontal</span><br><span class="line"></span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            implicitWidth: 200</span><br><span class="line">            SplitView.maximumWidth: 400; color: &quot;lightblue&quot;</span><br><span class="line">            Label &#123; text: &quot;View 1&quot;; anchors.centerIn: parent &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            id: centerItem</span><br><span class="line">            SplitView.minimumWidth: 50; SplitView.fillWidth: true</span><br><span class="line">            color: &quot;lightgray&quot;</span><br><span class="line">            Label &#123; text: &quot;View 2&quot;; anchors.centerIn: parent &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            implicitWidth: 200; color: &quot;lightgreen&quot;</span><br><span class="line">            Label &#123; text: &quot;View 3&quot;; anchors.centerIn: parent &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707112400375.png" alt="image-20250707112400375"></p>
<hr>
<h4 id="弹出类空间"><a href="#弹出类空间" class="headerlink" title="弹出类空间"></a>弹出类空间</h4><ul>
<li>弹出类控件主要包括Popup及其子类型<strong>Dialog、Drawer、Menu和ToolTip</strong>等。</li>
<li>Popup继承自QtObject，是弹出窗口类用户界面控件的基本类型，一般与Window或ApplicationWindow一起使用。为了确保Popup显示在场景中其他项目的上方，建议使用ApplicationWindow。</li>
<li>Popup不提供自己的布局，可以通过创建<strong>RowLayout</strong>或<strong>ColumnLayout</strong>来手动进行布局。声明为Popup的子对象将自动将其父对象设置为Popup的contentItem，动态创建的对象需要显式地将contentItem设置为其父对象。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707112438796.png" alt="image-20250707112438796"></p>
<ul>
<li><p>一般会使用附加的**<code>Overlay.Overlay</code>**属性将弹出窗口显示在界面中心，而不用考虑打开弹出窗口的按钮的位置。</p>
<p>Overlay是覆盖整个窗口的一个普通项目，为弹出窗口提供了一个层，确保弹出窗口显示在其他内容之上，并且当弹出窗口为模态（modal属性为true）或将dim属性设置为true，则弹出窗口可见时背景会变暗。</p>
</li>
<li><p>Popup的<strong>closePolicy</strong>属性用来设置弹出窗口的关闭策略，默认是**<code>Popup.CloseOnEscape | Popup.CloseOnPressOutside</code>**，就是在按下ESC键或者单击弹出窗口之外的界面时会关闭弹出窗口。</p>
<p>也可以设置为其他方式，比如**<code>Popup.CloseOnPressOutsideParent</code>**，需要在弹出窗口父项目之外单击才可以关闭。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ToolButton &#123;</span><br><span class="line">       text: qsTr(&quot;弹窗&quot;); onClicked: popup.open()</span><br><span class="line">   &#125;</span><br><span class="line">   Popup &#123;</span><br><span class="line">       id: popup; width: 250; height: 150</span><br><span class="line">       parent: Overlay.overlay; modal: true; focus: true</span><br><span class="line">       x: Math.round((parent.width - width) / 2)</span><br><span class="line">       y: Math.round((parent.height - height) / 2)</span><br><span class="line"></span><br><span class="line">       Label &#123;</span><br><span class="line">           id: label; text: &quot;这是个Popup&quot;</span><br><span class="line">           font.pixelSize: 16; font.italic: true</span><br><span class="line">           x: Math.round((parent.width - width) / 2)</span><br><span class="line">           y: Math.round((parent.height - height) / 2)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Button &#123;</span><br><span class="line">           text: &quot;Ok&quot;; onClicked: popup.close()</span><br><span class="line">           anchors.top: label.bottom; anchors.topMargin: 10</span><br><span class="line">           anchors.horizontalCenter: label.horizontalCenter</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707112830471.png" alt="image-20250707112830471"></p>
<hr>
<p><strong>Dialog</strong></p>
<ul>
<li><p>Dialog对话框是一个弹出窗口，主要用于短期任务或与用户的简短通信。与ApplicationWindow和Page类似，Dialog分为3个部分：<strong>header、contentItem和footer</strong>。</p>
</li>
<li><p>对话框的标准按钮通过DialogButtonBox进行管理，默认作为对话框的footer，通过Dialog的<strong>standardButtons</strong>属性可以用来设置标准按钮，该属性将转发至DialogButtonBox的相应属性。</p>
</li>
<li><p>另外，DialogButtonBox的**accepted()和rejected()<strong>信号将连接到Dialog中的相应信号。也就是说，可以明确创建一个DialogButtonBox控件来创建对话框的按钮并进行操作，也可以通过Dialog自身的standardButtons属性和</strong>accepted()、rejected()**等信号来创建按钮并进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ToolButton &#123;</span><br><span class="line">       text: qsTr(&quot;弹窗&quot;); onClicked: dialog.open()</span><br><span class="line">   &#125;</span><br><span class="line">   Dialog &#123;</span><br><span class="line">       id: dialog</span><br><span class="line">       title: &quot;Title&quot;</span><br><span class="line">       anchors.centerIn: Overlay.overlay</span><br><span class="line">       standardButtons: Dialog.Ok | Dialog.Cancel</span><br><span class="line">  </span><br><span class="line">       onAccepted: console.log(&quot;Ok clicked&quot;)</span><br><span class="line">       onRejected: console.log(&quot;Cancel clicked&quot;)</span><br><span class="line">  </span><br><span class="line">       Label &#123;</span><br><span class="line">           text: &quot;this is a dialog!&quot;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707113154193.png" alt="image-20250707113154193"></p>
</li>
</ul>
<hr>
<p><strong>ToolTip</strong></p>
<ul>
<li>ToolTip工具提示是告知用户控件功能的一小段文本，它通常位于父控件的上方或下方。</li>
<li>提示文本可以是任何富文本格式的字符串。最常用的使用方式是通过<strong>ToolTip.visible</strong>和<strong>ToolTip.text</strong>来设置工具提示的可见性和显示文本。</li>
<li>通过<strong>ToolTip.delay</strong>可以设置延迟显示时间，单位为毫秒，默认值为0；通过ToolTip.timeout 可以设置显示时间，单位为毫秒，默认值为-1，不会自动隐藏。这几个属性可以附加到任何项目上。</li>
<li>对于<strong>ToolTip.visible</strong>属性，可以设置为<strong>true</strong>，直接进行显示，也可以像这里一样，设置为Button的<strong>down、pressed、hovered</strong>等属性，只有在进行相应操作时才会显示。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Button &#123;</span><br><span class="line">    text: qsTr(&quot;Button&quot;)</span><br><span class="line">    onClicked: dialog.open()</span><br><span class="line">    ToolTip.visible: hovered</span><br><span class="line">    ToolTip.text: qsTr(&quot;打开对话框&quot;)</span><br><span class="line">    ToolTip.timeout: 10000</span><br><span class="line">    ToolTip.delay: 500</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707113648872.png" alt="image-20250707113648872"></p>
<hr>
<p><strong>Drawer</strong></p>
<ul>
<li>Drawer继承自Popup，是一个类似抽屉的侧面板控件。Drawer以及前面已经介绍过的StackView、SwipeView、TabBar和TabButton等又被称为导航类控件。</li>
<li>Drawer可以放置在内容项的4个边缘中的任何一个，默认靠着窗口的左边缘（Qt.LeftEdge），通过从左边缘“拖拽”来打开Drawer，可以通过edge属性设置为其他边缘，例如Qt.TopEdge、Qt.RightEdge和Qt.BottomEdge等。</li>
<li>dragMargin属性用来设置与屏幕边缘的距离，拖动操作将在该距离内打开Drawer，当设置为0或负数时将无法通过拖动打开Drawer。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ToolBar &#123;</span><br><span class="line">    id: header</span><br><span class="line">    width: parent.width</span><br><span class="line">    Label &#123;</span><br><span class="line">        text: &quot;My Application&quot;</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Drawer &#123;</span><br><span class="line">    id: drawer</span><br><span class="line">    width: window.width * 0.6</span><br><span class="line">    height: window.height - header.height</span><br><span class="line">    y: header.height;</span><br><span class="line"></span><br><span class="line">    Label &#123;</span><br><span class="line">        text: &quot;Content goes here!&quot;</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button &#123;</span><br><span class="line">       text: &quot;Open Drawer&quot;</span><br><span class="line">       onClicked: drawer.open()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707114640760.png" alt="image-20250707114640760"></p>
<ul>
<li>另外，position属性保存Drawer打开过程中相对于其最终目的地的位置，当完全关闭时，位置为0.0，当完全打开时，位置为1.0。通过position，可以实现在打开Drawer时将内容区域进行移动，从而尽量不被Drawer遮挡。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Label &#123;</span><br><span class="line">    id: content</span><br><span class="line">    text: &quot;Content&quot;; font.pixelSize: 25; anchors.fill: parent</span><br><span class="line">    verticalAlignment: Label.AlignVCenter</span><br><span class="line">    horizontalAlignment: Label.AlignHCenter</span><br><span class="line"></span><br><span class="line">    transform: Translate &#123;</span><br><span class="line">        x: drawer.position * content.width * 0.33</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250707114816392.png" alt="image-20250707114816392"></p>
<hr>
<hr>
<h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><h3 id="Qt-Widget-事件"><a href="#Qt-Widget-事件" class="headerlink" title="Qt Widget 事件"></a>Qt Widget 事件</h3><p>事件是对各种应用程序需要知道的由应用程序内部或者外部产生的事情或者动作的通称。</p>
<p>鼠标、键盘、定时器等常用事件的处理方式。</p>
<p>Qt中使用一个对象来表示一个事件，<strong>继承自QEvent类</strong>，比如常见的关闭事件QCloseEvent、输入事件QInputEvent、定时器事件QTimerEvent等。</p>
<p><strong>事件与信号并不相同，比如单击一下界面上的按钮，那么就会产生鼠标事件QMouseEvent（不是按钮产生的），而因为按钮被按下了，所以它会发射clicked()单击信号（是按钮产生的）。</strong></p>
<p><strong>这里一般只关心按钮的单击信号，而不用考虑鼠标事件，但是如果要设计一个按钮，或者通过鼠标拖拽按钮移动，那么就要关心鼠标事件了。</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250708090313395.png" alt="image-20250708090313395"></p>
<hr>
<h4 id="事件的处理"><a href="#事件的处理" class="headerlink" title="事件的处理"></a><strong>事件的处理</strong></h4><p>Qt的主事件循环从事件队列中获取本地窗口系统事件，将它们转换为<strong>QEvent对象</strong>，并将转换后的事件发送到QObject对象。</p>
<p>一个事件由一个特定的QEvent子类来表示，但是有时一个事件又包含多个事件类型，比如鼠标事件又可以分为鼠标按下、双击和移动等多种操作。这些事件类型都由QEvent类的枚举类型<code>QEvent::Type</code>来表示。虽然QEvent的子类可以表示一个事件，但是却不能用来处理事件，以下是5种处理事件的方法：</p>
<ul>
<li>重新实现部件的**paintEvent()、mousePressEvent() **用来处理特定部件的特定事件。</li>
<li>重新实现**notify()**函数，一次只能处理一个事件。（很强大，完全的控制）</li>
<li>向QApplication对象上安装事件过滤器。因为一个程序<strong>只有一个QApplication对象</strong>，所以这样实现的功能与使用notify()函数是相同的，优点是可以同时处理多个事件。</li>
<li>重新实现<strong>event()<strong>函数，可以在事件到达默认的事件处理函数</strong>之前</strong>获得该事件。</li>
<li>在对象上安装事件过滤器。以在一个界面类中<strong>同时处理</strong>不同子部件的不同事件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────────────────────────────────┐</span><br><span class="line">│                系统原生事件队列                          │</span><br><span class="line">└───────────────┬───────────────────────────────────────┘</span><br><span class="line">                │ 转换为QEvent对象</span><br><span class="line">                ▼</span><br><span class="line">┌───────────────────────────────────────────────────────┐</span><br><span class="line">│                Qt主事件循环 (QCoreApplication::exec())  │</span><br><span class="line">└───────────────┬───────────────────────────────────────┘</span><br><span class="line">                │ 分发事件到目标QObject</span><br><span class="line">                ▼</span><br><span class="line">┌───────────────────────────────────────────────────────┐</span><br><span class="line">│                  全局事件处理层                          │</span><br><span class="line">├───────────────────┬───────────────────────────────────┤</span><br><span class="line">│ 方法2: notify()   │ 方法3: QApplication事件过滤器         │</span><br><span class="line">│ • 完全控制事件分发 │ • 拦截所有对象的事件                    │</span><br><span class="line">│ • 每次处理一个事件 │ • 可同时处理多个事件                    │</span><br><span class="line">└─────────┬─────────┴───────────┬───────────────────────┘</span><br><span class="line">          │                     │</span><br><span class="line">          │                     │</span><br><span class="line">          ▼                     ▼</span><br><span class="line">┌───────────────────────────────────────────────────────┐</span><br><span class="line">│                 对象级事件处理层                         │</span><br><span class="line">├───────────────────┬───────────────────────────────────┤</span><br><span class="line">│ 方法4: event()     │ 方法5: 对象事件过滤器                │</span><br><span class="line">│ • 重写事件分发逻辑 │ • 监听特定对象的事件                   │</span><br><span class="line">│ • 可拦截所有事件   │ • 例如监控子控件的鼠标事件              │</span><br><span class="line">└─────────┬─────────┴───────────┬───────────────────────┘</span><br><span class="line">          │                     │</span><br><span class="line">          ▼                     ▼</span><br><span class="line">┌───────────────────────────────────────────────────────┐</span><br><span class="line">│                特定事件处理层                           │</span><br><span class="line">│ 方法1: 重写事件处理器                                    │</span><br><span class="line">│ • paintEvent()   • mousePressEvent()                  │</span><br><span class="line">│ • keyPressEvent() • resizeEvent() 等                  │</span><br><span class="line">└───────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="事件的传递"><a href="#事件的传递" class="headerlink" title="事件的传递"></a>事件的传递</h4><p>每个程序**main()<strong>函数的最后都会调用</strong>QApplication类的exec()**函数，它会使Qt应用程序进入事件循环，这样就可以使应用程序在运行时接收发生的各种事件。</p>
<p>一旦有事件发生，Qt便会构建一个相应的QEvent子类的对象来表示它，然后将它传递给相应的QObject对象或其子对象。</p>
<p><strong>事件的传递顺序</strong>：</p>
<p>先是<strong>事件过滤器</strong>，然后是焦点部件的<strong>event()<strong>函数，最后是焦点部件的</strong>事件处理函数</strong>，如果焦点部件忽略了该事件，那么会执行父部件的事件处理函数。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250708091624766.png" alt="image-20250708091624766"></p>
<h5 id="示例一：-1"><a href="#示例一：-1" class="headerlink" title="示例一："></a><strong>示例一：</strong></h5><ul>
<li><p>新建 <strong>Widget</strong> 项目myevent，再添加C++ Class 文件：MyLineEdit，基类为QLineEdit。</p>
</li>
<li><p>首先在<strong>mylineedit.h</strong>文件中添加函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//完整</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYLINEEDIT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYLINEEDIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLineEdit</span> : <span class="keyword">public</span> QLineEdit</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyLineEdit</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYLINEEDIT_H</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面转到<strong>mylineedit.cpp</strong>文件中，添加事件处理函数的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLineEdit::keyPressEvent</span><span class="params">(QKeyEvent *event)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;MyLineEdit键盘按下事件&quot;</span>);</span><br><span class="line">    QLineEdit::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line">    event-&gt;<span class="built_in">ignore</span>();   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完整</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylineedit.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QKeyEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QLineEdit&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyLineEdit::<span class="built_in">MyLineEdit</span>(QWidget *parent)</span><br><span class="line">    : QLineEdit&#123;parent&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLineEdit::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;MyLineEdit键盘按下事件&quot;</span>;  <span class="comment">// 移除非必要的 tr()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用基类处理</span></span><br><span class="line">    QLineEdit::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记事件为未处理</span></span><br><span class="line">    event-&gt;<span class="built_in">ignore</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<strong>widget.h</strong>文件中，添加函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//完整</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>;</span><br><span class="line">&#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<strong>widget.cpp</strong>文件中，添加事件处理函数的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;Widget键盘按下事件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完整</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;Widget键盘按下事件&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行，按键盘</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250708111107945.png" alt="image-20250708111107945"></p>
</li>
<li><p>详解：</p>
<p>事件是先传递给指定窗口部件的，这里确切的说应该是先传递给获得焦点的窗口部件。</p>
<p>但是如果该部件忽略掉该事件，那么这个事件就会传递给这个部件的父部件。</p>
<p>重新实现事件处理函数时，一般要调用父类的相应事件处理函数来实现默认操作。</p>
</li>
</ul>
<h5 id="示例二：-1"><a href="#示例二：-1" class="headerlink" title="示例二："></a><strong>示例二：</strong></h5><ul>
<li><p>在mylineedit.h文件中添加public函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent *event)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在mylineedit.cpp文件中对该函数进行定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyLineEdit::event</span><span class="params">(QEvent *event)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;MyLineEdit的event()函数&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> QLineEdit::<span class="built_in">event</span>(event);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入widget.h文件中声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLineEdit *lineEdit;  <span class="comment">// 声明lineEdit变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后到widget.cpp文件中，在构造函数添加代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并初始化lineEdit</span></span><br><span class="line">   lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">   lineEdit-&gt;<span class="built_in">setGeometry</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">30</span>);  <span class="comment">// 设置位置和大小</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 安装事件过滤器</span></span><br><span class="line">   lineEdit-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后添加事件过滤器函数的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Widget::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj == lineEdit)&#123;              </span><br><span class="line">        <span class="keyword">if</span>(event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress)</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">tr</span>(<span class="string">&quot;Widget的事件过滤器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250708112358156.png" alt="image-20250708112358156"></p>
</li>
<li><p>详解：</p>
<p>MyLineEdit的event()函数中使用了QEvent的type()函数来获取事件的类型，如果是键盘按下事件QEvent::KeyPress，则输出信息。</p>
<p>因为event()函数具有bool型的返回值，所以该函数的最后要使用return语句，这里一般是返回父类的event()函数的操作结果。<br>在事件过滤器中，先判断该事件的对象是不是lineEdit，如果是，再判断事件类型。最后返回了QWidget类默认的事件过滤器的执行结果。</p>
</li>
</ul>
<hr>
<h4 id="鼠标事件、滚轮事件"><a href="#鼠标事件、滚轮事件" class="headerlink" title="鼠标事件、滚轮事件"></a>鼠标事件、滚轮事件</h4><p>QMouseEvent类用来表示一个鼠标事件，在窗口部件中按下鼠标或者移动鼠标指针时，都会产生鼠标事件。</p>
<p>利用QMouseEvent类可以获知鼠标是哪个键按下了、鼠标指针的当前位置等信息。一般是通过重定义部件的鼠标事件处理函数来进行一些自定义的操作。</p>
<p>QWheelEvent类用来表示鼠标滚轮事件，在这个类中主要是获取滚轮移动的方向和距离。</p>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><ul>
<li><p>在Qt Designer中添加一个 QTextEdit 控件</p>
</li>
<li><p>设置对象名(objectName)为 textEdit</p>
</li>
<li><p>创建目录结构：项目根目录&#x2F;mymouseevent&#x2F;</p>
</li>
<li><p>将自定义光标图片命名为 logo.png 并放入该目录</p>
<ul>
<li><p>可以在界面上按着鼠标左键来拖动窗口；</p>
</li>
<li><p>双击鼠标左键来使其全屏</p>
</li>
<li><p>按着鼠标右键则使指针变为一个自定义的图片</p>
</li>
<li><p>而使用滚轮可以放大或者缩小编辑器中的内容</p>
</li>
</ul>
</li>
<li><p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;	<span class="comment">//构造参数</span></span><br><span class="line">    <span class="comment">// 设置窗口属性</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;鼠标事件示例&quot;</span>);</span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span>  <span class="comment">// 鼠标按下事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;        <span class="comment">// 如果是鼠标左键按下</span></span><br><span class="line">        QCursor cursor;</span><br><span class="line">        cursor.<span class="built_in">setShape</span>(Qt::ClosedHandCursor);</span><br><span class="line">        QApplication::<span class="built_in">setOverrideCursor</span>(cursor);  <span class="comment">// 使鼠标指针暂时改变形状</span></span><br><span class="line">        offset = event-&gt;<span class="built_in">globalPosition</span>() - <span class="built_in">pos</span>(); <span class="comment">// 获取指针位置和窗口位置的差值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::RightButton)&#123;  <span class="comment">// 如果是鼠标右键按下</span></span><br><span class="line">        QCursor <span class="built_in">cursor</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;../mymouseevent/logo.png&quot;</span>));</span><br><span class="line">        QApplication::<span class="built_in">setOverrideCursor</span>(cursor);  <span class="comment">// 使用自定义的图片作为鼠标指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;             </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span>   <span class="comment">// 鼠标移动事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)&#123;        <span class="comment">// 这里必须使用buttons()</span></span><br><span class="line">        QPointF temp;</span><br><span class="line">        temp = event-&gt;<span class="built_in">globalPosition</span>() - offset;</span><br><span class="line">	<span class="comment">// 使用鼠标指针当前的位置减去差值，就得到了窗口应该移动的位置</span></span><br><span class="line">        <span class="built_in">move</span>(temp.<span class="built_in">x</span>(), temp.<span class="built_in">y</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span>   <span class="comment">// 鼠标释放事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line">    QApplication::<span class="built_in">restoreOverrideCursor</span>();           <span class="comment">// 恢复鼠标指针形状</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span>   <span class="comment">// 鼠标双击事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;                <span class="comment">// 如果是鼠标左键按下</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">windowState</span>() != Qt::WindowFullScreen)         <span class="comment">// 如果现在不是全屏</span></span><br><span class="line">            <span class="built_in">setWindowState</span>(Qt::WindowFullScreen);         <span class="comment">// 将窗口设置为全屏</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">setWindowState</span>(Qt::WindowNoState);           <span class="comment">// 否则恢复以前的大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;                             </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::wheelEvent</span><span class="params">(QWheelEvent *event)</span>      <span class="comment">// 滚轮事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">angleDelta</span>().<span class="built_in">y</span>() &gt; <span class="number">0</span>)&#123;             <span class="comment">// 当滚轮远离使用者时</span></span><br><span class="line">        ui-&gt;textEdit-&gt;<span class="built_in">zoomIn</span>();                  <span class="comment">// 进行放大</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                                       <span class="comment">// 当滚轮向使用者方向旋转时</span></span><br><span class="line">        ui-&gt;textEdit-&gt;<span class="built_in">zoomOut</span>();                 <span class="comment">// 进行缩小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;                           </span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWheelEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCursor&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;   <span class="comment">// 添加鼠标移动事件声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>; <span class="comment">// 添加鼠标释放事件声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wheelEvent</span><span class="params">(QWheelEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPointF offset; <span class="comment">// 存储鼠标位置与窗口位置的差值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>在滚轮事件处理函数中，使用QWheelEvent类的angleDelta().y()函数获取了垂直滚轮移动的距离，每当滚轮旋转一下，默认是15度，这时delta()函数就会返回15*8即整数120。当滚轮向远离使用者的方向旋转时，返回正值；当向靠近使用者的方向旋转时，返回负值。</p>
<hr>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>QKeyEvent类用来描述一个键盘事件。</p>
<p>当键盘按键被按下或者被释放时，键盘事件便会被发送给拥有键盘输入焦点的部件。</p>
<p>QKeyEvent的key()函数可以获取具体的按键，对于Qt中给定的所有按键，可以在帮助中通过Qt::Key关键字查看。</p>
<p>注意，回车键是Qt::Key_Return；键盘上的一些修饰键，比如Ctrl和Shift等，需要使用QKeyEvent的modifiers()函数来获取。</p>
<h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><p>按下<strong>Ctrl+M</strong>最大化</p>
<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QKeyEvent&gt;</span>       <span class="comment">// 包含键盘事件头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span>          <span class="comment">// 包含调试输出头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span>        <span class="comment">// 键盘按下事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">modifiers</span>() == Qt::ControlModifier)&#123;  <span class="comment">// 是否按下Ctrl键</span></span><br><span class="line">        <span class="keyword">if</span>(event-&gt;<span class="built_in">key</span>() == Qt::Key_M)               <span class="comment">// 是否按下M键</span></span><br><span class="line">            <span class="built_in">setWindowState</span>(Qt::WindowMaximized);    <span class="comment">// 窗口最大化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> QWidget::<span class="built_in">keyPressEvent</span>(event);</span><br><span class="line">&#125;                      </span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QKeyEvent&gt;</span>  <span class="comment">// 包含键盘事件头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent *event)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="定时器事件与随机数"><a href="#定时器事件与随机数" class="headerlink" title="定时器事件与随机数"></a>定时器事件与随机数</h4><p>QTimerEvent类用来描述一个定时器事件。</p>
<p>对于一个QObject的子类，只需要使用<code>int QObject::startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer)</code>函数就可以开启一个定时器，函数的第一个参数interval用来设置触发定时器事件的间隔，单位是毫秒，第二个参数用来设置精度。</p>
<p>该函数返回一个整型编号来代表这个定时器，可以使用QObject::killTimer(int id)来关闭指定的定时器。</p>
<p>当定时器溢出时可以在timerEvent()函数中进行需要的操作。</p>
<h5 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5><p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimerEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTime&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="comment">// 启动三个定时器</span></span><br><span class="line">    id1 = <span class="built_in">startTimer</span>(<span class="number">1000</span>);   <span class="comment">// 1秒定时器</span></span><br><span class="line">    id2 = <span class="built_in">startTimer</span>(<span class="number">2000</span>);   <span class="comment">// 2秒定时器</span></span><br><span class="line">    id3 = <span class="built_in">startTimer</span>(<span class="number">5000</span>);   <span class="comment">// 5秒定时器</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;定时器已启动:&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;Timer1 ID:&quot;</span> &lt;&lt; id1</span><br><span class="line">             &lt;&lt; <span class="string">&quot;Timer2 ID:&quot;</span> &lt;&lt; id2</span><br><span class="line">             &lt;&lt; <span class="string">&quot;Timer3 ID:&quot;</span> &lt;&lt; id3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 停止所有定时器</span></span><br><span class="line">    <span class="built_in">killTimer</span>(id1);</span><br><span class="line">    <span class="built_in">killTimer</span>(id2);</span><br><span class="line">    <span class="built_in">killTimer</span>(id3);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;所有定时器已停止&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::timerEvent</span><span class="params">(QTimerEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    QTime currentTime = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line">    QString timeStr = currentTime.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">timerId</span>() == id1) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; timeStr &lt;&lt; <span class="string">&quot;| Timer1 触发&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;<span class="built_in">timerId</span>() == id2) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; timeStr &lt;&lt; <span class="string">&quot;| Timer2 触发&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event-&gt;<span class="built_in">timerId</span>() == id3) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; timeStr &lt;&lt; <span class="string">&quot;| Timer3 触发&quot;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; timeStr &lt;&lt; <span class="string">&quot;| 未知定时器 ID:&quot;</span> &lt;&lt; event-&gt;<span class="built_in">timerId</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimerEvent&gt;</span>  <span class="comment">// 包含定时器事件头文件</span></span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timerEvent</span><span class="params">(QTimerEvent *event)</span> <span class="keyword">override</span></span>;  <span class="comment">// 定时器事件处理函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id1;  <span class="comment">// 定时器1 ID</span></span><br><span class="line">    <span class="type">int</span> id2;  <span class="comment">// 定时器2 ID</span></span><br><span class="line">    <span class="type">int</span> id3;  <span class="comment">// 定时器3 ID</span></span><br></pre></td></tr></table></figure>

<p><strong>使用QTimer类</strong>来实现一个定时器，它提供了更高层次的编程接口，比如可以使用信号和槽，还可以设置只运行一次的定时器。</p>
<p>在Qt Designer中添加一个 QLCDNumber 控件</p>
<p>设置对象名(objectName)为 lcdNumber</p>
<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span>      <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTime&gt;</span>       <span class="comment">// 时间</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">// 创建并启动定时器</span></span><br><span class="line">    QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;Widget::updateTime);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);  <span class="comment">// 每秒触发一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始更新时间</span></span><br><span class="line">    <span class="built_in">updateTime</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::updateTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    QTime currentTime = QTime::<span class="built_in">currentTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化时间（小时:分钟）</span></span><br><span class="line">    QString timeText = currentTime.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每秒切换冒号显示状态（实现闪烁效果）</span></span><br><span class="line">    <span class="keyword">if</span> (currentTime.<span class="built_in">second</span>() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        timeText[<span class="number">2</span>] = <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 将冒号位置替换为空格</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在LCD上显示时间</span></span><br><span class="line">    ui-&gt;lcdNumber-&gt;<span class="built_in">display</span>(timeText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span>  <span class="comment">// 仅包含必要的定时器头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateTime</span><span class="params">()</span></span>;  <span class="comment">// 时间更新槽函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Qt中是使用QRandomGenerator类实现随机数的，它可以从一个高质量的随机数生成器来生成随机的数值。</li>
<li>使用时，可以在创建QRandomGenerator对象时直接给定一个数值作为种子来生成一组相同的随机数，给定不同的种子，那么生成的随机数序列也是不同的，也可以使用seed()来设置种子。</li>
<li>可以使用bounded()函数来设置生成随机数的范围，它有多种重载形式，例如bounded(256)可以生成 [0, 256)（包含0但不包含256）之间的一个随机整数。</li>
<li>可以使用QRandomGenerator::global()来获取一个QRandomGenerator的全局实例，它是线程安全的，并且使用了QRandomGenerator::system()进行播种，可以保证生成序列的随机性。</li>
</ul>
<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述代码的基础上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::updateTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">// 在LCD上显示时间</span></span><br><span class="line">    ui-&gt;lcdNumber-&gt;<span class="built_in">display</span>(timeText);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机颜色</span></span><br><span class="line">    <span class="type">int</span> red = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="type">int</span> green = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="type">int</span> blue = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试输出随机颜色值</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;随机颜色值:&quot;</span> &lt;&lt; red &lt;&lt; green &lt;&lt; blue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建随机颜色</span></span><br><span class="line">    <span class="function">QColor <span class="title">randomColor</span><span class="params">(red, green, blue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取LCD的调色板</span></span><br><span class="line">    QPalette palette = ui-&gt;lcdNumber-&gt;<span class="built_in">palette</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文字颜色为随机颜色</span></span><br><span class="line">    palette.<span class="built_in">setColor</span>(QPalette::WindowText, randomColor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用新调色板</span></span><br><span class="line">    ui-&gt;lcdNumber-&gt;<span class="built_in">setPalette</span>(palette);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述代码的基础上</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColor&gt;</span>  <span class="comment">// 添加颜色支持</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span>  <span class="comment">// 添加随机数生成器</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="拖放操作"><a href="#拖放操作" class="headerlink" title="拖放操作"></a>拖放操作</h4><p>Qt提供了强大的拖放机制。拖放操作分为拖动（Drag）和放下（Drop）两种操作，当数据被拖动时会被存储为MIME  (Multipurpose Internet Mail Extensions)类型，在Qt中使用QMimeData类来表示MIME类型的数据，并使用QDrag类来完成数据的转移，而整个拖放操作都是在几个鼠标事件和拖放事件中完成的。</p>
<ul>
<li>当鼠标拖拽一个数据进入主窗口时，就会触发dragEnterEvent()事件处理函数，获取其中的MIME数据，比如查看它是否包含URL路径。</li>
<li>如果有这样的数据，就接收它，否则忽略该事件。QMimeData类中提供了几个函数来处理常见的MIME数据。</li>
<li>当松开鼠标左键，将数据放入主窗口时就会触发dropEvent()事件处理函数，比如获取MIME数据中的URL列表。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250708122745555.png" alt="image-20250708122745555"></p>
<h5 id="示例一：-2"><a href="#示例一：-2" class="headerlink" title="示例一："></a>示例一：</h5><p>将桌面上的.txt文本文件拖入程序打开。</p>
<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMimeData&gt;</span>       <span class="comment">// MIME数据处理</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDragEnterEvent&gt;</span> <span class="comment">// 拖动进入事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDropEvent&gt;</span>      <span class="comment">// 放下事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span>          <span class="comment">// 调试输出</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造参数</span></span><br><span class="line">    <span class="comment">// 启用拖放功能</span></span><br><span class="line">    <span class="built_in">setAcceptDrops</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拖动进入事件处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::dragEnterEvent</span><span class="params">(QDragEnterEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查拖动的数据是否包含文件路径</span></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">mimeData</span>()-&gt;<span class="built_in">hasUrls</span>()) &#123;</span><br><span class="line">        event-&gt;<span class="built_in">acceptProposedAction</span>();  <span class="comment">// 接受拖动操作</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;文件拖动进入窗口&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event-&gt;<span class="built_in">ignore</span>();  <span class="comment">// 忽略不支持的类型</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;不支持的数据类型&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放下事件处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::dropEvent</span><span class="params">(QDropEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取拖放的文件路径</span></span><br><span class="line">    <span class="type">const</span> QList&lt;QUrl&gt; urls = event-&gt;<span class="built_in">mimeData</span>()-&gt;<span class="built_in">urls</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理每个文件路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> QUrl &amp;url : urls) &#123;</span><br><span class="line">        QString filePath = url.<span class="built_in">toLocalFile</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;拖放的文件路径:&quot;</span> &lt;&lt; filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受拖放操作</span></span><br><span class="line">    event-&gt;<span class="built_in">acceptProposedAction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dragEnterEvent</span><span class="params">(QDragEnterEvent *event)</span> <span class="keyword">override</span></span>;  <span class="comment">// 拖动进入事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dropEvent</span><span class="params">(QDropEvent *event)</span> <span class="keyword">override</span></span>;            <span class="comment">// 放下事件</span></span><br></pre></td></tr></table></figure>

<p>**运行：**将文件拉到运行窗口。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250708123349347.png" alt="image-20250708123349347"></p>
<p>完善代码：</p>
<p>在设计模式中拉入一个<strong>TextEdit</strong>部件</p>
<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span>           <span class="comment">// 文件操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextStream&gt;</span>     <span class="comment">// 文本流</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QUrl&gt;</span>            <span class="comment">// URL处理</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span>  <span class="comment">// 包含文本编辑控件</span></span></span><br><span class="line"><span class="comment">// 放下事件处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::dropEvent</span><span class="params">(QDropEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取MIME数据</span></span><br><span class="line">    <span class="type">const</span> QMimeData *mimeData = event-&gt;<span class="built_in">mimeData</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否包含URL（文件路径）</span></span><br><span class="line">    <span class="keyword">if</span>(mimeData-&gt;<span class="built_in">hasUrls</span>()) &#123;</span><br><span class="line">        <span class="comment">// 获取URL列表</span></span><br><span class="line">        QList&lt;QUrl&gt; urlList = mimeData-&gt;<span class="built_in">urls</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取第一个文件的本地路径</span></span><br><span class="line">        QString fileName = urlList.<span class="built_in">first</span>().<span class="built_in">toLocalFile</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查文件名是否有效</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="function">QFile <span class="title">file</span><span class="params">(fileName)</span></span>;  <span class="comment">// 创建文件对象</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试以只读方式打开文件</span></span><br><span class="line">            <span class="keyword">if</span>(file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">                <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;  <span class="comment">// 创建文本流</span></span><br><span class="line">                ui-&gt;textEdit-&gt;<span class="built_in">setText</span>(in.<span class="built_in">readAll</span>());  <span class="comment">// 读取全部内容并显示</span></span><br><span class="line">                file.<span class="built_in">close</span>();  <span class="comment">// 关闭文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 输出成功信息</span></span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;成功打开文件:&quot;</span> &lt;&lt; fileName;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 输出错误信息</span></span><br><span class="line">                <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;无法打开文件:&quot;</span> &lt;&lt; fileName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接受拖放操作</span></span><br><span class="line">    event-&gt;<span class="built_in">acceptProposedAction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="示例二：-2"><a href="#示例二：-2" class="headerlink" title="示例二："></a>示例二：</h5><p>编写一个在窗口中拖动图片的例子，实现的功能是：在窗口中有一个图片，可以随意拖动它。整个过程是在mousePressEvent()、dragEnterEvent()、dragMoveEvent()和dropEvent()等几个事件处理函数中完成的。</p>
<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMouseEvent&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建圆形图片</span></span><br><span class="line">    m_pixmap = <span class="built_in">QPixmap</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    m_pixmap.<span class="built_in">fill</span>(Qt::transparent);</span><br><span class="line"></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(&amp;m_pixmap)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(Qt::blue);</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::white);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(m_pixmap.<span class="built_in">rect</span>(), Qt::AlignCenter, <span class="string">&quot;拖我&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始位置在窗口中心</span></span><br><span class="line">    m_dragPosition = <span class="built_in">QPoint</span>(<span class="built_in">width</span>()/<span class="number">2</span> - <span class="number">50</span>, <span class="built_in">height</span>()/<span class="number">2</span> - <span class="number">50</span>);</span><br><span class="line">    m_isDragging = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 窗口设置</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;简单图片拖动示例&quot;</span>);</span><br><span class="line">    <span class="built_in">setMinimumSize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 计算点击位置相对于图片的位置</span></span><br><span class="line">    QPoint clickPos = event-&gt;<span class="built_in">pos</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否点击在图片区域内</span></span><br><span class="line">    <span class="keyword">if</span> (clickPos.<span class="built_in">x</span>() &gt;= m_dragPosition.<span class="built_in">x</span>() &amp;&amp;</span><br><span class="line">        clickPos.<span class="built_in">x</span>() &lt;= m_dragPosition.<span class="built_in">x</span>() + m_pixmap.<span class="built_in">width</span>() &amp;&amp;</span><br><span class="line">        clickPos.<span class="built_in">y</span>() &gt;= m_dragPosition.<span class="built_in">y</span>() &amp;&amp;</span><br><span class="line">        clickPos.<span class="built_in">y</span>() &lt;= m_dragPosition.<span class="built_in">y</span>() + m_pixmap.<span class="built_in">height</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        m_isDragging = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">update</span>(); <span class="comment">// 重绘窗口</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;开始拖动图片&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_isDragging) &#123;</span><br><span class="line">        <span class="comment">// 更新图片位置（中心点跟随鼠标）</span></span><br><span class="line">        m_dragPosition = event-&gt;<span class="built_in">pos</span>() - <span class="built_in">QPoint</span>(m_pixmap.<span class="built_in">width</span>()/<span class="number">2</span>, m_pixmap.<span class="built_in">height</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">update</span>(); <span class="comment">// 重绘窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);</span><br><span class="line"></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制背景</span></span><br><span class="line">    painter.<span class="built_in">fillRect</span>(<span class="built_in">rect</span>(), Qt::lightGray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制图片</span></span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(m_dragPosition, m_pixmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制说明文字</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::black);</span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&quot;点击并拖动蓝色圆形&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制拖动状态边框</span></span><br><span class="line">    <span class="keyword">if</span> (m_isDragging) &#123;</span><br><span class="line">        painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::red, <span class="number">2</span>, Qt::DashLine));</span><br><span class="line">        painter.<span class="built_in">drawRect</span>(m_dragPosition.<span class="built_in">x</span>(), m_dragPosition.<span class="built_in">y</span>(),</span><br><span class="line">                         m_pixmap.<span class="built_in">width</span>(), m_pixmap.<span class="built_in">height</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPixmap&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_pixmap;       <span class="comment">// 存储图片</span></span><br><span class="line">    QPoint m_dragPosition;  <span class="comment">// 图片位置</span></span><br><span class="line">    <span class="type">bool</span> m_isDragging;      <span class="comment">// 是否正在拖动</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Qt-Quick-事件"><a href="#Qt-Quick-事件" class="headerlink" title="Qt Quick 事件"></a>Qt Quick 事件</h3><p>Quick程序更多的是实现触摸式用户界面，所以对鼠标（在触屏设备上可能是手指）的处理更常见。</p>
<h4 id="MouseArea"><a href="#MouseArea" class="headerlink" title="MouseArea"></a>MouseArea</h4><p>在QML编码中，<strong>如果想要一个项目可以交互，一般会在该项目上放置一个MouseArea对象。</strong></p>
<p>MouseArea是一个不可见的项目，通常用来和一个可见的项目配合使用，为可视项目提供鼠标处理。</p>
<p>鼠标处理的逻辑完全包含在这个MouseArea项目中。</p>
<ul>
<li><p><strong>MouseArea的enabled属性可以用来设置是否启用鼠标处理，默认为true。</strong></p>
</li>
<li><p><strong>只读的pressed属性表明用户是否在MouseArea上按住了鼠标按钮，这个属性经常用于属性绑定，可以实现在鼠标按下时执行一些操作。</strong></p>
</li>
<li><p><strong>只读的containsMouse属性表明当前鼠标光标是否在MouseArea上，默认只有鼠标的一个按钮处于按下状态时才可以被检测到。</strong></p>
</li>
<li><p><strong>默认情况下，MouseArea项目只报告鼠标单击而不报告鼠标光标的位置改变，这可以通过设置hoverEnabled属性为true来进行更改。<strong>这样设置之后，<strong>onPositionChanged()、onEntered()和onExited()等处理函数才可以使用</strong>，而且这时</strong>containsMouse属性</strong>也可以在没有鼠标按钮按下的情况下检查光标。</p>
</li>
</ul>
<p>对于鼠标位置和按钮单击等信息是通过信号提供的，可以使用事件处理器来获取这些信息。</p>
<p><strong>常用的有onClicked()、onDoubleClicked()、onPressed()、onReleased()和onPressAndHold()等，使用onWheel()则可以处理滚轮事件。</strong></p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: <span class="number">100</span>; height: <span class="number">100</span>; color: <span class="string">&quot;green&quot;</span></span><br><span class="line"></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123; parent.color = <span class="string">&#x27;red&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                  </span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用<strong>anchors.fill: parent</strong>来使MouseArea充满整个Rectangle区域，这个在实际编程中经常用到。因为只有在MouseArea上单击才能进行处理，现在MouseArea覆盖了整个Rectangle，所以在Rectangle的任何位置单击鼠标都有效果。</li>
<li>当MouseArea与其他MouseArea项目重叠时，可以设置<strong>propagateComposedEvents</strong>属性为true来传播clicked、doubleClicked和pressAndHold等事件。但是只有在MouseArea没有接受这些事件的时候，它们才可以继续向下传播。也就是说，当事件已经在一个MouseArea中进行处理，则需要在其事件处理器中设置<strong>MouseEvent.accepted</strong>为false，这样该事件才能继续传播。</li>
</ul>
<hr>
<h4 id="MouseEvent和WheelEvent"><a href="#MouseEvent和WheelEvent" class="headerlink" title="MouseEvent和WheelEvent"></a>MouseEvent和WheelEvent</h4><p>鼠标事件MouseEvent和滚轮事件WheelEvent</p>
<p>大多数MouseArea的信号都包含了一个mouse参数，它是MouseEvent类型的。</p>
<p>在MouseEvent对象中，</p>
<ul>
<li><p>可以设置accepted属性为true来防止鼠标事件传播到下层的项目；</p>
</li>
<li><p>通过x和y属性获取鼠标的位置；</p>
</li>
<li><p>通过button或buttons属性可以获取按下的按键；</p>
<ul>
<li>button可取的值有Qt.LeftButton左键、Qt.RightButton右键和Qt.MiddleButton中键；</li>
</ul>
</li>
<li><p>通过modifiers属性可以获取按下的键盘修饰符等。</p>
<ul>
<li>modifiers的值由多个按键进行位组合而成，在使用时需要将modifiers与这些特殊的按键进行按位与来判断按键。</li>
</ul>
</li>
</ul>
<p>常用的按键有：</p>
<ul>
<li>Qt.NoModifier：没有修饰键被按下；</li>
<li>Qt.ShiftModifier：Shift键被按下；</li>
<li>Qt.ControlModifier：Ctrl键被按下；</li>
<li>Qt.AltModifier：Alt键被按下；</li>
<li>Qt.MetaModifier：Meta键被按下；</li>
<li>Qt.KeypadModifier：一个小键盘按钮被按下。</li>
</ul>
<h5 id="示例一：-3"><a href="#示例一：-3" class="headerlink" title="示例一："></a>示例一：</h5><p>右击鼠标矩形变为蓝色，单击变为红色，当按下键盘Shift键的同时双击鼠标，变为绿色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: <span class="number">100</span>; height: <span class="number">100</span>; color: <span class="string">&quot;green&quot;</span></span><br><span class="line"></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        acceptedButtons: Qt.LeftButton | Qt.RightButton</span><br><span class="line">        onClicked: (mouse)=&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (mouse.button === Qt.RightButton)</span><br><span class="line">                parent.color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                parent.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        onDoubleClicked: (mouse)=&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mouse.button === Qt.LeftButton)</span><br><span class="line">                    &amp;&amp; (mouse.modifiers &amp; Qt.ShiftModifier))</span><br><span class="line">                parent.color = <span class="string">&quot;green&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                 </span><br></pre></td></tr></table></figure>

<hr>
<p>还可以使用WheelEvent获取鼠标滚轮事件。MouseArea的onWheel处理器有一个wheel参数，就是WheelEvent类型的。</p>
<p>WheelEvent最重要的一个属性是angleDelta，可以用来获取滚轮滚动的距离，它的x和y坐标分别保存了水平和垂直方向的增量。</p>
<p>滚轮向上或向右滚动返回正直，向下或向左滚动返回负值。</p>
<p>对于大多数鼠标，每当滚轮旋转一下，默认是15°，此时angleDelta的值就是15x8，即整数120。</p>
<h5 id="示例二：-3"><a href="#示例二：-3" class="headerlink" title="示例二："></a>示例二：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: <span class="number">360</span>; height: <span class="number">360</span></span><br><span class="line">    Text &#123; id:myText; anchors.centerIn: parent; text: <span class="string">&quot;Qt&quot;</span> &#125;</span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onWheel: (wheel)=&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (wheel.modifiers &amp; Qt.ControlModifier) &#123;<span class="comment">// 检查是否按住Ctrl键</span></span><br><span class="line">                <span class="keyword">if</span> (wheel.angleDelta.y &gt; <span class="number">0</span>)<span class="comment">// 滚轮向上滚动（放大）</span></span><br><span class="line">                    myText.font.pointSize += <span class="number">1</span><span class="comment">// 字体大小+1</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    myText.font.pointSize -= <span class="number">1</span><span class="comment">// 字体大小-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                </span><br></pre></td></tr></table></figure>

<hr>
<h4 id="DragEvent"><a href="#DragEvent" class="headerlink" title="DragEvent"></a>DragEvent</h4><p>拖放事件DragEvent</p>
<p>MouseArea中的<strong>drag</strong>属性组：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250709091425248.png" alt="image-20250709091425248"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    id: container; width: <span class="number">600</span>; height: <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        id: rect; width: <span class="number">50</span>; height: <span class="number">50</span></span><br><span class="line">        color: <span class="string">&quot;red&quot;</span>; opacity: (<span class="number">600.0</span> - rect.x) / <span class="number">600</span></span><br><span class="line"></span><br><span class="line">        MouseArea &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            drag.target: rect; drag.axis: Drag.XAxis</span><br><span class="line">            drag.minimumX: <span class="number">0</span></span><br><span class="line">            drag.maximumX: container.width - rect.width</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                </span><br></pre></td></tr></table></figure>

<hr>
<p>要实现更复杂的拖放操作，比如想获取拖动项目的相关信息，那么就要使用<strong>DragEvent</strong>拖放事件了。</p>
<ul>
<li>在DragEvent中可以通过x和y属性获取拖动的位置；</li>
<li>使用keys属性获取可以识别数据类型或源的键列表；</li>
<li>通过hasColor、hasHtml、hasText和hasUrls属性来确定具体的拖动类型；</li>
<li>具体的类型数据可以使用colorData、html、text和urls属性获得；</li>
<li>formats属性可以获取拖动数据中包含的MIME类型格式的列表；</li>
<li>可以使用drag.source来获取拖动事件的源。</li>
</ul>
<p><strong>在实际编程中启动拖动并不是直接操作DragEvent，而是使用Drag附加属性和DropArea。</strong></p>
<p>任何项目都可以使用Drag来实现拖放。</p>
<p>当一个项目的Drag附加属性的<strong>active</strong>属性设置为true时，该项目的任何位置变化都会产生一个拖动事件，并发送给与项目新位置相交的DropArea。</p>
<p>其它实现了拖放事件处理器的项目也可以接收这些事件。</p>
<p>DropArea是一个不可见的项目。</p>
<p>当其它项目拖动到其上时，它可以接收相关的事件。</p>
<ul>
<li>通过drag.x和drag.y获取最后一个拖放事件的坐标；</li>
<li>使用drag.source获取拖放的源对象；</li>
<li>通过keys获取拖放的键列表。</li>
</ul>
<p>当DropArea范围内有拖放进入时，会调用onEntered()处理器；</p>
<ul>
<li>当有drop事件发生时，会调用onDropped()处理器；</li>
<li>当拖放离开时，会调用onExited()处理器；</li>
<li>当拖放位置改变时，会调用onPositionChanged()处理器。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// MyRect.qml</span><br><span class="line">import QtQuick</span><br><span class="line"></span><br><span class="line">Rectangle &#123;</span><br><span class="line">    id: rect; width: 20; height: 20</span><br><span class="line"></span><br><span class="line">    Drag.active: dragArea.drag.active</span><br><span class="line">    Drag.hotSpot.x: 10; Drag.hotSpot.y: 10</span><br><span class="line">    Drag.source: rect</span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        id: dragArea</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        drag.target: parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                               </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// main.qml</span><br><span class="line">import QtQuick</span><br><span class="line"></span><br><span class="line">Item &#123;</span><br><span class="line">    width: 400; height: 150</span><br><span class="line"></span><br><span class="line">    DropArea &#123;</span><br><span class="line">        x: 175; y: 75; width: 50; height: 50</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            id: area; anchors.fill: parent</span><br><span class="line">            border.color: &quot;black&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        onEntered: &#123;</span><br><span class="line">            area.color = drag.source.color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyRect&#123;color: &quot;blue&quot;; x:110 &#125;</span><br><span class="line">    MyRect&#123;color: &quot;red&quot;; x:140 &#125;</span><br><span class="line">    MyRect&#123;color: &quot;yellow&quot;; x:170 &#125;</span><br><span class="line">    MyRect&#123;color: &quot;black&quot;; x:200 &#125;</span><br><span class="line">    MyRect&#123;color: &quot;steelblue&quot;; x:230 &#125;</span><br><span class="line">    MyRect&#123;color: &quot;green&quot;; x:260 &#125;</span><br><span class="line">&#125;                             </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250709092552178.png" alt="image-20250709092552178"></p>
<hr>
<h4 id="KeyEvent"><a href="#KeyEvent" class="headerlink" title="KeyEvent"></a>KeyEvent</h4><p>键盘事件KeyEvent</p>
<p>当一个键盘按键按下或者释放时，会产生一个键盘事件，并将其传递给具有焦点的Qt Quick项目（将一个项目的focus属性设置为true，这个项目便会获得焦点）。</p>
<p>为了方便创建可重用的组件和解决一些实现流畅用户界面的特有问题，Qt Quick在Qt传统的键盘焦点模型上添加了基于作用域的扩展。</p>
<p>当用户按下或者释放一个按键，会按以下步骤进行处理：</p>
<ul>
<li>Qt获取键盘动作并产生一个键盘事件。</li>
<li>如果Window是活动窗口，那么键盘事件会传递给它。</li>
<li>场景将键盘事件交付给具有活动焦点的项目。如果没有项目具有活动焦点，键盘事件会被忽略。</li>
<li>如果具有活动焦点的项目接受了该键盘事件，那么传播将停止。否则，该事件会传递到其父项目，直到事件被接受，或者到达根项目。</li>
<li>如果到达了根项目，该键盘事件会被忽略而继续常规的Qt按键处理。</li>
</ul>
<p>所有基于Item的可见项目都可以通过Keys附加属性来进行按键处理。Keys附加属性提供了基本的处理器，例如onPressed和onReleased，也提供了对特殊按键的处理器，例如onSpacePressed。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按下向左键</span></span><br><span class="line">Item &#123;</span><br><span class="line">    focus: <span class="literal">true</span></span><br><span class="line">    Keys.onPressed: (event)=&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.key === Qt.Key_Left) &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">&quot;move left&quot;</span>);</span><br><span class="line">            event.accepted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Keys.onReturnPressed: console.<span class="built_in">log</span>(<span class="string">&quot;Pressed return&quot;</span>);</span><br><span class="line">&#125;                              </span><br></pre></td></tr></table></figure>

<ul>
<li>event.accepted设置为true，可以防止事件继续传播。</li>
<li>event.key获取了按下的按键，另外还有accepted属性判断是否接受按键、isAutoRepeat属性判断是否是自动重复按键、modifiers属性获取修饰符等。</li>
</ul>
<hr>
<h4 id="Timer-和-Random"><a href="#Timer-和-Random" class="headerlink" title="Timer 和 Random"></a>Timer 和 Random</h4><p>定时器Timer和随机数</p>
<p>定时器用来使一个动作在指定的时间间隔触发一次或者多次，在QML中使用Timer类型来表示一个定时器。</p>
<p>例如：下面的代码中使用了一个定时器来显示当前的日期和时间，并每隔1000毫秒更新一次文本的显示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    Timer &#123;</span><br><span class="line">        interval: 1000; running: true; repeat: true</span><br><span class="line">        onTriggered: time.text = Date().toString()</span><br><span class="line">    &#125;</span><br><span class="line">    Text &#123; id: time &#125;</span><br><span class="line">&#125;                            </span><br></pre></td></tr></table></figure>

<ul>
<li>interval属性用来设置时间间隔，单位是毫秒，默认值是1000毫秒；</li>
<li>repeat属性用来设置是否重复触发，如果为false，则只触发一次并自动将running属性设置为false；</li>
<li>当running属性设置为true时将开启定时器，否则停止定时器，其默认值为false；</li>
<li>当定时器触发时会执行onTriggered()信号处理器，在这里可以定义需要进行的操作。</li>
</ul>
<p>Timer还提供了一系列函数，如restart()、start()、stop()等。</p>
<hr>
<p>在QML代码中可以通过Math.random()产生[0.0, 1.0)之间的随机数，如果想产生[x,y)之间的随机数，可以使用<code>Math.random()*(y-x)+x</code>，</p>
<p>例如产生[1,3)之间的随机数，就是<code>Math.random()*2+1</code>。将前面例子中定时器的定义代码更改如下，每次更新时间都使用了随机的文本颜色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">        width: 400; height: 100</span><br><span class="line"></span><br><span class="line">        Text &#123;</span><br><span class="line">            id: time</span><br><span class="line">            anchors.centerIn: parent</span><br><span class="line">            font.pixelSize: 24</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Timer &#123;</span><br><span class="line">            interval: 1000; running: true; repeat: true</span><br><span class="line">            onTriggered: &#123;</span><br><span class="line">                time.text = Date().toString()</span><br><span class="line">                time.color = Qt.rgba(Math.random(), Math.random(), Math.random(), 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="界面外观与国际化"><a href="#界面外观与国际化" class="headerlink" title="界面外观与国际化"></a>界面外观与国际化</h2><p>Qt Widgets中的QStyle、Qt样式表（Qt Style Sheets）</p>
<p>Qt Quick中的控件样式</p>
<h3 id="Qt-Widgets外观样式"><a href="#Qt-Widgets外观样式" class="headerlink" title="Qt Widgets外观样式"></a>Qt Widgets外观样式</h3><p>QStyle类是一个抽象基类，封装了一个GUI的外观样式，Qt的内建部件使用它来执行几乎所有的绘制工作。</p>
<p>Qt 包含一组QStyle的子类，可支持不同平台。</p>
<p>Qt 也可通过插件来提供样式。</p>
<p>QStyleFactory类可以创建一个QStyle对象，通过keys()函数获取可用的样式，然后使用create()函数创建一个QStyle对象。样式包括：Windows和Fusion</p>
<p>使用方法：</p>
<ul>
<li>设计模式</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250709095638251.png" alt="image-20250709095638251"></p>
<ul>
<li><p>代码模式</p>
<p>在main()函数的“QApplication a(argc, argv);”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">setStyle</span>(QStyleFactory::<span class="built_in">create</span>(<span class="string">&quot;fusion&quot;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>单独部件使用样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;progressBar-&gt;<span class="built_in">setStyle</span>(QStyleFactory::<span class="built_in">create</span>(<span class="string">&quot;windows&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用命令行运行程序时通过添加参数来指定，比如要使用Fusion样式，则可以使用“<strong><code>-style fusion</code></strong>”参数。</p>
</li>
</ul>
<hr>
<h3 id="Qt样式表简介"><a href="#Qt样式表简介" class="headerlink" title="Qt样式表简介"></a>Qt样式表简介</h3><p>Qt样式表是一个可以自定义部件外观的十分强大的机制，Qt样式表的概念、术语和语法都受到了HTML的层叠样式表（Cascading Style Sheets，CSS）的启发，不过与CSS不同的是，Qt样式表应用于部件的世界。</p>
<h4 id="使用代码设置样式表"><a href="#使用代码设置样式表" class="headerlink" title="使用代码设置样式表"></a>使用代码设置样式表</h4><ul>
<li><p>样式表可以使用<strong>QApplication::setStyleSheet()<strong>函数将其设置到</strong>整个应用程序</strong>上，</p>
</li>
<li><p>可以使用<strong>QWidget::setStyleSheet()<strong>函数将其设置到</strong>一个指定的部件</strong>（还有它的子部件）上。</p>
</li>
<li><p>如果在不同的级别都设置了样式表，那么<strong>Qt会使用所有有效的样式表</strong>，这被称为样式表的<strong>层叠</strong>。</p>
</li>
</ul>
<p>调用指定部件的**setStyleSheet()**函数对这个部件应用该样式表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;pushButton-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background:yellow&quot;</span>);</span><br><span class="line">ui-&gt;horizontalSlider-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background:blue&quot;</span>);</span><br><span class="line"><span class="comment">//完整代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSlider&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建主窗口和布局</span></span><br><span class="line">    QMainWindow window;</span><br><span class="line">    QWidget *centralWidget = <span class="keyword">new</span> <span class="built_in">QWidget</span>(&amp;window);</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(centralWidget);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建控件</span></span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button&quot;</span>);</span><br><span class="line">    QSlider *slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加控件到布局</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(slider);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置控件样式 - 方法1：单独设置</span></span><br><span class="line">    button-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background:yellow;&quot;</span>);</span><br><span class="line">    slider-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">&quot;background:blue;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置控件样式 - 方法2：统一设置</span></span><br><span class="line">    <span class="comment">// centralWidget-&gt;setStyleSheet(&quot;QPushButton&#123;background:yellow&#125; QSlider&#123;background:blue&#125;&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    window.<span class="built_in">setCentralWidget</span>(centralWidget);</span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250709101146870.png" alt="image-20250709101146870"></p>
<p>对所有相同部件都使用相同的样式表，那么可以在它们的父部件上设置样式表。</p>
<p>例如两个部件都在MainWindow上，所以可以为MainWindow设置样式表，以后向主窗口上添加的所有QPushButton部件和QSlider部件的背景色都会改为这里指定的颜色：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;background:yellow&#125;QSlider&#123;background:blue&#125;&quot;</span>);</span><br><span class="line"><span class="comment">//完整代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSlider&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主窗口</span></span><br><span class="line">    QWidget window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建控件</span></span><br><span class="line">    QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Button&quot;</span>);</span><br><span class="line">    QSlider *slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置布局</span></span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;window);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(slider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码：一次性设置所有控件的样式</span></span><br><span class="line">    window.<span class="built_in">setStyleSheet</span>(<span class="string">&quot;QPushButton&#123;background:yellow&#125; QSlider&#123;background:blue&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">150</span>);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="在设计模式中设置样式表"><a href="#在设计模式中设置样式表" class="headerlink" title="在设计模式中设置样式表"></a>在设计模式中设置样式表</h4><p><strong>在MainWindow界面上设置了样式表：</strong></p>
<p>进入设计模式</p>
<p>在界面上右击，在弹出的级联菜单中选择“<strong>改变样式表</strong>”，这时会出现编辑样式表对话框，在其中输入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250709101450746.png" alt="image-20250709101450746"></p>
<p>单击上面“添加颜色”选项后面的下拉箭头，在弹出的列表中选择background-color一项。这时会弹出选择颜色对话框，可以随便选择一个颜色，然后单击“确定”按钮，则自动添加代码：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250709101705047.png" alt="image-20250709101705047"></p>
<p><strong>也可以按照这种方法在指定的部件上添加样式表。</strong></p>
<hr>
<h4 id="Qt样式表语法"><a href="#Qt样式表语法" class="headerlink" title="Qt样式表语法"></a>Qt样式表语法</h4><p>Qt样式表的术语和语法规则与HTML CSS基本相同。</p>
<ul>
<li><p><strong>样式规则</strong></p>
<p>样式表包含了一系列的样式规则，每个样式规则由选择器（selector）和声明（declaration）组成。</p>
<ul>
<li><p>选择器指定了受该规则影响的部件；</p>
</li>
<li><p>声明指定了这个部件上要设置的属性。例如：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton&#123;color:red&#125;</span><br></pre></td></tr></table></figure>

<p>在这个样式规则中，QPushButton是选择器，{color:red}是声明。这个规则指定了QPushButton和它的子类应该使用红色作为前景色。</p>
<p><strong>Qt样式表中一般不区分大小写</strong>，只有类名、对象名和Qt属性名是区分大小写的。</p>
<p>一些选择器可以指定相同的声明，使用逗号隔开，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton,QLineEdit,QComboBox&#123;color:red&#125;</span><br></pre></td></tr></table></figure>

<p>样式规则的多个声明，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton&#123;color:red;background-color:white&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/stylesheet-reference.html">Qt Style Sheets Reference</a></p>
</li>
<li><p>选择器类型</p>
<p>Qt样式表支持在CSS2中定义的所有选择器，例如：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250709102304718.png" alt="image-20250709102304718"></p>
</li>
<li><p>子控件（Sub-Controls）</p>
<p>对一些复杂的部件修改样式，可能需要访问它们的子控件，例如QComboBox的下拉按钮，还有QSpinBox的向上和向下箭头等。</p>
<p>选择器可以包含子控件来对部件的特定子控件应用规则，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::drop-down&#123;image:url(dropdown.png)&#125;</span><br></pre></td></tr></table></figure>

<p>这样的规则可以改变所有的QComboBox部件的下拉按钮的样式。</p>
<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/stylesheet-reference.html#list-of-sub-controls">List of Sub-Controls中列出了所有可用的子控件。</a></p>
</li>
<li><p>伪状态（Pseudo-States）</p>
<p><strong>选择器可以包含伪状态来限制规则只能应用在部件的指定状态上。</strong></p>
<p>伪状态出现在选择器之后，用<strong>冒号</strong>隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton:hover&#123;color:white&#125;</span><br></pre></td></tr></table></figure>

<p>这个规则表明当鼠标悬停在一个QPushButton部件上时才被应用。<strong>伪状态可以使用感叹号来表示否定</strong>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton:!hover&#123;color:red&#125;</span><br></pre></td></tr></table></figure>

<p>伪状态还可以<strong>多个连用</strong>，达到逻辑与效果，例如当鼠标悬停在一个被选中的QCheckBox部件上时才应用规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox:hover:checked&#123;color:white&#125;</span><br></pre></td></tr></table></figure>

<p>如果有需要，也可以使用<strong>逗号</strong>分开，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox:hover,QCheckBox:checked&#123;color:white&#125;</span><br></pre></td></tr></table></figure>

<p>当然，伪状态也可以<strong>和子控件联合</strong>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::drop-down:hover &#123; image: url(dropdown_bright.png) &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/stylesheet-reference.html#list-of-pseudo-states">List of Pseudo-States列出了Qt支持的所有的伪状态。</a></p>
</li>
<li><p>冲突解决</p>
<p>当几个样式规则对相同的属性指定了不同的值时就会产生冲突。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton#okButton &#123; color: gray &#125;</span><br><span class="line">QPushButton &#123; color: red &#125;</span><br></pre></td></tr></table></figure>

<p>okButton的color属性产生了冲突。</p>
<p>解决这个冲突的原则是：特殊的选择器优先。因为<strong>QPushButton#okButton</strong>一般代表一个<strong>单一</strong>的对象，而不是一个类所有的实例，所以它比QPushButton更特殊，那么<strong>这时便会使用第一个规则</strong>，okButton的文本颜色为灰色。</p>
<p><strong>有伪状态比没有伪状态优先。<strong>如果两个选择符的特殊性相同，则</strong>后面出现的比前面的优先</strong>。Qt样式表使用CSS2规范来确定规则的特殊性。</p>
</li>
<li><p>层叠<br>样式表可以被设置在QApplication上、父部件上或者子部件上。</p>
<p>部件有效的样式表是通过部件祖先的样式表和QApplication上的样式表合并得到的。</p>
<p>当发生冲突时，部件自己的样式表优先于任何继承的样式表，同样，父部件的样式表优先于祖先的样式表。</p>
</li>
<li><p>继承<br>当使用Qt样式表时，部件并不会自动从父部件继承字体和颜色设置。</p>
<p>例如，一个QPushButton包含在一个QGroupBox中，这里对QGroupBox设置样式表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet(&quot;QGroupBox &#123; color: red; &#125; &quot;);</span><br></pre></td></tr></table></figure>

<p>但没有对QPushButton设置样式表。这时，QPushButton会使用系统颜色，而不会继承QGroupBox的颜色。</p>
<p>如果想要QGroupBox的颜色设置到其子部件上，可以这样设置样式表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet(&quot;QGroupBox, QGroupBox * &#123; color: red; &#125;&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置QObject属性<br>任何可设计的Q_PROPERTY都可以使用“<strong>qproperty-属性名称</strong>”语法来设置样式表。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyLabel &#123; qproperty-pixmap: url(pixmap.png); &#125;</span><br><span class="line">QPushButton &#123; qproperty-iconSize: 20px 20px; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="自定义部件外观"><a href="#自定义部件外观" class="headerlink" title="自定义部件外观"></a>自定义部件外观</h4><p>当使用样式表时，每一个部件都被看做是拥有4个同心矩形的盒子。这4个矩形分别是：</p>
<ul>
<li>内容（content）</li>
<li>填衬（padding）</li>
<li>边框（border）</li>
<li>边距（margin）</li>
</ul>
<p>边距、边框宽度和填衬等属性的默认值都是0，这样4个矩形恰好重合。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250709103443721.png" alt="image-20250709103443721"></p>
<ul>
<li><p>可以使用background-image属性来为部件指定一个背景。</p>
<p>background-image默认只在边框以内的区域进行绘制，可以使用background-clip属性来进行更改。</p>
<p>还可以使用background-repeat和background-origin来控制背景图片的重复方式以及原点。</p>
</li>
<li><p>如果想要背景随着部件的大小变化，那就必须使用border-image。</p>
<p>如果同时指定了background-image和border-image，那么border-image会绘制在background-image之上。</p>
</li>
<li><p>此外，image属性可以用来在border-image之上绘制一个图片。</p>
</li>
</ul>
<hr>
<p>添加**.qss**文件</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250709104215642.png" alt="image-20250709104215642"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*my.qss*/</span></span><br><span class="line"><span class="comment">/****************主界面背景*******************/</span></span><br><span class="line">QMainWindow &#123;</span><br><span class="line">    <span class="comment">/*背景图片*/</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/images/bg.png</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************按钮部件*******************/</span></span><br><span class="line">QPushButton &#123;</span><br><span class="line">    <span class="comment">/*背景色*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">100</span>, <span class="number">225</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">/*边框样式*/</span></span><br><span class="line">    <span class="attribute">border-style</span>: outset;</span><br><span class="line">    <span class="comment">/*边框宽度为4像素*/</span></span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="comment">/*边框颜色*/</span></span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">    <span class="comment">/*文字颜色*/</span></span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="comment">/*文字大小*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="comment">/*内边距*/</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标悬停在按钮上时*/</span></span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">100</span>, <span class="number">255</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">225</span>, <span class="number">255</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按钮被按下时*/</span></span><br><span class="line">QPushButton:pressed &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">100</span>, <span class="number">255</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">225</span>, <span class="number">255</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="attribute">border-style</span>: inset;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Widget w;</span><br><span class="line"></span><br><span class="line">    <span class="function">QFile <span class="title">styleFile</span><span class="params">(<span class="string">&quot;:/style.qss&quot;</span>)</span></span>;</span><br><span class="line">    styleFile.<span class="built_in">open</span>(QFile::ReadOnly);</span><br><span class="line">    QString styleSheet = <span class="built_in">QLatin1String</span>(styleFile.<span class="built_in">readAll</span>());</span><br><span class="line">    qApp-&gt;<span class="built_in">setStyleSheet</span>(styleSheet);</span><br><span class="line"></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h3 id="Qt-Quick控件样式"><a href="#Qt-Quick控件样式" class="headerlink" title="Qt Quick控件样式"></a>Qt Quick控件样式</h3><p>Qt Quick Controls中也为控件提供了多种样式，包括Basic Style、Fusion Style等。</p>
<ul>
<li>Basic Style：这是一种简单而轻便的样式，为Qt Quick Controls提供了最好的性能，将动画和过渡的数量保持在最小。如果其他样式未实现某个控件，则默认选择该控件的Basic Style来实现。</li>
<li>Fusion Style：这是一种与平台无关的样式。它实现了与Qt Widgets的Fusion样式相同的设计语言。</li>
<li>Imagine Style：该样式基于图片资源，附带了一组默认的图片。通过预定义的命名约定提供一个包含图片的目录，可以轻松更改使用的图片。</li>
<li>Material Style：该样式基于Google Material Design Guidelines，但它并不是原生Android样式，而是一种100%跨平台的Qt Quick Controls样式。</li>
<li>Universal Style：这是一种基于Microsoft Universal Design Guidelines的设备无关的样式，是为了能在手机、平板电脑和个人电脑等所有设备上都具有良好效果而设计的。</li>
<li>除了这里列举的几种样式，还有一些特定系统的样式，例如macOS系统上的macOS Style、iOS系统上的iOS Style、Windows系统上的Windows Style等。如果没有指定特定的样式，那么在不同系统会使用不同的默认样式，其他操作系统会默认使用Basic Style。</li>
</ul>
<hr>
<h4 id="使用控件样式"><a href="#使用控件样式" class="headerlink" title="使用控件样式"></a>使用控件样式</h4><p>在Qt Quick程序中选择样式有两种情况，一种是在<strong>编译时</strong>选择，另一种是在<strong>运行时</strong>选择。</p>
<ul>
<li><p>在编译时选择样式，只需要使用import导入要使用的样式即可，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick.Controls.Material</span><br><span class="line">ApplicationWindow &#123; ...&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方式的好处是不再需要导入QtQuick.Controls模块，所以部署程序时也不需要包含该模块。另外，如果应用程序是静态构建的，则必须使用这种方式导入。</p>
</li>
<li><p>在运行时选择样式，在程序中必须导入QtQuick.Controls模块，然后通过如下几种方式来选择样式：</p>
<ul>
<li>使用<strong>QQuickStyle::setStyle()</strong></li>
<li>使用-style命令行参数</li>
<li>使用QT_QUICK_CONTROLS_STYLE环境变量</li>
<li>使用qtquickcontrols2.conf配置文件</li>
</ul>
</li>
<li><p>这些方式的优先级从高到低，也就是说，<strong>使用QQuickStyle设置样式总是优先于使用命令行参数</strong>。在运行时选择样式的好处是，单个应用程序二进制文件可以支持多种样式。</p>
</li>
</ul>
<p><strong>QQuickStyle的使用示例：</strong></p>
<p>注意，必须在加载导入了Qt Quick Controls模块的QML文件之前配置样式，</p>
<p>也就是说setStyle()必须在QQmlApplicationEngine::load()之前进行调用，当注册QML类型后，将无法再更改样式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQmlApplicationEngine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQuickStyle&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QQuickStyle::<span class="built_in">setStyle</span>(<span class="string">&quot;Fusion&quot;</span>); <span class="comment">// 设置样式</span></span><br><span class="line"></span><br><span class="line">    QQmlApplicationEngine engine;</span><br><span class="line">    engine.<span class="built_in">load</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;../mystyle/main.qml&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;                                  </span><br></pre></td></tr></table></figure>

<p><strong>CMakeList.txt</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.16)</span><br><span class="line"></span><br><span class="line">project(QStyle VERSION 0.1 LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line"></span><br><span class="line"># 添加 QuickControls2 模块</span><br><span class="line">find_package(Qt6 REQUIRED COMPONENTS Quick QuickControls2)</span><br><span class="line"></span><br><span class="line">qt_standard_project_setup(REQUIRES 6.8)</span><br><span class="line"></span><br><span class="line">qt_add_executable(appQStyle</span><br><span class="line">    main.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 修复 QML 模块声明：添加 OUTPUT_DIRECTORY 和 明确指定 QML 类型</span><br><span class="line">qt_add_qml_module(appQStyle</span><br><span class="line">    URI QStyle</span><br><span class="line">    VERSION 1.0</span><br><span class="line">    OUTPUT_DIRECTORY qml</span><br><span class="line">    QML_FILES</span><br><span class="line">        Main.qml</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Qt for iOS sets MACOSX_BUNDLE_GUI_IDENTIFIER automatically since Qt 6.1.</span><br><span class="line"># If you are developing for iOS or macOS you should consider setting an</span><br><span class="line"># explicit, fixed bundle identifier manually though.</span><br><span class="line">set_target_properties(appQStyle PROPERTIES</span><br><span class="line">#    MACOSX_BUNDLE_GUI_IDENTIFIER com.example.appQStyle</span><br><span class="line">    MACOSX_BUNDLE_BUNDLE_VERSION $&#123;PROJECT_VERSION&#125;</span><br><span class="line">    MACOSX_BUNDLE_SHORT_VERSION_STRING $&#123;PROJECT_VERSION_MAJOR&#125;.$&#123;PROJECT_VERSION_MINOR&#125;</span><br><span class="line">    MACOSX_BUNDLE TRUE</span><br><span class="line">    WIN32_EXECUTABLE TRUE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 链接 QuickControls2 模块</span><br><span class="line">target_link_libraries(appQStyle</span><br><span class="line">    PRIVATE</span><br><span class="line">        Qt6::Quick</span><br><span class="line">        Qt6::QuickControls2  # 添加这个关键模块</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">include(GNUInstallDirs)</span><br><span class="line">install(TARGETS appQStyle</span><br><span class="line">    BUNDLE DESTINATION .</span><br><span class="line">    LIBRARY DESTINATION $&#123;CMAKE_INSTALL_LIBDIR&#125;</span><br><span class="line">    RUNTIME DESTINATION $&#123;CMAKE_INSTALL_BINDIR&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<p>Qt Quick Controls支持一个特殊的配置文件<strong>qtquickcontrols2.conf</strong>，它内置在应用程序的资源中。</p>
<p>配置文件可以指定首选样式和某些特定于样式的属性。</p>
<p>首先按下Ctrl+N新建文件，模板选择概要分类中的Empty File，文件名称设置为qtquickcontrols2.conf，完成后在其中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Controls]</span><br><span class="line">Style=Material</span><br><span class="line"></span><br><span class="line">[Material]</span><br><span class="line">Theme=Light</span><br><span class="line">Accent=Teal</span><br><span class="line">Primary=BlueGrey                                 </span><br></pre></td></tr></table></figure>

<p>这里指定首选样式为Material样式，该样式的主题为浅色，强调色和基色分别为青色和蓝灰色。qtquickcontrols2.conf文件必须添加到资源文件中，且前缀为“&#x2F;”才能自动启用，所以下面需要添加资源文件。</p>
<p>再次按下Ctrl+N新建文件，模板选择Qt分类中的Qt Resource File，文件名设置为file.qrc。添加完成后在资源文件编辑界面，先添加前缀“&#x2F;”，然后单击“添加文件”按钮将qtquickcontrols2.conf文件添加进来，完成后按下Ctrl+S保存更改。注意将main.cpp中将前面添加的setStyle(“Fusion”)那行代码删除或者注释掉。</p>
<hr>
<h4 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h4><p>虽然在Qt Quick Controls中提供了多个样式可供使用，但是有时还是想实现自定义的外观。如果只是自定义一个特定的控件对象，那么可以直接在其定义处使用代码设置外观，</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick</span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    width: <span class="number">640</span></span><br><span class="line">    height: <span class="number">480</span></span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    title: <span class="built_in">qsTr</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Button &#123;</span><br><span class="line">        id: control</span><br><span class="line">        text: <span class="built_in">qsTr</span>(<span class="string">&quot;按钮&quot;</span>)  <span class="comment">// 按钮显示的文本</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内容文本</span></span><br><span class="line">        contentItem: Text &#123;</span><br><span class="line">            text: control.text  <span class="comment">// 直接使用按钮的文本</span></span><br><span class="line">            font: control.font  <span class="comment">// 使用按钮的字体设置</span></span><br><span class="line">            color: <span class="string">&quot;white&quot;</span>      <span class="comment">// 固定文本颜色为白色</span></span><br><span class="line">            horizontalAlignment: Text.AlignHCenter <span class="comment">// 水平居中</span></span><br><span class="line">            verticalAlignment: Text.AlignVCenter   <span class="comment">// 垂直居中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按钮背景</span></span><br><span class="line">        background: Rectangle &#123;</span><br><span class="line">            implicitWidth: <span class="number">100</span>  <span class="comment">// 默认宽度</span></span><br><span class="line">            implicitHeight: <span class="number">40</span>  <span class="comment">// 默认高度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据按钮状态改变背景颜色</span></span><br><span class="line">            color: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!control.enabled) <span class="keyword">return</span> <span class="string">&quot;gray&quot;</span>  <span class="comment">// 禁用状态</span></span><br><span class="line">                <span class="keyword">if</span> (control.pressed) <span class="keyword">return</span> <span class="string">&quot;darkgreen&quot;</span>  <span class="comment">// 按下状态</span></span><br><span class="line">                <span class="keyword">if</span> (control.hovered) <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>  <span class="comment">// 悬停状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;lightgreen&quot;</span>  <span class="comment">// 默认状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Button控件由两个视觉项目组成：background和contentItem，所以可以直接自定义这两个项目，从而产生想要的效果。</p>
<p>另外，如果想在某个现成样式的基础上进行修改也是可以的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick</span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls.Basic as Basic</span><br><span class="line"></span><br><span class="line">Basic.SpinBox &#123;</span><br><span class="line">    background: Rectangle &#123; color: <span class="string">&quot;lightblue&quot;</span> &#125;</span><br><span class="line">&#125;                              </span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p><strong>404 NOT FOUND</strong></p>
<hr>
<hr>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="Widgets"><a href="#Widgets" class="headerlink" title="Widgets"></a>Widgets</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><strong>1. 2D动画绘图</strong></p>
<p>QPainter、QPaintDevice和QPaintEngine</p>
<ul>
<li><p><strong>QPainter</strong>：</p>
<p>可以完成绘图操作。该类提供大量函数完成GUI编程所需要的绘制工作。</p>
<p>可以在<strong>继承QPaintDevice</strong>类的任何对象上进行绘制操作，可以绘制一切图形。</p>
<p>一般在paintEvent()中斤进行绘制：</p>
<ul>
<li>创建QPainter对象</li>
<li>图形绘制</li>
<li>销毁QPainter对象</li>
</ul>
</li>
<li><p><strong>QPaintDevice</strong></p>
<p>提供绘图设备，他是二维空间的抽象，可以使用QPainter在其上进行绘制。</p>
<p>该类是所有绘制对象的基类，其子类包括：QWidget、QPixmap、QPicture、QImage、QPagedPaintDevice和QOpenGLPaintDevice等。</p>
</li>
<li><p><strong>QPaintEngine</strong></p>
<p>为QPainter和QPaintDevice提供接口，使其可在不同设备上进行绘制。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<p>新建Widgets应用，在widget.h中声明重绘事件处理函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在widget.cpp中对paintEvent()函数进行定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawLine</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">QPoint</span>(<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在paintEvent()函数中绘制图形</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawLine</span>(<span class="built_in">QPoint</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">QPoint</span>(<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">QPen <span class="title">pen</span><span class="params">(Qt::green, <span class="number">5</span>, Qt::DotLine, Qt::RoundCap, Qt::RoundJoin)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">    <span class="function">QRectF <span class="title">rectangle</span><span class="params">(<span class="number">70.0</span>, <span class="number">40.0</span>, <span class="number">80.0</span>, <span class="number">60.0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> startAngle = <span class="number">30</span> * <span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span> spanAngle = <span class="number">160</span> * <span class="number">16</span>;</span><br><span class="line">    painter.<span class="built_in">drawArc</span>(rectangle, startAngle, spanAngle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710090159828.png" alt="image-20250710090159828"></p>
<hr>
<p><strong>2. 重绘事件</strong></p>
<p>之前的绘制操作都是在<strong>重绘事件</strong>paintEvent()函数中进行的。</p>
<p>程序开始运行会自动发送重绘事件调用paintEvent()。</p>
<p><strong>一个重绘事件用来重绘一个部件的全部或部分区域</strong>。</p>
<p>发生重绘事件的原因：</p>
<ul>
<li>repaint()函数或者update()函数被调用<ul>
<li>调用repaint()会立即调用paintEvent()重绘部件，只有在必须立即进行重绘操作的情况下（比如在动画中），才使用repaint()函数。</li>
<li>update()允许Qt优化速度和减少闪烁，但repaint()不支持。</li>
<li><strong>不要在paintEvent()函数中调用update()或者repaint()函数。</strong></li>
</ul>
</li>
<li>被隐藏的部件被重新显示</li>
<li>其他一些原因</li>
</ul>
<p>Qt 会通过<strong>合并多个重绘事件</strong>为一个事件来加快绘制。</p>
<p>诱发重绘的条件：</p>
<ul>
<li>当update()函数被调用多次<ul>
<li>当事件遇到最大的重绘区域的时候，update()不会立即重绘，要等到Qt返回主事件循环后才会进行。因此，多次调用update()只会触发一次paintEvent()。</li>
</ul>
</li>
<li>窗口系统发送了多个重绘事件，</li>
</ul>
<hr>
<p><strong>3. 颜色和画刷</strong></p>
<p>QColor类，支持RGB、HSV、CMYK。</p>
<p>QColor类还支持基于alpha的轮廓和填充（透明效果）。</p>
<p>QColor类与设备和平台无关。</p>
<p>Qt支持20种预定义的颜色。如Qt::red，可通过Qt::GlobalColor查看。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QColor::<span class="built_in">QColor</span>(<span class="type">int</span> r,<span class="type">int</span> g,<span class="type">int</span> b, <span class="type">int</span> a =<span class="number">255</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>r,g,b三基色，取值在0到255.</li>
<li>a表示alpha通道，表示透明度，取值在0到255</li>
</ul>
<p>QBrush类，提供了画刷来对图形进行填充。</p>
<p>使用Qt::BrushStyle枚举类型来定义。包含基本填充，渐变填充，纹理填充。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710092504633.png" alt="image-20250710092504633"></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷子</span></span><br><span class="line"><span class="comment">//重新设置画笔</span></span><br><span class="line">pen.<span class="built_in">setWidth</span>(<span class="number">1</span>);</span><br><span class="line">pen.<span class="built_in">setStyle</span>(Qt::SolidLine);</span><br><span class="line">painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line">painter.<span class="built_in">drawRect</span>(<span class="number">160</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">40</span>);</span><br><span class="line"><span class="comment">//创建画刷</span></span><br><span class="line"><span class="function">QBrush <span class="title">brush</span><span class="params">(QColor(<span class="number">0</span>, <span class="number">0</span> ,<span class="number">255</span>),Qt::Dense4Pattern)</span></span>;</span><br><span class="line">painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line">painter.<span class="built_in">drawEllipse</span>(<span class="number">220</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">//设置纹理</span></span><br><span class="line">brush.<span class="built_in">setTexture</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/new.png&quot;</span>));</span><br><span class="line"><span class="comment">//重新使用画刷</span></span><br><span class="line">painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> QPointF points[<span class="number">4</span>]= &#123;</span><br><span class="line">    <span class="built_in">QPointF</span>(<span class="number">270.0</span>, <span class="number">80.0</span>),</span><br><span class="line">    <span class="built_in">QPointF</span>(<span class="number">290.0</span>, <span class="number">10.0</span>),</span><br><span class="line">    <span class="built_in">QPointF</span>(<span class="number">350.0</span>, <span class="number">30.0</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用四个点绘制多边形</span></span><br><span class="line">painter.<span class="built_in">drawPolygon</span>(points, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>4. 渐变填充</strong></p>
<p>QGradient类和QBrush配合指定渐变填充。QGradient类的3种类型：</p>
<ul>
<li><p>线性渐变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QLinearGradient::<span class="built_in">QLinearGradient</span> ( <span class="type">const</span> QPointF &amp; start, <span class="type">const</span> QPointF &amp; finalStop )</span><br></pre></td></tr></table></figure>

<ul>
<li>start开始点，finalStop结束点。将开始点和结束点进行等分，0.0开始，1.0结束。</li>
<li>使用<code>QGradient::setColorAt ( qreal position, const QColor &amp; color )</code>函数在指定的位置<code>position（注：0到1）</code>插入指定的颜色<code>color</code>，还可使用setSpread()设置填充的扩散方式。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710094813930.png" alt="image-20250710094813930"></p>
</li>
<li><p>辐射渐变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QRadialGradient::<span class="built_in">QRadialGradient</span> ( <span class="type">const</span> QPointF &amp; center, qreal radius, <span class="type">const</span> QPointF &amp; focalPoint )</span><br></pre></td></tr></table></figure>

<p>圆心center和半径radius，焦点focalPoint。焦点的位置为0，圆环的位置为1.在焦点和圆环之间插入颜色。也可使用setSpread()设置渐变区域意外的扩散方式。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710094831080.png" alt="image-20250710094831080"></p>
</li>
<li><p>锥形渐变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QConicalGradient::<span class="built_in">QConicalGradient</span> ( <span class="type">const</span> QPointF &amp; center, qreal angle )</span><br></pre></td></tr></table></figure>

<p>中心点center，角度angel(0到360)，沿逆时针从给定的角度开始环绕中心点插入颜色。旋转一圈为1。setSpread()对于锥形渐变没有效果。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710094847972.png" alt="image-20250710094847972"></p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性渐变</span></span><br><span class="line"><span class="function">QLinearGradient <span class="title">linearGradient</span><span class="params">(QPointF(<span class="number">40</span>, <span class="number">190</span>), QPointF(<span class="number">70</span>, <span class="number">190</span>))</span></span>;</span><br><span class="line"><span class="comment">// 插入颜色</span></span><br><span class="line">linearGradient.<span class="built_in">setColorAt</span>(<span class="number">0</span>, Qt::yellow);</span><br><span class="line">linearGradient.<span class="built_in">setColorAt</span>(<span class="number">0.5</span>, Qt::red);</span><br><span class="line">linearGradient.<span class="built_in">setColorAt</span>(<span class="number">1</span>, Qt::green);</span><br><span class="line"><span class="comment">// 指定渐变区域以外的区域的扩散方式</span></span><br><span class="line">linearGradient.<span class="built_in">setSpread</span>(QGradient::RepeatSpread);</span><br><span class="line"><span class="comment">// 使用渐变作为画刷</span></span><br><span class="line">painter.<span class="built_in">setBrush</span>(linearGradient);</span><br><span class="line">painter.<span class="built_in">drawRect</span>(<span class="number">10</span>, <span class="number">170</span>, <span class="number">90</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画笔使用线性渐变来绘制直线和文字</span></span><br><span class="line">painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(linearGradient,<span class="number">2</span>));</span><br><span class="line">painter.<span class="built_in">drawLine</span>(<span class="number">0</span>, <span class="number">280</span>, <span class="number">100</span>, <span class="number">280</span>);</span><br><span class="line">painter.<span class="built_in">drawText</span>(<span class="number">150</span>, <span class="number">280</span>, <span class="built_in">tr</span>(<span class="string">&quot;helloQt!&quot;</span>));                            </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710094936964.png" alt="image-20250710094936964"></p>
<p><strong>5. 坐标系统和抗锯齿渲染</strong></p>
<p>QPainter类，一个绘图设备的默认坐标系统中，原点（0, 0）在其左上角，x坐标向右增长，y坐标向下增长。在基于像素的设备上，默认的单位是一个像素，而在打印机上默认的单位是一个点（1&#x2F;72英寸）。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710095318404.png" alt="image-20250710095318404"></p>
<p>QPainter的逻辑坐标与绘图设备的物理坐标之间的映射由QPainter的变换矩阵、视口和窗口进行处理。逻辑坐标和物理坐标默认是一致的。</p>
<p>QPainter也支持坐标变换（例如旋转和缩放）。</p>
<p>抗锯齿（Anti-aliased）又被称为反锯齿或者反走样，就是对图像的边缘进行平滑处理，使其看起来更加柔和流畅的一种技术。</p>
<p>QPainter进行绘制时可以使用QPainter::RenderHint渲染提示来指定是否要使用抗锯齿功能。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710095446947.png" alt="image-20250710095446947"></p>
<hr>
<p><strong>6. 坐标变换</strong></p>
<p><strong>QPainter</strong>类可在相关设备的坐标系统上进行操作，也完全支持仿射（affine）坐标变换。</p>
<ul>
<li>使用<code>QPainter::scale()</code>函数<strong>缩放</strong>坐标系统，</li>
<li>使用<code>QPainter::rotate()</code>函数<strong>旋转</strong>坐标系统，</li>
<li>使用<code>QPainter::translate()</code>函数<strong>平移</strong>坐标系统，</li>
<li>使用<code>QPainter::shear()</code><strong>围绕原点来扭曲</strong>坐标系统。</li>
</ul>
<p><strong>QTransform</strong>类实现坐标系统的2D变换。</p>
<p>QTransform类也可以实现坐标系统变换。</p>
<p>QTransform类对象可以存储多个变换操作，尤其当同样的变换要多次使用时建议使用。</p>
<p>在进行变换操作时，可能需要多次改变坐标系统，然后再恢复，这样编码会很乱，而且很容易出现操作错误。这时可以使用<code>QPainter::save()</code>函数来<strong>保存</strong>QPainter的变换矩阵，它会把变换矩阵保存到一个<strong>内部栈</strong>中，然后在需要恢复变换矩阵时，再使用<code>QPainter::restore()</code>函数将其弹出。</p>
<p>示例：</p>
<p>定时器的信号关联到update()槽，每过一秒执行一次paintEvent()函数。</p>
<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> angle;  <span class="comment">// 添加角度成员变量</span></span><br><span class="line">    QTimer *timer; <span class="comment">// 添加定时器成员变量</span></span><br></pre></td></tr></table></figure>

<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTransform&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">    , <span class="built_in">angle</span>(<span class="number">0</span>)<span class="comment">// 初始化角度</span></span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 在构造函数中初始化定时器</span></span><br><span class="line">    timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, QOverload&lt;&gt;::<span class="built_in">of</span>(&amp;Widget::update));</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);  <span class="comment">// 每秒触发重绘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*坐标*/</span></span><br><span class="line">    angle += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(angle == <span class="number">360</span>)</span><br><span class="line">        angle = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> side = <span class="built_in">qMin</span>(<span class="built_in">width</span>(), <span class="built_in">height</span>());</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);</span><br><span class="line">    QTransform transform;</span><br><span class="line">    transform.<span class="built_in">translate</span>(<span class="built_in">width</span>()/<span class="number">2</span>, <span class="built_in">height</span>()/<span class="number">2</span>);</span><br><span class="line">    transform.<span class="built_in">scale</span>(side/<span class="number">300.0</span>, side/<span class="number">300.0</span>);</span><br><span class="line">    transform.<span class="built_in">rotate</span>(angle);</span><br><span class="line">    painter.<span class="built_in">setWorldTransform</span>(transform);</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="number">-120</span>, <span class="number">-120</span>, <span class="number">240</span>, <span class="number">240</span>);</span><br><span class="line">    painter.<span class="built_in">drawLine</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710101819707.png" alt="image-20250710101819707"></p>
<hr>
<p><strong>7. 绘制图像</strong></p>
<p>QImage、QPixmap、QBitmap和QPicture</p>
<ul>
<li><p><strong>QImage</strong></p>
<p>QImage是QPaintDevice的子类，QPainter可以直接在QImage对象上进行绘制，所以可以直接访问像素数据。</p>
<p>当在QImage上使用QPainter时，绘制操作会在当前GUI线程以外的其他线程中执行。</p>
<p>QImage支持众多图像格式，包含了单色、8位、32位和alpha混合格式图像。</p>
<p>QImage提供了获取图像各种信息的相关函数，还提供了一些转换图像的函数。</p>
<p>QImage使用了隐式数据共享，所以可以进行值传递。</p>
<p>QImage对象可以使用数据流，而且还提供了强大的操作像素的功能。</p>
</li>
<li><p><strong>QPixmap</strong></p>
<p>QPixmap可以作为一个绘图设备将图像显示在屏幕上。</p>
<p>QPixmap中的像素在内部由底层的窗口系统进行管理</p>
<p>QPixmap是QPaintDevice的子类，所以QPainter也可以直接在它上面进行绘制。</p>
<p>要想访问像素，只能使用QPainter的相应函数，或者将QPixmap转换为QImage。而与QImage不同，QPixmap中的fill()函数可以使用指定的颜色初始化整个pixmap图像。</p>
</li>
<li><p><strong>QBitmap</strong></p>
<p>QBitmap是QPixmap的子类，用来处理颜色深度为1的图像，即只能显示黑白两种颜色。</p>
</li>
<li><p><strong>QPicture</strong></p>
<p>QPicture可以记录和重演QPainter。</p>
<p>QPicture可以使用一个平台无关的格式（.pic格式）将绘图命令序列化到IO设备中。</p>
<p>所有可以绘制在QWidget部件或者QPixmap上的内容，都可以保存在QPicture中。</p>
<p>QPicture与分辨率无关，在不同设备上的显示效果都是一样的。</p>
</li>
</ul>
<p>示例一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    QPixmap pix;</span><br><span class="line">    pix.<span class="built_in">load</span>(<span class="string">&quot;:/images/new.png&quot;</span>);</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>, <span class="number">0</span>, pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>(), pix);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">100</span>));</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>());</span><br><span class="line">    painter.<span class="built_in">drawPixmap</span>(<span class="number">200</span>, <span class="number">0</span>, pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>(), pix);</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">100</span>));</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">200</span>, <span class="number">0</span>, pix.<span class="built_in">width</span>(), pix.<span class="built_in">height</span>());</span><br><span class="line">&#125;                          </span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<p><strong>截取屏幕的内容到一个QPixmap中：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QScreen::<span class="built_in">grabWindow</span> ( WId window = <span class="number">0</span>, <span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, <span class="type">int</span> width = <span class="number">-1</span>, <span class="type">int</span> height = <span class="number">-1</span> )</span><br></pre></td></tr></table></figure>

<p><strong>将图片进行缩放：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPixmap::<span class="built_in">scaled</span> ( <span class="type">const</span> QSize &amp; size, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation )</span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showEvent</span><span class="params">(QShowEvent *event)</span></span>;  <span class="comment">// 添加显示事件处理</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel *screenshotLabel;  <span class="comment">// 添加标签成员变量</span></span><br><span class="line">    QPixmap screenshot;       <span class="comment">// 添加截图缓存</span></span><br></pre></td></tr></table></figure>

<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPainter&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QScreen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QShowEvent&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">    , <span class="built_in">screenshotLabel</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建并配置标签</span></span><br><span class="line">    screenshotLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    screenshotLabel-&gt;<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    screenshotLabel-&gt;<span class="built_in">move</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    screenshotLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::showEvent</span><span class="params">(QShowEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QWidget::<span class="built_in">showEvent</span>(event);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在窗口显示后截图一次</span></span><br><span class="line">    QScreen *screen = QGuiApplication::<span class="built_in">primaryScreen</span>();</span><br><span class="line">    <span class="keyword">if</span> (screen) &#123;</span><br><span class="line">        screenshot = screen-&gt;<span class="built_in">grabWindow</span>(<span class="number">0</span>);  <span class="comment">// 截取整个屏幕</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缩放截图以适应标签大小</span></span><br><span class="line">        QPixmap scaled = screenshot.<span class="built_in">scaled</span>(screenshotLabel-&gt;<span class="built_in">size</span>(), </span><br><span class="line">                                          Qt::KeepAspectRatio,</span><br><span class="line">                                          Qt::SmoothTransformation);</span><br><span class="line">        screenshotLabel-&gt;<span class="built_in">setPixmap</span>(scaled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只绘制背景或其他静态内容</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">fillRect</span>(<span class="built_in">rect</span>(), Qt::white);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示截图标签（已在showEvent中设置）</span></span><br><span class="line">    screenshotLabel-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>8. 动态图片</strong></p>
<p>QMovie使用QImageReader来播放没有声音的动画，例如GIF格式的动图，其支持的格式可以使用<code>QMovie::supportedFormats()</code>静态函数获取。</p>
<p>要播放一个动画，只需要先创建一个QMovie对象，并为其指定要播放的动画文件，然后将QMovie对象传递给<code>QLabel::setMovie()</code>函数，最后调用start()函数来播放动画。</p>
<p>还可以使用<code>setPaused()</code>来暂停或恢复播放；使用stop()可以停止动画的播放。</p>
<p>QMovie一共有<strong>QMovie::NotRunning、QMovie::Paused和QMovie::Running</strong>等3个状态，每当状态改变时都会发射<code>stateChanged()</code>信号，可以关联这个信号来改变播放、暂停等按钮的状态。</p>
<p><code>frameCount()</code>获取当前动画总的帧数；</p>
<p><code>currentFrameNumber()</code>返回当前帧的序列号，动画第一个帧的序列号为0；如果动画播放到了一个新的帧，QMovie会发射<code>updated()</code>信号，这时可以使用<code>currentImage()</code>或者<code>currentPixmap()</code>函数来获取当前帧的一个副本。</p>
<p>示例：</p>
<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMovie&gt;</span></span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel *gifLabel;  <span class="comment">// 用于显示GIF的标签</span></span><br><span class="line">    QMovie *gifMovie;  <span class="comment">// 用于播放GIF的动画对象</span></span><br></pre></td></tr></table></figure>

<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建并配置标签</span></span><br><span class="line">    gifLabel = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">    gifLabel-&gt;<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">    gifLabel-&gt;<span class="built_in">move</span>(<span class="number">50</span>, <span class="number">50</span>);  <span class="comment">// 设置位置</span></span><br><span class="line">    gifLabel-&gt;<span class="built_in">setAlignment</span>(Qt::AlignCenter);  <span class="comment">// 居中对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并配置动画</span></span><br><span class="line">    gifMovie = <span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;:/images/fireworks.gif&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查GIF是否加载成功</span></span><br><span class="line">    <span class="keyword">if</span> (!gifMovie-&gt;<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">        gifLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Failed to load GIF!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gifLabel-&gt;<span class="built_in">setMovie</span>(gifMovie);</span><br><span class="line">        gifMovie-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">delete</span> gifMovie;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>提供了图形视图框架（Graphics View Framework）</p>
<p>动画框架（The Animation Framework）</p>
<p>状态机框架（The State Machine Framework）</p>
<p><strong>1. 结构</strong></p>
<p>图形视图框架提供了一个基于图形项的模型视图编程方法，主要由<strong>场景、视图和图形项</strong>这3部分组成，它们分别由<strong>QGraphicsScene、QGraphicsView和QGraphicsItem</strong>这3个类来表示。</p>
<p>多个视图可以察看一个场景，场景中包含各种各样几何形状的图形项。</p>
<p><strong>场景：</strong></p>
<p>QGraphicsScene提供了图形视图框架中的场景，场景拥有以下功能：</p>
<ul>
<li>提供用于管理大量图形项的高速接口</li>
<li>传播事件到每一个图形项</li>
<li>管理图形项的状态，例如选择和处理焦点</li>
<li>提供无变换的渲染功能，主要用于打印</li>
</ul>
<p>场景是图形项QGraphicsItem对象的容器。</p>
<ul>
<li><p><code>QGraphicsScene::addItem()</code>将图形项添加到场景中，然后调用任意一个图形项发现函数来检索添加的图形项。</p>
</li>
<li><p><code>QGraphicsScene::items()</code>和它的其他几个重载函数可以返回符合条件的所有图形项，这些图形项不是与指定的点、矩形、多边形或者矢量路径相交，就是包含在它们之中。</p>
</li>
<li><p><code>QGraphicsScene::itemAt()</code>返回指定点的最上层的图形项。</p>
</li>
<li><p><code>QGraphicsScene::RemoveItem()</code>从场景中删除一个图形项。</p>
</li>
</ul>
<p>所有的图形项发现函数返回的图形项都是使用<strong>递减</strong>顺序（例如第一个返回的图形项在最上层，最后返回的图形项在最下层）。</p>
<p><strong>示例一：</strong></p>
<p>新建widget项目。</p>
<p>QGraphicsScene也用来管理图形项的状态，如图形项的选择和焦点等。</p>
<ul>
<li><p>向<code>QGraphicsScene::setSelectionArea()</code>传递一个任意的形状来选择场景中指定的图形项。</p>
</li>
<li><p>使用<code>QGraphicsScene::selectedItems()</code>获取当前选取的所有图形项的列表。</p>
</li>
<li><p>调用<code>QGraphicsScene::setFocusItem()</code>或者<code>QGraphicsScene::setFocus()</code>函数来为一个图形项设置焦点，调用<code>QGraphicsScene::focusItem()</code>函数获取当前获得焦点的图形项。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsScene&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsRectItem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[ ])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc,argv)</span></span>;</span><br><span class="line">    <span class="comment">// 新建场景</span></span><br><span class="line">    QGraphicsScene scene;</span><br><span class="line">    <span class="comment">// 创建矩形图形项</span></span><br><span class="line">    QGraphicsRectItem *item = <span class="keyword">new</span> <span class="built_in">QGraphicsRectItem</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 将图形项添加到场景中</span></span><br><span class="line">    scene.<span class="built_in">addItem</span>(item);</span><br><span class="line">    <span class="comment">// 输出(50, 50)点处的图形项</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; scene.<span class="built_in">itemAt</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="built_in">QTransform</span>());</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;                     </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710110341555.png" alt="image-20250710110341555"></p>
<p><strong>QGraphicsView</strong>提供了视图部件，它用来使场景中的内容可视化。可以连接多个视图到同一个场景来为相同的数据集提供多个视口。</p>
<p>视图部件是一个可滚动的区域，它提供了一个滚动条来浏览大的场景。</p>
<ul>
<li><p>使用<code>setDragMode()</code>的参数为<code>QGraphicsView::ScrollHandDrag</code>可使光标变为<strong>手掌</strong>形状，从而可以拖动场景。</p>
</li>
<li><p>设置<code>setDragMode()</code>的参数为<code>QGraphicsView::RubberBandDrag</code>可以在视图上使用<strong>鼠标拖出橡皮筋框</strong>来选择图形项。</p>
</li>
</ul>
<p>默认的QGraphicsView提供了一个QWidget作为视口部件，如果要使用<strong>OpenGL</strong>进行渲染，可以调用<code>QGraphicsView::setViewport()</code>设置QOpenGLWidget作为视口。QGraphicsView会获取视口部件的拥有权。</p>
<p>视图从键盘或者鼠标接收输入事件，然后会在发送这些事件到可视化的场景之前将它们转换为场景事件（将坐标转换为合适的场景坐标）。</p>
<p>另外，使用视图的变换矩阵函数<code>QGraphicsView::transform()</code>，可以通过视图来变换场景的坐标系统，这样便可以实现例如缩放和旋转等高级的导航功能。</p>
<p><strong>示例二：</strong></p>
<p>新建视图部件，并指定要可视化的场景。然后为该视图设置场景前景色和背景图片。最后设置视图的大小，并调用show()函数来显示视图。</p>
<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsScene&gt;</span></span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QGraphicsScene *scene;   <span class="comment">// 场景对象</span></span><br><span class="line">    QGraphicsView *view;     <span class="comment">// 视图对象</span></span><br></pre></td></tr></table></figure>

<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsRectItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建场景</span></span><br><span class="line">    scene = <span class="keyword">new</span> <span class="built_in">QGraphicsScene</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在场景中添加一些内容（示例）</span></span><br><span class="line">    QGraphicsRectItem *rect = scene-&gt;<span class="built_in">addRect</span>(<span class="built_in">QRectF</span>(<span class="number">-50</span>, <span class="number">-50</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">    rect-&gt;<span class="built_in">setBrush</span>(Qt::blue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建视图并设置场景</span></span><br><span class="line">    view = <span class="keyword">new</span> <span class="built_in">QGraphicsView</span>(scene, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置前景色（半透明黄色）</span></span><br><span class="line">    view-&gt;<span class="built_in">setForegroundBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置背景图片（确保路径正确）</span></span><br><span class="line">    <span class="comment">// 注意：实际项目中应使用资源路径（如&quot;:/images/new.png&quot;）或绝对路径</span></span><br><span class="line">    view-&gt;<span class="built_in">setBackgroundBrush</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/new.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置视图大小和位置</span></span><br><span class="line">    view-&gt;<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">    view-&gt;<span class="built_in">move</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整窗口大小以适应视图</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(<span class="number">420</span>, <span class="number">330</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个场景分为3层：图形项层（ItemLayer）、前景层（ForegroundLayer）和背景层（BackgroundLayer）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">背景层-&gt;图形项层-&gt;前景层</span><br></pre></td></tr></table></figure>

<ul>
<li><p>前景层和背景层都可以使用QBrush进行填充，比如使用渐变和贴图等。使用好前景色可以实现很多特殊的效果，比如使用半透明的黑色便可以实现夜幕降临的效果。</p>
<p>代码中使用了<strong>QGraphicsView</strong>类中的函数设置了场景中的背景和前景，也可以使用<strong>QGraphicsScene</strong>中的同名函数来实现，不过它们的效果并不完全一样。</p>
</li>
<li><p>如果使用<strong>QGraphicsScene</strong>对象设置了场景背景或者前景，那么对所有关联了该场景的视图都有效，而<strong>QGraphicsView</strong>对象设置的场景的背景或者前景，只对它本身对应的视图有效。</p>
</li>
</ul>
<hr>
<p><strong>图形项：</strong></p>
<p><strong>QGraphicsItem</strong>是场景中图形项的基类。</p>
<p>图形视图框架为典型的形状提供了标准的图形项，例如矩形QGraphicsRectIem、椭圆QGraphicsEllipseItem和文本项QGraphicsTextItem。</p>
<p>不过，只有当编写自定义的图形项时才能发挥QGraphicsItem的强大功能。</p>
<p>QGraphicsItem主要支持如下功能：</p>
<ul>
<li>鼠标按下、移动、释放、双击、悬停、滚轮和右键菜单事件</li>
<li>键盘输入焦点和键盘事件</li>
<li>拖放事件</li>
<li>分组，使用QGraphicsItemGroup通过parent-child关系来实现</li>
<li>碰撞检测</li>
</ul>
<p>除此之外，图形项还可以存储自定义的数据，可以使用setData()进行数据存储，然后使用data()获取其中的数据。下面通过一个例子来讲解如何自定义图形项。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710112140514.png" alt="image-20250710112140514"></p>
<p><strong>示例：</strong></p>
<p>自定义MyItem类，基类设置为QGraphicsItem。添加完成后，将<strong>myitem.h</strong>文件修改如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYITEM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYITEM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGraphicsItem&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyItem</span> : <span class="keyword">public</span> QGraphicsItem</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyItem</span>();</span><br><span class="line">    <span class="function">QRectF <span class="title">boundingRect</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter *painter, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> QStyleOptionGraphicsItem *option,</span></span></span><br><span class="line"><span class="params"><span class="function">               QWidget *widget)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYITEM_H                 </span></span></span><br></pre></td></tr></table></figure>

<p>再到<strong>myitem.cpp</strong>文件中添加头文件<code>#include &lt;QPainter&gt;</code>，然后定义添加的两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRectF <span class="title">MyItem::boundingRect</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qreal penWidth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">QRectF</span>(<span class="number">0</span> - penWidth / <span class="number">2</span>, <span class="number">0</span> - penWidth / <span class="number">2</span>,</span><br><span class="line">                  <span class="number">20</span> + penWidth, <span class="number">20</span> + penWidth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyItem::paint</span><span class="params">(QPainter *painter, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> QStyleOptionGraphicsItem *, </span></span></span><br><span class="line"><span class="params"><span class="function">	         QWidget *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    painter-&gt;<span class="built_in">setBrush</span>(Qt::red);</span><br><span class="line">    painter-&gt;<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">&#125;              </span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>void QGraphicsItem::paint ( QPainter * painter, const QStyleOptionGraphicsItem * option, QWidget * widget = nullptr )</code></p>
<p>这个函数一般会被QGraphicsView调用，用来在本地坐标中绘制图形项中的内容。</p>
<ul>
<li><p>其中painter参数用来进行一般的绘图操作；</p>
</li>
<li><p>option参数为图形项提供了一个风格选项；</p>
</li>
<li><p>widget参数是可选的，如果提供了该参数，那么它会指向那个要在其上进行绘图的部件，否则默认为0（nullptr），表明使用缓冲绘图。</p>
</li>
</ul>
<p>painter的画笔的宽度默认为0，它的画笔被初始化为绘图设备调色板的<code>QPalette::Text</code>画刷，而painter的画刷被初始化为<code>QPalette::Window</code>。</p>
</li>
<li><p>下面来使用自定义的图形项。在main.cpp文件中先添加头文件<code>#include &quot;myitem.h&quot;</code>，然后将以前的图形项的创建代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsRectItem *item = <span class="keyword">new</span> <span class="built_in">QGraphicsRectItem</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//更改为：</span></span><br><span class="line">MyItem *item = <span class="keyword">new</span> MyItem; </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>2. 坐标系统</strong></p>
<p>图形视图框架是基于笛卡尔坐标系统的，一个图形项在场景中的位置和几何形状由x坐标和y坐标来表示。</p>
<p>当使用一个没有变换的视图来观察场景时，场景中的一个单元代表屏幕上的一个像素。</p>
<p>在图形视图框架中有3个有效的坐标系统：<strong>图形项坐标、场景坐标和视图坐标</strong>。</p>
<p>为了方便应用，图形视图框架中提供了一些便捷函数来完成3个坐标系统之间的映射。</p>
<p>当进行绘图时，场景坐标对应<strong>QPainter</strong>的逻辑坐标，视图坐标对应设备坐标。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710113131001.png" alt="image-20250710113131001"></p>
<ul>
<li><p><strong>图形项坐标</strong></p>
<p>图形项使用自己的本地坐标系统，坐标通常是以它们的中心为原点（0, 0）。当要创建一个自定义图形项时，只需要考虑图形项的坐标系统，一个图形项的边界矩形和图形形状都是在图形项坐标系统中的。</p>
<p>图形项的位置是指图形项的原点在其父图形项或者场景中的位置。如果一个图形项在另一个图形项之中，那么它被称为子图形项，而包含它的图形项称为它的父图形项。可以使用<code>setPos()</code>函数来指定图形项的位置，如果没有指定，它默认会出现在父图形项或者场景的原点处。</p>
<p>所有的图形项都包含一个<strong>Z值</strong>来设置它们的层叠顺序，一个图形项的Z值默认为0，可以使用<code>QGraphicsItem::setZValue()</code>来改变一个图形项的Z值，从而使它堆叠到其兄弟图形项的上面（使用较大的Z值时）或者下面（使用较小的Z值时）。</p>
</li>
<li><p><strong>场景坐标</strong><br>场景坐标是所有图形项的基础坐标系统。场景坐标系统描述了每一个顶层图形项的位置，也用于处理所有从视图传到场景上的事件。</p>
<p>场景坐标的原点在场景的中心，x和y坐标分别向右和向下增大。每一个在场景中的图形项除了拥有一个图形项的本地坐标和边界矩形外，还都拥有一个场景坐标<code>QGraphicsItem::scenePos()</code>和一个场景中的边界矩形<code>QGraphicsItem::sceneBoundingRect()</code>。</p>
<p>场景坐标用来描述图形项在场景坐标系统中的位置，而图形项的场景边界矩形用于判断场景中的哪些区域进行了更改。</p>
</li>
<li><p><strong>视图坐标</strong></p>
<p>视图的坐标就是部件的坐标。视图坐标的每一个单位对应一个像素，原点（0, 0）总在QGraphicsView的视口的左上角，而右下角是（宽，高）。所有的鼠标事件和拖放事件最初都是使用视图坐标接收的。</p>
</li>
<li><p><strong>坐标映射</strong></p>
<p>当处理场景中的图形项时，将坐标或者一个任意的形状从场景映射到图形项、或者从一个图形项映射到另一个图形项、或者从视图映射到场景，这些坐标变换都是很常用的。</p>
<p>例如，在QGraphicsView的视口上单击了鼠标，便可调用<code>QGraphicsView::mapToScene()</code>以及<code>QGraphicsScene::itemAt()</code>来获取光标下的图形项；</p>
<p>如果要获取一个图形项在视口中的位置，那么可以先在图形项上调用<code>QGraphicsItem::mapToScene()</code>，然后在视图上调用<code>QGraphicsView::mapFromScene()</code>；</p>
<p>如果要获取在视图的一个椭圆形中包含的图形项，可以先传递一个QPainterPath对象作为参数给mapToScene()函数，然后传递映射后的路径给<code>QGraphicsScene::items()</code>函数。</p>
<p>不仅可以在视图、场景和图形项之间使用坐标映射，还可以在子图形项和父图形项或者图形项和图形项之间进行坐标映射。</p>
</li>
</ul>
<p><strong>3.动画、碰撞检测和图形部件</strong></p>
<p>图形视图框架支持几种级别的动画。</p>
<ul>
<li>动画框架来实现动画效果</li>
<li>创建一个继承自QObject和QGraphicsItem的自定义图形项，然后创建它自己的定时器来实现动画</li>
<li>第三种方法是使用QGraphicsScene::advance()来推进场景。</li>
</ul>
<p>调用场景的advance()函数就会自动调用场景中所有图形项的advance()函数，而且图形项的advance()函数会被分为两个阶段调用两次。</p>
<p>第一次phase为0，告知所有的图形项场景将要改变；第二次phase为1，在这时才进行具体的操作。可以通过定时器来调用该函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTimer timer;</span><br><span class="line">QObject::<span class="built_in">connect</span>(&amp;timer, &amp;QTimer::timeout, &amp;scene, &amp;QGraphicsScene::advance);</span><br><span class="line">timer.<span class="built_in">start</span>(<span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyItem::advance</span><span class="params">(<span class="type">int</span> phase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在第一个阶段不进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (!phase)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 图形项向不同方向随机移动</span></span><br><span class="line">    <span class="type">int</span> value = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">25</span>) &#123;</span><br><span class="line">        <span class="built_in">setRotation</span>(<span class="number">45</span>); <span class="built_in">moveBy</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">50</span>) &#123;</span><br><span class="line">        <span class="built_in">setRotation</span>(<span class="number">-45</span>); <span class="built_in">moveBy</span>(<span class="number">-5</span>, <span class="number">-5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="number">75</span>) &#123;</span><br><span class="line">        <span class="built_in">setRotation</span>(<span class="number">30</span>); <span class="built_in">moveBy</span>(<span class="number">-5</span>, <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">setRotation</span>(<span class="number">-30</span>); <span class="built_in">moveBy</span>(<span class="number">5</span>, <span class="number">-5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;             </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>碰撞检测</strong></p>
<p>图形视图框架提供了图形项之间的碰撞检测，碰撞检测可以使用两种方法来实现：</p>
<ul>
<li>重新实现QGraphicsItem::shape()函数来返回图形项准确的形状，然后使用默认的collidesWithItem()函数通过两个图形项形状之间的交集来判断是否发生碰撞。如果图形项的形状很复杂，那么进行这个操作是非常耗时的。如果没有重新实现shape()函数，那么它默认会调用boundingRect()函数返回一个简单的矩形。</li>
<li>重新实现collidesWithItem()函数来提供一个自定义的图形项碰撞算法。</li>
</ul>
<p>可以使用QGraphicsItem类中的collidesWithItem()函数来判断是否与指定的图形项进行了碰撞；使用collidesWithPath()来判断是否与指定的路径碰撞；</p>
<p>使用collidingItems()来获取与该图形项碰撞的所有图形项的列表；也可以调用QGraphicsScene类的collidingItems()。</p>
<p><strong>示例：</strong></p>
<p>首先在myitem.h文件的public部分进行函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QPainterPath <span class="title">shape</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后到myitem.cpp文件中定义该函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QPainterPath MyItem::shape() const</span><br><span class="line">&#123;</span><br><span class="line">    QPainterPath path;</span><br><span class="line">    path.addRect(-10, -10, 20, 20);</span><br><span class="line">    return path;</span><br><span class="line">&#125;           </span><br></pre></td></tr></table></figure>

<p>最后将paint()函数更改如下，这样就可以在图形项与其他图形项碰撞时使其轮廓线变为白色了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void MyItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *, </span><br><span class="line">		QWidget *)</span><br><span class="line">&#123;</span><br><span class="line">    if(hasFocus() || !collidingItems().isEmpty()) &#123;</span><br><span class="line">        painter-&gt;setPen(QPen(QColor(255, 255, 255, 200)));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        painter-&gt;setPen(QPen(QColor(100, 100, 100, 100)));</span><br><span class="line">    &#125;</span><br><span class="line">    painter-&gt;setBrush(Qt::red);</span><br><span class="line">    painter-&gt;drawRect(0, 0, 20, 20);</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>图形部件</strong></p>
<p>Qt 4.4引入了图形部件QGraphicsWidget类，该类与QWidget相似，但它不是继承自QPaintDevice，而是QGraphicsItem。通过该类可以实现一个拥有事件、信号和槽、大小提示和策略的完整的部件，还可以使用<strong>QGraphicsAnchorLayout、QGraphicsLinearLayout和QGraphicsGridLayout</strong>来实现部件的布局。</p>
<p>QGraphicsWidget继承自QGraphicsObject和QGraphicsLayoutItem，</p>
<p>而QGraphicsObject继承自QObject和QGraphicsItem，所以QGraphicsWidget既拥有以前窗口部件的一些特性也拥有图形项的一些特性。</p>
<p>图形视图框架提供了对任意的窗口部件嵌入场景的无缝支持，这是通过QGraphicsWidget的子类QGraphicsProxyWidget实现的。</p>
<p>可以使用QGraphicsScene类的addWidget()函数将任何一个窗口部件嵌入到场景中，也可以通过创建QGraphicsProxyWidget类的实例来实现。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QGraphicsScene&gt;</span><br><span class="line">... ... // 省略了部分头文件，请读者自行添加</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[ ])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line">    QGraphicsScene scene;</span><br><span class="line">    // 创建部件，并关联它们的信号和槽</span><br><span class="line">    QTextEdit *edit = new QTextEdit;</span><br><span class="line">    QPushButton *button = new QPushButton(&quot;clear&quot;);</span><br><span class="line">    QObject::connect(button, &amp;QPushButton::clicked, </span><br><span class="line">                     edit, &amp;QTextEdit::clear);</span><br><span class="line">    // 将部件添加到场景中</span><br><span class="line">    QGraphicsProxyWidget *textEdit =</span><br><span class="line">                                  scene.addWidget(edit);</span><br><span class="line">    QGraphicsProxyWidget *pushButton =</span><br><span class="line">                                 scene.addWidget(button);</span><br><span class="line">                                    // 将部件添加到布局管理器中</span><br><span class="line">    QGraphicsLinearLayout *layout = </span><br><span class="line">                        new QGraphicsLinearLayout;</span><br><span class="line">    layout-&gt;addItem(textEdit);</span><br><span class="line">    layout-&gt;addItem(pushButton);</span><br><span class="line">    </span><br><span class="line">   // 创建图形部件，在其上应用布局</span><br><span class="line">    QGraphicsWidget *form = new QGraphicsWidget;</span><br><span class="line">    form-&gt;setWindowFlags(Qt::Window);</span><br><span class="line">    form-&gt;setWindowTitle(&quot;Widget Item&quot;);</span><br><span class="line">    form-&gt;setLayout(layout);</span><br><span class="line">    // 将图形部件进行扭曲，然后添加到场景中</span><br><span class="line">    form-&gt;setTransform(</span><br><span class="line">               QTransform().shear(2, -0.5), true);</span><br><span class="line">    scene.addItem(form);</span><br><span class="line">    QGraphicsView view(&amp;scene);</span><br><span class="line">    view.show();</span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;           </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>4. 动画框架</strong></p>
<p>动画框架的目的是为了提供一种简单的方法来创建平滑的具有动画效果的GUI界面。该框架是通过控制Qt的属性来实现动画的，它可以应用在窗口部件和其他QObject对象上，也可以应用在图形视图框架中。动画框架在Qt 4.6中被引入。</p>
<p>动画框架中基类QAbstractAnimation和它的两个子类QVariantAnimation以及QAnimationGroup构成了动画框架的基础。这里的QAbstractAnimation是所有动画类的祖先，它定义了一些所有动画类都共享的功能函数，比如动画的开始、停止和暂停等，它也可以接收时间变化的通知，通过继承这个类，可以创建自定义的动画类。</p>
<p>动画框架中提供了QPropertyAnimation类，继承自QVariantAnimation，用来执行Qt属性的动画。这个类使用缓和曲线（easing curve）来对属性进行插值。如果要对一个值使用动画就可以创建继承自QObject的类，然后在类中将该值定义为一个属性。属性动画为现有的窗口部件以及其他QObject子类提供了非常灵活的动画控制。Qt现在支持的可以进行插值的QVariant类型有：Int、Uint、Double、Float、QLine、QLineF、QPoint、QPointF、QSize、QSizeF、QRect、QRectF和QColor等。<br>如果要实现复杂的动画，可以通过动画组QAnimationGroup类实现，它的功能是作为其他动画类的容器，一个动画组中还可以包含另外的动画组。</p>
<p><strong>属性动画</strong></p>
<p>QPropertyAnimation类可以对Qt属性进行插值，之所以要使用Qt属性来进行动画，其主要原因是这样可以为已经存在的Qt API中的类提供灵活的动画设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QPropertyAnimation&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[ ])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line">    QPushButton button(&quot;Animated Button&quot;);</span><br><span class="line">    button.show();</span><br><span class="line">    QPropertyAnimation animation(&amp;button, &quot;geometry&quot;);</span><br><span class="line">    animation.setDuration(10000);</span><br><span class="line">    animation.setStartValue(QRect(50, 50, 120, 30));</span><br><span class="line">    animation.setEndValue(QRect(250, 250, 200, 60));</span><br><span class="line">    animation.start();</span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure>

<p>除了设置属性开始和结束的值以外，还可以调用setKeyValueAt(qreal step, const QVariant &amp;value)函数在动画中间为属性设置值，其中step取值在0.0~1.0之间，0.0表示开始位置，1.0表示结束位置，而value为属性的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animation.setKeyValueAt(0, QRect(50, 50, 120, 30));</span><br><span class="line">animation.setKeyValueAt(0.8, QRect(250, 250, 200, 60));</span><br><span class="line">animation.setKeyValueAt(1, QRect(50, 50, 120, 30));       </span><br></pre></td></tr></table></figure>

<p>在动画中可以使用pause()来暂停动画；使用resume()来恢复暂停状态；使用stop()来停止动画；可以使用setDirection()设置动画的方向，还可以使用setLoopCount()函数来设置动画的重复次数。</p>
<hr>
<p><strong>缓和曲线</strong></p>
<p>在前面程序的运行效果中可以看到，按钮部件的运动过程都是线性的，即匀速运动。除了在动画中添加更多的关键点，还可以使用缓和曲线，缓和曲线描述了怎样来控制0和1之间的插值速度的功能，这样就可以在不改变插值的情况下来控制动画的速度。</p>
<p>这里使用了QEasingCurve::OutBounce缓和曲线，此时运行程序，会发现它会使按钮部件就像从开始位置掉落到结束位置的皮球一样出现弹跳效果。在QEasingCurve类中提供了40多种缓和曲线，而且还可以自定义缓和曲线，具体可以查看一下该类的帮助文档。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation.setDuration(2000);</span><br><span class="line">animation.setStartValue(QRect(250, 0, 120, 30));</span><br><span class="line">animation.setEndValue(QRect(250, 300, 120, 30));</span><br><span class="line">animation.setEasingCurve(QEasingCurve::OutBounce);        </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>动画组</strong></p>
<p>在一个应用中经常会包含多个动画，例如要同时移动多个图形项或者让它们一个接一个的串行移动。通过使用QAnimationGroup类可以实现复杂的动画，它的两个子类QSequentialAnimationGroup和QParallelAnimationGroup分别提供了串行动画组和并行动画组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">QPushButton button(&quot;Animated Button&quot;);</span><br><span class="line">button.show();</span><br><span class="line">// 按钮部件的动画1</span><br><span class="line">QPropertyAnimation *animation1 = new QPropertyAnimation(&amp;button, &quot;geometry&quot;);</span><br><span class="line">animation1-&gt;setDuration(2000);</span><br><span class="line">animation1-&gt;setStartValue(QRect(250, 0, 120, 30));</span><br><span class="line">animation1-&gt;setEndValue(QRect(250, 300, 120, 30));</span><br><span class="line">animation1-&gt;setEasingCurve(QEasingCurve::OutBounce);</span><br><span class="line">// 按钮部件的动画2</span><br><span class="line">QPropertyAnimation *animation2 = new QPropertyAnimation(&amp;button, &quot;geometry&quot;);</span><br><span class="line">animation2-&gt;setDuration(1000);</span><br><span class="line">animation2-&gt;setStartValue(QRect(250, 300, 120, 30));</span><br><span class="line">animation2-&gt;setEndValue(QRect(250, 300, 200, 60));</span><br><span class="line">// 串行动画组</span><br><span class="line">QSequentialAnimationGroup group;</span><br><span class="line">group.addAnimation(animation1);</span><br><span class="line">group.addAnimation(animation2);</span><br><span class="line">group.start();       </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>在图形框架种使用动画</strong></p>
<p>要为QGraphicsItem对象使用动画，也可以通过QPropertyAnimation类实现。但是，QGraphicsItem并不是继承自QObject类，所以直接继承自QGraphicsItem的图形项并不能使用QPropertyAnimation类来创建动画。</p>
<p>在Qt 4.6中提供了一个QGraphicsItem的子类QGraphicsObject，它继承自QObject和QGraphicsItem，这个类为所有需要使用信号和槽以及属性的图形项提供了一个基类，通过创建这个类的子类就可以使用属性动画了。</p>
<p>QGraphicsObject还提供了多个常用的属性，比如位置pos、透明度opacity、旋转rotation和缩放scale等，这些都可以直接用来设置动画。</p>
<p><strong>示例：</strong></p>
<p>自定义新的C++类，类名MyItem，基类设置为QGraphicsObject。<br>在myitem.h文件添加内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyItem : public QGraphicsObject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MyItem(QGraphicsItem *parent = 0);</span><br><span class="line">    QRectF boundingRect() const override;</span><br><span class="line">    void paint(QPainter *painter,const QStyleOptionGraphicsItem *option, </span><br><span class="line">		QWidget *widget) override;</span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure>

<p>然后到myitem.cpp文件中，添加函数定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QRectF MyItem::boundingRect() const</span><br><span class="line">&#123;</span><br><span class="line">    return QRectF(-10 - 0.5, -10 - 0.5, 20 + 1, 20 + 1);</span><br><span class="line">&#125;</span><br><span class="line">void MyItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *, </span><br><span class="line">		QWidget *)</span><br><span class="line">&#123;</span><br><span class="line">    painter-&gt;drawRect(-10, -10, 20, 20);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>使用新的图形项类创建属性动画：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[ ])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line">    QGraphicsScene scene;</span><br><span class="line">    scene.setSceneRect(-200, -150, 400, 300);</span><br><span class="line">    MyItem *item = new MyItem;</span><br><span class="line">    scene.addItem(item);</span><br><span class="line">    QGraphicsView view;</span><br><span class="line">    view.setScene(&amp;scene);</span><br><span class="line">    view.show();</span><br><span class="line">    // 为图形项的rotation属性创建动画</span><br><span class="line">    QPropertyAnimation *animation = new QPropertyAnimation(item, &quot;rotation&quot;);</span><br><span class="line">    animation-&gt;setDuration(2000);</span><br><span class="line">    animation-&gt;setStartValue(0);</span><br><span class="line">    animation-&gt;setEndValue(360);</span><br><span class="line">    animation-&gt;start(QAbstractAnimation::DeleteWhenStopped);</span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p><strong>5. 状态机框架</strong></p>
<p>状态机框架提供了一些类来创建和执行状态图（state graphs），状态图为一个系统如何对外界激励进行反应提供了一个图形化模型，该模型是通过定义一些系统可能进入的状态以及系统怎样从一个状态切换到另一个状态来实现的。例如，假定状态机由一个QPushButton控制，包含3个状态：s1、s2和s3，其中s1是初始状态。当单击按钮时，状态机切换到另一个状态。该状态机的状态图如下：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710120226181.png" alt="image-20250710120226181"></p>
<p>状态机框架提供了一个API和一个执行模型来有效地将状态图的元素和语义嵌入到Qt应用程序中。该框架与Qt的元对象系统是紧密结合的，例如状态间的切换可以由信号来触发。<br>Qt的事件系统用来驱动状态机。在状态机框架中的状态图是分层的，状态可以嵌套在其他状态中，在状态机的一个有效配置中的所有状态都拥有一个共同的祖先。</p>
<p><strong>示例：</strong></p>
<p>这里定义的3个状态间的切换是循环的，状态机也永远不会停止，如果想让状态机完成一个状态后就停止，那么可以设置这个状态为QFinalState对象，将它加入状态图中，等切换到该状态时状态机就会发射finished()信号并停止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[ ])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line">    QPushButton button(&quot;State Machine&quot;);</span><br><span class="line">    // 创建状态机和3个状态，并将3个状态添加到状态机中</span><br><span class="line">    QStateMachine machine;</span><br><span class="line">    QState *s1 = new QState(&amp;machine);</span><br><span class="line">    QState *s2 = new QState(&amp;machine);</span><br><span class="line">    QState *s3 = new QState(&amp;machine);</span><br><span class="line">    // 为按钮部件的geometry属性分配一个值，当进入该状态时会设置该值</span><br><span class="line">    s1-&gt;assignProperty(&amp;button, &quot;geometry&quot;, QRect(100, 100, 120, 50));</span><br><span class="line">    s2-&gt;assignProperty(&amp;button, &quot;geometry&quot;, QRect(300, 100, 120, 50));</span><br><span class="line">    s3-&gt;assignProperty(&amp;button, &quot;geometry&quot;, QRect(200, 200, 120, 50));</span><br><span class="line">    // 使用按钮部件的单击信号来完成3个状态的切换</span><br><span class="line">    s1-&gt;addTransition(&amp;button, &amp;QPushButton::clicked, s2);</span><br><span class="line">    s2-&gt;addTransition(&amp;button, &amp;QPushButton::clicked, s3);</span><br><span class="line">    s3-&gt;addTransition(&amp;button, &amp;QPushButton::clicked, s1);</span><br><span class="line">    // 设置状态机的初始状态并启动状态机</span><br><span class="line">    machine.setInitialState(s1);</span><br><span class="line">    machine.start();</span><br><span class="line">    button.show();</span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p><strong>使用动画</strong></p>
<p>如果将状态机中的API和Qt中的动画API相关联，那么就可以使分配到状态上的属性自动实现动画效果。这样就可以在状态切换时使用动画效果了。在属性上添加动画，就意味着当进入一个状态时分配的属性将无法立即生效，而是在进入时开始播放动画，然后以平滑的动画来达到属性分配的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSignalTransition *transition1 = s1-&gt;addTransition(&amp;button,&amp;QPushButton::clicked, s2);</span><br><span class="line">QSignalTransition *transition2 = s2-&gt;addTransition(&amp;button,&amp;QPushButton::clicked, s3);</span><br><span class="line">QSignalTransition *transition3 = s3-&gt;addTransition(&amp;button,&amp;QPushButton::clicked, s1);</span><br><span class="line">QPropertyAnimation *animation = new QPropertyAnimation(&amp;button, &quot;geometry&quot;);</span><br><span class="line">transition1-&gt;addAnimation(animation);</span><br><span class="line">transition2-&gt;addAnimation(animation);</span><br><span class="line">transition3-&gt;addAnimation(animation);  </span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h3 id="Quick"><a href="#Quick" class="headerlink" title="Quick"></a>Quick</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><p><strong>1. 颜色、渐变</strong></p>
<p><strong>颜色</strong></p>
<p>QtQuick模块扩展了QML的基本类型，其中包含一个color类型。color类型是一个ARGB格式的颜色值，可以使用多种方式来指定，例如SVG颜色名称、十六进制表示法、Qt.rgba()函数等。</p>
<ul>
<li><p>SVG颜色名称</p>
<p>SVG颜色名称使用一个英文单词来指定一个颜色，例如红色就是“red”。所有的颜色名称可以在帮助中color QML Value Type文档进行查看。</p>
</li>
<li><p>十六进制表示法</p>
<p>color可以使用3个或者4个十六进制数字来表示，格式为#RRGGBB或#AARRGGBB。其中的AA设置透明度（Alpha值），取值范围是0<del>255，即十六进制的00-FF，00表示完全透明，FF表示完全不透明；RR、GG、BB分别表示红、绿、蓝分量，取值范围是0</del>255。例如完全不透明的红色就是#FF0000。如果颜色是完全不透明的，AA分量可以省略。半透明的蓝色可以用#800000FF表示。</p>
</li>
<li><p>使用Qt函数</p>
<p>QML可以使用Qt全局对象，它提供了一些实用的函数、属性和枚举类型，例如与颜色相关的函数包括rgba()、hsla()、darker()、lighter()和tint()等。其中，rgba()通过指定红、绿、蓝和Alpha等分量来返回一个颜色，所有分量的取值范围都是0~1，例如Qt.rgba(1, 0, 0, 1)返回红色。</p>
</li>
</ul>
<p><strong>渐变</strong></p>
<p>QML使用Gradient定义一个渐变。渐变使用一组GradientStop子项目指定颜色，每一个GradientStop子项目都在渐变中指定一个位置和一个颜色；位置通过position属性设置，取值范围是0.0~1.0；颜色通过color属性设置，默认是黑色。另外，渐变默认是垂直的Gradient.Vertical，可以通过orientation属性设置为水平的Gradient.Horizontal。注意，Gradient本身是不可见项目，因此需要在一个可见项目（如Rectangle）中使用渐变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: 100; height: 100</span><br><span class="line">    gradient: Gradient &#123;</span><br><span class="line">        GradientStop &#123; position: 0.0; color: &quot;red&quot; &#125;</span><br><span class="line">        GradientStop &#123; position: 0.33; color: &quot;yellow&quot; &#125;</span><br><span class="line">        GradientStop &#123; position: 1.0; color: &quot;green&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>2. 图片、边界图片和动态图片</strong></p>
<p>Image类型用来显示图片。图片路径通过source属性指定，可以是绝对路径或相对路径。图片格式可以是Qt支持的任何格式，如PNG、JPEG和SVG等。如果Image对象的width和height属性都没有指定，Image会自动使用加载的图片的宽度和高度。如果指定了Image的大小，那么默认情况下，图片会缩放到这个大小。这个行为也可以通过设置fillMode属性来改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Image &#123;</span><br><span class="line">    width: 200; height: 200</span><br><span class="line">    fillMode: Image.Tile</span><br><span class="line">    source: &quot;qtlogo.png&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710120714008.png" alt="image-20250710120714008"></p>
<p>本地图片默认会被立即加载，并且在加载完成以前阻塞用户界面。如果加载一个特别巨大的图片，可以将Image的asynchronous属性设置为true，将加载的操作放在一个低优先级的线程中进行。<br>如果图片需要从网络获取，则自动在低优先级线程中进行异步加载；通过progress属性和status属性可以获得实时进度。另外，sourceSize属性可以设置sourceSize.width和sourceSize.height，它们与width和height属性不同：设置Image的width和height属性会在绘制图片时进行缩放，但是内存中保存的还是图片原始大小，而sourceSize属性则会设置图片在内存中的大小，这样，即使巨大的图片也不会占用过多内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Image &#123;</span><br><span class="line">    id: image; width: 200; height: 200</span><br><span class="line">    fillMode: Image.Tile</span><br><span class="line">    source: &quot;http://www.baidu.com/img/baidu_sylogo1.gif&quot;</span><br><span class="line">    sourceSize.width: 100; sourceSize.height: 100;</span><br><span class="line"></span><br><span class="line">    onStatusChanged: &#123;</span><br><span class="line">        if (image.status == Image.Ready) console.log(&#x27;Loaded&#x27;)</span><br><span class="line">        else if (image.status == Image.Loading) console.log(&#x27;Loading&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>边界图片</strong></p>
<p>BorderImage类型利用图片创建边框。BorderImage将源图片分成9个区域。当图片进行缩放时，源图片的各个区域使用下面的方式进行缩放或者平铺来创建要显示的边界图片：</p>
<ul>
<li>4个角（1、3、7、9区域）不进行缩放；</li>
<li>区域2和8通过horizontalTileMode属性设置的模式进行缩放；</li>
<li>区域4和6通过verticalTileMode属性设置的模式进行缩放；</li>
<li>区域5结合horizontalTileMode和verticalTileMode属性设置的模式进行缩放。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710120801379.png" alt="image-20250710120801379"></p>
<p>这些区域可以使用图片的border属性组进行定义。4条边界线将图片分成9个区域，上下左右四条边界线分别是border.top、border.bottom、border.left和border.right，每条边界线都指定了到相应图片边界的、以像素为单位的距离。水平或垂直方向上，可用的填充模式有BorderImage.Stretch拉伸、BorderImage.Repeat平铺但边缘可能被修剪、BorderImage.Round平铺但可能会将图片进行缩小以确保边缘的图片不会被修剪。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BorderImage &#123;</span><br><span class="line">    width: 180; height: 180</span><br><span class="line">    border &#123; left: 30; top: 30; right: 30; bottom: 30 &#125;</span><br><span class="line">    horizontalTileMode: BorderImage.Repeat</span><br><span class="line">    verticalTileMode: BorderImage.Repeat</span><br><span class="line">    source: &quot;colors.png&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态图片</strong></p>
<p>AnimatedImage类型扩展了Image类型，可以用来播放包含了一系列帧的图片动画，比如GIF文件。当前帧和动画总长度信息可以分别使用currentFrame和frameCount属性获取。通过改变playing和paused属性来开始、暂停和停止动画。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: animation.width; height: animation.height + 8</span><br><span class="line">    AnimatedImage &#123; id: animation; source: &quot;fireworks.gif&quot; &#125;</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        property int frames: animation.frameCount</span><br><span class="line"></span><br><span class="line">        width: 4; height: 8; color: &quot;red&quot;</span><br><span class="line">        x: (animation.width - width) * animation.currentFrame / frames</span><br><span class="line">        y: animation.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 缩放、旋转和平移</strong></p>
<p>Item类型拥有一个scale属性和一个rotation属性，分别可以实现项目的缩放和旋转。<br>对于scale，如果其值小于1.0，会将项目缩小显示；如果大于1.0，则会将项目放大显示。如果使用一个负值，则显示镜像效果。scale默认值是1.0，也就是显示正常大小。缩放以transformOrigin属性指定的点为原点进行。<br>使用rotation属性可以指定项目顺时针旋转的度数，默认值为0；如果是负值，则进行逆时针旋转。旋转也是以transformOrigin属性指定的点为中心点。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710120940592.png" alt="image-20250710120940592"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    color: &quot;lightgrey&quot;; width: 100; height: 100</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        color: &quot;blue&quot;; width: 25; height: 25</span><br><span class="line">    &#125;</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        color: &quot;yellow&quot;; x: 25; y: 25; </span><br><span class="line">        width: 25; height: 25</span><br><span class="line">        scale: 1.6</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">color: &quot;lightgrey&quot;; width: 100; height: 100</span><br><span class="line"></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        color: &quot;yellow&quot;; x: 25; y: 25; </span><br><span class="line">        width: 50; height: 50</span><br><span class="line">        rotation: 30</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果前面的简单变换不能满足需要，则可以使用Item的transform属性，该属性需要指定一个Transform类型的列表。Transform是一个抽象类型，无法被直接实例化，常用的Transform类型有3个：Rotation、Scale和Translate，分别用来进行旋转、缩放和平移。这些类型可以通过专门的属性进行更高级的变换设置。<br>Rotation提供了坐标轴和原点属性。坐标轴有axis.x、axis.y和axis.z，分别代表X轴、Y轴和Z轴，可以实现3D效果。原点由origin.x和origin.y来指定。对于简单的2D旋转，是不需要指定坐标轴的。对于典型的3D旋转，既需要指定原点，也需要指定坐标轴。使用angle属性可以指定顺时针旋转的度数。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250710121025061.png" alt="image-20250710121025061"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Row &#123;</span><br><span class="line">    x: 10; y: 10; spacing: 10</span><br><span class="line">    Image &#123; source: &quot;qtlogo.png&quot; &#125;</span><br><span class="line">    Image &#123; source: &quot;qtlogo.png&quot;</span><br><span class="line">              transform: Rotation &#123; </span><br><span class="line">                    origin.x: 30; origin.y: 30; angle: 72 </span><br><span class="line">            	axis &#123; x: 0; y: 1; z: 0 &#125; </span><br><span class="line">               &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>4. 状态</strong></p>
<p>应用程序的不同界面可以被看作是对应不同的场景，或者是通过改变外观来响应用户的交互。通常情况下，界面中多个组件的改变是并发进行的，这样的界面，可以看作从一个状态改变到另一个状态。这种理解适用于各种界面类型。例如，一个图片浏览器最初使用网格来显示多张图片；当单击一张图片后，进入“详细”状态，放大显示单张图片，与此同时，用户界面也改变成图片编辑界面。再比如，一个按钮被按下时，会改变到“按下”状态，按钮的多个属性（颜色和位置）都会发生变化来产生一个被按下的外观。<br>QML的状态依赖于State类型的一组属性设置，可以包含以下几点：</p>
<ul>
<li>显示一些组件而隐藏其它组件；</li>
<li>为用户呈现不同的动作；</li>
<li>开始、停止或者暂停动画；</li>
<li>执行一些需要在新的状态中使用的脚本；</li>
<li>为一个特定的项目改变一个属性值；</li>
<li>显示一个不同的视图或者画面。</li>
</ul>
<p>要创建一个状态，可以向项目的states属性添加一个State对象。states属性是一个包含了该项目所有状态的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    width: 150; height: 100</span><br><span class="line"></span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        id: signal; anchors.fill: parent; color: &quot;lightgrey&quot;</span><br><span class="line">        state: &quot;WARNING&quot;</span><br><span class="line">        Image &#123;id: img; anchors.centerIn: parent; </span><br><span class="line">                source: &quot;warning.png&quot;&#125;</span><br><span class="line"></span><br><span class="line">        states: [</span><br><span class="line">            State &#123;</span><br><span class="line">                name: &quot;WARNING&quot;</span><br><span class="line">                PropertyChanges &#123; target: signal; color: &quot;lightgrey&quot;&#125;</span><br><span class="line">                PropertyChanges &#123; target: img; source: &quot;warning.png&quot;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            State &#123;</span><br><span class="line">                name: &quot;CRITICAL&quot;</span><br><span class="line">                PropertyChanges &#123; target: signal; color: &quot;red&quot;&#125;</span><br><span class="line">                PropertyChanges &#123; target: img; source: &quot;critical.png&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure>

<p>可以通过为对象的state属性指定合适的状态名称来改变状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Image &#123;</span><br><span class="line">    id: signalswitch</span><br><span class="line">    width: 22; height: 22; </span><br><span class="line">    source: &quot;switch.png&quot;</span><br><span class="line"></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">       anchors.fill: parent</span><br><span class="line">       onClicked: &#123;</span><br><span class="line">            if (signal.state === &quot;WARNING&quot;)</span><br><span class="line">                signal.state = &quot;CRITICAL&quot;</span><br><span class="line">            else</span><br><span class="line">                signal.state = &quot;WARNING&quot;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有基于Item的组件都有一个state属性和一个默认状态。默认状态就是空字符串（””），包含了项目的所有初始属性值。默认状态主要用于在状态改变前管理属性值，可以将state属性设置为空字符串来加载默认状态。<br>为简化操作，可以使用State类型的when属性绑定一个表达式来改变状态。当表达式的值为true时，会切换到相应状态；当表达式的值为false时，会切换到默认状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    id: bell</span><br><span class="line">    width: 75; height: 75; color: &quot;yellow&quot;</span><br><span class="line"></span><br><span class="line">    states: State &#123;</span><br><span class="line">                name: &quot;RINGING&quot;</span><br><span class="line">                when: (signal.state == &quot;CRITICAL&quot;)</span><br><span class="line">                PropertyChanges &#123;target: speaker; play: &quot;RING!&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>在实际开发中，经常搭配使用when和MouseArea简化切换程序界面的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    ...</span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        id: mouseArea</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">&#125;</span><br><span class="line">    states: State &#123;</span><br><span class="line">        name: &quot;CRITICAL&quot;; when: mouseArea.pressed</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h4 id="动画与过渡"><a href="#动画与过渡" class="headerlink" title="动画与过渡"></a>动画与过渡</h4><p><strong>1. 使用属性动画</strong></p>
<p>PropertyAnimation属性动画是针对属性值应用的动画对象，可以随时间的推移逐渐改变属性的值。其原理是在设置的两个属性值之间进行插值，形成平滑的变化效果。属性动画提供了时间控制，并且可以使用缓和曲线（easing curves）进行不同的插值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Image &#123;</span><br><span class="line">    id: fengche</span><br><span class="line">    width: 300; height: 300; source: &quot;fengche.png&quot;; opacity: 0.1</span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            animateRotation.start(); animateOpacity.start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PropertyAnimation &#123;</span><br><span class="line">        id: animateOpacity</span><br><span class="line">        target: fengche; properties: &quot;opacity&quot;; </span><br><span class="line">        to: 1.0; duration: 2000</span><br><span class="line">    &#125;</span><br><span class="line">    NumberAnimation &#123;</span><br><span class="line">        id: animateRotation</span><br><span class="line">        target: fengche; properties: &quot;rotation&quot;</span><br><span class="line">        from: 0; to: 360; duration: 3000</span><br><span class="line">        loops: Animation.Infinite</span><br><span class="line">        easing &#123;type: Easing.OutBack&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>2. 使用预定义的目标和属性</strong></p>
<p>在前面的例子中，PropertyAnimation和NumberAnimation对象需要指定目标target和属性properties来设置动画。其实也可以不设置这两个属性，而是使用预定义的目标和属性，这需要使用<code>&lt;Animation&gt;</code> on <code>&lt;Property&gt;</code>语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    width: 300; height: 300</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        id: rect</span><br><span class="line">        width: 100; height: 100; color: &quot;red&quot;</span><br><span class="line">        PropertyAnimation on x &#123; to: 100 &#125;</span><br><span class="line">        PropertyAnimation on y &#123; to: 100 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种语法也可以使用在组合动画中，这样可以保证一组动画都应用在相同的属性上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: 100; height: 100; color: &quot;red&quot;</span><br><span class="line">    SequentialAnimation on color &#123;</span><br><span class="line">        ColorAnimation &#123; to: &quot;yellow&quot;; duration: 1000 &#125;</span><br><span class="line">        ColorAnimation &#123; to: &quot;blue&quot;; duration: 1000 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 在状态改变时使用过渡</strong></p>
<p>一般状态的改变会导致属性值突然变化，在改变状态时使用动画过渡效果会产生更好的视觉体验。Qt Quick中的Transition类型用来指定一个过渡，其中可以包含动画类型，即通过在不同状态的属性值之间进行插值产生动画效果。通过将Transition对象绑定到项目的transitions属性来使用过渡。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    width: 100; height: 100</span><br><span class="line">    Rectangle &#123;</span><br><span class="line">        id: button</span><br><span class="line">	... ...</span><br><span class="line">        states: [</span><br><span class="line">	... ...</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        transitions: [</span><br><span class="line">            Transition &#123;</span><br><span class="line">                from: &quot;PRESSED&quot;; to: &quot;RELEASED&quot;</span><br><span class="line">                ColorAnimation &#123; target: button; duration: 500&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            Transition &#123;</span><br><span class="line">                from: &quot;RELEASED&quot;; to: &quot;PRESSED&quot;</span><br><span class="line">                ColorAnimation &#123; target: button; duration: 500&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Transition分别将状态名称绑定到to和from属性，用来指定在这两个状态间切换时使用过渡。另外，使用类似上面的对称或其它简单的过渡，可以将to属性值直接设置为通配符“*”，这样所有的状态改变都可以使用这个过渡</p>
<hr>
<p><strong>4. 使用默认的行为动画</strong></p>
<p>默认的属性动画可以使用Behavior设置。Behavior可以指定到具体的属性，如果在这样的Behavior类型中使用了动画，那么当这个属性的值改变时都会应用动画。Behavior类型有一个enabled属性，可以设置为true或false来开启或者关闭行为动画。</p>
<p>例如，一个Ball组件将行为动画指定到它的x、y和color属性上，通过设置动画，使该组件的实例在每次移动时都具有弹性效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Ball.qml</span><br><span class="line">import QtQuick</span><br><span class="line"></span><br><span class="line">Rectangle &#123;</span><br><span class="line">    id: ball</span><br><span class="line">    width: 75; height: 75; radius: width; color: &quot;lightsteelblue&quot;</span><br><span class="line">    Behavior on x &#123;</span><br><span class="line">        NumberAnimation &#123;</span><br><span class="line">            id: bouncebehavior; duration: 700</span><br><span class="line">            easing &#123;</span><br><span class="line">                type: Easing.OutElastic</span><br><span class="line">                amplitude: 1.0; period: 0.5</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Behavior on y &#123; animation: bouncebehavior &#125;</span><br><span class="line">    Behavior &#123; ColorAnimation &#123; target: ball; duration: 800 &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面在mybehavior.qml文件中使用该组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// mybehavior.qml</span><br><span class="line">import QtQuick</span><br><span class="line"></span><br><span class="line">Item &#123;</span><br><span class="line">    width: 800; height: 800</span><br><span class="line">    Ball &#123; id: ball &#125;</span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            ball.color = Qt.rgba(Math.random(256),</span><br><span class="line">                                 Math.random(256), Math.random(256), 1)</span><br><span class="line">            ball.x += 100; ball.y += 100</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 使用并行或顺序动画组</strong></p>
<p>一组动画可以使用ParallelAnimation或SequentialAnimation类型实现并行或者顺序执行。并行动画使一组动画在同一时间同时执行；顺序动画使一组动画逐个执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    id: banner</span><br><span class="line">    width: 150; height: 100; border.color: &quot;black&quot;</span><br><span class="line">    Column &#123;</span><br><span class="line">        anchors.centerIn: parent</span><br><span class="line">        Text &#123; id: code; text: &quot;Code less.&quot;; opacity: 0.01 &#125;</span><br><span class="line">        Text &#123; id: create; text: &quot;Create more.&quot;; opacity: 0.01 &#125;</span><br><span class="line">        Text &#123; id: deploy; text: &quot;Deploy everywhere.&quot;; opacity: 0.01 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MouseArea &#123; anchors.fill: parent; onPressed: playbanner.start() &#125;</span><br><span class="line">    SequentialAnimation &#123;</span><br><span class="line">        id: playbanner; running: false</span><br><span class="line">        NumberAnimation &#123; target: code; property: &quot;opacity&quot;; to: 1.0; duration: 2000&#125;</span><br><span class="line">        NumberAnimation &#123; target: create; property: &quot;opacity&quot;; to: 1.0; duration: 2000&#125;</span><br><span class="line">        NumberAnimation &#123; target: deploy; property: &quot;opacity&quot;; to: 1.0; duration: 2000&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>6. 使用动画师动画</strong></p>
<p>Animator类型与前面讲到的普通动画类型不同，它会直接在Qt Quick的场景图上进行操作。当使用Animator时，动画会运行在场景图的渲染线程中，并且当动画运行时相关属性的值不会变化，只有当动画结束时，相关的属性值会直接设置为最终值。<br>Animator类型不能直接使用，可以使用它的几个子类型：OpacityAnimator、RotationAnimator、ScaleAnimator、UniformAnimator、XAnimator和YAnimator。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    id: mixBox; width: 50; height: 50</span><br><span class="line">    </span><br><span class="line">    ParallelAnimation &#123;</span><br><span class="line">        running: true</span><br><span class="line">        ColorAnimation &#123;</span><br><span class="line">            target: mixBox; property: &quot;color&quot;</span><br><span class="line">            from: &quot;forestgreen&quot;; to: &quot;lightsteelblue&quot;; duration: 1000</span><br><span class="line">        &#125;</span><br><span class="line">        ScaleAnimator &#123;</span><br><span class="line">            target: mixBox; from: 2; to: 1; duration: 1000</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. 控制动画的执行</strong></p>
<ul>
<li><p>动画回放：所有的动画类型都继承自Animation。虽然Animation本身无法实例化，但是它为其它动画类型提供了基本的属性和函数。Animation类型包含了start()开始、stop()停止、resume()恢复、pause()暂停、restart()重新开始和complete()完毕等方法，可以用来控制动画的执行。</p>
</li>
<li><p>缓和曲线：一个QML对象可以对不同的属性动画使用不同的缓和曲线。缓和曲线提供了多种属性来进行控制曲线，例如振幅amplitude、过冲overshoot、周期period和贝赛尔曲线bezierCurve等。不过，有些属性只能在特定的曲线中使用。</p>
</li>
<li><p>其他动画类型：QML还提供了几个在设置动画时很有用的类型：PauseAnimation在动画执行时暂停；ScriptAction在动画过程中执行JavaScript，可以和StateChangeScript一起使用，从而重用现有脚本；PropertyAction在动画中立即修改一个属性的值，属性改变时不使用动画。</p>
</li>
<li><p>特定属性类型的动画：SmoothedAnimation一个特定的NumberAnimation类型，当目标值改变时会在动画中提供一个平滑的过渡效果；SpringAnimation一个类似弹簧的动画，并制定了mass、damping和epsilon等特性；ParentAnimation用来在父项目改变时产生动画效果；AnchorAnimation用来在锚改变时产生动画。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="Widgets-1"><a href="#Widgets-1" class="headerlink" title="Widgets"></a>Widgets</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong>架构</strong></h4><p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711085456826.png" alt="image-20250711085456826"></p>
<p><strong>1. 模型 Model：表示数据</strong></p>
<ul>
<li><p><strong>QAbstractItemModel</strong> 类供视图和委托来访问数据。</p>
<p>该类还提供接口处理视图，这些视图将数据表现为<strong>表格 QAbstractTableModel</strong>、<strong>列表 QAbstractListModel</strong> 和 <strong>树</strong> 等形式。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711090558672.png" alt="image-20250711090558672"></p>
</li>
<li><p><strong>QStringListModel</strong></p>
<p>用来存储一个简单的QString项目列表</p>
</li>
<li><p><strong>QStandardItemModel</strong></p>
<p>管理复杂的树型结构数据项，每一个数据项可以包含任意的数据；</p>
</li>
<li><p><strong>QFileSystemModel</strong></p>
<p>提供了本地文件系统中文件和目录的信息，可以和QListView或者QTreeView一起使用来显示一个目录中内容；</p>
</li>
<li><p><strong>QSqlQueryModel、QSqlTableModel和QSqlRelationalTableModel</strong></p>
<p>用来访问数据库。</p>
</li>
<li><p>其他</p>
<p>还可以子类化<strong>QAbstractItemModel</strong>、<strong>QAbstractListModel</strong>或者<strong>QAbstractTableModel</strong>来创建自定义的模型。</p>
</li>
</ul>
<p><strong>1.1模型索引</strong></p>
<p>目的：为了确保数据的表示与数据的获取相分离。</p>
<p>每一块可以通过模型获取的数据都使用一个模型索引来表示，视图和委托使用这些索引来请求数据项并显示。</p>
<p>模型索引包含一个指针，指向创建它们的模型，当使用多个模型时可以避免混淆。</p>
<p><strong>QModelIndex</strong> 类，一块数据的临时引用，可以用来检索或者修改模型中的数据。</p>
<p>因为模型随时可能对内部的结构进行重新组织，这样模型索引可能失效，所以不需要也不应该存储模型索引。</p>
<p><strong>QPersistentModelIndex</strong> 类创建模型索引：对一块数据进行长时间的引用。</p>
<p>如果要获得一个数据项的模型索引，必须指定模型的3个属性：行号、列号和父项的模型索引，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QModelIndex index = model-&gt;<span class="built_in">index</span>(row, column, parent);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>1.2 行和列</strong></p>
<p>行号和列号都是从<strong>0</strong>开始的，<strong>列表模型和表格模型的所有数据项都是以根项（Root item）为父项的</strong>，这些数据项都可以被称为<strong>顶层数据项（Top level item）</strong>，在获取这些数据项的索引时，父项的模型索引可以用<code>QModelIndex()</code>表示。</p>
<p>例如：</p>
<p>Table Model中的A、B、C这3项的模型索引可以用如下代码获取</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QModelIndex indexA = model-&gt;<span class="built_in">index</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexB = model-&gt;<span class="built_in">index</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br><span class="line">QModelIndex indexC = model-&gt;<span class="built_in">index</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="built_in">QModelIndex</span>());</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711092210171.png" alt="image-20250711092210171"></p>
<hr>
<p><strong>1.3 项角色</strong></p>
<p>模型中的数据项可以作为各种角色在其他组件中使用，允许为不同的情况提供不同类型的数据。</p>
<p>例如：</p>
<p><strong>Qt::DisplayRole</strong>用于访问一个字符串，所以可以作为文本显示在视图中</p>
<p>通常情况下，数据项包含了一些不同角色的数据，这些标准的角色由<strong>枚举类型Qt::ItemDataRole</strong>来定义，常用的角色包括<strong>Qt::DisplayRole、Qt::EditRole和Qt::DecorationRole</strong>等。</p>
<p>通过为每个角色提供适当的项目数据，模型可以为视图和委托提供提示，告知数据应该怎样展示给用户。</p>
<p>角色指出了从模型中引用数据的类型；视图可以使用不同的方式来显示不同的角色；不同类型的视图也可以自由的解析或者忽略这些角色信息。</p>
<p>通过向模型指定<strong>相关数据项对应的模型索引以及特定的角色</strong>来获取需要的类型的数据，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QVariant value = model-&gt;data(index, role);</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711092844588.png" alt="image-20250711092844588"></p>
<hr>
<p><strong>1.4 示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTreeView&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建标准项模型</span></span><br><span class="line">    QStandardItemModel model;</span><br><span class="line">    <span class="comment">// 获取模型的根项（Root Item），根项是不可见的</span></span><br><span class="line">    QStandardItem *parentItem = model.<span class="built_in">invisibleRootItem</span>();</span><br><span class="line">    <span class="comment">// 创建标准项item0，并设置显示文本，图标和工具提示</span></span><br><span class="line">    QStandardItem *item0 = <span class="keyword">new</span> QStandardItem;</span><br><span class="line">    item0-&gt;<span class="built_in">setText</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap0</span><span class="params">(<span class="number">50</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">    pixmap<span class="number">0.f</span>ill(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    item0-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(pixmap0));</span><br><span class="line">    item0-&gt;<span class="built_in">setToolTip</span>(<span class="string">&quot;indexA&quot;</span>);</span><br><span class="line">    <span class="comment">// 将创建的标准项作为根项的子项</span></span><br><span class="line">    parentItem-&gt;<span class="built_in">appendRow</span>(item0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第二个项(B)作为A的子项</span></span><br><span class="line">    parentItem = item0;</span><br><span class="line">    <span class="comment">// 创建新的标准项，它将作为item0的子项</span></span><br><span class="line">    QStandardItem *item1 = <span class="keyword">new</span> QStandardItem;</span><br><span class="line">    item1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap1</span><span class="params">(<span class="number">50</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line">    pixmap<span class="number">1.f</span>ill(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    item1-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(pixmap1));</span><br><span class="line">    item1-&gt;<span class="built_in">setToolTip</span>(<span class="string">&quot;indexB&quot;</span>);</span><br><span class="line">    parentItem-&gt;<span class="built_in">appendRow</span>(item1);</span><br><span class="line">    <span class="comment">// 在树视图中显示模型</span></span><br><span class="line">    QTreeView view;</span><br><span class="line">    view.<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line">    view.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711094522476.png" alt="image-20250711094522476"></p>
<hr>
<p><strong>2. 视图 View：显示数据</strong></p>
<p><strong>QAbstractItemView</strong></p>
<p>视图包含了模型中的数据项，并将它们呈现给用户，而数据的表示方法可能与底层用于存储数据项的数据结构完全不同。</p>
<p>视图通常管理从模型获取的数据的整体布局，它们可以自己渲染独立的数据项，也可以使用委托来处理渲染和编辑。</p>
<p>Qt提供了几种不同类型的视图：这些类都是基于<strong>QAbstractItemView</strong>抽象基类</p>
<ul>
<li>QListView将数据项显示为一个列表；</li>
<li>QTableView将模型中的数据显示在一个表格中；</li>
<li>QTreeView将模型的数据项显示在具有层次的列表中。</li>
<li><strong>QTableView和QTreeView，在显示项目的同时还可以显示头部</strong></li>
</ul>
<hr>
<p>视图还处理项目间的导航，以及项目选择的一些功能。</p>
<p>视图也实现了一些基本的用户接口特性，比如上下文菜单和拖放等。</p>
<p>视图可以为项目提供默认的编辑实现，当然也可以和委托一起来提供一个自定义的编辑器。</p>
<p>视图中的项目选择的行为和模式通过如下枚举类型进行设置：</p>
<ul>
<li><p>选择行为<strong>QAbstractItemView::SelectionBehavior</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711095539152.png" alt="image-20250711095539152"></p>
</li>
<li><p>选择模式<strong>QAbstractItemView::SelectionMode</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711095555888.png" alt="image-20250711095555888"></p>
</li>
</ul>
<p>在视图中被选择的项目的信息存储在一个<strong>QItemSelectionModel</strong>实例中，这样被选择的项目的模型索引便保持在一个独立的模型中，与所有的视图都是独立的。当在一个模型上设置多个视图时，就可以实现在多个视图之间共享选择。</p>
<p>标准的视图类中提供了默认的选择模型，可以在大多数的应用中直接使用。属于一个视图的选择模型可以使用这个视图的selectionModel()函数获得，而且还可以在多个视图之间使用setSelectionModel()函数来共享该选择模型，所以一般不需要重新构建一个选择模型。下面通过例子来看一下选择模型的使用。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTableView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模型并填充数据</span></span><br><span class="line">    QStandardItemModel *model = <span class="keyword">new</span> <span class="built_in">QStandardItemModel</span>(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">10</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">3</span>; ++col) &#123;</span><br><span class="line">            QStandardItem *item = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QString</span>(<span class="string">&quot;行%1 列%2&quot;</span>).<span class="built_in">arg</span>(row).<span class="built_in">arg</span>(col));</span><br><span class="line">            model-&gt;<span class="built_in">setItem</span>(row, col, item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建视图并设置模型</span></span><br><span class="line">    QTableView *tableView = <span class="keyword">new</span> QTableView;</span><br><span class="line">    tableView-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置选择</span></span><br><span class="line">    QItemSelectionModel *selectionModel = tableView-&gt;<span class="built_in">selectionModel</span>();</span><br><span class="line">    QModelIndex topLeft = model-&gt;<span class="built_in">index</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    QModelIndex bottomRight = model-&gt;<span class="built_in">index</span>(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="function">QItemSelection <span class="title">selection</span><span class="params">(topLeft, bottomRight)</span></span>;</span><br><span class="line">    selectionModel-&gt;<span class="built_in">select</span>(selection, QItemSelectionModel::Select);</span><br><span class="line"></span><br><span class="line">    tableView-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711095926287.png" alt="image-20250711095926287"></p>
<hr>
<p><strong>3. 委托，代理 Delegate：渲染数据</strong></p>
<p>一般的，视图用来将模型中的数据展示给用户，也用来处理用户的输入。但为了获得更高的灵活性，交互可以由委托来执行。</p>
<p>这些委托组件提供了输入功能，而且也负责渲染一些视图中的个别项目。控制委托的标准接口在QAbstractItemDelegate类中定义。</p>
<p><strong>QAbstractItemDelegate 默认的委托实现</strong></p>
<ul>
<li><strong>QItemDelegate</strong>：</li>
<li><strong>QStyledItemDelegate</strong></li>
</ul>
<p>委托通过实现**paint()和sizeHint()**函数来使它们可以渲染自身的内容。</p>
<p>委托的编辑器可以通过两种方式来实现</p>
<ul>
<li>一种是使用部件来管理编辑过程，</li>
<li>一种是直接处理事件。</li>
</ul>
<p>Qt中的标准视图都使用<strong>QStyledItemDelegate</strong>的实例来提供编辑功能，这种委托接口的默认实现为<strong>QListView、QTableView和QTreeView</strong>等标准视图的每一个项目提供了普通风格的渲染。</p>
<p>可以使用**itemDelegate()<strong>函数获取一个视图中使用的委托，使用</strong>setItemDelegate()**函数可以为一个视图安装一个自定义委托。</p>
<p><strong>示例：</strong></p>
<p>向项目中添加新的C++类，类名为SpinBoxDelegate，基类设置为QStyledItemDelegate。完成后将<strong>spinboxdelegate.h</strong>文件内容更改如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPINBOXDELEGATE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPINBOXDELEGATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStyledItemDelegate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSpinBox&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpinBoxDelegate</span> : <span class="keyword">public</span> QStyledItemDelegate</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SpinBoxDelegate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须重写的四个函数</span></span><br><span class="line">    <span class="function">QWidget *<span class="title">createEditor</span><span class="params">(QWidget *parent, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setEditorData</span><span class="params">(QWidget *editor, <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelData</span><span class="params">(QWidget *editor, QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateEditorGeometry</span><span class="params">(QWidget *editor, <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SPINBOXDELEGATE_H</span></span></span><br></pre></td></tr></table></figure>

<p>下面到<strong>spinboxdelegate.cpp</strong>文件中，添加这几个函数的定义。<br>当视图需要一个编辑器时，它会告知委托来为被修改的项目提供一个编辑器部件。这里的createEditor()函数为委托设置一个合适的部件提供了所需要的一切。<br>委托必须将模型中的数据复制到编辑器中，需要为模型中不同类型的数据提供不同的编辑器，要在访问部件的成员函数以前将它转换为合适的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinboxdelegate.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SpinBoxDelegate::<span class="built_in">SpinBoxDelegate</span>(QObject *parent)</span><br><span class="line">    : <span class="built_in">QStyledItemDelegate</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QWidget *<span class="title">SpinBoxDelegate::createEditor</span><span class="params">(QWidget *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> QStyleOptionViewItem &amp;<span class="comment">/* option */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> QModelIndex &amp;<span class="comment">/* index */</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSpinBox *editor = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(parent);</span><br><span class="line">    editor-&gt;<span class="built_in">setFrame</span>(<span class="literal">false</span>);          <span class="comment">// 无边框</span></span><br><span class="line">    editor-&gt;<span class="built_in">setMinimum</span>(<span class="number">0</span>);            <span class="comment">// 最小值</span></span><br><span class="line">    editor-&gt;<span class="built_in">setMaximum</span>(<span class="number">100</span>);          <span class="comment">// 最大值</span></span><br><span class="line">    <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpinBoxDelegate::setEditorData</span><span class="params">(QWidget *editor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = index.<span class="built_in">model</span>()-&gt;<span class="built_in">data</span>(index, Qt::EditRole).<span class="built_in">toInt</span>();</span><br><span class="line">    QSpinBox *spinBox = <span class="built_in">static_cast</span>&lt;QSpinBox*&gt;(editor);</span><br><span class="line">    spinBox-&gt;<span class="built_in">setValue</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpinBoxDelegate::setModelData</span><span class="params">(QWidget *editor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   QAbstractItemModel *model,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> QModelIndex &amp;index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSpinBox *spinBox = <span class="built_in">static_cast</span>&lt;QSpinBox*&gt;(editor);</span><br><span class="line">    spinBox-&gt;<span class="built_in">interpretText</span>();  <span class="comment">// 确保获取最新值</span></span><br><span class="line">    <span class="type">int</span> value = spinBox-&gt;<span class="built_in">value</span>();</span><br><span class="line">    model-&gt;<span class="built_in">setData</span>(index, value, Qt::EditRole);  <span class="comment">// 更新模型数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpinBoxDelegate::updateEditorGeometry</span><span class="params">(QWidget *editor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> QStyleOptionViewItem &amp;option,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> QModelIndex &amp;<span class="comment">/* index */</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    editor-&gt;<span class="built_in">setGeometry</span>(option.rect);  <span class="comment">// 编辑器覆盖单元格区域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来使用自定义的委托：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpinBoxDelegate *delegate = <span class="keyword">new</span> <span class="built_in">SpinBoxDelegate</span>(<span class="keyword">this</span>);</span><br><span class="line">tableView-&gt;<span class="built_in">setItemDelegate</span>(delegate);</span><br></pre></td></tr></table></figure>

<p>编辑完成后，委托应该为其他组件提供提示，告知它们编辑操作的结果，提供提示也有利于后续的编辑操作。这个可以通过在发射colseEditor()信号时使用合适的提示来实现，它们会被在构造编辑器时安装的默认的QStyledItemDelegate事件过滤器捕获。可以通过调整编辑器的行为来使得它更加友好。</p>
<p>对于QStyledItemDelegate提供的默认事件过滤器，如果用户在SpinBox编辑器中按下回车键，那么委托就会向模型提交数值然后关闭编辑器。可以通过在SpinBox上安装自己的事件过滤器来改变这个行为，并提供编辑提示来迎合自己的需要。</p>
<hr>
<p><strong>4.  项目视图的边便捷类</strong></p>
<p>开始引进了一些标准部件来提供经典的基于项的容器部件，它们底层是通过模型&#x2F;视图框架实现的。这些部件分别是：****</p>
<ul>
<li>QListWidget提供了一个项目列表；</li>
<li>QTreeWidget显示了一个多层次的树结构；</li>
<li>QTableWidget提供了一个以项目作为单元的表格。</li>
</ul>
<p><strong>它们都继承了QAbstractItemView类的行为，适合于少量的数据的存储和显示</strong></p>
<p><strong>因为它们没有将视图和模型进行分离，所以没有视图类灵活，不能和任意的模型一起使用，一般建议使用模型&#x2F;视图的方式来处理数据。</strong></p>
<p><strong>示例：</strong></p>
<p>单层的项目列表一般使用一个QListWidget和一些QListWidgetItem来显示，一个列表部件可以像一般的窗口部件那样进行创建。可以在创建QListWidgetItem时将它直接添加到已经创建的列表部件中，也可以稍后使用QListWidget类的insertItem()函数来添加。</p>
<p>列表中的每一个项目都可以显示一个文本标签和一个图标，还可以为其设置工具提示、状态提示和“What’s This?”提示。<br>默认的，列表中的项目会根据它们添加的顺序进行排序，也可以使用sortItems()函数对项目进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QListWidget listWidget;</span><br><span class="line">// 一种添加项目的简便方法</span><br><span class="line">new QListWidgetItem(&quot;a&quot;, &amp;listWidget);</span><br><span class="line">// 添加项目的另一种方法，这样还可以进行各种设置</span><br><span class="line">QListWidgetItem *listWidgetItem = new QListWidgetItem;</span><br><span class="line">listWidgetItem-&gt;setText(&quot;b&quot;);</span><br><span class="line">listWidgetItem-&gt;setIcon(QIcon(&quot;../listwidget/yafeilinux.png&quot;));</span><br><span class="line">listWidgetItem-&gt;setToolTip(&quot;this is b!&quot;);</span><br><span class="line">listWidget.insertItem(1, listWidgetItem);</span><br><span class="line">// 设置排序为倒序</span><br><span class="line">listWidget.sortItems(Qt::DescendingOrder);</span><br><span class="line">// 显示列表部件</span><br><span class="line">listWidget.show();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="数据库应用"><a href="#数据库应用" class="headerlink" title="数据库应用"></a>数据库应用</h4><p><strong>1. 简介</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711110039212.png" alt="image-20250711110039212"></p>
<ul>
<li>驱动层为具体的数据库和SQL接口层之间提供了底层的桥梁；</li>
<li>SQL接口层提供了对数据库的访问，其中的QSqlDatabase类用来创建连接，QSqlQuery类可以使用SQL语句来实现与数据库交互，其他几个类对该层提供了支持；</li>
<li>用户接口层的几个类实现了将数据库中的数据链接到窗口部件上，这些类是使用前面讲到的模型&#x2F;视图框架实现的，它们是更高层次的抽象，即便不熟悉SQL也可以操作数据库。</li>
</ul>
<p>要使用Qt SQL模块中的这些类，需要在项目文件（<strong>.pro</strong>文件）中添加一行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += sql</span><br></pre></td></tr></table></figure>

<p><strong>2. 驱动</strong></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711110152280.png" alt="image-20250711110152280"></p>
<p><strong>SQLite数据库</strong>，它是一款<strong>轻型的文件型数据库</strong>，无需数据库服务器，主要应用于嵌入式领域，支持跨平台，而且Qt对它提供了很好的默认支持，所以在本章后面的内容将使用该数据库为例进行讲解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringList&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Available drivers:&quot;</span>;</span><br><span class="line">    QStringList drivers = QSqlDatabase::<span class="built_in">drivers</span>();</span><br><span class="line">    foreach(QString driver, drivers)</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; driver;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了**QSqlDatabase类的静态函数drivers()**获取了可用的驱动列表，然后将它们遍历输出。</p>
<p>运行程序，在应用程序输出栏可以看到输出的结果为：<strong>QSQLITE、QODBC和QPSQL</strong>，表明现在仅支持这3个驱动。其实，也可以在Qt安装目录下的plugins&#x2F;sqldrivers文件夹中看到所有的驱动插件文件。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711110648300.png" alt="image-20250711110648300"></p>
<hr>
<p><strong>3. 创建数据库连接</strong></p>
<p>要想使用<strong>QSqlQuery或者QSqlQueryModel</strong>访问数据库，那么先要创建并打开一个或者多个数据库连接。</p>
<p>数据库连接使用连接名来定义，可以向相同的数据库创建多个连接。<strong>QSqlDatabase</strong>也支持默认连接的概念，默认连接就是一个没有命名的连接。</p>
<p>在使用QSqlQuery或者QSqlQueryModel的成员函数时需要指定一个<strong>连接名</strong>作为参数，如果没有指定，那么就会使用默认连接。</p>
<p>要移除一个数据库连接，需要先使用**QSqlDatabase::close()<strong>关闭数据库，然后使用静态函数</strong>QSqlDatabase::removeDatabase()**移除该连接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>);</span><br><span class="line">db.<span class="built_in">setHostName</span>(<span class="string">&quot;bigblue&quot;</span>);</span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;flightdb&quot;</span>);</span><br><span class="line">db.<span class="built_in">setUserName</span>(<span class="string">&quot;acarlson&quot;</span>);</span><br><span class="line">db.<span class="built_in">setPassword</span>(<span class="string">&quot;1uTbSbAs&quot;</span>);</span><br><span class="line"><span class="type">bool</span> ok = db.<span class="built_in">open</span>();</span><br></pre></td></tr></table></figure>

<p>下面的示例代码中创建了两个名为first和second的连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase firstDB = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>, <span class="string">&quot;first&quot;</span>);</span><br><span class="line">QSqlDatabase secondDB = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QMYSQL&quot;</span>, <span class="string">&quot;second&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以在任何地方使用QSqlDatabase::database()静态函数通过连接名称获取指向数据库连接的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase defaultDB = QSqlDatabase::<span class="built_in">database</span>();</span><br><span class="line">QSqlDatabase firstDB = QSqlDatabase::<span class="built_in">database</span>(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">QSqlDatabase secondDB = QSqlDatabase::<span class="built_in">database</span>(<span class="string">&quot;second&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>完整连接：</strong></p>
<p>添加新的C++头文件<strong>connection.h</strong>，这个头文件中添加了一个建立连接的函数，使用这个头文件的目的主要是为了简化主函数中的内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONNECTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMessageBox&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">createConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line">    db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;:memory:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!db.<span class="built_in">open</span>()) &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">critical</span>(<span class="number">0</span>, <span class="string">&quot;Cannot open database&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Unable to establish a database connection.&quot;</span>, QMessageBox::Cancel);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;create table student (id int primary key, &quot;</span></span><br><span class="line">               <span class="string">&quot;name varchar(20))&quot;</span>);</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;insert into student values(0, &#x27;LiMing&#x27;)&quot;</span>);</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;insert into student values(1, &#x27;LiuTao&#x27;)&quot;</span>);</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;insert into student values(2, &#x27;WangHong&#x27;)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// CONNECTION_H</span></span></span><br></pre></td></tr></table></figure>

<p>这里先创建了一个SQLite数据库的默认连接，设置数据库名称时使用了“<strong>:memory:</strong>”，表明这个是建立在<strong>内存中</strong>的数据库（SQLite数据库支持内存中的临时数据库），也就是说该数据库只在程序运行期间有效，等程序运行结束时就会将其销毁。当然，也可以将其改为一个具体的数据库名称，比如my.db，这样就会在项目生成目录中创建该数据库文件。</p>
<p><strong>调用：</strong></p>
<p>调用createConnection()函数来创建数据库连接，使用QSqlQuery查询整张表并将其所有内容进行输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;connection.h&quot;</span>  <span class="comment">// 包含数据库连接头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建数据库连接并插入数据</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">createConnection</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;数据库连接失败，程序退出&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 连接失败退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查询并显示数据</span></span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;学生信息表:&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ID\t姓名&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;----------------&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> id = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        QString name = query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; id &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;\n数据库操作完成！&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 保持程序运行（如果需要GUI组件）</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>4. 执行SQL语句</strong></p>
<ul>
<li><p>执行一个查询。QSqlQuery类提供了一个接口，用于执行SQL语句和浏览查询的结果集。要执行一个SQL语句，只需要简单的创建一个QSqlQuery对象，然后调用QSqlQuery::exec()函数即可，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">query.exec(&quot;select * from student&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览结果集。当执行完exec()函数后，QSqlQuery的内部指针会位于第一条记录前面的位置。必须调用一次QSqlQuery::next()函数来使其前进到第一条记录，然后可以重复使用next()函数来访问其他的记录，直到该函数的返回值为false，例如可以使用以下代码来遍历一个结果集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(query.next()) &#123;</span><br><span class="line">qDebug() &lt;&lt; query.value(0).toInt() </span><br><span class="line">      	    &lt;&lt; query.value(1).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>**QSqlQuery::value()**函数可以返回当前记录的一个字段值。比如value(0)就是第一个字段的值，各个字段从0开始编号。该函数返回一个QVariant，不同的数据库类型会自动映射为Qt中最接近的相应类型，这里的toInt()和toString()就是将QVariant转换为int和QString类型。另外，next()函数定位到下一条记录，previous()定位到前一条记录，first()定位的第一条记录，last()定位到最后一条记录，seek(n)定位到第n条记录。</p>
<ul>
<li><p>插入一条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.exec(&quot;insert into student (id, name) values (100, &#x27;ChenYun&#x27;)&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果想在同一时间插入多条记录，那么一个有效的方法就是将查询语句和真实的值分离，这可以使用占位符来完成。Qt支持两种占位符：名称绑定和位置绑定。</p>
<ul>
<li><p>名称绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query.prepare(&quot;insert into student (id, name) values (:id, :name)&quot;);</span><br><span class="line">int idValue = 100;</span><br><span class="line">QString nameValue = &quot;ChenYun&quot;;</span><br><span class="line">query.bindValue(&quot;:id&quot;, idValue);</span><br><span class="line">query.bindValue(&quot;:name&quot;, nameValue);</span><br><span class="line">query.exec();</span><br></pre></td></tr></table></figure>
</li>
<li><p>位置绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query.prepare(&quot;insert into student (id, name) values (?, ?)&quot;);</span><br><span class="line">int idValue = 100;</span><br><span class="line">QString nameValue = &quot;ChenYun&quot;;</span><br><span class="line">query.addBindValue(idValue);</span><br><span class="line">query.addBindValue(nameValue);</span><br><span class="line">query.exec();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当要插入多条记录时，只需要调用QSqlQuery::prepare()一次，然后使用多次bindValue()或者addBindValue()函数来绑定需要的数据，最后调用一次exec()函数就可以了。其实，进行多条数据插入时，还可以使用批处理进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query.prepare(&quot;insert into student (id, name) values (?, ?)&quot;);</span><br><span class="line">QVariantList ids;</span><br><span class="line">ids &lt;&lt; 20 &lt;&lt; 21 &lt;&lt; 22;</span><br><span class="line">query.addBindValue(ids);</span><br><span class="line">QVariantList names;</span><br><span class="line">names &lt;&lt; &quot;xiaoming&quot; &lt;&lt; &quot;xiaoliang&quot; &lt;&lt; &quot;xiaogang&quot;;</span><br><span class="line">query.addBindValue(names);</span><br><span class="line">if(!query.execBatch()) qDebug() &lt;&lt; query.lastError();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>记录的更新和删除。它们和插入操作是相似的，并且也可以使用占位符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query.exec(&quot;update student set name = &#x27;xiaohong&#x27; where id = 20&quot;); // 更新</span><br><span class="line">query.exec(&quot;delete from student where id = 21&quot;);                  // 删除</span><br></pre></td></tr></table></figure>
</li>
<li><p>事务</p>
<p>事务可以保证一个复杂操作的原子性，就是对于一个数据库操作序列，这些操作要么全部做完，要么一条也不做，它是一个不可分割的工作单位。在Qt中，如果底层的数据库引擎支持事务，那么QSqlDriver::hasFeature(QSqlDriver::Transactions)会返回true。可以使用QSqlDatabase::transaction()来启动一个事务，然后编写一些希望在事务中执行的SQL语句，最后调用QSqlDatabase::commit()提交或者QSqlDatabase::rollback()回滚。当使用事务时必须在创建查询以前就开始事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QSqlDatabase::database().transaction();</span><br><span class="line">QSqlQuery query;</span><br><span class="line">query.exec(&quot;SELECT id FROM employee WHERE name = &#x27;Torild Halvorsen&#x27;&quot;);</span><br><span class="line">if (query.next()) &#123;</span><br><span class="line">    int employeeId = query.value(0).toInt();</span><br><span class="line">    query.exec(&quot;INSERT INTO project (id, name, ownerid) &quot;</span><br><span class="line">               &quot;VALUES (201, &#x27;Manhattan Project&#x27;, &quot;</span><br><span class="line">               + QString::number(employeeId) + &#x27;)&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">QSqlDatabase::database().commit();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>完整增删改查：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QInputDialog&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;connection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlError&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示所有学生信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showAllStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;SELECT * FROM student&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;\n学生列表:&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ID\t姓名&quot;</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;----------------&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> id = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        QString name = query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; id &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加学生</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    QString name = QInputDialog::<span class="built_in">getText</span>(<span class="literal">nullptr</span>, <span class="string">&quot;添加学生&quot;</span>, <span class="string">&quot;请输入学生姓名:&quot;</span>,</span><br><span class="line">                                         QLineEdit::Normal, <span class="string">&quot;&quot;</span>, &amp;ok);</span><br><span class="line">    <span class="keyword">if</span> (!ok || name.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;INSERT INTO student (name) VALUES (?)&quot;</span>);</span><br><span class="line">    query.<span class="built_in">addBindValue</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (query.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;添加成功!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;添加失败:&quot;</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除学生</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    <span class="type">int</span> id = QInputDialog::<span class="built_in">getInt</span>(<span class="literal">nullptr</span>, <span class="string">&quot;删除学生&quot;</span>, <span class="string">&quot;请输入学生ID:&quot;</span>,</span><br><span class="line">                                  <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">1</span>, &amp;ok);</span><br><span class="line">    <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;DELETE FROM student WHERE id = ?&quot;</span>);</span><br><span class="line">    query.<span class="built_in">addBindValue</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (query.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query.<span class="built_in">numRowsAffected</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除成功!&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;未找到该ID的学生&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;删除失败:&quot;</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改学生信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> ok;</span><br><span class="line">    <span class="type">int</span> id = QInputDialog::<span class="built_in">getInt</span>(<span class="literal">nullptr</span>, <span class="string">&quot;修改学生&quot;</span>, <span class="string">&quot;请输入要修改的学生ID:&quot;</span>,</span><br><span class="line">                                  <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">1</span>, &amp;ok);</span><br><span class="line">    <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    QString newName = QInputDialog::<span class="built_in">getText</span>(<span class="literal">nullptr</span>, <span class="string">&quot;修改学生&quot;</span>, <span class="string">&quot;请输入新的姓名:&quot;</span>,</span><br><span class="line">                                            QLineEdit::Normal, <span class="string">&quot;&quot;</span>, &amp;ok);</span><br><span class="line">    <span class="keyword">if</span> (!ok || newName.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;UPDATE student SET name = ? WHERE id = ?&quot;</span>);</span><br><span class="line">    query.<span class="built_in">addBindValue</span>(newName);</span><br><span class="line">    query.<span class="built_in">addBindValue</span>(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (query.<span class="built_in">exec</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query.<span class="built_in">numRowsAffected</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;修改成功!&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;未找到该ID的学生&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;修改失败:&quot;</span> &lt;&lt; query.<span class="built_in">lastError</span>().<span class="built_in">text</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数据库连接</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">createConnection</span>()) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;数据库连接失败，程序退出&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主菜单循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;\n===== 学生信息管理系统 =====&quot;</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;1. 显示所有学生&quot;</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;2. 添加学生&quot;</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;3. 删除学生&quot;</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;4. 修改学生信息&quot;</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;0. 退出&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> ok;</span><br><span class="line">        <span class="type">int</span> choice = QInputDialog::<span class="built_in">getInt</span>(<span class="literal">nullptr</span>, <span class="string">&quot;主菜单&quot;</span>, <span class="string">&quot;请选择操作:&quot;</span>,</span><br><span class="line">                                          <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, &amp;ok);</span><br><span class="line">        <span class="keyword">if</span> (!ok) choice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">showAllStudents</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">addStudent</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">deleteStudent</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">updateStudent</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;程序已退出&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;无效选择，请重新输入&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>5. SQL查询模型</strong></p>
<p>除了QSqlQuery，Qt还提供了3个更高层的类来访问数据库，分别是**QSqlQueryModel、QSqlTableModel和QSqlRelationalTableModel。**这3个类都是从QAbstractTableModel派生来的，可以很容易地实现将数据库中的数据在QListView和QTableView等视图中进行显示。</p>
<p>其中，QSqlQueryModel提供了一个基于SQL查询的只读模型。</p>
<p>其实QSqlQueryModel中存储的是执行完setQuery()函数后的结果集，所以视图中显示的是结果集的内容。</p>
<p>QSqlQueryModel中还提供了</p>
<ul>
<li>columnCount()返回一条记录中字段的个数；</li>
<li>rowCount()返回结果集中记录的条数；</li>
<li>record()返回第n条记录；</li>
<li>index()返回指定记录的指定字段的索引；</li>
<li>clear()可以清空模型中的结果集。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSqlQueryModel *model = new QSqlQueryModel(this);</span><br><span class="line">model-&gt;setQuery(&quot;select * from student&quot;);</span><br><span class="line">model-&gt;setHeaderData(0, Qt::Horizontal, tr(&quot;学号&quot;));</span><br><span class="line">model-&gt;setHeaderData(1, Qt::Horizontal, tr(&quot;姓名&quot;));</span><br><span class="line">model-&gt;setHeaderData(2, Qt::Horizontal, tr(&quot;课程&quot;));</span><br><span class="line">QTableView *view = new QTableView(this);</span><br><span class="line">view-&gt;setModel(model);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>6. 表格模型</strong></p>
<p>QSqlTableModel提供了一个一次只能操作一个SQL表的读写模型，它是QSqlQuery的更高层次的替代品，可以浏览和修改独立的SQL表，并且只需编写很少的代码，而且不需要了解SQL语法。该模型默认是可读可写的，如果想让其成为只读的，那么可以从视图进行设置，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);</span><br></pre></td></tr></table></figure>

<p>创建一个QSqlTableModel后，只需使用setTable()来为其指定数据库表，然后使用select()函数进行查询，调用这两个函数就等价于执行了**“select * from student”**这个SQL语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model = new QSqlTableModel(this);</span><br><span class="line">model-&gt;setTable(&quot;student&quot;);</span><br><span class="line">model-&gt;select();</span><br><span class="line">// 设置编辑策略</span><br><span class="line">model-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit);</span><br><span class="line">ui-&gt;tableView-&gt;setModel(model);</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711113200532.png" alt="image-20250711113200532"></p>
<p>先来看提交修改操作。可以使用事务，如果使用submitAll()将模型中的修改向数据库提交成功，那么执行commit()；否则进行回滚rollback()，并提示错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_pushButton_clicked() // 提交修改按钮</span><br><span class="line">&#123;</span><br><span class="line">    // 开始事务操作</span><br><span class="line">    model-&gt;database().transaction();</span><br><span class="line">    if (model-&gt;submitAll()) &#123;</span><br><span class="line">        if(model-&gt;database().commit())   // 提交</span><br><span class="line">            QMessageBox::information(this, tr(&quot;tableModel&quot;),</span><br><span class="line">                                     tr(&quot;数据修改成功！&quot;));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        model-&gt;database().rollback();    // 回滚</span><br><span class="line">        QMessageBox::warning(this, tr(&quot;tableModel&quot;),</span><br><span class="line">                           tr(&quot;数据库错误: %1&quot;).arg(model-&gt;lastError().text()),</span><br><span class="line">                           QMessageBox::Ok);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要撤销修改，可以简单调用了revertAll()函数将模型中的修改进行恢复。</p>
<p>可以使用setFilter()函数来进行数据筛选：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_pushButton_7_clicked() &#123;</span><br><span class="line">    QString name = ui-&gt;lineEdit-&gt;text();</span><br><span class="line">    // 根据姓名进行筛选，一定要使用单引号</span><br><span class="line">    model-&gt;setFilter(QString(&quot;name = &#x27;%1&#x27;&quot;).arg(name));</span><br><span class="line">    model-&gt;select();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，筛选的字符串中“%1”必须用单引号括起来。</p>
<p>可以使用setSort()函数来对指定的字段进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_pushButton_5_clicked() // 按id升序排列按钮</span><br><span class="line">&#123;</span><br><span class="line">    model-&gt;setSort(0, Qt::AscendingOrder); //id字段，即第0列，升序排列</span><br><span class="line">    model-&gt;select();</span><br><span class="line">&#125;</span><br><span class="line">void MainWindow::on_pushButton_6_clicked() // 按id降序排列按钮</span><br><span class="line">&#123;</span><br><span class="line">    model-&gt;setSort(0, Qt::DescendingOrder);</span><br><span class="line">    model-&gt;select();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以调用removeRow()来删除行，这时该行的最前面会显示“！”号。<br>在删除行时会弹出一个对话框，提示是否确定要删除该行，如果确定删除，那么就执行submitAll()函数进行提交修改，否则执行revertAll()函数进行恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_pushButton_4_clicked() // 删除选中行按钮</span><br><span class="line">&#123;   </span><br><span class="line">    int curRow = ui-&gt;tableView-&gt;currentIndex().row(); // 获取选中的行</span><br><span class="line">    model-&gt;removeRow(curRow);   // 删除该行</span><br><span class="line">    int ok = QMessageBox::warning(this,tr(&quot;删除当前行!&quot;),</span><br><span class="line">          tr(&quot;你确定删除当前行吗？&quot;), QMessageBox::Yes, QMessageBox::No);</span><br><span class="line">    if(ok == QMessageBox::No)</span><br><span class="line">    &#123;         // 如果不删除，则撤销</span><br><span class="line">        model-&gt;revertAll();</span><br><span class="line">    &#125; else &#123; // 否则提交，在数据库中删除该行</span><br><span class="line">        model-&gt;submitAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以使用insertRow()插入一行，使用setData()可以为一个字段设置值。注意，因为id为主键，所以必须为其提供一个id值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_pushButton_3_clicked()    // 添加记录按钮</span><br><span class="line">&#123;   </span><br><span class="line">    int rowNum = model-&gt;rowCount();           // 获得表的行数</span><br><span class="line">    int id = 10;</span><br><span class="line">    model-&gt;insertRow(rowNum);                  // 添加一行</span><br><span class="line">    model-&gt;setData(model-&gt;index(rowNum,0), id);</span><br><span class="line">    //model-&gt;submitAll();                      // 可以直接提交</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>7. SQL关系表格模型</strong></p>
<p>QSqlRelationalTableModel继承自QSqlTableModel，并且对其进行了扩展，提供了对外键的支持。一个外键就是一个表中的一个字段和其他表中的主键字段之间的一对一的映射。例如，student表中的course字段对应的是course表中的id字段，那么就称字段course是一个外键。因为这里的course字段的值是一些数字，这样的显示很不友好，使用关系表格模型，就可以将它显示为course表中的name字段的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QSqlRelationalTableModel *model = new QSqlRelationalTableModel(this);</span><br><span class="line">model-&gt;setTable(&quot;student&quot;);</span><br><span class="line">model-&gt;setRelation(2, QSqlRelation(&quot;course&quot;, &quot;id&quot;, &quot;name&quot;));</span><br><span class="line">model-&gt;select();</span><br><span class="line">QTableView *view = new QTableView(this);</span><br><span class="line">view-&gt;setModel(model);</span><br><span class="line">setCentralWidget(view);</span><br></pre></td></tr></table></figure>

<p>Qt中还提供了一个QSqlRelationalDelegate委托类，它可以为QSqlRelationalTableModel显示和编辑数据。这个委托为一个外键提供了一个QComboBox部件来显示所有可选的数据，这样就显得更加人性化了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-&gt;setItemDelegate(new QSqlRelationalDelegate(view));</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h4 id="XML应用"><a href="#XML应用" class="headerlink" title="XML应用"></a>XML应用</h4><p>XML(Extensible Markup Language，可扩展标记语言)，是一种类似于HTML的标记语言，设计目的是用来传输数据，而不是显示数据。</p>
<p>从Qt 5开始，推荐使用Qt Core模块中的<strong>QXmlStreamReader</strong>和<strong>QXmlStreamWriter</strong>进行XML读取和写入，这是一种基于流的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;library&gt;</span><br><span class="line">    &lt;book id=&quot;01&quot;&gt;</span><br><span class="line">        &lt;title&gt;Qt&lt;/title&gt;</span><br><span class="line">        &lt;author&gt;shiming&lt;/author&gt;</span><br><span class="line">    &lt;/book&gt;</span><br><span class="line">    &lt;book id=&quot;02&quot;&gt;</span><br><span class="line">        &lt;title&gt;Linux&lt;/title&gt;</span><br><span class="line">        &lt;author&gt;yafei&lt;/author&gt;</span><br><span class="line">    &lt;/book&gt;</span><br><span class="line">&lt;/library&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个XML文档都由XML声明语句（或者称为XML序言）开始，它是对XML文档处理的环境和要求的说明，比如这里的<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>，其中xml version&#x3D;“1.0”，表明使用的XML的版本号，这里字母是区分大小写的；encoding&#x3D;“UTF-8”是使用的编码。</li>
<li>XML文档内容由多个元素组成，一个元素由起始标签&lt;标签名&gt;、终止标签&lt;&#x2F;标签名&gt;以及两个标签之间的内容组成。文档中第一个元素被称为根元素，比如这里的<code>&lt;library&gt;&lt;/library&gt;</code>，XML文档必须有且只有一个根元素。</li>
<li>元素的名称是区分大小写的，元素还可以嵌套，比如这里的library、book、title和author等都是元素。</li>
<li>元素可以包含属性，用来描述元素的相关信息，属性名和属性值在元素的起始标签中给出，格式为&lt;元素名 属性名&#x3D;“属性值”&gt;，如<code>&lt;book id=&quot;01&quot;&gt;</code>，属性值必须在单引号或者双引号中。</li>
<li>在元素中可以包含子元素，也可以只包含文本内容，比如这里的<code>&lt;title&gt;Qt&lt;/title&gt;</code>中的Qt就是文本内容。</li>
</ul>
<hr>
<p><strong>1. QXmlStreamReader</strong></p>
<ul>
<li>QXmlStreamReader可以从QIODevice或者QByteArray中读取数据。流读取器的基本原理就是将XML文档报告为一个记号（tokens）流，应用程序代码自身来驱动循环，在需要的时候可以从读取器中一个接一个的拉出记号。这个是通过调用readNext()函数实现的，它可以读取下一个记号，然后返回一个记号类型，它由枚举类型QXmlStreamReader::TokenType定义。</li>
</ul>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711113857785.png" alt="image-20250711113857785"></p>
<ul>
<li>可以使用isStartElement()和text()等函数来判断这个记号是否包含需要的信息。使用这种主动拉取记号的方式最大的好处就是可以构建递归解析器，也就是可以在不同的函数或者类中来处理XML文档中的不同记号。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QFile file(&quot;../myxmlstream/my.xml&quot;);</span><br><span class="line">if (!file.open(QFile::ReadOnly | QFile::Text))</span><br><span class="line">&#123;</span><br><span class="line">    qDebug()&lt;&lt;&quot;Error: cannot open file&quot;;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">QXmlStreamReader reader;</span><br><span class="line">// 设置文件，这时会将流设置为初始状态</span><br><span class="line">reader.setDevice(&amp;file);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 如果没有读到文档结尾，而且没有出现错误</span><br><span class="line">while (!reader.atEnd()) &#123;</span><br><span class="line">    // 读取下一个记号，它返回记号的类型</span><br><span class="line">    QXmlStreamReader::TokenType type = reader.readNext();</span><br><span class="line">    // 下面便根据记号的类型来进行不同的输出</span><br><span class="line">    if (type == QXmlStreamReader::StartDocument)</span><br><span class="line">        qDebug() &lt;&lt; reader.documentEncoding() &lt;&lt; reader.documentVersion();</span><br><span class="line">    if (type == QXmlStreamReader::StartElement) &#123;</span><br><span class="line">        qDebug() &lt;&lt; &quot;&lt;&quot; &lt;&lt; reader.name() &lt;&lt; &quot;&gt;&quot;;</span><br><span class="line">        if (reader.attributes().hasAttribute(&quot;id&quot;))</span><br><span class="line">            qDebug() &lt;&lt; reader.attributes().value(&quot;id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (type == QXmlStreamReader::EndElement)</span><br><span class="line">        qDebug() &lt;&lt; &quot;&lt;/&quot; &lt;&lt; reader.name() &lt;&lt; &quot;&gt;&quot;;</span><br><span class="line">    if (type == QXmlStreamReader::Characters &amp;&amp; !reader.isWhitespace())</span><br><span class="line">        qDebug() &lt;&lt; reader.text();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 如果读取过程中出现错误，那么输出错误信息</span><br><span class="line">if (reader.hasError()) &#123;</span><br><span class="line">    qDebug() &lt;&lt; &quot;error: &quot; &lt;&lt; reader.errorString();</span><br><span class="line">&#125;</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. QXmlStreamWriter</strong></p>
<ul>
<li><p>与QXmlStreamReader对应的是QXmlStreamWriter，它通过一个简单的流API提供了一个XML写入器。QXmlStreamWriter的使用也是十分简单的，只需要调用相应的记号的写入函数来写入相关数据即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QFile file(&quot;../myxmlstream/my2.xml&quot;);</span><br><span class="line">if (!file.open(QFile::WriteOnly | QFile::Text))</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; &quot;Error: cannot open file&quot;;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">QXmlStreamWriter stream(&amp;file);</span><br><span class="line">stream.setAutoFormatting(true);</span><br><span class="line">stream.writeStartDocument();</span><br><span class="line">stream.writeStartElement(&quot;bookmark&quot;);</span><br><span class="line">stream.writeAttribute(&quot;href&quot;, &quot;https://www.qt.io/&quot;);</span><br><span class="line">stream.writeTextElement(&quot;title&quot;, &quot;Qt Home&quot;);</span><br><span class="line">stream.writeEndElement();</span><br><span class="line">stream.writeEndDocument();</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure>

<p>这里使用了setAutoFormatting(true)函数来自动设置格式，这样会自动换行和添加缩进。然后使用了writeStartDocument()，该函数会自动添加首行的XML声明，添加元素可以使用writeStartElement()，要注意，一定要在元素的属性、文本等添加完成后，使用writeEndElement()来关闭前一个打开的元素。在最后使用writeEndDocument()来完成文档的写入。</p>
</li>
</ul>
<hr>
<hr>
<h3 id="Quick-1"><a href="#Quick-1" class="headerlink" title="Quick"></a>Quick</h3><p>在Qt Quick中也使用模型、视图和委托的概念来存储显示数据。这种开发架构将可视的数据模块化，从而让开发人员和设计人员能够分别控制数据的不同层面。例如，开发人员可以很方便地在列表视图和表格视图之间进行切换。而将数据实例封装进一个委托，可以使开发人员决定如何显示或处理这些数据。</p>
<p><strong>简介</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    width: 200; height: 250</span><br><span class="line"></span><br><span class="line">    ListModel &#123;</span><br><span class="line">        id: myModel</span><br><span class="line">        ListElement &#123; type: &quot;Dog&quot;; age: 8 &#125;</span><br><span class="line">        ListElement &#123; type: &quot;Cat&quot;; age: 5 &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Component &#123;</span><br><span class="line">        id: myDelegate</span><br><span class="line">        Text &#123; text: type + &quot;, &quot; + age; font.pointSize: 12 &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListView &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        model: myModel; delegate: myDelegate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里首先创建了一个ListModel作为数据模型，然后使用一个Component组件作为委托，最后使用ListView作为视图，在视图中需要指定模型和委托。ListView的数据模型model用来提供数据，委托delegate用来设置数据的显示方式。</li>
<li>在ListModel中，使用了ListElement添加数据项。每一个数据项都可以有多种类型的角色，比如这里有两个：type和age，并且分别指定了它们的值。如果模型中没有包含任何命名的角色，那么可以通过modelData角色来提供数据。</li>
<li>委托可以使用一个组件来实现，在其中可以直接绑定数据模型中的角色，比如这里将type和age的值显示在了一个Text文本中。委托还可以使用一个特殊的index角色，它包含了模型中数据项的索引值。</li>
</ul>
<h4 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h4><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>Qt Quick提供的模型类型主要包含在<strong>QtQml.Models</strong>模块中，另外还有一个基于XML的<strong>QtQml.XmlListModel</strong>模型，以及现在版本中还处于实验阶段的TableModel模型。</p>
<p>如果这些模型都不能满足需要，还可以使用Qt C++定义模型，或者使用<strong>QtQuick.LocalStorage</strong>类型来读取和写入SQLite数据库。</p>
<p><strong>1. 整数作为模型</strong></p>
<p>最简单的，可以使用整数作为模型。在这种情况下，模型中不包含任何数据角色。例如，在下面的代码片段中创建了一个包含5个数据项的ListView：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    width: 200; height: 250</span><br><span class="line">    Component &#123;</span><br><span class="line">        id: itemDelegate</span><br><span class="line">        Text &#123; text: &quot;I am item number: &quot; + index &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListView &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        model: 5</span><br><span class="line">        delegate: itemDelegate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. ListModel</strong></p>
<p>ListModel是一个简单的容器，可以包含ListElement类型来存储数据。</p>
<p>ListModel的数据项的数量可以使用count属性获得。为了维护模型中的数据，该类型还提供了一系列方法，包括**追加append()、插入insert()、移动move()、移除remove()、获取get()、替换set()和清空clear()**等。其中一些方法需要接受字典类型（如”cost”: 5.95）作为其参数，这种字典类型会被模型自动转换成ListElement对象。</p>
<p>如果需要通过模型修改ListElement中的内容，可以使用setProperty()方法，这个方法可以修改给定索引位置的ListElement的属性值。</p>
<p>ListElement需要在ListModel中定义，使用方法同其它QML类型基本没有区别，不同之处在于，ListElement没有固定的属性，而是包含一系列自定义的键值。可以把ListElement看作是一个键值对组成的集合，其中键被称为role（角色），它使用与属性相同的语法进行定义，角色既定义了如何访问数据，也定义了数据本身。例如：cost: 5.95</p>
<ul>
<li>角色的名字以小写字母开始，并且应当是给定模型中所有ListElement通用的名字。</li>
<li>角色的值必须是简单的常量：字符串（带有引号，可以包含在QT_TR_NOOP调用中）、布尔类型（true和false）、数字或枚举类型（例如AlignText.AlignHCenter）。</li>
<li>角色的名字供委托获取数据使用，每一个角色的名字都可以在委托的作用域内访问，并且指向当前ListElement中对应的值。另外，角色还可以包含列表数据，例如包含多个ListElement。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ListModel &#123;</span><br><span class="line">    id: fruitModel</span><br><span class="line"></span><br><span class="line">    ListElement &#123;</span><br><span class="line">        name: &quot;Apple&quot;; cost: 2.45</span><br><span class="line">        attributes: [</span><br><span class="line">            ListElement &#123; description: &quot;Core&quot; &#125;,</span><br><span class="line">            ListElement &#123; description: &quot;Deciduous&quot; &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListElement &#123;</span><br><span class="line">        name: &quot;Orange&quot;; cost: 3.25</span><br><span class="line">        attributes: [</span><br><span class="line">            ListElement &#123; description: &quot;Citrus&quot; &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListElement &#123; ... ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Component &#123;</span><br><span class="line">    id: fruitDelegate</span><br><span class="line">    </span><br><span class="line">    Item &#123;</span><br><span class="line">        width: 200; height: 50</span><br><span class="line">        </span><br><span class="line">        Text &#123; id: nameField; text: name &#125;</span><br><span class="line">        Text &#123; text: &#x27;$&#x27; + cost; anchors.left: nameField.right &#125;</span><br><span class="line">        Row &#123;</span><br><span class="line">            anchors.top: nameField.bottom; spacing: 5</span><br><span class="line">            Text &#123; text: &quot;Attributes:&quot; &#125;</span><br><span class="line">            Repeater &#123;</span><br><span class="line">                model: attributes</span><br><span class="line">                Text &#123; text: description &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MouseArea &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            onClicked: fruitModel.setProperty(</span><br><span class="line">                                index, &quot;cost&quot;, cost * 2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ListView &#123;</span><br><span class="line">    anchors.fill: parent</span><br><span class="line">    model: fruitModel; delegate: fruitDelegate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. XmlListModel</strong></p>
<p>XmlListModel可以从XML数据创建只读的模型，即可以作为视图的数据源，也可以为Repeater等能够和模型数据进行交互的类型提供数据。由于XmlListModel的数据是异步加载的，因此当程序启动、数据尚未加载的时候，界面会显示一段时间的空白。可以使用XmlListModel::status属性判断模型加载的状态。该属性可取的值为：</p>
<ul>
<li>XmlListModel.Null：模型中没有XML数据；</li>
<li>XmlListModel.Ready：XML数据已经加载到模型；</li>
<li>XmlListModel.Loading：模型正在读取和加载XML数据；</li>
<li>XmlListModel.Error：加载数据出错，详细出错信息可以使用errorString()获得。</li>
</ul>
<p>XmlListModel是只读模型，当原始XML数据发生改变时，可以通过调用reload()刷新模型数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;rss version=&quot;2.0&quot;&gt;</span><br><span class="line">    &lt;channel&gt;</span><br><span class="line">        ...</span><br><span class="line">	    &lt;item&gt;</span><br><span class="line">	        &lt;title&gt;名校投放新专业&lt;/title&gt;</span><br><span class="line">	        &lt;pubDate&gt;2016&lt;/pubDate&gt;</span><br><span class="line">	        ...</span><br><span class="line">	    &lt;/item&gt;</span><br><span class="line">	    &lt;item&gt;</span><br><span class="line">	        &lt;title&gt;北京普通初中&lt;/title&gt;</span><br><span class="line">	        &lt;pubDate&gt;2016&lt;/pubDate&gt;</span><br><span class="line">	        ...</span><br><span class="line">        &lt;/item&gt;</span><br><span class="line">	    ...</span><br><span class="line">    &lt;/channel&gt;</span><br><span class="line">&lt;/rss&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">XmlListModel &#123;</span><br><span class="line">    id: xmlModel</span><br><span class="line">    source: &quot;http://www.people.com.cn/rss/edu.xml&quot;</span><br><span class="line">    query: &quot;/rss/channel/item&quot;</span><br><span class="line">    </span><br><span class="line">    XmlListModelRole &#123; name: &quot;title&quot;; elementName: &quot;title&quot; &#125;</span><br><span class="line">    XmlListModelRole &#123; name: &quot;pubDate&quot;; elementName: &quot;pubDate&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListView &#123;</span><br><span class="line">    id: view</span><br><span class="line">    anchors.fill: parent</span><br><span class="line">    model: xmlModel</span><br><span class="line">    focus: true</span><br><span class="line">    spacing: 8</span><br><span class="line">    delegate: Label &#123;</span><br><span class="line">        id: label</span><br><span class="line">        width: view.width; height: 50</span><br><span class="line">        verticalAlignment: Text.AlignVCenter</span><br><span class="line">        text: title + &quot;: &quot; + pubDate</span><br><span class="line">        font.pixelSize: 15; elide: Text.ElideRight</span><br><span class="line">        color: label.ListView.isCurrentItem ? </span><br><span class="line">                                 &quot;white&quot; : &quot;black&quot;</span><br><span class="line">        background: Image &#123;</span><br><span class="line">            visible: label.ListView.isCurrentItem</span><br><span class="line">            source: &quot;bg.png&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>4. TableModel</strong></p>
<p>TableModel从Qt 5.14引入，在现在的版本中依然需要通过实验模块Qt.labs.qmlmodels来提供。</p>
<p>在该类型出现以前，要想创建具有多个列的模型，需要通过C++中自定义QAbstractTableModel子类来实现。而TableModel的目的就是实现一个简单的模型，可以将JavaScript&#x2F;JSON对象存储为能与TableView一起使用的表格模型的数据，而不再需要子类化QAbstractTableModel。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TableModel &#123;</span><br><span class="line">    id: tableModel</span><br><span class="line">    TableModelColumn &#123; display: &quot;checked&quot; &#125;</span><br><span class="line">    TableModelColumn &#123; display: &quot;amount&quot; &#125;</span><br><span class="line">    TableModelColumn &#123; display: &quot;fruitType&quot; &#125;</span><br><span class="line">    TableModelColumn &#123; display: &quot;fruitName&quot; &#125;</span><br><span class="line">    TableModelColumn &#123; display: &quot;fruitPrice&quot; &#125;</span><br><span class="line"></span><br><span class="line">    rows: [</span><br><span class="line">        &#123;</span><br><span class="line">            checked: false, amount: 1, fruitType: &quot;Apple&quot;,</span><br><span class="line">            fruitName: &quot;Granny Smith&quot;, fruitPrice: 1.50</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            checked: true, amount: 4, fruitType: &quot;Orange&quot;,</span><br><span class="line">            fruitName: &quot;Navel&quot;, fruitPrice: 2.50</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            checked: false, amount: 1, fruitType: &quot;Banana&quot;,</span><br><span class="line">            fruitName: &quot;Cavendish&quot;, fruitPrice: 3.50</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模型中的每个列都是通过声明TableModelColumn实例来指定的，其中每个实例的顺序决定了其列索引。使用rows属性或通过调用appendRow()来设置模型的初始行数据。</p>
<p>TableModel设计用于JavaScript&#x2F;JSON数据，其中每一行都是一些简单的键值对。要访问特定行，可以使用getRow()，也可以通过rows属性直接访问模型的JavaScript数据，但不能以这种方式修改模型数据。要添加新行，可以使用appendRow()和insertRow()，要修改现有行，可以使用setRow()、moveRow()、removeRow()和clear()等方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TableView &#123;</span><br><span class="line">    anchors.fill: parent</span><br><span class="line">    columnSpacing: 1; rowSpacing: 1</span><br><span class="line">    boundsBehavior: Flickable.StopAtBounds</span><br><span class="line"></span><br><span class="line">    model: tableModel</span><br><span class="line"></span><br><span class="line">    delegate:  TextInput &#123;</span><br><span class="line">        text: model.display; padding: 12; selectByMouse: true</span><br><span class="line">        onAccepted: model.display = text</span><br><span class="line"></span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            anchors.fill: parent; color: &quot;#efefef&quot;; z: -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 其他模型类型</strong></p>
<ul>
<li>ObjectModel包含了用于在视图中进行显示的可视项目，也就是说，该类型可以将Qt Quick中的可视化项目作为数据项显示到视图上。与ListModel不同，使用ObjectModel的视图不需要指定委托，因为ObjectModel的数据项本身就是可视化项目。可以使用model的附加属性index获取数据项的索引位置。该类型也提供了追加append()、插入insert()、移动move()、移除remove()、获取get()和清空clear()等方法。</li>
<li>DelegateModel类型封装了一个模型和用于显示这个模型的委托，可以使用model属性指定模型，delegate属性指定委托。一般情况下并不需要使用DelegateModel。不过，如果需要将QAbstractItemModel的子类作为模型使用的时候，使用DelegateModel可以很方便地操作和访问modelIndex()。另外，DelegateModel可以与Package一起，为多种视图提供委托，也可以与DelegateModelGroup一起用于排序和过滤委托项。DelegateModelGroup类型提供了一种定位DelegateModel委托项的模型数据的方法，并且能够对委托项进行排序和过滤。</li>
<li>Package类型可以结合DelegateModel，实现让委托为多个视图提供共享的上下文。在Package中的任何项目都会通过Package.name附加属性分配一个名称。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    width: 200; height: 300</span><br><span class="line"></span><br><span class="line">    DelegateModel &#123;</span><br><span class="line">        id: delegateModel</span><br><span class="line">        delegate: Package &#123;</span><br><span class="line">            Text &#123; id: listDelegate; width: parent.width; height: 25;</span><br><span class="line">                text: &#x27;in list&#x27;; Package.name: &#x27;list&#x27;&#125;</span><br><span class="line">            Text &#123; id: gridDelegate; width: parent.width / 2; height: 50;</span><br><span class="line">                text: &#x27;in grid&#x27;; Package.name: &#x27;grid&#x27; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        model: 5</span><br><span class="line">    &#125;</span><br><span class="line">    Rectangle&#123;</span><br><span class="line">        height: parent.height/2; width: parent.width; color: &quot;lightgrey&quot;</span><br><span class="line">        ListView &#123;</span><br><span class="line">            anchors.fill: parent; model: delegateModel.parts.list</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GridView &#123;</span><br><span class="line">        y: parent.height/2;</span><br><span class="line">        height: parent.height/2; width: parent.width;</span><br><span class="line">        cellWidth: width / 2; cellHeight: 50</span><br><span class="line">        model: delegateModel.parts.grid</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用Package作为DelegateModel的委托，里面包含了两个命名Package.name的项目：list和grid。在DelegateModel类型中包含一个parts属性，它可以选取一个DelegateModel模型，这个模型中会使用指定名称的项目作为委托。例如这里在ListView中使用了parts.list作为模型，该模型就会使用Package中的list项目作为委托。</p>
<hr>
<p><strong>6. 在委托中使用必需属性来匹配模型角色</strong></p>
<p>required关键字声明的必需属性在模型视图程序中扮演特殊角色。为了更好地控制可访问的角色，并使委托在视图之外更为独立和适用，可以借助必需属性。如果委托包含必需属性，则不用指定角色，QML引擎将检查必需属性的名称是否与模型角色的名称匹配，如果是，则该属性将绑定到模型中的相应值。</p>
<p>注意，如果在委托中使用了必需属性，那么用到的模型角色都要进行声明，比如这里只声明了type和age角色，所以现在noise无法直接使用，不仅如此，model、index和modelData等常用的角色也将无法直接使用，除非明确把它们设置为必需属性。</p>
<p>还有一种情况，就是委托中的属性与模型角色名称相同，这时，只需要为相关属性添加required关键字即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ListModel &#123;</span><br><span class="line">    id: myModel</span><br><span class="line">    ListElement &#123; type: &quot;Dog&quot;; age: 8; noise: &quot;meow&quot; &#125;</span><br><span class="line">    ListElement &#123; type: &quot;Cat&quot;; age: 5; noise: &quot;woof&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">component MyDelegate : Text &#123;</span><br><span class="line">    required property string type</span><br><span class="line">    required property int age</span><br><span class="line">    text: type + &quot;, &quot; + age</span><br><span class="line">&#125;</span><br><span class="line">ListView &#123;</span><br><span class="line">    anchors.fill: parent</span><br><span class="line">    model: myModel</span><br><span class="line">    delegate: MyDelegate &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. LocalStorage</strong></p>
<p>LocalStorage是一个用于读取和写入SQLite数据库的单例类型，可以使用openDatabaseSync()打开一个本地存储的SQL数据库。这些数据库是特定于用户的，也是特定于QML的，但是可以被所有QML应用程序访问。数据库保存在QQmlEngine::offlineStoragePath()返回的子文件夹Databases中。数据库的链接无须手动释放，它们会被JavaScript的垃圾收集器自动关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Text &#123;</span><br><span class="line">    text: &quot;?&quot;</span><br><span class="line">    anchors.horizontalCenter: parent.horizontalCenter</span><br><span class="line">    </span><br><span class="line">    function findGreetings() &#123;</span><br><span class="line">        var db = LocalStorage.openDatabaseSync(&quot;QQmlExampleDB&quot;,</span><br><span class="line">                                &quot;1.0&quot;, &quot;The Example QML SQL!&quot;, 1000000);</span><br><span class="line">        db.transaction(</span><br><span class="line">                    function(tx) &#123;</span><br><span class="line">                        // 如果数据库表不存在则进行创建</span><br><span class="line">                        tx.executeSql(&#x27;CREATE TABLE IF NOT EXISTS Greeting</span><br><span class="line">                                   (salutation TEXT, salutee TEXT)&#x27;);</span><br><span class="line">                        // 添加一条记录</span><br><span class="line">                        tx.executeSql(&#x27;INSERT INTO Greeting VALUES(?, ?)&#x27;,</span><br><span class="line">                                      [ &#x27;hello&#x27;, &#x27;world&#x27; ]);</span><br><span class="line">                        // 显示内容</span><br><span class="line">                        var rs = tx.executeSql(&#x27;SELECT * FROM Greeting&#x27;);</span><br><span class="line">                        </span><br><span class="line">                        var r = &quot;&quot;</span><br><span class="line">                        for(var i = 0; i &lt; rs.rows.length; i++) &#123;</span><br><span class="line">                            r += rs.rows.item(i).salutation + &quot;, &quot;</span><br><span class="line">                                    + rs.rows.item(i).salutee + &quot;\n&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                        text = r</span><br><span class="line">                    &#125;</span><br><span class="line">                    )</span><br><span class="line">    &#125;</span><br><span class="line">    Component.onCompleted: findGreetings()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LocalStorage模块的API与HTML 5 Web Database API兼容。模块中所有API都是异步的，每一个函数的最后一个参数都是该操作的回调函数。如果不关心这个回调函数，可以简单地忽略该参数。</p>
<p>可以使用如下方式打开或创建数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick.LocalStorage as Sql</span><br><span class="line">var db = Sql.openDatabaseSync(identifier, version, description,</span><br><span class="line">                            estimated_size, callback(db))</span><br></pre></td></tr></table></figure>

<p>openDatabaseSync()函数返回数据库标识符为identifier的数据库。如果数据库不存在，将会自动创建。回调函数callback(db)以该数据库作为参数，当数据库创建失败时，callback()函数才会被回调。参数description和estimatedSize将被写入INI文件，不过这两个参数现在都没有使用。函数可能会抛出异常，异常代码为SQLException.DATABASE_ERR或SQLException.VERSION_ERR。</p>
<p>数据库创建完成之后，系统会创建一个INI文件，用于指定数据库的特性。这些数据能够被应用程序工具使用。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250711115006887.png" alt="image-20250711115006887"></p>
<hr>
<hr>
<h3 id="视图类型"><a href="#视图类型" class="headerlink" title="视图类型"></a>视图类型</h3><p>视图作为数据项集合的容器，不仅提供了强大的功能，还可以进行定制来满足样式或行为上的特殊需求。视图类型主要是Flickable的几个子类型，包括列表视图ListView、网格视图GridView、表格视图TableView及其子类型树视图TreeView。作为Flickable的子类型，这几个视图在数据量超出窗口范围时，可以进行拖动以显示更多的数据</p>
<p><strong>ListView</strong></p>
<p><strong>1. 按键导航和高亮</strong></p>
<p>使用键盘控制视图，需要设置focus属性为true，以便ListView能够接收键盘事件。keyNavigationEnabled属性可以设置是否启用键盘导航。还可以设置keyNavigationWraps属性为true，这样当使用键盘导航时如果到达列表的最后一个数据项，会自动跳转到列表的第一个数据项。</p>
<p>highlight属性可以设置一个组件作为高亮，实际的组件实例的几何形状是被列表管理的，以便该高亮留在当前项目，除非将highlightFollowsCurrentItem属性设置为false。</p>
<p>高亮项目的默认z值为0。默认情况下，ListView负责移动高亮项的位置。可以自行设置高亮项的移动速度和改变大小的速度，可用的属性有highlightMoveVelocity 、highlightMoveDuration 、highlightResizeVelocity 和highlightResizeDuration 。前两个分别以速度值和持续时间设置高亮项移动速度；后两个分别以速度值和持续时间设置高亮项大小改变的速度。默认情况下，速度值为每秒400像素，持续时间值为-1。如果同时设置速度值和持续时间，则取二者之中较快的一个。要使用这4个属性，必须保证highlightFollowsCurrentItem为true才会有效果。</p>
<p>移动速度和持续时间属性用于index变化而产生的移动，例如调用incrementCurrentIndex()，而当用户轻击ListView时，轻击的速度将用于控制移动速度。ListView还会在委托的根项目中附加多个属性，例如ListView.isCurrentItem，可以对当前项进行特殊处理。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ListView &#123;</span><br><span class="line">    id: listview; anchors.fill: parent; anchors.margins: 30</span><br><span class="line">    model: 5; spacing: 5</span><br><span class="line">    delegate: numberDelegate; snapMode: ListView.SnapToItem</span><br><span class="line">    header: Rectangle &#123;</span><br><span class="line">        width: 50; height: 20; color: &quot;#b4d34e&quot;</span><br><span class="line">        Text &#123;anchors.centerIn: parent; text: &quot;header&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    footer: Rectangle &#123;</span><br><span class="line">        width: 50; height: 20; color: &quot;#797e65&quot;</span><br><span class="line">        Text &#123;anchors.centerIn: parent; text: &quot;footer&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    highlight: Rectangle &#123;</span><br><span class="line">        color: &quot;black&quot;; radius: 5</span><br><span class="line">        opacity: 0.3; z:5</span><br><span class="line">    &#125;</span><br><span class="line">    focus: true; keyNavigationWraps :true</span><br><span class="line">    highlightMoveVelocity: -1</span><br><span class="line">    highlightMoveDuration: 1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分别使用了两个Rectangle项目来作为header和footer。在highlight中使用了一个黑色半透明的矩形，并设置了其z值为5，目的是让高亮可以显示在所有数据项的上面，也可以设置为大于0的其它值。这里必须在ListView中设置focus为true，才可以使用键盘进行导航。</p>
<p>当使用高亮时，可以使用一系列属性控制高亮的行为。preferredHighlightBegin属性和preferredHighlightEnd属性用来设置高亮（当前项目）的最佳范围，前者必须小于后者。它们还受到highlightRangeMode属性的影响。</p>
<hr>
<p><strong>2. 数据分组</strong></p>
<p>ListView支持数据的分组显示：相关数据可以出现在一个分组中。每个分组还可以使用委托定义其显示的样式。ListView定义了一个section附加属性，用于将相关数据显示在一个分组中，section是一个属性组，其属性包含：</p>
<ul>
<li><p>section.property：定义分组的依据，也就是根据数据模型的哪一个角色进行分组；</p>
</li>
<li><p>section.criteria：定义如何创建分组名字，可选值是：</p>
</li>
<li><p>ViewSection.FullString：默认，依照section.property定义的值创建分组；</p>
</li>
<li><p>ViewSection.FirstCharacter：依照section.property值的首字母创建分组；</p>
</li>
<li><p>section.delegate：与ListView的委托类似，用于提供每一个分组的委托组件，其z属性值为2。</p>
<ul>
<li><p>section.labelPositioning：定义当前或下一个分组标签的位置，可选值是：</p>
</li>
<li><p>ViewSection.InlineLabels：默认，分组标签出现在数据项之间；</p>
</li>
<li><p>ViewSection.CurrentLabelAtStart：在列表滚动时，当前分组的标签始终出现在列表视图开始的位置；</p>
</li>
<li><p>ViewSection.NextLabelAtEnd：在列表滚动时，下一分组的标签始终出现在列表视图末尾。该选项要求系统预先找到下一个分组的位置，因此可能会有一定的性能问题。</p>
</li>
</ul>
</li>
</ul>
<p>ListView中的每一个数据项都有<strong>ListView.section、ListView.previousSection和ListView.nextSection</strong>等附加属性。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Rectangle &#123;</span><br><span class="line">    id: container; width: 150; height: 300</span><br><span class="line"></span><br><span class="line">    ListModel &#123;</span><br><span class="line">        id: nameModel</span><br><span class="line">        ListElement &#123; name: &quot;LiLi&quot;; group: &quot;friend&quot; &#125;</span><br><span class="line">        ListElement &#123; name: &quot;LiuMing&quot;; group: &quot;friend&quot; &#125;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListView &#123;</span><br><span class="line">        anchors.fill: parent; model: nameModel</span><br><span class="line">        delegate: Text &#123; text: name; font.pixelSize: 18 &#125;</span><br><span class="line">        section.property: &quot;group&quot;</span><br><span class="line">        section.criteria: ViewSection.FullString</span><br><span class="line">        section.delegate: sectionHeading</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Component &#123;</span><br><span class="line">        id: sectionHeading</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: container.width; height: childrenRect.height</span><br><span class="line">            color: &quot;lightsteelblue&quot;</span><br><span class="line">            Text &#123;</span><br><span class="line">                text: section; font.bold: true; font.pixelSize: 20</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了模型中的group角色进行分组，并且是FullString匹配，这样就会按照模型中的group角色的值进行分组，将group值相同的分在一组进行显示。</p>
<hr>
<p><strong>GridView</strong></p>
<p>网格视图GridView在一块可用的空间中以方格形式显示数据列表。GridView和ListView非常类似，实质的区别在于，GridView需要在一个二维表格视图中使用委托，而不是线性列表中。相对于ListView，GridView并不建立在委托的大小及其之间的间距之上，GridView使用cellWidth和cellHeight属性控制单元格的大小，每一个委托所渲染的数据项都会出现在这样一个单元格的左上角。</p>
<p>GridView也可以包含头部和脚部以及使用高亮委托，这与ListView是类似的。还可以使用flow属性设置GridView的方向，可选值为：</p>
<ul>
<li>GridView.FlowLeftToRight：默认值，表格从左向右开始填充，按照从上向下的顺序添加行。此时，表格是纵向滚动的。</li>
<li>GridView.FlowTopToBottom：表格从上向下开始填充，按照从左向右的顺序添加列。此时，表格是横向滚动的。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ListModel &#123;</span><br><span class="line">    id: model</span><br><span class="line">    ListElement &#123; name: &quot;Jim&quot;; portrait: &quot;icon.png&quot; &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GridView &#123;</span><br><span class="line">    id: grid; width: 200; height: 200</span><br><span class="line">    cellWidth: 100; cellHeight: 100</span><br><span class="line">    model: model; delegate: contactDelegate</span><br><span class="line">    highlight: Rectangle &#123; color: &quot;lightsteelblue&quot;; radius: 5 &#125;</span><br><span class="line">    focus: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component &#123;</span><br><span class="line">    id: contactDelegate</span><br><span class="line">    Item &#123;</span><br><span class="line">        width: grid.cellWidth; height: grid.cellHeight</span><br><span class="line">        Column &#123;</span><br><span class="line">            anchors.centerIn: parent</span><br><span class="line">            Image &#123; source: portrait; anchors.horizontalCenter:</span><br><span class="line">                    parent.horizontalCenter &#125;</span><br><span class="line">            Text &#123; text: name; anchors.horizontalCenter:</span><br><span class="line">                    parent.horizontalCenter &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个网格视图，视图中每一个单元格的宽度和高度均为100像素，而委托中为每一个数据项设置了一个图片和一个文本。</p>
<hr>
<p><strong>3. 视图过渡</strong></p>
<p>在ListView和GridView中，因为修改了模型中的数据而需要更改视图上的数据项时，可以指定一个过渡使视图的变化出现动画效果。可以使用过渡的属性有：populate、add、remove、move、displaced、addDisplaced、removeDisplaced和moveDisplaced等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ListView &#123;</span><br><span class="line">    width: 160; height: 320</span><br><span class="line">    model: ListModel &#123;&#125;</span><br><span class="line"></span><br><span class="line">    delegate: Rectangle &#123;</span><br><span class="line">        width: 100; height: 30; border.width: 1</span><br><span class="line">        color: &quot;lightsteelblue&quot;</span><br><span class="line">        Text &#123; anchors.centerIn: parent; text: name &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add: Transition &#123;</span><br><span class="line">        NumberAnimation &#123; property: &quot;opacity&quot;;</span><br><span class="line">               from: 0; to: 1.0; duration: 400 &#125;</span><br><span class="line">        NumberAnimation &#123; property: &quot;scale&quot;;</span><br><span class="line">               from: 0; to: 1.0; duration: 400 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    displaced: Transition &#123;</span><br><span class="line">        NumberAnimation &#123; properties: &quot;x,y&quot;; duration: 400;</span><br><span class="line">               easing.type: Easing.OutBounce &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    focus: true</span><br><span class="line">    Keys.onSpacePressed: model.insert(0, &#123; &quot;name&quot;: &quot;Item &quot;</span><br><span class="line">                                                 + model.count &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里每当按下空格键的时候，都会向模型中添加一个数据项。在视图中为添加add和移位displaced操作设置了过渡效果，所以每当添加数据项时都会有动画效果。注意，这里的NumberAnimation对象并不需要指定target和to属性，因为视图已经隐式的将target设置为了对应的项目，将to设置为了该项目最终的位置。</p>
<p>运行代码，有读者可能发现，快速按下空格键的时候会有一些数据项无法正常添加，下面来看一下如何解决这个问题。</p>
<p>一个视图过渡有可能在任意时刻被其他过渡打断。如果只进行简单的过渡，无需考虑动画中断的情况。但是，如果过渡中更改了一些属性，那么中断可能会引起不可预料的后果。例如，在前面示例中快速按下空格键出现的问题，项目0通过add过渡插入到了index 0的位置。这时项目1非常快速地插入到index 0的位置，而此时项目0的过渡还没有结束。项目1插入到项目0的前面，所以项目0要移位，视图就会中断项目0的add过渡，并开始项目0的displaced过渡。因为中断的发生，opacity和scale动画没有结束，会导致项目的opacity和scale值小于1.0。要解决这个问题，在displaced过渡中要确保项目的属性已经到达了在add过渡中设置的值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">displaced: Transition &#123;</span><br><span class="line">    NumberAnimation &#123; properties: &quot;x,y&quot;; duration: 400; </span><br><span class="line">                      easing.type: Easing.OutBounce &#125;</span><br><span class="line">    // 确保opacity和scale值变为1.0</span><br><span class="line">    NumberAnimation &#123; property: &quot;opacity&quot;; to: 1.0 &#125;</span><br><span class="line">    NumberAnimation &#123; property: &quot;scale&quot;; to: 1.0 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>Qt Charts模块来创建几乎所有常见的图表类型，包括折线图、曲线图、面积图、散点图、柱形图、饼状图、盒须图等等。</p>
<p>Qt Charts模块是基于Qt图形视图框架的，生成的图表可以很容易集成到QWidget、QGraphicsWidget或QML程序中。</p>
<p>要使用Qt Charts模块，需要在安装Qt时选择安装Qt Charts组件，还需要在项目文件.pro中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += charts</span><br></pre></td></tr></table></figure>

<h3 id="widgets"><a href="#widgets" class="headerlink" title="widgets"></a>widgets</h3><p>Qt Charts模块中的<strong>QChart类</strong>用来管理不同类型的系列以及相关的图例、坐标轴等对象，QChart继承自 <strong>QGraphicsWidget</strong>，可以很容易在<strong>QGraphicsScene</strong>中使用。如果要在普通的QWidget部件中显示图表，那么可以借助<strong>QChartView</strong>类。</p>
<hr>
<p><strong>1. 简单示例</strong></p>
<p><strong>widget.cpp</strong></p>
<p>第一条线</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineSeries&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChartView&gt;</span></span></span><br><span class="line"><span class="comment">//在widget.cpp的构造函数中添加</span></span><br><span class="line">QLineSeries* series = <span class="keyword">new</span> <span class="built_in">QLineSeries</span>();</span><br><span class="line">series-&gt;<span class="built_in">append</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">series-&gt;<span class="built_in">append</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">QChartView *view = <span class="keyword">new</span> <span class="built_in">QChartView</span>(<span class="keyword">this</span>);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">addSeries</span>(series);</span><br><span class="line">view-&gt;<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);                            </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712090009509.png" alt="image-20250712090009509"></p>
<ul>
<li><strong>QLineSeries</strong>用来绘制折线图，它是一个线系列，通过直线将一系列的数据点进行相连。可以通过**append()<strong>函数来向系列中添加数据点，其参数为</strong>（X, Y）**坐标值。</li>
<li>在QWidget中使用图表，需要使用<strong>QChartView</strong>，创建该类实例时会<strong>自动</strong>创建一个<strong>QChart</strong>对象，可以通过**chart()**函数来获取关联图表的指针。</li>
<li>Qt图表的主要功能都要由<strong>QChart</strong>类来完成，比如这里使用了**addSeries()**来添加系列，添加完成后图表会获得系列的拥有权。</li>
</ul>
<p>第二条线</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QLineSeries* series1 = new QLineSeries();</span><br><span class="line">series1-&gt;append(0, 0);</span><br><span class="line">series1-&gt;append(1, 4);</span><br><span class="line">series1-&gt;append(3, 5);</span><br><span class="line">view-&gt;chart()-&gt;addSeries(series1);</span><br><span class="line">// 设置默认坐标轴</span><br><span class="line">view-&gt;chart()-&gt;createDefaultAxes();</span><br><span class="line">view-&gt;setRenderHint(QPainter::Antialiasing); </span><br><span class="line"></span><br><span class="line">view-&gt;chart()-&gt;setTitle(tr(&quot;My Charts&quot;));</span><br><span class="line">view-&gt;chart()-&gt;setTitleBrush(Qt::darkYellow);</span><br><span class="line">view-&gt;chart()-&gt;setTitleFont(QFont(&quot;Arial&quot;, 20));</span><br><span class="line">series-&gt;setName(&quot;2020&quot;);</span><br><span class="line">series1-&gt;setName(&quot;2021&quot;);                    </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712090106267.png" alt="image-20250712090106267"></p>
<ul>
<li><p>使用QChart的**createDefaultAxes()**生成了默认的坐标轴，注意，<strong>必须在所有系列都添加完毕后才能使用该函数生成默认坐标轴。</strong></p>
</li>
<li><p>最后调用QChartView的<strong>setRenderHint(QPainter::Antialiasing)<strong>来</strong>启用抗锯齿</strong>，这样可以使折线绘制得更平滑。</p>
</li>
<li><p>接着使用**setTitle()<strong>函数来为图表添加标题，并设置标题颜色和字体。通过使用</strong>setName()**为系列设置名称，可以使其在图例中显示出来。</p>
</li>
</ul>
<hr>
<p><strong>比例和画刷</strong></p>
<p>通过<strong>QChart::legend()<strong>函数获取图表的图例对象，图例是一个图形对象，由</strong>QLegend</strong>类表示，该对象无法被创建或者删除。当系列发生变化时，QChart会更新图例的状态。默认情况下，图例附着在图表上，可以使用**QLegend::detachFromChart()**将其分离从而独立于图表进行布局。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">legend</span>()-&gt;<span class="built_in">setMarkerShape</span>(</span><br><span class="line">                                   QLegend::MarkerShapeStar);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">legend</span>()-&gt;<span class="built_in">setBackgroundVisible</span>(<span class="literal">true</span>);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">legend</span>()-&gt;<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">150</span>));</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">legend</span>()-&gt;<span class="built_in">setLabelColor</span>(Qt::darkYellow);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">legend</span>()-&gt;<span class="built_in">setAlignment</span>(Qt::AlignBottom);</span><br></pre></td></tr></table></figure>

<p>使用QChart的<strong>setBackgroundBrush()<strong>可以设置背景画刷，默认是为整个图表设置背景。还可以通过</strong>setPlotAreaBackgroundBrush()<strong>为中间的绘图区设置背景，该背景默认是不显示的，如果需要设置该背景，需要调用</strong>setPlotAreaBackgroundVisible(true)</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">setBackgroundBrush</span>(Qt::lightGray);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">setPlotAreaBackgroundBrush</span>(Qt::white);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">setPlotAreaBackgroundVisible</span>(<span class="literal">true</span>);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">setBackgroundRoundness</span>(<span class="number">15</span>);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">setDropShadowEnabled</span>(<span class="literal">true</span>);                       </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712090610564.png" alt="image-20250712090610564"></p>
<hr>
<p><strong>主题</strong></p>
<p>QChart中还提供了几个现成的主题，可以通过setTheme()函数进行设置，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">setTheme</span>(QChart::ChartThemeBlueIcy);</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712090640464.png" alt="image-20250712090640464"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712090719825.png" alt="image-20250712090719825"></p>
<hr>
<p><strong>动画</strong></p>
<p>Qt图表还支持动画效果，可以通过QChart的setAnimationOptions()函数来设置动画选项。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712090743496.png" alt="image-20250712090743496"></p>
<p>如果开启了动画，可以使用setAnimationDuration()设置动画的持续时间，使用setAnimationEasingCurve()来设置动画使用的缓和曲线。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">setAnimationOptions</span>(QChart::AllAnimations);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">setAnimationDuration</span>(<span class="number">2000</span>);</span><br><span class="line">view-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">setAnimationEasingCurve</span>(<span class="built_in">QEasingCurve</span>(QEasingCurve::InQuad));</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 坐标轴</strong></p>
<p>坐标轴用来设置一条包含刻度线、网格线和阴影的轴线，可以显示在图表的上、下、左、右等不同方向。每一个系列都可以绑定一个或多个水平和垂直坐标轴。</p>
<p>Qt Charts支持下面这几种坐标轴类型，它们全部继承自QAbstractAxis类：</p>
<ul>
<li>数值坐标轴<strong>QValueAxis</strong>：数值轴会直接向轴上添加实际的数值，该数值显示在刻度线的位置；</li>
<li>分类坐标轴<strong>QCategoryAxis</strong>：分类轴可以使用分类标签来区分基础数据，类别范围的宽度可以自由指定，分类标签显示在刻度线之间；</li>
<li>柱形图分类坐标轴<strong>QBarCategoryAxis</strong>：柱形图分类轴与分类轴类似，但是所有类别的范围宽度是一样的，分类标签显示在刻度线之间；</li>
<li>日期时间坐标轴<strong>QDateTimeAxis</strong>：在标签上可以显示日期或者时间信息，日期时间可以指定显示格式；</li>
<li>对数数值坐标轴<strong>QLogValueAxis</strong>：对数数值轴上的刻度是非线性的，它依赖于使用的数量级，轴上的每一个刻度数值都是前一个刻度数值乘以一个值；</li>
<li>颜色坐标轴<strong>QColorAxis</strong>：可以显示指定渐变的颜色比例。</li>
</ul>
<p><strong>数值坐标轴</strong></p>
<ul>
<li>使用setRange()来设置轴上最小值和最大值之间的范围，通过setTickCount()来设置刻度线数量，默认值为5，不能小于2；</li>
<li>使用setMinorTickCount()来设置次要刻度线的数量，就是在主要刻度线之间的网格线的数量，默认值为0；</li>
<li>使用setLabelFormat()来设置标签格式，支持标准C++库函数printf()提供的各种格式控制符，如d、i、o、x、X、f、F、e、E、g、G、c等。还可以使用<strong>setLabelsAngle()</strong>、**setLabelsColor()**来设置标签的角度和颜色。</li>
<li>使用QChart::addAxis()将坐标轴添加到图表中，并指明对齐方式。</li>
<li>要将一个系列与指定坐标轴进行关联，需要该系列调用attachAxis()来附着指定的轴，一个系列只能有一个横坐标轴和一个竖坐标轴。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建图表视图并设置为窗口中心</span></span><br><span class="line">   QChartView *chartView = <span class="keyword">new</span> <span class="built_in">QChartView</span>(<span class="keyword">this</span>);</span><br><span class="line">   chartView-&gt;<span class="built_in">setMinimumSize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 创建图表和序列</span></span><br><span class="line">   QChart *chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">   QLineSeries *series = <span class="keyword">new</span> <span class="built_in">QLineSeries</span>();</span><br><span class="line">   series-&gt;<span class="built_in">append</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   series-&gt;<span class="built_in">append</span>(<span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">   chart-&gt;<span class="built_in">addSeries</span>(series);</span><br><span class="line">   chartView-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 配置X轴（核心代码）</span></span><br><span class="line">   QValueAxis *axisX = <span class="keyword">new</span> QValueAxis;</span><br><span class="line">   axisX-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">21</span>);</span><br><span class="line">   axisX-&gt;<span class="built_in">setTickCount</span>(<span class="number">6</span>);</span><br><span class="line">   axisX-&gt;<span class="built_in">setMinorTickCount</span>(<span class="number">1</span>);</span><br><span class="line">   axisX-&gt;<span class="built_in">setLabelFormat</span>(<span class="string">&quot;%.2f&quot;</span>);</span><br><span class="line">   axisX-&gt;<span class="built_in">setLabelsAngle</span>(<span class="number">30</span>);</span><br><span class="line">   axisX-&gt;<span class="built_in">setLabelsColor</span>(Qt::darkYellow);</span><br><span class="line">   chart-&gt;<span class="built_in">addAxis</span>(axisX, Qt::AlignBottom);</span><br><span class="line">   series-&gt;<span class="built_in">attachAxis</span>(axisX);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 自动创建Y轴</span></span><br><span class="line">   chart-&gt;<span class="built_in">createDefaultAxes</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712094449363.png" alt="image-20250712094449363"></p>
<hr>
<p><strong>对数数值坐标轴</strong></p>
<p>对数数值坐标轴<strong>QLogValueAxis</strong>，需要通过setBase()来指定对数的底数，轴上的每个刻度值都是前一个刻度值乘以底数，不需要指定刻度线数量。QLogValueAxis和QValueAxis都继承自QAbstractAxis，它们的一些用法是相似的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建图表视图</span></span><br><span class="line">QChartView *view = <span class="keyword">new</span> <span class="built_in">QChartView</span>(<span class="keyword">this</span>);</span><br><span class="line">view-&gt;<span class="built_in">resize</span>(<span class="number">500</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建图表和曲线序列</span></span><br><span class="line">QChart *chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">QSplineSeries *series = <span class="keyword">new</span> <span class="built_in">QSplineSeries</span>(); <span class="comment">// 使用曲线序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加曲线数据点（指数增长）</span></span><br><span class="line">series-&gt;<span class="built_in">append</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">series-&gt;<span class="built_in">append</span>(<span class="number">5</span>, <span class="number">32</span>);</span><br><span class="line">series-&gt;<span class="built_in">append</span>(<span class="number">10</span>, <span class="number">128</span>);</span><br><span class="line">series-&gt;<span class="built_in">append</span>(<span class="number">15</span>, <span class="number">200</span>);</span><br><span class="line">series-&gt;<span class="built_in">append</span>(<span class="number">20</span>, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">chart-&gt;<span class="built_in">addSeries</span>(series);</span><br><span class="line">view-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line"></span><br><span class="line"><span class="comment">// X轴</span></span><br><span class="line">QValueAxis *axisX = <span class="keyword">new</span> QValueAxis;</span><br><span class="line">axisX-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">21</span>);</span><br><span class="line">chart-&gt;<span class="built_in">addAxis</span>(axisX, Qt::AlignBottom);</span><br><span class="line">series-&gt;<span class="built_in">attachAxis</span>(axisX);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数Y轴（核心）</span></span><br><span class="line">QLogValueAxis *axisY = <span class="keyword">new</span> QLogValueAxis;</span><br><span class="line">axisY-&gt;<span class="built_in">setBase</span>(<span class="number">2</span>);</span><br><span class="line">axisY-&gt;<span class="built_in">setRange</span>(<span class="number">8</span>, <span class="number">260</span>);</span><br><span class="line">axisY-&gt;<span class="built_in">setMinorTickCount</span>(<span class="number">1</span>);</span><br><span class="line">chart-&gt;<span class="built_in">addAxis</span>(axisY, Qt::AlignLeft);</span><br><span class="line">series-&gt;<span class="built_in">attachAxis</span>(axisY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置曲线样式</span></span><br><span class="line">series-&gt;<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::blue, <span class="number">2</span>)); <span class="comment">// 蓝色曲线，线宽2</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712095147103.png" alt="image-20250712095147103"></p>
<hr>
<p><strong>柱形图分类坐标轴</strong></p>
<p>柱形图系列由QBarSeries类表示，会将数据绘制为一系列按类别分组的竖条，每个类别从添加到系列中的每个柱形集QBarSet中提取一条。QBarSet作为柱形集包含了每个类别中的一个数据值，可以通过append()来添加一个值或者值的列表，也可以使用流运算符添加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QBarSet *set0 = new QBarSet(&quot;Jane&quot;);</span><br><span class="line">QBarSet *set1 = new QBarSet(&quot;John&quot;);</span><br><span class="line">QBarSet *set2 = new QBarSet(&quot;Axel&quot;);</span><br><span class="line">*set0 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 5 &lt;&lt; 6;</span><br><span class="line">*set1 &lt;&lt; 5 &lt;&lt; 0 &lt;&lt; 0 &lt;&lt; 4 &lt;&lt; 0 &lt;&lt; 7;</span><br><span class="line">*set2 &lt;&lt; 3 &lt;&lt; 5 &lt;&lt; 8 &lt;&lt; 13 &lt;&lt; 8 &lt;&lt; 5;</span><br><span class="line">QBarSeries *series1 = new QBarSeries();</span><br><span class="line">series1-&gt;append(set0);</span><br><span class="line">series1-&gt;append(set1);</span><br><span class="line">series1-&gt;append(set2);</span><br><span class="line">view2-&gt;chart()-&gt;addSeries(series1);</span><br></pre></td></tr></table></figure>

<p>下面来添加柱形图分类坐标轴，柱形图分类坐标轴由QBarCategoryAxis表示，可以通过append()来添加分类，类别名称会显示在刻度之间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QStringList categories;</span><br><span class="line">categories &lt;&lt; &quot;Jan&quot; &lt;&lt; &quot;Feb&quot; &lt;&lt; &quot;Mar&quot; &lt;&lt; &quot;Apr&quot; &lt;&lt; &quot;May&quot; &lt;&lt; &quot;Jun&quot;;</span><br><span class="line">QBarCategoryAxis *axisX1 = new QBarCategoryAxis();</span><br><span class="line">axisX1-&gt;append(categories);</span><br><span class="line">view2-&gt;chart()-&gt;addAxis(axisX1, Qt::AlignBottom);</span><br><span class="line">series1-&gt;attachAxis(axisX1);</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCharts&gt;</span></span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="comment">// 创建图表视图</span></span><br><span class="line">   QChartView *view = <span class="keyword">new</span> <span class="built_in">QChartView</span>(<span class="keyword">this</span>);</span><br><span class="line">   view-&gt;<span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建图表</span></span><br><span class="line">   QChart *chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">   view-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建柱状数据集</span></span><br><span class="line">   QBarSet *set0 = <span class="keyword">new</span> <span class="built_in">QBarSet</span>(<span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">   QBarSet *set1 = <span class="keyword">new</span> <span class="built_in">QBarSet</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">   QBarSet *set2 = <span class="keyword">new</span> <span class="built_in">QBarSet</span>(<span class="string">&quot;Axel&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加数据</span></span><br><span class="line">   *set0 &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">   *set1 &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">   *set2 &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="number">13</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建柱状序列并添加数据集</span></span><br><span class="line">   QBarSeries *series = <span class="keyword">new</span> <span class="built_in">QBarSeries</span>();</span><br><span class="line">   series-&gt;<span class="built_in">append</span>(set0);</span><br><span class="line">   series-&gt;<span class="built_in">append</span>(set1);</span><br><span class="line">   series-&gt;<span class="built_in">append</span>(set2);</span><br><span class="line">   chart-&gt;<span class="built_in">addSeries</span>(series);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建分类轴（X轴）</span></span><br><span class="line">   QStringList categories = &#123;<span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;Jun&quot;</span>&#125;;</span><br><span class="line">   QBarCategoryAxis *axisX = <span class="keyword">new</span> <span class="built_in">QBarCategoryAxis</span>();</span><br><span class="line">   axisX-&gt;<span class="built_in">append</span>(categories);</span><br><span class="line">   chart-&gt;<span class="built_in">addAxis</span>(axisX, Qt::AlignBottom);</span><br><span class="line">   series-&gt;<span class="built_in">attachAxis</span>(axisX);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 自动创建Y轴</span></span><br><span class="line">   chart-&gt;<span class="built_in">createDefaultAxes</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712100220177.png" alt="image-20250712100220177"></p>
<hr>
<p><strong>分类坐标轴</strong></p>
<p>分类坐标轴<strong>QCategoryAxis</strong>，它继承自<strong>QValueAxis</strong>。与柱形图分类坐标轴<strong>QBarCategoryAxis</strong>不同，<strong>QCategoryAxis</strong>可以指定分类的宽度。可以通过append()来添加新的类别，其中需要指定分类标签和该分类的最大值。还可以通过setStartValue()来设置第一个分类的最小值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QBarSet&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QBarCategoryAxis&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChartView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QBarSeries&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCategoryAxis&gt;</span> <span class="comment">// 包含分类轴头文件</span></span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="comment">// 创建图表视图</span></span><br><span class="line">    QChartView *view = <span class="keyword">new</span> <span class="built_in">QChartView</span>(<span class="keyword">this</span>);</span><br><span class="line">    view-&gt;<span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图表</span></span><br><span class="line">    QChart *chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">    view-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建柱状数据集</span></span><br><span class="line">    QBarSet *set = <span class="keyword">new</span> <span class="built_in">QBarSet</span>(<span class="string">&quot;Performance&quot;</span>);</span><br><span class="line">    *set &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="number">7</span> &lt;&lt; <span class="number">12</span> &lt;&lt; <span class="number">9</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 5个数据点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建柱状序列并添加数据集</span></span><br><span class="line">    QBarSeries *series = <span class="keyword">new</span> <span class="built_in">QBarSeries</span>();</span><br><span class="line">    series-&gt;<span class="built_in">append</span>(set);</span><br><span class="line">    chart-&gt;<span class="built_in">addSeries</span>(series);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建分类X轴（月份）</span></span><br><span class="line">    QStringList months = &#123;<span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>, <span class="string">&quot;May&quot;</span>&#125;;</span><br><span class="line">    QBarCategoryAxis *axisX = <span class="keyword">new</span> <span class="built_in">QBarCategoryAxis</span>();</span><br><span class="line">    axisX-&gt;<span class="built_in">append</span>(months);</span><br><span class="line">    chart-&gt;<span class="built_in">addAxis</span>(axisX, Qt::AlignBottom);</span><br><span class="line">    series-&gt;<span class="built_in">attachAxis</span>(axisX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建分类Y轴（核心代码）</span></span><br><span class="line">    QCategoryAxis *axisY = <span class="keyword">new</span> <span class="built_in">QCategoryAxis</span>();</span><br><span class="line">    axisY-&gt;<span class="built_in">append</span>(<span class="string">&quot;Low&quot;</span>, <span class="number">5</span>);     <span class="comment">// 0-5为Low</span></span><br><span class="line">    axisY-&gt;<span class="built_in">append</span>(<span class="string">&quot;Medium&quot;</span>, <span class="number">10</span>); <span class="comment">// 5-10为Medium</span></span><br><span class="line">    axisY-&gt;<span class="built_in">append</span>(<span class="string">&quot;High&quot;</span>, <span class="number">15</span>);   <span class="comment">// 10-15为High</span></span><br><span class="line">    axisY-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">15</span>);      <span class="comment">// 设置Y轴范围</span></span><br><span class="line">    chart-&gt;<span class="built_in">addAxis</span>(axisY, Qt::AlignLeft);</span><br><span class="line">    series-&gt;<span class="built_in">attachAxis</span>(axisY);</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712100645716.png" alt="image-20250712100645716"></p>
<hr>
<p>与柱形图QBarSeries相似的，还有堆积柱形图QStackedBarSeries和百分比堆积柱形图QPercentBarSeries。</p>
<ul>
<li><p>QStackedBarSeries会将一类柱形条堆积在一个垂直柱形条上，每个柱形集中对应分类的柱形条都作为这个垂直柱形条的一段；</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712100759795.png" alt="image-20250712100759795"></p>
</li>
<li><p>而QPercentBarSeries与QStackedBarSeries类似，只是所有堆积柱形条都是等长的，而其中的分段柱形会根据代表的数值在总值中的占比绘制为不同的长度。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712100814042.png" alt="image-20250712100814042"></p>
</li>
</ul>
<hr>
<p><strong>3. 使用外部数据动态创建图表</strong></p>
<p>图表是用来显示数据的，前面的例子中为了演示方便都使用了现成的个别数据，但是实际编程中一般要使用数据库或者XML来作为数据源提供数据。</p>
<p>下面通过一个实例，演示如何使用数据库来提供数据，通过表格和图表两种方式进行数据显示。</p>
<p>在Qt Charts模块中提供了一些模型映射类，可以让各个图表使用QAbstractItemModel的子类作为数据源，这些类均以ModelMapper结尾。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712100858580.png" alt="image-20250712100858580"></p>
<p>通过使用这些映射器，可以将数据模型中指定的数据全部显示到图表上，还可以随着数据模型中数据的变化而自动更新显示。</p>
<p>除了使用这种方式，有时还希望将模型中的数据一个一个动态显示到图表上，这个可以使用定时器更新图表的绘图区域来实现。</p>
<p><strong>示例：</strong></p>
<p>本例使用的QVXYModelMapper类，被称为垂直模型映射器，可以将折线图、曲线图或散点图与一个数据模型进行关联，在这个数据模型中需要包含两列数值来分别为数据点提供X、Y坐标。可以分别通过setModel()和setSeries()来设置模型和系列，然后通过setXColumn()和setYColumn()来指定模型中的字段为X和Y坐标提供数值。</p>
<p>这里分别使用m_xy表中的m_x和m_y字段来为QSplineSeries的数据点提供X和Y坐标，表中的每一行记录都表示为了一个数据点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCharts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span></span></span><br><span class="line"><span class="comment">// 创建模型并添加测试数据</span></span><br><span class="line">    model = <span class="keyword">new</span> <span class="built_in">QStandardItemModel</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="keyword">this</span>); <span class="comment">// 5行2列</span></span><br><span class="line">    model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">0</span>, Qt::Horizontal, <span class="string">&quot;X&quot;</span>);</span><br><span class="line">    model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, <span class="string">&quot;Y&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充测试数据 (x, y)</span></span><br><span class="line">    model-&gt;<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;1.0&quot;</span>));</span><br><span class="line">    model-&gt;<span class="built_in">setItem</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;2.0&quot;</span>));</span><br><span class="line">    model-&gt;<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;2.0&quot;</span>));</span><br><span class="line">    model-&gt;<span class="built_in">setItem</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;4.0&quot;</span>));</span><br><span class="line">    model-&gt;<span class="built_in">setItem</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;3.0&quot;</span>));</span><br><span class="line">    model-&gt;<span class="built_in">setItem</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;6.0&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图表视图</span></span><br><span class="line">    QChartView *chartView = <span class="keyword">new</span> <span class="built_in">QChartView</span>(<span class="keyword">this</span>);</span><br><span class="line">    chartView-&gt;<span class="built_in">resize</span>(<span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图表和系列</span></span><br><span class="line">    QChart *chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">    chartView-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line">    QLineSeries *series = <span class="keyword">new</span> <span class="built_in">QLineSeries</span>();</span><br><span class="line">    chart-&gt;<span class="built_in">addSeries</span>(series);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心映射器代码</span></span><br><span class="line">    QVXYModelMapper *mapper = <span class="keyword">new</span> <span class="built_in">QVXYModelMapper</span>(<span class="keyword">this</span>);</span><br><span class="line">    mapper-&gt;<span class="built_in">setSeries</span>(series);</span><br><span class="line">    mapper-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line">    mapper-&gt;<span class="built_in">setXColumn</span>(<span class="number">0</span>); <span class="comment">// X值来自第0列</span></span><br><span class="line">    mapper-&gt;<span class="built_in">setYColumn</span>(<span class="number">1</span>); <span class="comment">// Y值来自第1列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动创建坐标轴</span></span><br><span class="line">    chart-&gt;<span class="built_in">createDefaultAxes</span>();</span><br><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QChartView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStandardItemModel&gt;</span> <span class="comment">// 使用标准项模型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVXYModelMapper&gt;</span></span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QStandardItemModel *model; <span class="comment">// 使用标准项模型</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>通过定时器为图表动态添加数据</strong></p>
<p>先开启一个间隔2S的定时器。并进行定时器溢出信号和自定义槽的关联。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;Widget::handleTimeout);</span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>下面来添加定时器溢出信号关联的槽的实现：</p>
<p>这里就是获取数据模型中的数据值添加到图表系列中，然后更新图表的显示区域，这个是通过**QChart::scroll()**来实现的，它可以根据指定的距离来滚动图表的可见区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handleTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; model-&gt;<span class="built_in">ZrowCount</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> m_x = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(id, <span class="number">1</span>)).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="type">int</span> m_y = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(id, <span class="number">2</span>)).<span class="built_in">toInt</span>();</span><br><span class="line">        series-&gt;<span class="built_in">append</span>(m_x, m_y);</span><br><span class="line">        <span class="keyword">if</span> (m_x &gt; axisX-&gt;<span class="built_in">max</span>() - <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> temp = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(id<span class="number">-1</span>, <span class="number">1</span>)).<span class="built_in">toInt</span>();</span><br><span class="line">            qreal width = chartView-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">plotArea</span>().<span class="built_in">width</span>();</span><br><span class="line">            qreal dx = width / (axisX-&gt;<span class="built_in">tickCount</span>()<span class="number">-1</span>) *(m_x - temp);</span><br><span class="line">            chartView-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">scroll</span>(dx, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        id++;</span><br><span class="line">    &#125; <span class="keyword">else</span> timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<p>widget.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图表视图</span></span><br><span class="line">    chartView = <span class="keyword">new</span> <span class="built_in">QChartView</span>(<span class="keyword">this</span>);</span><br><span class="line">    chartView-&gt;<span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图表和系列</span></span><br><span class="line">    QChart *chart = <span class="keyword">new</span> <span class="built_in">QChart</span>();</span><br><span class="line">    chartView-&gt;<span class="built_in">setChart</span>(chart);</span><br><span class="line">    series = <span class="keyword">new</span> <span class="built_in">QLineSeries</span>();</span><br><span class="line">    chart-&gt;<span class="built_in">addSeries</span>(series);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建坐标轴</span></span><br><span class="line">    axisX = <span class="keyword">new</span> QValueAxis;</span><br><span class="line">    axisX-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 初始X轴范围</span></span><br><span class="line">    QValueAxis *axisY = <span class="keyword">new</span> QValueAxis;</span><br><span class="line">    axisY-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">20</span>); <span class="comment">// Y轴范围</span></span><br><span class="line"></span><br><span class="line">    chart-&gt;<span class="built_in">addAxis</span>(axisX, Qt::AlignBottom);</span><br><span class="line">    chart-&gt;<span class="built_in">addAxis</span>(axisY, Qt::AlignLeft);</span><br><span class="line">    series-&gt;<span class="built_in">attachAxis</span>(axisX);</span><br><span class="line">    series-&gt;<span class="built_in">attachAxis</span>(axisY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化定时器</span></span><br><span class="line">    timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;Widget::handleTimeout);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>); <span class="comment">// 每秒触发一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::handleTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成模拟数据</span></span><br><span class="line">    <span class="type">int</span> m_x = id;</span><br><span class="line">    <span class="type">int</span> m_y = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">20</span>); <span class="comment">// 生成0-19的随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据点</span></span><br><span class="line">    series-&gt;<span class="built_in">append</span>(m_x, m_y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滚动逻辑：当接近X轴右边界时滚动图表</span></span><br><span class="line">    <span class="keyword">if</span> (m_x &gt; axisX-&gt;<span class="built_in">max</span>() - <span class="number">3</span>) &#123;</span><br><span class="line">        qreal width = chartView-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">plotArea</span>().<span class="built_in">width</span>();</span><br><span class="line">        qreal dx = width / (axisX-&gt;<span class="built_in">tickCount</span>() - <span class="number">1</span>);</span><br><span class="line">        chartView-&gt;<span class="built_in">chart</span>()-&gt;<span class="built_in">scroll</span>(dx, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id++; <span class="comment">// 移动到下一个数据点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：设置停止条件（例如100个点后停止）</span></span><br><span class="line">    <span class="keyword">if</span> (id &gt; <span class="number">100</span>) timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>widget.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCharts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QRandomGenerator&gt;</span> <span class="comment">// 包含随机数生成器头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QChartView *chartView;</span><br><span class="line">    QLineSeries *series;</span><br><span class="line">    QValueAxis *axisX;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    QTimer *timer;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Quick-2"><a href="#Quick-2" class="headerlink" title="Quick"></a>Quick</h3><p>要在Qt Quick中使用Qt Charts模块，需要使用如下导入语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import QtCharts</span><br></pre></td></tr></table></figure>

<p><strong>1. 示例：</strong></p>
<p>创建Empty qmake Project，项目名称为<strong>mycharts</strong>，打开mycharts.pro文件，添加如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += quick widgets charts</span><br></pre></td></tr></table></figure>

<p>添加main.qml文件。按下 Ctrl+N，添加 qml 文件 <strong>main.qml</strong>，添加下列代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick</span><br><span class="line">import QtCharts</span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    visible: true</span><br><span class="line">    width: 640; height: 480</span><br><span class="line"></span><br><span class="line">    ChartView &#123;</span><br><span class="line">        title: &quot;Line&quot;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        antialiasing: true</span><br><span class="line"></span><br><span class="line">        LineSeries &#123;</span><br><span class="line">            name: &quot;LineSeries&quot;</span><br><span class="line">            XYPoint &#123; x: 0; y: 0 &#125;</span><br><span class="line">            XYPoint &#123; x: 1.1; y: 2.1 &#125;</span><br><span class="line">            XYPoint &#123; x: 1.9; y: 3.3 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的<strong>LineSeries</strong>用来绘制折线图，其中name属性就是系列的名称，会显示为该系列的图例，XYPoint 对象用来提供静态坐标数据，这里一共设置了3个点。所有的系列都需要放到ChartView 类型中进行显示。</p>
<p>添加main.cpp文件，C&#x2F;C++ Source File模板。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtWidgets/QApplication&gt;</span><br><span class="line">#include &lt;QQmlApplicationEngine&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line"></span><br><span class="line">    QQmlApplicationEngine engine;</span><br><span class="line">    engine.load(QUrl::fromLocalFile(&quot;../mycharts/main.qml&quot;));</span><br><span class="line"></span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2.  坐标轴Axes</strong></p>
<p>坐标轴可以用来显示刻度线、网格线和阴影等，与Qt Widgets编程中相似，Qt Charts在Qt Quick中支持下面这几种坐标轴类型，它们全部继承自AbstractAxis类型：</p>
<ul>
<li><p>数值坐标轴ValueAxis</p>
</li>
<li><p>分类坐标轴CategoryAxis</p>
</li>
<li><p>柱形图分类坐标轴BarCategoryAxis</p>
</li>
<li><p>日期时间坐标轴DateTimeAxis</p>
</li>
<li><p>对数数值坐标轴LogValueAxis</p>
</li>
</ul>
<p>同一个图表可以使用多个不同类型的坐标轴，它们可以设置在图表的上、下、左、右等不同方向。</p>
<hr>
<p><strong>数值坐标轴和对数数值坐标轴</strong></p>
<p>示例中使用数值坐标轴ValueAxis作为了LineSeries的横轴，可以通过axisX 属性来指定系列的横坐标轴。对于ValueAxis对象，min、max属性可以设置轴的最小值和最大值；labelFormat 属性可以设置标签格式，支持标准C++库函数printf()提供的各种格式控制符；minorTickCount 属性用来指定次要刻度线的数量，默认为0；tickCount 属性用来指定轴上的刻度线数量，默认值是5，不能小于2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ValueAxis &#123;</span><br><span class="line">    id: xAxis</span><br><span class="line">    min: 0; max: 1000; labelFormat: &quot;%.1f&quot;</span><br><span class="line">    minorTickCount: 1; tickCount : 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LineSeries &#123;</span><br><span class="line">    name: &quot;LineSeries&quot;</span><br><span class="line">    axisX: xAxis</span><br><span class="line"></span><br><span class="line">    XYPoint &#123; x: 0; y: 0 &#125;</span><br><span class="line">    XYPoint &#123; x: 100; y: 200 &#125;</span><br><span class="line">    XYPoint &#123; x: 300; y: 500 &#125;</span><br><span class="line">    XYPoint &#123; x: 600; y: 400 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里默认显示的刻度值是将最大值减去最小值，然后根据刻度线的数量进行均分，当调用applyNiceNumbers()函数后，为了使刻度值更美观，会自动调整刻度线的数量。刻度值显示有两种类型，由tickType属性指定，默认的这种是ValueAxis.TicksFixed，还有一种动态的ValueAxis.TicksDynamic，它会根据tickAnchor和 tickInterval两个属性来设置刻度线的位置。</p>
<p>对数数值坐标轴LogValueAxis用法与数值坐标轴ValueAxis相似，只需要指定对数的底数base属性即可。</p>
<hr>
<p><strong>分类坐标轴</strong></p>
<p>分类坐标轴CategoryAxis中可以使用CategoryRange子对象来指定标签和范围，标签默认显示在范围中间，可以通过labelsPosition属性让其显示在刻度值处。另外，CategoryAxis类型中还提供了startValue属性用来指定第一个分类的最小值；categoriesLabels属性用来获取所有标签的字符串列表；count属性用来获取分类数量；append()、remove()和replace()等函数用来修改分类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CategoryAxis &#123;</span><br><span class="line">    id: yAxis</span><br><span class="line">    min: 0; max: 700</span><br><span class="line">    labelsPosition : CategoryAxis.AxisLabelsPositionOnValue</span><br><span class="line">    </span><br><span class="line">    CategoryRange &#123; label: &quot;critical&quot;; endValue: 200 &#125;</span><br><span class="line">    CategoryRange &#123; label: &quot;low&quot;; endValue: 400 &#125;</span><br><span class="line">    CategoryRange &#123; label: &quot;normal&quot;; endValue: 700 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面在LineSeries 中指定纵轴：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axisY: yAxis</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>柱形图分类坐标轴</strong></p>
<p>柱形图分类坐标轴BarCategoryAxis用于柱形图中。这里使用BarSeries来创建一个柱形图，BarCategoryAxis做为柱形图的横坐标轴，在其中一般只需要设置分类信息categories属性即可，它是一个字符串列表。柱形图中使用 BarSet子对象来为各个分类提供数据集，包括了名称和各个分类对应的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ChartView &#123;</span><br><span class="line">    title: &quot;BarSeries&quot;</span><br><span class="line">    anchors.fill: parent; antialiasing: true</span><br><span class="line"></span><br><span class="line">    BarSeries &#123;</span><br><span class="line">        axisX: BarCategoryAxis &#123; categories: [&quot;2007&quot;, &quot;2008&quot;, &quot;2009&quot;,</span><br><span class="line">                &quot;2010&quot;, &quot;2011&quot;, &quot;2012&quot; ] &#125;</span><br><span class="line">        BarSet &#123; label: &quot;Bob&quot;; values: [2, 2, 3, 4, 5, 6] &#125;</span><br><span class="line">        BarSet &#123; label: &quot;Susan&quot;; values: [5, 1, 2, 4, 1, 7] &#125;</span><br><span class="line">        BarSet &#123; label: &quot;James&quot;; values: [3, 5, 8, 13, 5, 8] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>日期时间坐标轴</strong></p>
<p>日期时间坐标轴DateTimeAxis，可以将日期时间作为刻度值。format用来设置刻度标签显示格式；然后是使用JavaScript的Date对象来设置日期时间时，中间表示月份的参数介于0到11之间，所以1月份需要设置为0；还有就是在LineSeries上的点只能用数值表示，所以需要将日期时间格式转换为数值，这个可以通过JavaScript的getTime()方法来获取，它返回从1970年1月1日至今的毫秒数，为了更加清晰，这里自定义了一个toMsecsSinceEpoch()函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ChartView &#123;</span><br><span class="line">    title: &quot;LineSeries&quot;； anchors.fill: parent； antialiasing: true</span><br><span class="line">    DateTimeAxis &#123;</span><br><span class="line">        id: xAxis；format: &quot;MM-dd&quot;; tickCount: 5</span><br><span class="line">        min: new Date(2019, 0, 15)  // 2019-1-15</span><br><span class="line">        max: new Date(2019, 2, 1)  // 2019-3-1</span><br><span class="line">    &#125;</span><br><span class="line">    LineSeries &#123;</span><br><span class="line">        name: &quot;LineSeries&quot;； axisX: xAxis</span><br><span class="line">        </span><br><span class="line">        XYPoint &#123; x: toMsecsSinceEpoch(new Date(2019, 0, 20)); y: 12 &#125;</span><br><span class="line">        XYPoint &#123; x: toMsecsSinceEpoch(new Date(2019, 1, 13)); y: 18 &#125;</span><br><span class="line">        XYPoint &#123; x: toMsecsSinceEpoch(new Date(2019, 1, 20)); y: 30 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function toMsecsSinceEpoch(date) &#123;</span><br><span class="line">    var msecs = date.getTime(); return msecs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>坐标轴的共有属性</strong></p>
<p>前面提到的所有坐标轴类型全部继承自AbstractAxis类型，所以它们都可以使用AbstractAxis的属性。通过这些属性可以单独控制坐标轴的各种元素，包括轴线、标题、标签、网格线、阴影等。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">color: &quot;blue&quot;</span><br><span class="line">gridLineColor: &quot;lightgreen&quot;</span><br><span class="line">labelsAngle: 90</span><br><span class="line">labelsColor: &quot;red&quot;</span><br><span class="line">labelsFont &#123; bold: true; pixelSize: 15 &#125;</span><br><span class="line">shadesVisible: true</span><br><span class="line">shadesColor: &quot;lightgrey&quot;</span><br><span class="line">titleText: &quot;date&quot;</span><br><span class="line">titleFont &#123; bold: true; pixelSize: 30 &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 图例Legend</strong></p>
<p>Legend类型用来显示图表的图例，Legend对象可以通过ChartView进行引用，当图表中系列改变时，ChartView会自动更新图例的状态。</p>
<p>Legend类型包含的属性如下表所列，但是并没有提供用于修改图例标记的接口，如果想修改图例标记可以创建自定义图例。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250712114044546.png" alt="image-20250712114044546"></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ChartView &#123;</span><br><span class="line">    title: &quot;Bar series&quot;</span><br><span class="line">    anchors.fill: parent; antialiasing: true</span><br><span class="line"></span><br><span class="line">    legend &#123;</span><br><span class="line">        alignment: Qt.AlignBottom</span><br><span class="line">        backgroundVisible: true</span><br><span class="line">        color: &quot;lightblue&quot;; borderColor: &quot;blue&quot;; labelColor: &quot;gold&quot;</span><br><span class="line">        font.bold: true; font.pointSize: 15</span><br><span class="line">        markerShape: Legend.MarkerShapeCircle</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BarSeries &#123;</span><br><span class="line">        id: mySeries</span><br><span class="line">        axisX: BarCategoryAxis &#123; categories: [&quot;2007&quot;, &quot;2008&quot;, &quot;2009&quot; ] &#125;</span><br><span class="line">        BarSet &#123; label: &quot;Bob&quot;; values: [2, 2, 3] &#125;</span><br><span class="line">        BarSet &#123; label: &quot;Susan&quot;; values: [5, 1, 2] &#125;</span><br><span class="line">        BarSet &#123; label: &quot;James&quot;; values: [3, 5, 8] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>4. ChartView</strong></p>
<p>前面已经看到可以通过ChartView来显示一个图表，其实，是由ChartView将系列、坐标轴、图例等元素组合到一起形成了一个完整的图表。</p>
<p>可以使用title属性来设置图表的标题，titleColor和titleFont用来设置标题的颜色和字体；plotAreaColor用来设置中间绘图区的颜色；backgroundColor设置整个图表的背景色，如果没有设置plotAreaColor，那么中间的绘图区也显示背景色；backgroundRoundness可以设置图表背景矩形的圆角弧度；dropShadowEnabled设置图表背景是否使用阴影效果。</p>
<p>虽然可以使用属性来简单自定义图表外观，但组合一个漂亮的主题还是需要费些功夫的。ChartView中为我们提供了几个内建的主题，具体可以查看前面11.1.1讲到的。ChartView的主题会涉及图表的所有可视化元素，包括系列、坐标轴和图例的颜色、画笔、画刷、字体等。</p>
<p>ChartView还可以选择是否启用动画效果，包括系列动画和网格轴动画，由animationOptions属性指定。另外可以使用animationDuration属性指定动画的持续时间，使用animationEasingCurve设置缓和曲线。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ChartView &#123;</span><br><span class="line">    title: qsTr(&quot;我的图表&quot;); titleColor: Qt.lighter(&quot;blue&quot;)</span><br><span class="line">    titleFont&#123; bold: true; pointSize: 20&#125;</span><br><span class="line">    plotAreaColor: &quot;lightgrey&quot;</span><br><span class="line">    backgroundColor: Qt.lighter(&quot;red&quot;); backgroundRoundness: 25</span><br><span class="line">    dropShadowEnabled: true</span><br><span class="line"></span><br><span class="line">    animationOptions: ChartView.AllAnimations</span><br><span class="line">    animationDuration: 5000</span><br><span class="line">    animationEasingCurve: Easing.InQuad</span><br><span class="line"></span><br><span class="line">    anchors.fill: parent; anchors.margins: 20</span><br><span class="line">    antialiasing: true</span><br><span class="line"></span><br><span class="line">    LineSeries &#123;</span><br><span class="line">        name: &quot;LineSeries&quot;</span><br><span class="line">        XYPoint &#123; x: 0; y: 0 &#125;</span><br><span class="line">        XYPoint &#123; x: 1.1; y: 2.1 &#125;</span><br><span class="line">        XYPoint &#123; x: 1.9; y: 3.3 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>5. 使用数据动态创建图表</strong></p>
<p>前面对图表的基本构成元素进行了介绍，在示例中只是使用了现成的数据直接创建的系列，但是在实际应用中大多是从外部读取数据来动态创建图表。这一小节，将通过一个简单的例子，从模型中动态读取数据来创建图表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Window &#123;</span><br><span class="line">    visible: true</span><br><span class="line">    width: 640; height: 480</span><br><span class="line">    property int currentIndex: -1</span><br><span class="line"></span><br><span class="line">    ChartView &#123;</span><br><span class="line">        id: chartView</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        title: qsTr(&quot;我的网站访问量&quot;)</span><br><span class="line">        theme: ChartView.ChartThemeBlueCerulean</span><br><span class="line">        antialiasing: true</span><br><span class="line">    &#125;</span><br><span class="line">    // 通过一个ListModel来模拟数据源</span><br><span class="line">    ListModel &#123;</span><br><span class="line">        id: listModel</span><br><span class="line"></span><br><span class="line">        ListElement &#123; month: 1; pv: 205864 &#125;</span><br><span class="line">        ListElement &#123; month: 2; pv: 254681 &#125;</span><br><span class="line">        ListElement &#123; month: 3; pv: 306582 &#125;</span><br><span class="line">        ListElement &#123; month: 4; pv: 284326 &#125;</span><br><span class="line">        ListElement &#123; month: 5; pv: 248957 &#125;</span><br><span class="line">        ListElement &#123; month: 6; pv: 315624 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Timer &#123;</span><br><span class="line">    id: timer</span><br><span class="line">    interval: 1500; repeat: true</span><br><span class="line">    triggeredOnStart: true; running: true</span><br><span class="line">    onTriggered: &#123;</span><br><span class="line">        currentIndex++;</span><br><span class="line">        if (currentIndex &lt; listModel.count) &#123;</span><br><span class="line">            var lineSeries = chartView.series(&quot;2018&quot;);</span><br><span class="line">            // 第一次运行时创建曲线</span><br><span class="line">            if (!lineSeries) &#123;</span><br><span class="line">                lineSeries = chartView.createSeries(ChartView.SeriesTypeSpline,</span><br><span class="line">                                                    &quot;2018&quot;);</span><br><span class="line">                chartView.axisY().min = 200000;</span><br><span class="line">                chartView.axisY().max = 320000;</span><br><span class="line">                chartView.axisY().tickCount = 6;</span><br><span class="line">                chartView.axisY().titleText = qsTr(&quot;PV&quot;);</span><br><span class="line">                chartView.axisX().visible = false</span><br><span class="line">                lineSeries.color = &quot;#87CEFA&quot;</span><br><span class="line">                lineSeries.pointsVisible = true</span><br><span class="line">                lineSeries.pointLabelsVisible = true</span><br><span class="line">                lineSeries.pointLabelsFormat = qsTr(&quot;@xPoint月份PV:@yPoint&quot;)</span><br><span class="line">                chartView.animationOptions = ChartView.SeriesAnimations</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lineSeries.append(listModel.get(currentIndex).month,</span><br><span class="line">                  listModel.get(currentIndex).pv);</span><br><span class="line"></span><br><span class="line">if (listModel.get(currentIndex).month &gt; 3) &#123;</span><br><span class="line">    chartView.axisX().max =</span><br><span class="line">            Number(listModel.get(currentIndex).month) + 1;</span><br><span class="line">    chartView.axisX().min = chartView.axisX().max - 5;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    chartView.axisX().max = 5;</span><br><span class="line">    chartView.axisX().min = 0;</span><br><span class="line">&#125;</span><br><span class="line">chartView.axisX().tickCount = chartView.axisX().max</span><br><span class="line">        - chartView.axisX().min + 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">timer.stop();</span><br><span class="line">chartView.axisX().min = 0;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>6. 常见图表类型</strong></p>
<p>前面示例中讲解了常用的折线图、曲线图、柱形图，在Qt Charts模块中还包括散点图、面积图、饼状图、盒须图等其他类型的图表，它们用法相似。</p>
<ul>
<li><p>折线图、曲线图和散点图</p>
<p>散点图与前面讲到的折线图和曲线图用法相似。折线图LineSeries、曲线图SplineSeries和散点图ScatterSeries都继承自XYSeries，它们的共同特点是显示的信息都是由XYPoint指定的数据点。在XYSeries类型中定义的属性、信号和方法在这3个图表类型中都可以使用。</p>
</li>
<li><p>面积图</p>
<p>面积图AreaSeries用来显示一定量的数据，强调数据随时间变化的程度。面积图基于折线图，可以通过upperSeries属性来指定一个折线系列作为区域的上边界，默认的下边界是可绘制区域的下边界，然后填充颜色。当然，也可以通过lowerSeries来指定另外一个折线系列作为图形的下边界。</p>
</li>
<li><p>柱形图、堆积柱形图、百分比堆积柱形图</p>
<p>柱形图通过水平或垂直的按类分组的柱形条来表示数据，前面示例中已经看到柱形图BarSeries类型可以使用按类分组的垂直柱形条来表示数据，每一类（categories）都包含了所有柱形集BarSet的一个柱形条。</p>
<p>而在堆积柱形图StackedBarSeries中，一类柱形条会堆积在一个垂直柱形条上，每个柱形集中对应分类的柱形条都作为这个垂直柱形条的一段。</p>
<p>百分比堆积柱形图PercentBarSeries与堆积柱形图类似，只是所有堆积柱形条都是等长的，而其中的分段柱形会根据代表的数值在总值中的占比绘制为不同的长度。</p>
<p>这3种柱形图的代码可以通用，比如前面使用BarSeries的示例，可以直接更改类型名称为StackedBarSeries或者PercentBarSeries来使用其他两种类型。</p>
</li>
<li><p>饼状图</p>
<p>饼状图PieSeries由PieSlice类型定义的切片组成，PieSeries可以通过计算一个切片在总切片中占得百分比来决定该切片在饼状图中的大小。默认的，饼状图被定义为一个完整的饼状，也可以通过设置开始角度startAngle和结束角度endAngle来创建部分饼图。一个完整的饼图为360度，12点钟方向为0。可以通过find(string label)或者at(int index)来获取一个指定的切片，切片的exploded属性可以设置该切片与饼状图分离，从而突出显示。</p>
</li>
<li><p>盒须图（箱形图）</p>
<p>盒须图BoxPlotSeries又称为箱形图，因其形状如箱子而得名，常用于品质管理。盒须图中的盒须项由BoxSet类型指定，它是五个不同数值的图形表示，这五个数值按最小值、下四分位数、中位数、上四分位数和最大值的顺序进行指定。</p>
</li>
<li><p>蜡烛图（K线图）</p>
<p>蜡烛图CandlestickSeries又称为K线图，常用于股市和期货市场。蜡烛图中的蜡烛项由CandlestickSet类型指定，它是五个数值的图形表示：open、high、low、close和timestamp。需要注意的是，在一个蜡烛图中，每个timestamp必须是唯一的。</p>
</li>
<li><p>极坐标图</p>
<p>极坐标图PolarChartView在一个圆图中来展示数据，在这个圆图中的数据点通过一个夹角和一段相对于极点（中心点）的距离来表示。PolarChartView是对ChartView类型的特例化，支持折线系列、曲线系列、面积系列和散点系列，以及这些系列所支持的坐标轴类型，每一个坐标轴既可以作为径向轴也可以作为角轴。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p><strong>Qt</strong> <strong>Data Visualization</strong> 模块提供了一种开发复杂、动态且需要快速响应的3D可视化应用的方法，可以通过3D柱形图、3D散点图和3D曲面图等形式来展示数据，还可以实现在3D视图和2D视图之间进行切换。</p>
<p>使用该模块需要在项目文件.pro中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += datavisualization</span><br></pre></td></tr></table></figure>

<p>Qt Data Visualization模块需要OpenGL的支持。可以在main()函数的开头添加如下一行代码来明确定义渲染后端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qputenv(&quot;QSG_RHI_BACKEND&quot;, &quot;opengl&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="Widgets-2"><a href="#Widgets-2" class="headerlink" title="Widgets"></a>Widgets</h3><p><strong>QAbstract3DGraph</strong>类是所有3D图形的基类，它继承自<strong>QWindow</strong>和<strong>QOpenGLFunctions</strong>。</p>
<p>该类无法直接使用，实际编程中，使用的是它的3个子类，分别是Q3DBars（3D柱形图）、Q3DScatter（3D散点图）和Q3DSurface（3D曲面图）。使用Qt Data Visualization模块，需要包含如下头文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtDataVisualization&gt;</span><br></pre></td></tr></table></figure>

<p><strong>1. 3D柱形图</strong></p>
<p>以Q3DBars为例，因为要将其作为顶级窗口，默认设置的<code>Qt::FramelessWindowHint</code>窗口类型清除掉，然后通过rowAxis()、columnAxis()来获取行和列的默认轴并设置了范围。</p>
<p>QBar3DSeries类用来管理系列的可视化元素和数据。</p>
<p>需要通过使用数据代理QBarDataProxy来添加数据，可以通过dataProxy()来获取默认的数据代理。</p>
<p>系列中每一行的数据可以由QBarDataRow来指定，然后通过QBarDataProxy的addRow()将其添加到系列中。</p>
<p>最后使用Q3DBars的addSeries()将系列添加到3D柱形图中，并调用show()进行显示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    qputenv(&quot;QSG_RHI_BACKEND&quot;, &quot;opengl&quot;);</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    Q3DBars bars;</span><br><span class="line">    bars.setFlags(bars.flags() ^ Qt::FramelessWindowHint);</span><br><span class="line">    bars.resize(800, 600);</span><br><span class="line">    bars.rowAxis()-&gt;setRange(0, 1);</span><br><span class="line">    bars.columnAxis()-&gt;setRange(0, 3);</span><br><span class="line">    QBar3DSeries *series = new QBar3DSeries;</span><br><span class="line">    QBarDataRow *data = new QBarDataRow;</span><br><span class="line">    QBarDataRow *data1 = new QBarDataRow;</span><br><span class="line">    *data &lt;&lt; 1.0f &lt;&lt; 3.0f &lt;&lt; 7.5f &lt;&lt; 5.0f ;</span><br><span class="line">    *data1 &lt;&lt; 2.0f &lt;&lt; 1.0f &lt;&lt; 4.0f &lt;&lt; 3.5f;</span><br><span class="line">    series-&gt;dataProxy()-&gt;addRow(data);</span><br><span class="line">    series-&gt;dataProxy()-&gt;addRow(data1);</span><br><span class="line">    bars.addSeries(series);</span><br><span class="line">    bars.show();</span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;                           </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095520949.png" alt="image-20250713095520949"></p>
<p><strong>2. 自定义3D场景</strong></p>
<p>3D场景是通过使用Q3DScene类实现的，场景中包含了一个活动相机（使用Q3DCamera类实现）和一个活动光源（使用Q3DLight类实现）。光源始终相对于相机定位，默认情况下，灯光位置会自动跟随相机。</p>
<p>可以通过指定相机的预设位置、旋转和缩放级别来定制相机。代码中可以使用Q3DBars的scene()函数来获取Q3DScene实例的指针，然后使用其activeCamera()函数获取场景中当前活动的相机。<br>对于Q3DCamera，可以使用setXRotation()、setYRotation()和setZoomLevel()等函数来设置相机的旋转和缩放，还可以使用setCameraPreset()来设置相机的位置，通过Q3DCamera::CameraPreset枚举类型提供了20多种预设的相机位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q3DCamera *camera = bars.scene()-&gt;activeCamera();</span><br><span class="line">camera-&gt;setCameraPreset(Q3DCamera::CameraPresetIsometricRightHigh);</span><br><span class="line">camera-&gt;setZoomLevel(130);                           </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095534057.png" alt="image-20250713095534057"></p>
<p><strong>3. 设置轴标签、柱形标签和轴标题</strong></p>
<p>在前面使用addRow()添加数据的时候就可以使用该函数的另外一种重载形式指定行标签，不过，也可以单独使用QBarDataProxy类的setRowLabels()来为所有行添加标签，使用setColumnLabels()来为所有列添加标签。</p>
<p>对于3D柱形图中每个柱形的标签，可以使用QBar3DSeries的setItemLabelFormat()来设置，其中可以使用@rowLabel、@colLabel和@valueLabel等格式标记。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const QStringList rows = &#123; &quot;row0&quot;, &quot;row1&quot; &#125;;</span><br><span class="line">const QStringList cols = &#123; &quot;col0&quot;, &quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot; &#125;;</span><br><span class="line">series-&gt;dataProxy()-&gt;setRowLabels(rows);</span><br><span class="line">series-&gt;dataProxy()-&gt;setColumnLabels(cols);</span><br><span class="line">series-&gt;setItemLabelFormat(&quot;@rowLabel, @colLabel: @valueLabel&quot;);       </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095604154.png" alt="image-20250713095604154"></p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095050305.png" alt="image-20250713095050305"></p>
<p>可以分别使用Q3DBars的rowAxis()、columnAxis()和valueAxis()来获取默认的3个轴， 3D柱形图的行和列坐标轴均为QCategory3DAxis，数值坐标轴为QValue3DAxis，这两类坐标轴都继承自QAbstract3DAxis。轴标题默认是不显示的，可以通过setTitleVisible(true)进行显示，使用setTitle()来设置轴标题。</p>
<p>轴上标签也可以随着相机的移动来自动改变角度，从而尽可能朝向相机，可以使用setLabelAutoRotation()来设置角度，取值范围为0~90。另外，可以通过orientation()来获取轴的方向，其结果由QAbstract3DAxis::AxisOrientation枚举类型指定，即X轴、Y轴和Z轴。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bars.rowAxis()-&gt;setTitle(&quot;Row&quot;);</span><br><span class="line">bars.rowAxis()-&gt;setTitleVisible(true);</span><br><span class="line">bars.columnAxis()-&gt;setTitle(&quot;Column&quot;);</span><br><span class="line">bars.columnAxis()-&gt;setTitleVisible(true);</span><br><span class="line">bars.valueAxis()-&gt;setTitle(&quot;Value&quot;);</span><br><span class="line">bars.valueAxis()-&gt;setTitleVisible(true);</span><br><span class="line">bars.columnAxis()-&gt;setLabelAutoRotation(60);</span><br><span class="line">qDebug() &lt;&lt; &quot;rowAxis: &quot; &lt;&lt; bars.rowAxis()-&gt;orientation();        // Z轴</span><br><span class="line">qDebug() &lt;&lt; &quot;columnAxis: &quot; &lt;&lt; bars.columnAxis()-&gt;orientation();  // X轴</span><br><span class="line">qDebug() &lt;&lt; &quot;valueAxis: &quot; &lt;&lt; bars.valueAxis()-&gt;orientation();    // Y轴     </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095615823.png" alt="image-20250713095615823"></p>
<p><strong>4. 设置3D项的形状</strong></p>
<p>在QAbstract3DSeries中预定义了多个3D形状，如下表所列。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095147991.png" alt="image-20250713095147991"></p>
<p>可以通过setMesh()为系列的项进行设置。还可以通过setMeshSmooth(true)来使3D形状显示更平滑。</p>
<p>另外，Q3DBars中的setBarThickness()可以设置柱形条的宽窄，默认值为1.0，表示宽度和深度一样，如果设置为0.5，则表示深度是宽度的两倍。</p>
<p>可以使用setBarSpacing()来设置在X轴、Z轴上柱形条之间的空隙，默认值为(1.0, 1.0)。</p>
<p>还有一个setFloorLevel()可以设置Y轴的水平面位置，默认值为0，大于该值的柱形条会绘制在平面上方，小于该值的柱形条会绘制在平面下方。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">series-&gt;setMesh(QAbstract3DSeries::MeshPyramid);</span><br><span class="line">series-&gt;setMeshSmooth(true);    </span><br><span class="line">bars.setBarThickness(0.6);</span><br><span class="line">bars.setBarSpacing(QSizeF(3.0, 2.0));                   </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095626652.png" alt="image-20250713095626652"></p>
<p><strong>5. 设置主题</strong></p>
<p>Q3DTheme类用来指定影响所有图形的视觉属性，Qt提供了几个内置的主题可以直接使用，也可以在这些现成主题上进行修改。可以通过Q3DBars的activeTheme()来获取主题对象，然后使用Q3DTheme的setType()来设置要使用的主题类型，可以通过Q3DTheme::Theme关键字查看所有主题类型。另外，还可以使用Q3DTheme类中众多的函数来自定义主题的相关属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bars.activeTheme()-&gt;setType(Q3DTheme::ThemeStoneMoss);</span><br><span class="line">const QList&lt;QColor&gt; colors = &#123; Qt::green &#125;;</span><br><span class="line">bars.activeTheme()-&gt;setBaseColors(colors);</span><br><span class="line">bars.activeTheme()-&gt;setSingleHighlightColor(Qt::red);                 </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095637460.png" alt="image-20250713095637460"></p>
<p><strong>6. 选择模式和切片视图</strong></p>
<p>所有可视化类型都支持使用鼠标、触摸和编程的方式来选择单个数据项，被选中的项会进行突出显示。3D柱形图和3D曲面图还支持切片选择模式，可以将选中的行或列以伪2D图形的形式绘制在分离出来的视图中，这样可以很方便地查看单个行或列的实际值。</p>
<p>3D柱形图还支持在不打开切片视图的情况下突出显示所选柱形的整个行或列。通过设置选择模式，在3D柱形图中还支持通过单击轴标签来选择整个行或列。</p>
<p>可以使用QAbstract3DGraph的setSelectionMode()来设置选择模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bars.setSelectionMode(QAbstract3DGraph::SelectionRow | QAbstract3DGraph::SelectionSlice);                 </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095650829.png" alt="image-20250713095650829"></p>
<p><strong>7. 项目模型和数据映射</strong></p>
<p>前面示例中通过数据代理为3D柱形图添加了数据，除此之外，每种可视化类型都为项目模型（QAbstractItemModel的子类）提供了专门的代理类，例如，用于QBar3DSeries的QItemModelBarDataProxy，用于Q3DScatter的QItemModelScatterDataProxy，以及用于Q3DSurface的QItemModelSurfaceDataProxy。</p>
<p>这些代理使用起来很简单，只需要为它们指定一个包含数据的项目模型的指针，然后设置映射规则即可。数据映射是基于项目模型的角色（role）的，需要为不同可视化类型提供不同角色的数据。对于特定的可视化类型，代理也支持其他一些功能，例如，QItemModelBarDataProxy可以将QAbstractItemModel的行和列直接映射到柱形图的行和列。</p>
<p>这里先使用QTableWidget来生成表格并保存数据，最后需要指定竖直和水平表头的标签内容。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095325256.png" alt="image-20250713095325256"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">QTableWidget *tableWidget = new QTableWidget(2, 3, this);</span><br><span class="line">tableWidget-&gt;resize(360, 90);</span><br><span class="line">tableWidget-&gt;move(220, 10);</span><br><span class="line">QStringList days;</span><br><span class="line">days &lt;&lt; &quot;Monday&quot; &lt;&lt; &quot;Tuesday&quot; &lt;&lt; &quot;Wednesday&quot;;</span><br><span class="line">QStringList weeks;</span><br><span class="line">weeks &lt;&lt; &quot;week 1&quot; &lt;&lt; &quot;week 2&quot;;</span><br><span class="line">//                       Mon   Tue   Wed</span><br><span class="line">float expenses[2][3] = &#123;&#123;2.0f, 1.0f, 3.0f&#125;,    // week 1</span><br><span class="line">                        &#123;0.5f, 1.0f, 3.0f&#125;&#125;;   // week 2</span><br><span class="line">for (int week = 0; week &lt; weeks.size(); week++) &#123;</span><br><span class="line">    for (int day = 0; day &lt; days.size(); day++) &#123;</span><br><span class="line">        QModelIndex index = tableWidget-&gt;model()-&gt;index(week, day);</span><br><span class="line">        tableWidget-&gt;model()-&gt;setData(index, expenses[week][day]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tableWidget-&gt;setVerticalHeaderLabels(weeks);</span><br><span class="line">tableWidget-&gt;setHorizontalHeaderLabels(days);                 </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Q3DBars *graph = new Q3DBars();</span><br><span class="line">QWidget *container = QWidget::createWindowContainer(graph, this);</span><br><span class="line">container-&gt;resize(780, 450);</span><br><span class="line">container-&gt;move(10, 120);</span><br><span class="line">Q3DCamera *camera = graph-&gt;scene()-&gt;activeCamera();</span><br><span class="line">camera-&gt;setCameraPreset(Q3DCamera::CameraPresetIsometricRightHigh);</span><br><span class="line">graph-&gt;activeTheme()-&gt;setType(Q3DTheme::ThemeIsabelle);                </span><br></pre></td></tr></table></figure>

<p>因为所有数据可视化图形类都继承自QWindow，所以它们无法直接作为QWidget的子部件，需要使用QWidget::createWindowContainer()来创建一个QWidget窗口容器，从而将QWindow嵌入到基于QWidget的应用中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QItemModelBarDataProxy *proxy = </span><br><span class="line">new QItemModelBarDataProxy(tableWidget-&gt;model());</span><br><span class="line">proxy-&gt;setUseModelCategories(true);</span><br><span class="line">QBar3DSeries *series = new QBar3DSeries(proxy);</span><br><span class="line">series-&gt;setMesh(QAbstract3DSeries::MeshPyramid);</span><br><span class="line">graph-&gt;addSeries(series);</span><br><span class="line">graph-&gt;setSelectionMode(QAbstract3DGraph::SelectionRow</span><br><span class="line">| QAbstract3DGraph::SelectionSlice);              </span><br></pre></td></tr></table></figure>

<p>创建QItemModelBarDataProxy实例时需要指定数据模型，通过setUseModelCategories(true)可以直接使用模型中的行和列映射到3D柱形图的行和列，并使用Qt::DisplayRole指定的数据作为柱形项的数值。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095732963.png" alt="image-20250713095732963"></p>
<p><strong>8. 3D散点图和3D曲面图</strong></p>
<p>Q3DScatter用于创建3D散点图，它将数据呈现为一些点的集合。QScatter3DSeries和QScatterDataProxy用于将数据设置到图形，以及控制图形的可视属性。</p>
<p>可以分别通过Q3DScatter的axisX()、axisY()和axisZ()来获取3个坐标轴，它们都是QValue3DAxis数值坐标轴。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Q3DScatter scatter;</span><br><span class="line">scatter.setFlags(scatter.flags() ^ Qt::FramelessWindowHint);</span><br><span class="line">scatter.resize(800, 600);</span><br><span class="line">QScatter3DSeries *series = new QScatter3DSeries;</span><br><span class="line">QScatterDataArray data;</span><br><span class="line">data &lt;&lt; QVector3D(0.5f, 0.5f, 0.5f) &lt;&lt; QVector3D(-0.3f, -0.5f, -0.4f)</span><br><span class="line">     &lt;&lt; QVector3D(0.0f, -0.3f, 0.2f);</span><br><span class="line">series-&gt;dataProxy()-&gt;addItems(data);</span><br><span class="line">scatter.addSeries(series);</span><br><span class="line">scatter.show();               </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095749337.png" alt="image-20250713095749337"></p>
<p>Q3DSurface用于将数据呈现为3D曲面图，QSurface3DSeries和 QSurfaceDataProxy用于为图形设置数据，以及控制图形的可视属性。</p>
<p>与Q3DScatter一样，可以通过Q3DSurface的axisX()、axisY()和axisZ()来获取3个坐标轴，它们都是QValue3DAxis数值坐标轴。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Q3DSurface surface;</span><br><span class="line">surface.setFlags(surface.flags() ^ Qt::FramelessWindowHint);</span><br><span class="line">surface.resize(800, 600);</span><br><span class="line">QSurfaceDataArray *data = new QSurfaceDataArray;</span><br><span class="line">QSurfaceDataRow *dataRow1 = new QSurfaceDataRow;</span><br><span class="line">QSurfaceDataRow *dataRow2 = new QSurfaceDataRow;</span><br><span class="line">*dataRow1 &lt;&lt; QVector3D(0.0f, 0.1f, 0.5f) </span><br><span class="line">               &lt;&lt; QVector3D(1.0f, 0.5f, 0.5f);</span><br><span class="line">*dataRow2 &lt;&lt; QVector3D(0.0f, 1.8f, 1.0f) </span><br><span class="line">               &lt;&lt; QVector3D(1.0f, 1.2f, 1.0f);</span><br><span class="line">*data &lt;&lt; dataRow1 &lt;&lt; dataRow2;</span><br><span class="line">QSurface3DSeries *series = new QSurface3DSeries;</span><br><span class="line">series-&gt;dataProxy()-&gt;resetArray(data);</span><br><span class="line">surface.addSeries(series);</span><br><span class="line">surface.show();             </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095802300.png" alt="image-20250713095802300"></p>
<p>Q3DSurface还可以使用QHeightMapSurfaceDataProxy数据代理对高度图数据进行处理，从而将高度图可视化为3D曲面图，显示出3D地形图的效果。<br>可以看到，只需要使用QHeightMapSurfaceDataProxy指定高度图的路径即可，为了显示更清晰，一般会设置setDrawMode(QSurface3DSeries::DrawSurface)，这样只绘制曲面而不再绘制网格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Q3DSurface surface1;</span><br><span class="line">surface1.setFlags(surface1.flags() ^ Qt::FramelessWindowHint);</span><br><span class="line">surface1.resize(800, 600);</span><br><span class="line">surface1.activeTheme()-&gt;setType(Q3DTheme::ThemeStoneMoss);</span><br><span class="line">QSurface3DSeries *series1 = new QSurface3DSeries;</span><br><span class="line">QHeightMapSurfaceDataProxy *proxy =</span><br><span class="line">        new QHeightMapSurfaceDataProxy(&quot;../my3dsurface/layer.png&quot;);</span><br><span class="line">series1-&gt;setDataProxy(proxy);</span><br><span class="line">series1-&gt;setDrawMode(QSurface3DSeries::DrawSurface);</span><br><span class="line">surface1.addSeries(series1);</span><br><span class="line">surface1.show();           </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095814397.png" alt="image-20250713095814397"></p>
<hr>
<h3 id="Quick-3"><a href="#Quick-3" class="headerlink" title="Quick"></a>Quick</h3><p>在Qt Data Visualization模块中的<strong>AbstractGraph3D</strong>类型是Qt Quick中所有3D图形的基类型，</p>
<p>其3个子类型分别是Bars3D（3D柱形图）、Scatter3D（3D散点图）和Surface3D（3D曲面图）。要使用这些QML类型，需要使用如下导入语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import QtDataVisualization</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>1. 3D柱形图</strong></p>
<p>Qt Quick中Bars3D类型用来创建3D柱形图，Bar3DSeries和BarDataProxy用来为图形设置数据并控制图形的可视化属性。BarDataProxy作为3D柱形图的数据代理，可以处理数据行的添加、插入、更改、移除等操作，但是该类型无法直接创建，编程中要使用其子类型ItemModelBarDataProxy。</p>
<p>Bars3D类型用来渲染3D柱形图，在其中需要使用Bar3DSeries来设置数据系列，Bar3DSeries除了管理可视化元素以外，还需要通过数据代理ItemModelBarDataProxy来设置系列的数据。</p>
<p>这里的数据是通过ListModel提供的，在ItemModelBarDataProxy中由itemModel属性指定了数据模型，然后通过rowRole、columnRole和valueRol这3个属性将模型中的角色与3D柱形系列的行、列和数值进行映射。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Window &#123;</span><br><span class="line">    visible: true; width: 640; height: 480</span><br><span class="line"></span><br><span class="line">    Bars3D &#123;</span><br><span class="line">        width: parent.width</span><br><span class="line">        height: parent.height</span><br><span class="line"></span><br><span class="line">        Bar3DSeries &#123;</span><br><span class="line">            itemLabelFormat: &quot;@colLabel, @rowLabel: @valueLabel&quot;</span><br><span class="line"></span><br><span class="line">            ItemModelBarDataProxy &#123;</span><br><span class="line">                itemModel: dataModel</span><br><span class="line">                rowRole: &quot;year&quot;</span><br><span class="line">                columnRole: &quot;city&quot;</span><br><span class="line">                valueRole: &quot;expenses&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListModel &#123;</span><br><span class="line">        id: dataModel</span><br><span class="line">        ListElement&#123; year: &quot;2012&quot;; city: &quot;Oulu&quot;; expenses: &quot;4200&quot;; &#125;</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095921899.png" alt="image-20250713095921899"></p>
<p><strong>2. 3D坐标轴</strong></p>
<p>Qt Data Visualization中支持数值坐标轴ValueAxis3D和分类坐标轴CategoryAxis3D，它们都继承自AbstractAxis3D类型。与Qt Charts类似，如果没有明确指定坐标轴，那么会创建一个没有标签的临时默认坐标轴。但是如果在一个方向上指定了坐标轴，那么该方向上的默认坐标轴就会被销毁。</p>
<p>这里通过ValueAxis3D和两个CategoryAxis3D定义了3个坐标轴，分别设置为了Bars3D的行坐标轴、列坐标轴和数值坐标轴。对于ValueAxis3D，它与Qt Charts中的ValueAxis类似；CategoryAxis3D与Qt Charts中的CategoryAxis也很类似，这里在cAxis中还设置了其labels属性，因为该轴上对应的数据month为数值，显示不够友好，所以这里进行了设置；而labelAutoRotation属性可以设置标签的可旋转角度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Bars3D &#123;</span><br><span class="line">    width: parent.width; height: parent.height</span><br><span class="line">    rowAxis: rAxis; columnAxis: cAxis; valueAxis: vAxis</span><br><span class="line">    </span><br><span class="line">    Bar3DSeries &#123;</span><br><span class="line">        itemLabelFormat: &quot;@colLabel, @rowLabel: @valueLabel&quot;</span><br><span class="line">        </span><br><span class="line">        ItemModelBarDataProxy &#123;</span><br><span class="line">            itemModel: dataModel</span><br><span class="line">            rowRole: &quot;year&quot;; columnRole: &quot;month&quot;; valueRole: &quot;income&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ValueAxis3D &#123;</span><br><span class="line">    id: vAxis</span><br><span class="line">    title: &quot;Y-Axis&quot;; titleVisible: true</span><br><span class="line">    min: 0; max: 30</span><br><span class="line">    subSegmentCount: 2</span><br><span class="line">    labelFormat: &quot;%.1f&quot;</span><br><span class="line">&#125;</span><br><span class="line">CategoryAxis3D &#123;</span><br><span class="line">    id: rAxis</span><br><span class="line">    title: &quot;Z-Axis&quot;; titleVisible: true; labelAutoRotation: 30</span><br><span class="line">&#125;</span><br><span class="line">CategoryAxis3D &#123;</span><br><span class="line">    id: cAxis</span><br><span class="line">    title: &quot;X-Axis&quot;; titleVisible: true</span><br><span class="line">    labels: [&quot;January&quot;, &quot;February&quot;]</span><br><span class="line">    labelAutoRotation: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713095956557.png" alt="image-20250713095956557"></p>
<p><strong>3. 数据代理</strong></p>
<p>在前面的示例中已经看到，需要通过数据代理将模型中的数据映射到图表上。除了前面在Bar3DSeries中使用的ItemModelBarDataProxy，后面要讲到的3D散点图、3D曲面图也有自己的数据代理，相关类型的继承关系如图所示。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713100019653.png" alt="image-20250713100019653"></p>
<p>通过ItemModelBarDataProxy可以使用AbstractItemModel派生出的模型作为3D柱形图 Bars3D的数据源，当映射或模型改变时，数据会进行异步解析。在前面的示例中已经看到，默认情况下映射的数据会自动生成行分类和列分类，但有时候可能只想显示某些分类的内容，这时可以通过ItemModelBarDataProxy类型的rowCategories和columnCategories来明确指定需要显示的行、列分类，同时还需要设置autoRowCategories、autoColumnCategories为false，这样才能使设置的分类生效。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rowCategories: [&quot;2019&quot;]</span><br><span class="line">autoRowCategories: false</span><br><span class="line">columnCategories: [&quot;01&quot;]</span><br><span class="line">autoColumnCategories: false</span><br></pre></td></tr></table></figure>

<p>有时候模型提供的数据并不是直接可用的，比如角色timestamp的值为2006-01，而实际需要的是里面的年份2006和月份01，这时就需要对这个timestamp的数据进行处理。</p>
<p>在ItemModelBarDataProxy中提供了rowRolePattern和columnRolePattern来使用正则表达式分别对行和列映射来的数据进行查找和替换，然后再作为分类使用。rowRolePattern和columnRolePattern属性可以指定一个正则表达式来找到需要替换的那部分数据，而对应的rowRoleReplace和columnRoleReplace两个属性则用来指定具体要替换的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ItemModelBarDataProxy &#123;</span><br><span class="line">    itemModel: dataModel</span><br><span class="line">    rowRole: &quot;timestamp&quot;</span><br><span class="line">    columnRole: &quot;timestamp&quot;</span><br><span class="line">    valueRole: &quot;income&quot;</span><br><span class="line">    rowRolePattern: /^(\d\d\d\d).*$/</span><br><span class="line">    columnRolePattern: /^.*-(\d\d)$/</span><br><span class="line">    rowRoleReplace: &quot;\\1&quot;</span><br><span class="line">    columnRoleReplace: &quot;\\1&quot;</span><br><span class="line">    multiMatchBehavior: ItemModelBarDataProxy.MMBCumulative</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListModel &#123;</span><br><span class="line">    id: dataModel</span><br><span class="line">    ListElement&#123; timestamp: &quot;2006-01&quot;; expenses: &quot;-4&quot;;  income: &quot;5&quot; &#125;</span><br><span class="line">    ListElement&#123; timestamp: &quot;2006-02&quot;; expenses: &quot;-5&quot;;  income: &quot;6&quot; &#125;</span><br><span class="line">    ListElement&#123; timestamp: &quot;2006-02&quot;; expenses: &quot;-5&quot;;  income: &quot;4&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里行和列需要的年、月信息都包含在timestamp角色中，所以rowRole和columnRole都指定为了该角色，然后通过设置搜索表达式和替换字符串来获取timestamp中需要的那部分字段。</p>
<p>具体来说，对于rowRole，这里获取了timestamp字符串中第一个捕获的2006，然后使用2006把整个timestamp字符串进行替换，这样就只保留了年份信息；类似的，对于columnRole只保留了月份信息。</p>
<p>这里指定的ItemModelBarDataProxy.MMBCumulative表明会使用所有匹配到的数据的总和作为条形的数值。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713100119683.png" alt="image-20250713100119683"></p>
<p><strong>4. 3D系列</strong></p>
<p>3D柱形系列Bar3DSeries以及后面要讲到的Scatter3DSeries、Surface3DSeries都继承自Abstract3DSeries。在Abstract3DSeries中定义了一些基本的属性，比如颜色、项目标签、高亮颜色等，其中mesh属性指定了3D图形中单个项目的形状。另外，可以设置meshSmooth为true来显示3D图形的光滑版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mesh: Abstract3DSeries.MeshPyramid</span><br><span class="line">baseColor: &quot;gold&quot;</span><br><span class="line">singleHighlightColor: &quot;lightgreen&quot;</span><br><span class="line">itemLabelVisible: false</span><br><span class="line">meshAngle: 30</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713100157410.png" alt="image-20250713100157410"></p>
<p><strong>5. 自定义3D场景</strong></p>
<p>通过Scene3D类型可以设置3D场景，其中包含了一个由Camera3D指定的相机和一个由Light3D指定的光源，光源位置始终与相机相对应，默认情况下，光源位置会自动跟随相机。在代码中，一般可以通过scene.activeCamera来获取图形关联的场景的活动相机，从而进行相关设置。对于Camera3D，其cameraPreset属性可以设置预设的相机位置，提供了20多个现成的位置进行设置，可以参考Q3DCamera::CameraPreset；如果没有通过cameraPreset设置相机位置，那么也可以使用xRotation和yRotation来设置相机的角度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scene&#123;</span><br><span class="line">    activeCamera.cameraPreset: </span><br><span class="line">          Camera3D.CameraPresetIsometricRightHigh</span><br><span class="line">    activeCamera.zoomLevel: 120</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713100226033.png" alt="image-20250713100226033"></p>
<p><strong>6. 设置主题</strong></p>
<p>Qt Data Visualization中可以通过Theme3D类型来设置主题，其中内建了9种现成的主题，可以在帮助中通过Q3DTheme::Theme关键字进行查看。这些主题是通过一些可视元素的样式设置的集合，其中包含了颜色、字体、光照强度、环境光强度等。</p>
<p>在编程中可以直接使用现成的主题，也可以在这些主题的基础上进行修改，如果对所有主题都不满意，那么可以直接（当不指定主题时，默认使用Theme3D.ThemeUserDefined）从头来创建一个主题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Window &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    ThemeColor &#123; id: dynamicColor; color: &quot;gold&quot; &#125;</span><br><span class="line">    ThemeColor &#123; id: dynamicColor2; color: &quot;lightgreen&quot;&#125;</span><br><span class="line"></span><br><span class="line">    Theme3D &#123;</span><br><span class="line">        id: userDefinedTheme</span><br><span class="line">        ambientLightStrength: 0.5</span><br><span class="line">        backgroundColor: &quot;transparent&quot;; backgroundEnabled: true</span><br><span class="line">        baseColors: [dynamicColor, dynamicColor2]</span><br><span class="line">        colorStyle: Theme3D.ColorStyleUniform</span><br><span class="line">        font.pointSize: 35; font.bold: true</span><br><span class="line">        gridLineColor: &quot;grey&quot;</span><br><span class="line">        highlightLightStrength: 0.5</span><br><span class="line">        labelBackgroundColor: &quot;transparent&quot;</span><br><span class="line">        labelBorderEnabled: false; labelTextColor: &quot;white&quot;</span><br><span class="line">        lightColor: &quot;white&quot;; lightStrength: 7.0</span><br><span class="line">        singleHighlightColor: &quot;lightblue&quot;</span><br><span class="line">        windowColor: &quot;black&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    Bars3D &#123;theme: userDefinedTheme // 指定主题... ...&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713100259028.png" alt="image-20250713100259028"></p>
<p><strong>7. 选择模式和切换视图</strong></p>
<p>所有可视化类型都支持使用鼠标、触摸和编程的方式来选择单个数据项，被选中的项目会进行突出显示。3D柱形图和3D曲面图还支持切片选择模式，可以将选中的行或列以伪2D图形的形式绘制在分离出来的视图中，这样可以很方便地查看单个行或列的实际值。3D柱形图还支持在不打开切片视图的情况下突出显示所选柱形的整个行或列。通过设置选择模式，在3D柱形图中还支持通过单击轴标签来选择整个行或列。</p>
<p>要实现2D切片视图，只需要在Bars3D对象中添加如下一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionMode: AbstractGraph3D.SelectionItemAndRow | AbstractGraph3D.SelectionSlice</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713100332874.png" alt="image-20250713100332874"></p>
<p><strong>8. 3D散点图</strong></p>
<p>3D散点图Scatter3D通过一系列点来展示数据，与其对应的系列和数据代理分别是Scatter3DSeries和ScatterDataProxy。3D散点图的三个轴axisX、axisY和axisZ都是ValueAxis3D类型的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Scatter3D &#123;</span><br><span class="line">    width: parent.width; height: parent.height</span><br><span class="line">    axisX: xAxis; axisY: yAxis; axisZ: zAxis</span><br><span class="line"></span><br><span class="line">    scene&#123;</span><br><span class="line">        activeCamera.cameraPreset: </span><br><span class="line">             Camera3D.CameraPresetIsometricRightHigh</span><br><span class="line">        activeCamera.zoomLevel: 120</span><br><span class="line">    &#125;</span><br><span class="line">    theme: Theme3D &#123; type: Theme3D.ThemeStoneMoss；</span><br><span class="line">        font.pointSize: 35</span><br><span class="line">    &#125;</span><br><span class="line">    Scatter3DSeries &#123;</span><br><span class="line">        ItemModelScatterDataProxy &#123;</span><br><span class="line">            itemModel: dataModel</span><br><span class="line">            xPosRole: &quot;xPos&quot;; yPosRole: &quot;yPos&quot;; </span><br><span class="line">                      zPosRole: &quot;zPos&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713100402436.png" alt="image-20250713100402436"></p>
<p><strong>9. 3D曲面图</strong></p>
<p>3D曲面图Surface3D通过设置点形成一个曲面来展示数据，与其对应的系列和数据代理分别是Surface3DSeries和SurfaceDataProxy。3D曲面图的3个轴也都是ValueAxis3D类型的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Surface3D &#123;</span><br><span class="line">    width: parent.width</span><br><span class="line">    height: parent.height</span><br><span class="line">    </span><br><span class="line">    Surface3DSeries &#123;</span><br><span class="line">        itemLabelFormat: &quot;Pop density at (@xLabel N,</span><br><span class="line">                        @zLabel E): @yLabel&quot;</span><br><span class="line">        ItemModelSurfaceDataProxy &#123;</span><br><span class="line">            itemModel: dataModel</span><br><span class="line">            rowRole: &quot;longitude&quot;</span><br><span class="line">            columnRole: &quot;latitude&quot;</span><br><span class="line">            yPosRole: &quot;pop_density&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ListModel &#123;</span><br><span class="line">    id: dataModel</span><br><span class="line">    ListElement&#123; longitude: &quot;20&quot;; latitude: &quot;10&quot;; </span><br><span class="line">                 pop_density: &quot;4.75&quot;; &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713100443486.png" alt="image-20250713100443486"></p>
<p>在3D曲面图中还有一个HeightMapSurfaceDataProxy数据代理，它可以将一个高度图可视化为一个3D曲面图从而显示出3D地形图的效果，这个代理使用起来也非常简单，只需要指定一个高度图路径即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Surface3D &#123;</span><br><span class="line">    width: parent.width; height: parent.height</span><br><span class="line">    shadowQuality: AbstractGraph3D.ShadowQualityNone</span><br><span class="line"></span><br><span class="line">    scene&#123; activeCamera.cameraPreset:</span><br><span class="line">                Camera3D.CameraPresetIsometricLeft &#125;</span><br><span class="line">    axisY&#123; min: 20; max: 200; segmentCount: 5;</span><br><span class="line">        subSegmentCount: 2; labelFormat: &quot;%i&quot; &#125;</span><br><span class="line">    axisX&#123;...&#125;</span><br><span class="line">    axisZ&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    Surface3DSeries &#123;</span><br><span class="line">        baseGradient: layerGradient</span><br><span class="line">        drawMode: Surface3DSeries.DrawSurface</span><br><span class="line">        flatShadingEnabled: false</span><br><span class="line">        </span><br><span class="line">        HeightMapSurfaceDataProxy &#123;</span><br><span class="line">            heightMapFile:</span><br><span class="line">                  &quot;../mydatavisualization/layer.png&quot;</span><br><span class="line">        &#125;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250713100501502.png" alt="image-20250713100501502"></p>
<hr>
<hr>
<h2 id="多媒体应用"><a href="#多媒体应用" class="headerlink" title="多媒体应用"></a>多媒体应用</h2><p>Qt Multimedia 模块分别提供了一组QML类型和一组C++类来处理多媒体内容</p>
<p>要使用多媒体模块的内容，需要在.pro项目文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += multimedia</span><br></pre></td></tr></table></figure>

<h3 id="Widgets-3"><a href="#Widgets-3" class="headerlink" title="Widgets"></a>Widgets</h3><p>QMediaPlayer</p>
<p>QCamera</p>
<p><strong>1. 播放音频</strong></p>
<p>在Qt中，要想使计算机发出响声，最简单的方法是调用QApplication::beep()静态函数。</p>
<p>在Qt Multimedia模块中提供了多个类来实现不同层次的音频输入、输出和处理。</p>
<ul>
<li><p><strong>播放压缩音频</strong></p>
<p>Qt中播放一个音频文件（比如MP3歌曲）十分简单，通过使用QMediaPlayer，只需要几行代码即可完成。</p>
<p>QMediaPlayer被设计用来进行媒体播放，可以播放音频、视频和网络广播等。下面先来看一下如何使用该类播放音频文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">player = new QMediaPlayer;</span><br><span class="line">audioOutput = new QAudioOutput;</span><br><span class="line">player-&gt;setAudioOutput(audioOutput);</span><br><span class="line">// ...</span><br><span class="line">player-&gt;setSource(QUrl::fromLocalFile(&quot;/Music/coolsong.mp3&quot;));</span><br><span class="line">audioOutput-&gt;setVolume(50);</span><br><span class="line">player-&gt;play();                     </span><br></pre></td></tr></table></figure>

<p>当创建QMediaPlayer后，需要连接到QAudioOutput对象来播放音频，还要设置媒体源，这里使用了本地的一个MP3文件，如果要播放网络歌曲，只需要将地址修改为QUrl网络地址即可。</p>
<p>QMediaPlayer支持的音频文件格式取决于操作系统环境以及用户安装的媒体插件。</p>
</li>
<li><p><strong>低延迟声音效果</strong></p>
<p>QSoundEffect类可以使用一种低延迟方式来播放未压缩的音频文件，如WAV文件。</p>
<p>它非常适合用来播放与用户交互时的音效，如弹出框提示音、虚拟键盘按键音、游戏音效等。</p>
<p>如果并不需要低延迟效果，那么最好使用QMediaPlayer来播放音频，因为其支持更多的媒体格式并且占用资源更少。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">effect = new QSoundEffect(this);</span><br><span class="line">effect-&gt;setSource(QUrl::fromLocalFile(&quot;../mysoundeffect/sound.wav&quot;));</span><br><span class="line">effect-&gt;setVolume(0.25f);              </span><br></pre></td></tr></table></figure>

<p>QSoundEffect中还提供了play()、stop()等函数控制声音的播放，使用setLoopCount()可以设置声音的播放次数，当设置为0或1时表明只播放一次，如果要无限重复需要设置为QSoundEffect::Infinite。</p>
</li>
</ul>
<hr>
<p><strong>2. 播放视频</strong></p>
<p>视频文件也可以通过QMediaPlayer进行播放，但是需要借助QVideoWidget或者QGraphicsVideoItem类进行显示，这两个类都属于Qt Multimedia Widgets模块。</p>
<p>QVideoWidget继承自QWidget，所以它可以作为一个普通窗口部件进行显示，也可以嵌入到其他窗口中。</p>
<p>将QVideoWidget指定为QMediaPlayer的视频输出窗口后，就可以显示播放的视频画面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">player = new QMediaPlayer(this);</span><br><span class="line">audioOutput = new QAudioOutput;</span><br><span class="line">player-&gt;setAudioOutput(audioOutput);</span><br><span class="line">videoWidget = new QVideoWidget(this);</span><br><span class="line">videoWidget-&gt;resize(600, 300);</span><br><span class="line">videoWidget-&gt;move(100, 150);</span><br><span class="line">player-&gt;setVideoOutput(videoWidget);</span><br><span class="line">player-&gt;setSource(QUrl::fromLocalFile(&quot;../myvideowidget/video.wmv&quot;));</span><br><span class="line">player-&gt;play();      </span><br></pre></td></tr></table></figure>

<p>再来看下QGraphicsVideoItem，它继承自QGraphicsObject，类似于图形视图框架中讲到的QGraphicsWidget。QGraphicsVideoItem提供了一个窗口并可以作为一个图形项嵌入到场景中显示视频内容。</p>
<p>这里首先创建了场景、视图和视频图形项，然后创建了播放器，并将视频图形项作为播放器的视频输出窗口，最后设置了要播放的视频，并显示视图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QGraphicsScene scene;</span><br><span class="line">QGraphicsView view(&amp;scene);</span><br><span class="line">view.resize(600, 320);</span><br><span class="line">QGraphicsVideoItem item;</span><br><span class="line">scene.addItem(&amp;item);</span><br><span class="line">item.setSize(QSizeF(500, 300));</span><br><span class="line">item.setRotation(60);</span><br><span class="line">QMediaPlayer player;</span><br><span class="line">player.setVideoOutput(&amp;item);</span><br><span class="line">QAudioOutput audioOutput;</span><br><span class="line">player.setAudioOutput(&amp;audioOutput);</span><br><span class="line">player.setSource(QUrl::fromLocalFile(&quot;../myvideoitem/video.wmv&quot;));</span><br><span class="line">player.play();</span><br><span class="line">view.show();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. QMediaPlayer</strong></p>
<p>要使用QMediaPlayer进行播放，需要先使用setSource(const QUrl &amp;source)槽来设置媒体源，一般对于本地媒体只需要指定路径即可，所以像前面示例代码那样直接使用QUrl::fromLocalFile指定路径即可。如果这里提供了一个媒体流stream，那么将会直接从流中读取媒体数据而不再对媒体进行解析。</p>
<p>设置完媒体源以后，可以使用play()函数进行播放，使用pause()、stop()进行暂停和停止。可以通过source()来获取当前进行播放的媒体内容。使用duration()可以获得当前媒体的时长，position()可以获取当前的播放位置，单位均为毫秒。使用setPosition()可以跳转到一个播放点，通过关联positionChanged()信号可以随时获取播放进度。</p>
<p>QMediaPlayer本身无法播放声音，需要使用setAudioOutput()来指定QAudioOutput对象实现音频输出。QAudioOutput类可以通过setDevice()来设置音频输出设备，使用volume()可以获取当前的播放音量，其范围为0.0~1.0，setVolume()可以设置音量大小，而当音量改变时会发射volumeChanged()信号，如果要设置为静音，可以使用setMuted()函数。</p>
<p>新建Qt Widgets应用，并在设计模式设计界面：</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250714084222261.png" alt="image-20250714084222261"></p>
<p>下面先在构造函数中添加如下代码进行初始化操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">player = new QMediaPlayer(this);</span><br><span class="line">audioOutput = new QAudioOutput;</span><br><span class="line">player-&gt;setAudioOutput(audioOutput);</span><br><span class="line">player-&gt;setSource(QUrl::fromLocalFile(&quot;../myplayer/music.mp3&quot;));</span><br><span class="line">connect(player, &amp;QMediaPlayer::positionChanged,</span><br><span class="line">                       this, &amp;Widget::updatePosition);</span><br></pre></td></tr></table></figure>

<p>下面添加几个槽的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void Widget::on_pushButton_play_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    player-&gt;play(); // 播放</span><br><span class="line">&#125;</span><br><span class="line">void Widget::on_pushButton_pause_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    player-&gt;pause(); // 暂停</span><br><span class="line">&#125;</span><br><span class="line">void Widget::on_pushButton_stop_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    player-&gt;stop(); // 停止</span><br><span class="line">&#125;</span><br><span class="line">void Widget::on_horizontalSlider_position_sliderMoved(int position)</span><br><span class="line">&#123;</span><br><span class="line">    player-&gt;setPosition(position * 1000);  // 拖放进度</span><br><span class="line">&#125;</span><br><span class="line">void Widget::on_horizontalSlider_volume_sliderMoved(int position)</span><br><span class="line">&#123;</span><br><span class="line">    audioOutput-&gt;setVolume(position / 100.0);  //音量调节</span><br><span class="line">&#125;</span><br><span class="line">void Widget::updatePosition(qint64 position)  // 播放位置</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;horizontalSlider_position-&gt;setMaximum(player-&gt;duration() / 1000);</span><br><span class="line">    ui-&gt;horizontalSlider_position-&gt;setValue(position / 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>播放状态</strong></p>
<p>QMediaPlayer使用setSource()设置了媒体源后，该函数会直接返回，并不等待媒体加载完成，也不会检查可能存在的错误。当媒体的状况发生改变时播放器会发射mediaStatusChanged()信号，可以通过关联该信号来获取媒体加载的一些信息。播放器播放的当前媒体会有8种不同的状况，由QMediaPlayer::MediaStatus枚举类型定义。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250714084319702.png" alt="image-20250714084319702"></p>
<p>当播放器发生错误时会发射errorOccurred()信号，通过关联该信号可以对相应的错误进行处理。播放器会出现5种不同的错误情况，由QMediaPlayer::Error枚举类型定义。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250714084345066.png" alt="image-20250714084345066"></p>
<p>QMediaPlayer进行播放时拥有3种状态，它总是处于这3种状态的其中一种。这3种状态由QMediaPlayer::PlaybackState枚举类型定义。无论其先前处于什么状态，当播放器的状态发生改变时就会发射playbackStateChanged()信号，可以通过关联该信号来获取播放器当前的状态。</p>
<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250714084353947.png" alt="image-20250714084353947"></p>
<p>使用时可以先声明槽，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void stateChanged(QMediaPlayer::PlaybackState state);</span><br></pre></td></tr></table></figure>

<p>然后进行信号和槽的关联，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(player, &amp;QMediaPlayer::playbackStateChanged,  this, &amp;Widget::stateChanged);</span><br></pre></td></tr></table></figure>

<p>最后添加槽定义，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Widget::stateChanged(QMediaPlayer::PlaybackState state)</span><br><span class="line">&#123;</span><br><span class="line">    switch (state) &#123;</span><br><span class="line">    	case QMediaPlayer::StoppedState:</span><br><span class="line">        		ui-&gt;label_state-&gt;setText(tr(&quot;停止状态！&quot;));</span><br><span class="line">        		break;</span><br><span class="line">    	... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取媒体元数据</strong></p>
<p>可以使用QMediaPlayer的metaData()函数来获取媒体的元数据。在QMediaMetaData中提供了众多元数据属性，例如标题Title、作者Author、长度Duration、专辑艺术家AlbumArtist等。每当QMediaPlayer对媒体源进行解析，元数据可用时都会发射metaDataChanged()信号，可以关联该信号来获取当前媒体的相关信息。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(player, &amp;QMediaPlayer::metaDataChanged, this, &amp;Widget::metaDataChanged);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Widget::metaDataChanged()</span><br><span class="line">&#123;</span><br><span class="line">    QMediaMetaData metaData = player-&gt;metaData();</span><br><span class="line">    QString title = metaData.stringValue(QMediaMetaData::Title);</span><br><span class="line">    QString artist = metaData.stringValue(QMediaMetaData::AlbumArtist);</span><br><span class="line"></span><br><span class="line">    if(artist != &quot;&quot;) &#123;</span><br><span class="line">        setWindowTitle(title + &quot;-&quot; + artist);</span><br><span class="line">    &#125; else setWindowTitle(title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250714084452845.png" alt="image-20250714084452845"></p>
<hr>
<p><strong>4.  使用相机</strong></p>
<p>在Qt多媒体模块中提供了一些与相机相关的类，可以通过这些类进行拍照或者视频录制。<br>使用 QMediaDevices可以查询系统当前可用的相机设备，一般使用其静态函数defaultVideoInput()来获取默认相机设备信息，或者使用静态函数videoInputs()来获取所有可用相机的列表，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const QList&lt;QCameraDevice&gt; cameras = QMediaDevices::videoInputs();</span><br><span class="line">for (const QCameraDevice &amp;cameraDevice : cameras)</span><br><span class="line">    qDebug() &lt;&lt; cameraDevice.description();</span><br></pre></td></tr></table></figure>

<p>当获取了可用的相机信息后，可以通过QCameraDevice来构建一个相机，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera = new QCamera(cameraDevice);</span><br></pre></td></tr></table></figure>

<p>QCamera类为系统相机设备提供了相应的接口，可以使用start()和stop()来开启和关闭相机。</p>
<p>QMediaCaptureSession是管理本地设备上媒体捕获的中心类，可以使用其setCamera() 函数将相机连接到QMediaCaptureSession，还可以使用setVideoOutput()来设置取景器部件，在普通部件中可以使用QVideoWidget来作为取景器进行相机内容预览，在QGraphicsView中则可以使用QGraphicsVideoItem。</p>
<p><strong>进行拍照</strong></p>
<p>QImageCapture是一个图像录制类，与QCamera配合可以进行拍照。在使用该类对象前，需要先使用QMediaCaptureSession类的setImageCapture()函数进行设置。</p>
<p>使用QImageCapture类的captureToFile()可以捕获图片并保存到文件，这个操作一般是异步的，如果没有指定文件路径，那么会使用系统上的默认位置和图片命名方式来保存图片，如果只是提供了文件名，并没有指定完整的路径，那么会将图片保存到默认目录。</p>
<p>在拍照前，可以使用setMetaData()来为图片设置元数据；使用setQuality()可以设置图片质量，包括QImageCapture::VeryLowQuality、QImageCapture::NormalQuality等5种选择；还可以使用setResolution()来设置图片分辨率。</p>
<p>在调用start()开启相机前，需要先使用isActive()判断相机是否处于活动状态，因为有可能相机已经无法使用了但是camera依然处于活动状态的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Widget::on_pushButton_clicked() // 开启相机</span><br><span class="line">&#123;</span><br><span class="line">    if(QMediaDevices::videoInputs().count()) &#123;</span><br><span class="line">        const QList&lt;QCameraDevice&gt; cameras = QMediaDevices::videoInputs();</span><br><span class="line">        for (const QCameraDevice &amp;cameraDevice : cameras) &#123;</span><br><span class="line">            qDebug() &lt;&lt; cameraDevice.description();</span><br><span class="line">        &#125;</span><br><span class="line">        camera-&gt;setCameraDevice(cameras.at(0));</span><br><span class="line">        // 当开启相机后如果拔掉摄像头设备，相机依然处于活动状态，必须先关闭才能再次开启</span><br><span class="line">        if (camera-&gt;isActive()) camera-&gt;stop();</span><br><span class="line">        camera-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>视频录制</strong></p>
<p>QMediaRecorder类用来记录媒体内容，可以和QCamera一起使用进行视频录制。先创建QMediaRecorder对象，然后使用QMediaCaptureSession类的setRecorder()函数关联QMediaRecorder对象。进行录制时，可以先通过isAvailable()判断录制功能是否可用，如果可用，使用setOutputLocation()来设置录制文件保存路径，最后调用record()进行录制，可以使用pause()、stop()暂停和停止录制。还可以使用setQuality()、setMediaFormat()来设置录制品质和媒体格式。</p>
<p>先进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">recorder = new QMediaRecorder(camera);</span><br><span class="line">captureSession-&gt;setRecorder(recorder);	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Widget::on_pushButton_3_clicked(bool checked) &#123;</span><br><span class="line">    if(!recorder-&gt;isAvailable()) return;</span><br><span class="line">    if(checked) &#123;</span><br><span class="line">        ui-&gt;pushButton_3-&gt;setText(tr(&quot;停止录制&quot;));</span><br><span class="line">        QMediaFormat format(QMediaFormat::MPEG4);</span><br><span class="line">        format.setVideoCodec(QMediaFormat::VideoCodec::H264);</span><br><span class="line">        recorder-&gt;setMediaFormat(format);</span><br><span class="line">        recorder-&gt;setQuality(QMediaRecorder::HighQuality);</span><br><span class="line">        QString fileName = QFileDialog::getSaveFileName();</span><br><span class="line">        recorder-&gt;setOutputLocation(QUrl::fromLocalFile(fileName));</span><br><span class="line">        recorder-&gt;record();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ui-&gt;pushButton_3-&gt;setText(tr(&quot;录制视频&quot;));</span><br><span class="line">        recorder-&gt;stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对相机进行设置</strong></p>
<p>QCamera提供了丰富的函数来进行成像管道的控制，从而产生不同效果的最终图像。注意，并不是所有相机都支持以下这些设置。</p>
<ul>
<li><p>聚焦和缩放</p>
<p>在QCamera中可以通过setFocusMode()来设置焦点策略，其值由QCamera::FocusMode枚举类型指定，例如QCamera::FocusModeAuto、QCamera::FocusModeInfinity等。其中的QCamera::FocusModeAutoNear允许对靠近传感器的物体进行成像，这在条形码识别或者名片扫描等应用上非常有用。另外，QCamera还可以使用setZoomFactor()或zoomTo()来设置缩放，可以通过minimumZoomFactor()和maximumZoomFactor()来获取允许缩放的范围。</p>
</li>
<li><p>曝光和闪光灯</p>
<p>有许多设置会影响到照射到相机传感器上的光亮，从而影响最终生成图像的质量。对于自动成像而言，最重要的是设置曝光模式和闪光模式。在QCamera中，可以分别使用setExposureMode()和setFlashMode()来设置。另外，可以通过setTorchMode()来设置火炬模式，为低光条件下录制视频提供连续的光源。</p>
</li>
<li><p>白平衡</p>
<p>可以通过QCamera类的setWhiteBalanceMode()来设置白平衡模式，各种白平衡模式由QCamera::WhiteBalanceMode枚举类型进行定义，当使用QCamera::WhiteBalanceManual手动白平衡模式时，可以使用setColorTemperature()来设置色温。</p>
</li>
</ul>
<hr>
<p><strong>5.  录制音频</strong></p>
<p>录制音频也是通过QMediaRecorder来完成的。<br>录制音频与使用相机类似，需要先使用QMediaDevices的audioInputs()来获取可用的音频输入设备，可以使用defaultAudioInput()来获取默认的设备。可用的音频设备由QAudioDevice对象表示，可以通过其id()或者description()函数来获取设备相关信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const QList&lt;QAudioDevice&gt; devices = QMediaDevices::audioInputs();</span><br><span class="line">QStringList list;</span><br><span class="line">for (const QAudioDevice &amp;deviceInfo : devices) &#123;</span><br><span class="line">    qDebug() &lt;&lt; &quot;Device: &quot; &lt;&lt; deviceInfo.description();</span><br><span class="line">    list &lt;&lt; deviceInfo.description();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得音频输入设备以后需要创建QAudioInput对象，用来表示与QMediaCaptureSession一起使用的输入通道，该类可以通过setVolume()设置音量，使用setMuted()设置静音。最后使用QMediaRecorder的setOutputLocation()设置音频文件的保存路径，并调用record()进行录制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QMediaCaptureSession *session = new QMediaCaptureSession(this);</span><br><span class="line">audioInput = new QAudioInput(this);</span><br><span class="line">session-&gt;setAudioInput(audioInput);</span><br><span class="line">recorder = new QMediaRecorder(this);</span><br><span class="line">session-&gt;setRecorder(recorder);</span><br></pre></td></tr></table></figure>

<p>开始录制时，需要先设置音频输入设备、保存地址，然后调用record()进行录制。可以通过stop()停止录制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const QList&lt;QAudioDevice&gt; devices = QMediaDevices::audioInputs();</span><br><span class="line">int index = ui-&gt;comboBox-&gt;currentIndex();</span><br><span class="line">audioInput-&gt;setDevice(devices.at(index));</span><br><span class="line">recorder-&gt;setOutputLocation(QUrl::fromLocalFile(ui-&gt;lineEdit-&gt;text()));</span><br><span class="line">recorder-&gt;record();</span><br></pre></td></tr></table></figure>

<p>还可以通过关联durationChanged()信号来显示音频的录制时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connect(recorder,</span><br><span class="line">    &amp;QMediaRecorder::durationChanged, </span><br><span class="line">    this, </span><br><span class="line">    &amp;Widget::updateProgress);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Widget::updateProgress(qint64 duration)</span><br><span class="line">&#123;</span><br><span class="line">    if(recorder-&gt;error() != QMediaRecorder::NoError || duration &lt; 1000)</span><br><span class="line">        return;</span><br><span class="line">    setWindowTitle(tr(&quot;Recorded %1 sec&quot;).arg(duration / 1000));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Quick-4"><a href="#Quick-4" class="headerlink" title="Quick"></a>Quick</h3><p>在Qt Quick编程中，Qt Multimedia模块提供了相似的API，</p>
<p>例如在Qt Widgets中的QMediaPlayer类，在Qt Quick中对应了MediaPlayer类型。在QML代码中使用Qt Multimedia模块中的类型，需要添加如下导入语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import QtMultimedia</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>1.  播放压缩音频</strong></p>
<p>MediaPlayer类型可以用来播放压缩音频或者视频。要播放音频，需要为audioOutput属性设置一个AudioOutput对象，然后通过source属性指定音频文件的路径，最后在需要的地方调用play()来开始播放。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayer &#123; </span><br><span class="line">    audioOutput: AudioOutput &#123;&#125;； source: &quot;music.mp3&quot;；</span><br><span class="line">    Component.onCompleted: &#123; play() &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MediaPlayer可以通过play()、pause()和stop()等方法进行播放、暂停和停止等操作。</li>
<li>当进行完这些操作时会发射playbackStateChanged()信号，如果发生错误，会发射errorOccurred()信号。</li>
<li>使用duration属性可以获取音频的持续时间，单位是毫秒。</li>
<li>使用position属性可以获取当前的播放位置。</li>
<li>通过loops属性可以设置播放的循环次数，当设置为0或1时只会播放一次，当设置为MediaPlayer::Infinite时会无限循环播放，其默认值为1。</li>
<li>playbackRate属性可以用来设置播放速率，设置的值为默认播放速率的倍数，默认值为1.0。</li>
<li>使用metaData属性组可以获取媒体相关的信息，比如专辑的艺术家Author、专辑标题Title等。</li>
<li>mediaStatus属性保存了媒体加载的状况。</li>
</ul>
<p>下面的例子通过工具栏添加了控制播放的几个按钮，然后对播放进度、音量大小、循环次数和播放速度进行了设置。</p>
<p>首先是工具栏的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ApplicationWindow &#123;</span><br><span class="line">    id: window; width: 250; height: 200; visible: true</span><br><span class="line">    </span><br><span class="line">    header: ToolBar &#123;</span><br><span class="line">        RowLayout &#123;</span><br><span class="line">            anchors.fill: parent</span><br><span class="line">            ToolButton &#123; text: qsTr(&quot;播放&quot;); onClicked: player.play() &#125;</span><br><span class="line">            ToolButton &#123; text: qsTr(&quot;暂停&quot;); onClicked: player.pause() &#125;</span><br><span class="line">            ToolButton &#123; text: qsTr(&quot;停止&quot;); onClicked: player.stop() &#125;</span><br><span class="line">            ToolButton &#123; text: qsTr(&quot;打开&quot;); onClicked: fileDialog.open() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog2025.github.io/2025/07/01/Qt/image-20250714085025044.png" alt="image-20250714085025044"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Frame &#123;</span><br><span class="line">    anchors.fill: parent</span><br><span class="line">    ColumnLayout &#123;</span><br><span class="line">        spacing: 10; anchors.fill: parent</span><br><span class="line">        RowLayout &#123; Text &#123; text: qsTr(&quot;进度：&quot;) &#125;</span><br><span class="line">            Slider &#123;  Layout.fillWidth: true; to: player.duration; value: player.position；</span><br><span class="line">                      onMoved: player.position = value &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RowLayout &#123; Text &#123; text: qsTr(&quot;音量：&quot;) &#125;</span><br><span class="line">            Slider &#123; Layout.fillWidth: true; to: 1.0; value: audio.volume； onMoved: audio.volume = value &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RowLayout &#123; Layout.alignment: Qt.AlignHCenter; Text &#123; text: qsTr(&quot;循环次数：&quot;) &#125;</span><br><span class="line">            SpinBox &#123; value: 1; onValueChanged: player.loops = value &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RowLayout &#123; Layout.alignment: Qt.AlignHCenter; Text &#123; text: qsTr(&quot;播放速度：&quot;) &#125;</span><br><span class="line">            SpinBox &#123; value: 1;  stepSize: 1；onValueChanged: player.playbackRate = value &#125;</span><br><span class="line">   &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayer &#123;</span><br><span class="line">    id: player</span><br><span class="line">    audioOutput: AudioOutput &#123; id: audio &#125;</span><br><span class="line">    source: fileDialog.file</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileDialog &#123;</span><br><span class="line">    id: fileDialog</span><br><span class="line">    folder: StandardPaths.writableLocation(StandardPaths.DocumentsLocation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 播放未压缩音频</strong><br>与前面讲到的QSoundEffect类对应的是SoundEffect类型，允许在Qt Quick中使用低延迟的方式播放未压缩的音频文件。如果不需要低延迟，那么建议使用MediaPlayer类型。</p>
<p>一般SoundEffect类型播放的声音都是会被多次使用的。它允许提前进行解析并且准备完毕，在需要的时候只需要触发即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Text &#123;</span><br><span class="line">    text: &quot;Click Me!&quot;;  font.pointSize: 24; width: 150; height: 50</span><br><span class="line"></span><br><span class="line">    SoundEffect &#123;</span><br><span class="line">        id: playSound； source: &quot;soundeffect.wav&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        id: playArea; anchors.fill: parent</span><br><span class="line">        onPressed: &#123;  playSound.play() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 播放视频</strong></p>
<p>要使用MediaPlayer播放视频，除了指定音频输出，还需要使用videoOutput属性指定视频输出对象VideoOutput。VideoOutput类型中有一个orientation属性，可以设置视频的方向，通过指定一个度数（需要是90的倍数）来旋转视频，逆时针方向为正值。另外，该类型还包含一个fillMode属性，用来定义视频如何缩放来适应窗口，可以取以下值：</p>
<ul>
<li>VideoOutput.Stretch：视频进行缩放来适应窗口大小；</li>
<li>VideoOutput.PreserveAspectFit：默认值，视频宽高按比例进行缩放，不会进行裁剪；</li>
<li>VideoOutput.PreserveAspectCrop：视频宽高按比例进行缩放，在必要时会进行裁剪。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">        id: item; anchors.fill: parent</span><br><span class="line"></span><br><span class="line">        MediaPlayer &#123;</span><br><span class="line">            id: player； source: &quot;video.wmv&quot;</span><br><span class="line">            audioOutput: AudioOutput &#123;&#125;</span><br><span class="line">            videoOutput: videoOutput</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VideoOutput &#123; id: videoOutput; anchors.fill: parent &#125;</span><br></pre></td></tr></table></figure>

<p>可以通过play()、pause()等控制播放，可以通过position属性设置播放的进度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Keys.onSpacePressed: player.playbackState === MediaPlayer.PlayingState? player.pause() : player.play()</span><br><span class="line">Keys.onLeftPressed: player.position = player.position - 5000</span><br><span class="line">Keys.onRightPressed: player.position = player.position + 5000</span><br></pre></td></tr></table></figure>

<p>可以通过Slider类型来显示播放的进度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Slider &#123;</span><br><span class="line">        width: parent.width; anchors.bottom: item.bottom</span><br><span class="line">        to: player.duration; value: player.position</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>4.  媒体捕获相关类型</strong></p>
<ul>
<li>CaptureSession是管理本地设备上媒体捕获的中心类型，用于捕获的输入输出设备通过该类型进行统一管理，例如可以将相机和音频输入对象绑定到CaptureSession。该类型的属性包括audioInput指定音频输入对象、audioOutput指定音频输出对象、camera指定相机、imageCapture指定图形捕获对象、recorder指定音视频录制对象、videoOutput指定视频输出对象。</li>
<li>MediaDevices类型用于提供可用多媒体设备和系统默认值的信息，它主要监控音频输入设备（麦克风）、音频输出设备（扬声器、耳机）和视频输入设备（摄像头）。该类型可以通过audioInputs、audioOutputs和videoInputs等属性来获取相应设备组的列表，也可以通过defaultAudioInput、defaultAudioOutput和defaultVideoInput等属性来获取相应设备组的系统默认设备。</li>
<li>Camera类型可以在CaptureSession中用于视频录制和图像拍摄。可以使用MediaDevices获得可用的相机并指定要使用的相机，然后调用start()来开启相机，调用stop()来关闭相机。Camera提供了多个属性来控制拍摄和图像的处理，可以通过supportedFeatures来获取当前相机支持的特色，主要包括聚焦和缩放、曝光和闪光灯、白平衡等设置，可以参考前面QCamera处的介绍。</li>
</ul>
<hr>
<p><strong>5. 使用ImageCapture进行拍照</strong></p>
<p>虽然需要使用Camera进行图像输入，但具体拍照和录像等功能是分别由单独的类型来完成的。<br>ImageCapture类型用来捕获静止图像，并在图像已经捕获或成功保存时发射信号。使用该类型，需要先在CaptureSession中进行绑定，然后调用capture()来捕获图像，一旦捕获成功，就可以使用preview属性获取捕获图像的路径并通过Image进行预览，或者通过saveToFile(location)保存到指定的位置。另外，也可以通过captureToFile(location)直接完成捕获和保存操作。</p>
<p>当图像捕获成功或者保存成功时会分别发射imageCaptured()和imageSaved()信号，如果出现问题，会发射errorOccurred()信号。</p>
<p>首先使用MediaDevices获取了默认的相机设备，并在CaptureSession中分别绑定图像捕获、相机和视频输出等对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MediaDevices &#123; id: mediaDevices &#125;</span><br><span class="line">Camera &#123; id: camera; cameraDevice: mediaDevices.defaultVideoInput &#125;</span><br><span class="line">ImageCapture &#123; id: imageCapture &#125;</span><br><span class="line">VideoOutput &#123; id: videoOutput; anchors.fill: parent &#125;</span><br><span class="line"></span><br><span class="line">CaptureSession &#123;</span><br><span class="line">    imageCapture: imageCapture</span><br><span class="line">    camera: camera</span><br><span class="line">    videoOutput: videoOutput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开关按钮控件，根据相机是否可用来打开和关闭相机：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Button &#123;</span><br><span class="line">    id: openBtn</span><br><span class="line">    text: camera.active ? qsTr(&quot;关闭&quot;) : qsTr(&quot;打开&quot;)</span><br><span class="line">    anchors.bottom: parent.bottom</span><br><span class="line">    anchors.horizontalCenter: parent.horizontalCenter</span><br><span class="line">    onClicked: camera.active ? camera.stop() : camera.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是拍照按钮控件，单击后调用capture()进行图像捕获，并弹出预览框：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Button &#123;</span><br><span class="line">    id: imageCaptureBtn</span><br><span class="line">    text: qsTr(&quot;拍照&quot;)； visible: camera.active</span><br><span class="line">    anchors.left: openBtn.right</span><br><span class="line">    anchors.verticalCenter: openBtn.verticalCenter</span><br><span class="line">    onClicked: &#123;</span><br><span class="line">        imageCapture.capture()</span><br><span class="line">        popup.open()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 使用ImageCapture进行拍照</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Popup &#123;</span><br><span class="line">    id: popup;width: 400; height: 300</span><br><span class="line">    modal: true; focus: true; anchors.centerIn: Overlay.overlay</span><br><span class="line"></span><br><span class="line">    Image &#123; anchors.fill: parent; source: imageCapture.preview  &#125;</span><br><span class="line"></span><br><span class="line">    Button &#123; text: qsTr(&quot;保存&quot;)； onClicked: fileDialog.open() &#125;</span><br><span class="line"></span><br><span class="line">    FileDialog &#123;</span><br><span class="line">        id: fileDialog</span><br><span class="line">        folder: StandardPaths.writableLocation(StandardPaths.DocumentsLocation)</span><br><span class="line">        fileMode: FileDialog.SaveFile</span><br><span class="line">        currentFile: &quot;untitled.png&quot;</span><br><span class="line">        onAccepted: imageCapture.saveToFile(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>6. 使用MediaRecorder进行音视频录制</strong></p>
<p>MediaRecorder可以绑定到CaptureSession中，对相机和麦克风捕获的视频和音频进行录制。可以通过isAvailable属性判断录制服务是否可用；通过quality指定录制质量；通过metaData指定元数据；通过outputLocation指定输出路径。</p>
<p>然后调用record()开始录制，调用pause()暂停录制，调用stop()停止录制，每当调用一个方法，就会发射recorderStateChanged()信号，可以通过recorderState获取录制状态。</p>
<p>可以通过duration获取录制时长，单位是毫秒，每当duration的值改变时都会发射durationChanged()信号。</p>
<p>下面来看一个例子。首先在CaptureSession中绑定音频输入和多媒体录制对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CaptureSession &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    audioInput: AudioInput &#123;&#125;</span><br><span class="line">    recorder: MediaRecorder &#123; id: recorder &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里添加了一个按钮来进行视频捕获，在捕获前先打开一个文件保存对话框选择视频保存的路径，然后再执行录制操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Button &#123;</span><br><span class="line">    id: recordBtn</span><br><span class="line">    text: qsTr(&quot;录像&quot;)</span><br><span class="line">    visible: camera.active</span><br><span class="line">    anchors.left: imageCaptureBtn.right</span><br><span class="line">    anchors.verticalCenter: openBtn.verticalCenter</span><br><span class="line">    onClicked:  &#123;</span><br><span class="line">        if( recorder.duration === 0 || recorder.recorderState === MediaRecorder.StoppedState ) &#123;</span><br><span class="line">            recordDialog.open()</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            recorder.stop()</span><br><span class="line">            text = qsTr(&quot;录像&quot;)</span><br><span class="line">            timeLabel.visible = false</span><br><span class="line">            console.log(recorder.duration)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FileDialog &#123;</span><br><span class="line">    id: recordDialog</span><br><span class="line">    folder: StandardPaths.writableLocation(StandardPaths.DocumentsLocation)</span><br><span class="line">    fileMode: FileDialog.SaveFile</span><br><span class="line">    currentFile: &quot;untitled.mp4&quot;</span><br><span class="line">    onAccepted: &#123;</span><br><span class="line">        recorder.outputLocation = file</span><br><span class="line">        recorder.record()</span><br><span class="line">        timeLabel.visible = true</span><br><span class="line">        recordBtn.text = qsTr(&quot;停止&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="QML-与-C-混合开发"><a href="#QML-与-C-混合开发" class="headerlink" title="QML 与 C++ 混合开发"></a>QML 与 C++ 混合开发</h2><p>为了实现用户界面与应用程序逻辑分离的目的，QML支持使用C++进行扩展，允许将QML、JavaScript和C++三者进行混合开发。</p>
<p>由于QML引擎与Qt元对象系统的集成，实现了在QML中可以直接调用C++的功能，而QML模块中提供的C++类能够帮助开发人员从C++加载、维护QML对象。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>只有QObject派生的类才能将数据或函数提供给QML使用。由于QML引擎集成了Qt元对象系统，由QObject派生的所有子类的属性、方法和信号等都可以在QML中访问。</p>
<p>另外，还可以创建C++插件与QML模块集成，然后导入到QML代码中使用。</p>
<p>除了可以从QML中访问C++的功能，Qt QML模块中也提供了多种方式，实现了在C++代码中操作QML对象，不过，一般情况下并不推荐这样使用。重构QML要比重构C++容易得多，为了减少后期维护成本，建议尽量减少在C++端处理QML内容。</p>
<p><strong>1. 概述</strong></p>
<p>QObject的子类可以通过多种方式将功能暴露给QML：</p>
<ul>
<li>C++类可以被注册为一个可实例化的QML类型，这样它就可以像其它普通QML对象类型一样在QML代码中被实例化使用。</li>
<li>C++类可以被注册为一个单例类型，这样可以在QML代码中导入这个单例对象实例。</li>
<li>C++类的实例可以作为上下文属性或上下文对象嵌入到QML代码中。</li>
</ul>
<p>总的来说，通过QML与C++的集成，可以提供下面这些优势：</p>
<ul>
<li>将用户界面代码与应用程序逻辑代码分离。用户界面可以基于QML和JavaScript实现，程序逻辑则可以使用C++实现。</li>
<li>在QML中调用C++功能。例如调用程序逻辑、使用由C++实现的数据模型或者调用第三方C++库中的一些函数等。</li>
<li>使用Qt QML或Qt Quick模块中现成的C++接口。例如使用QQuickImageProvider来动态生成图像。</li>
<li>使用C++实现自定义的QML对象类型。既可以在自己指定的应用程序中使用，也可以分配给其他程序使用。</li>
</ul>
<h3 id="注册C-类型"><a href="#注册C-类型" class="headerlink" title="注册C++类型"></a>注册C++类型</h3><p>将一个C++类注册到QML类型系统，是一种常用的C++扩展QML的方式，这样就可以在QML代码中将该C++类作为一个数据类型使用。</p>
<p>要在QML中访问QObject派生类的属性、函数和信号，该派生类就必须先在QML类型系统中进行注册。</p>
<p><strong>1. 基于宏的注册方式</strong></p>
<p>QObject的子类可以注册到QML类型系统，无论该类是否可实例化。</p>
<ul>
<li>注册一个可实例化的C++类，意味着将这个类定义为一个QML对象类型，允许在QML代码中创建这种类型的对象。同时，QML对象类型通过这种注册能够获得这种类型的元数据，能够将这种类型用作QML与C++之间进行数据交换的属性值、函数参数和返回值以及信号参数等。</li>
<li>而注册一个不可实例化的C++类，意味着这种类型不能够被实例化。有时这个是很有用的，例如一个类型包含的枚举要暴露给QML但是这个类型本身不需要被实例化。</li>
</ul>
<p>Qt 5.15中重新设计了类型注册系统，使用一组可以添加到类定义中的宏，它们会将类型标记为导出到QML。这些宏中最常用的是QML_ELEMENT，它可以将所在类提供给QML作为一个类型，而类型名称就是类名。如果不想使用类名，而是自定义类型名称，那么可以使用对应的QML_NAMED_ELEMENT(name)宏，通过参数name来指定类型名称。</p>
<p>下面通过一个例子来讲解如何通过QML_ELEMENT宏将QObject派生类注册为可实例化的QML对象类型。</p>
<p><strong>示例：</strong></p>
<p>新建项目mybackend，向项目中添加新的C++类，类名为BackEnd。将backend.h文件内容更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtQml/qqmlregistration.h&gt; // 添加头文件</span><br><span class="line">... ...</span><br><span class="line">class BackEnd : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PROPERTY(QString userName READ userName WRITE setUserName </span><br><span class="line">               NOTIFY userNameChanged)</span><br><span class="line">    QML_ELEMENT // 添加宏</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit BackEnd(QObject *parent = nullptr);</span><br><span class="line">    QString userName();</span><br><span class="line">    void setUserName(const QString &amp;userName);</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    void userNameChanged();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QString m_userName;</span><br><span class="line">&#125;;                  </span><br></pre></td></tr></table></figure>

<p>要使用QML_ELEMENT等宏，需要添加 #include &lt;QtQml&#x2F;qqmlregistration.h&gt;头文件，然后在类定义的私有区添加QML_ELEMENT宏，一般在开始处添加，这样会声明这个BackEnd类可以作为QML的BackEnd类型。</p>
<p>这里还使用Q_PROPERTY宏声明了一个userName属性，该属性可以从QML访问。</p>
<p>下面修改backend.cpp内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;backend.h&quot;</span><br><span class="line"></span><br><span class="line">BackEnd::BackEnd(QObject *parent) :</span><br><span class="line">    QObject(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QString BackEnd::userName()</span><br><span class="line">&#123;</span><br><span class="line">    return m_userName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BackEnd::setUserName(const QString &amp;userName)</span><br><span class="line">&#123;</span><br><span class="line">    if (userName == m_userName)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    m_userName = userName;</span><br><span class="line">    emit userNameChanged();</span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure>

<p>每当m_userName的值改变时，setUserName()函数都会发射userNameChanged()信号，该信号可以在QML中通过onUserNameChanged信号处理器进行处理。</p>
<p>下面需要在项目文件mybackend.pro中添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += qmltypes</span><br><span class="line">QML_IMPORT_NAME = io.qt.examples.backend</span><br><span class="line">QML_IMPORT_MAJOR_VERSION = 1.                  </span><br></pre></td></tr></table></figure>

<p>这样可以使用构建系统在类型命名空间io.qt.examples.backend中注册主版本为1的类型。次要版本将从附加到属性、方法或信号的任何修订中派生出来，默认次要版本为0。</p>
<p>现在BackEnd被注册为一个QML类型，可以在QML中通过导入io.qt.examples.backend来访问该类型。下面添加新的main.qml文件，完成后将其内容修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import io.qt.examples.backend</span><br><span class="line">... ...</span><br><span class="line">ApplicationWindow &#123;</span><br><span class="line">    id: root； width: 300; height: 480; visible: true</span><br><span class="line"></span><br><span class="line">    BackEnd &#123;</span><br><span class="line">        id: backend</span><br><span class="line">        onUserNameChanged: console.log(backend.userName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Column &#123;</span><br><span class="line">        spacing: 10; anchors.centerIn: parent</span><br><span class="line">        TextField &#123;</span><br><span class="line">            placeholderText: qsTr(&quot;User name&quot;)</span><br><span class="line">            onTextChanged: backend.userName = text</span><br><span class="line">        &#125;</span><br><span class="line">        Label &#123;</span><br><span class="line">            text: backend.userName；width: 200; font.pointSize: 20</span><br><span class="line">            background: Rectangle &#123; color: &quot;lightgrey&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;               </span><br></pre></td></tr></table></figure>

<p>这里通过导入io.qt.examples.backend使得可以在QML中使用BackEnd类型。</p>
<p>通过这个例子可以看到，使用QML_ELEMENT等宏将QObject派生类注册为QML对象类型，一般需要做如下工作：</p>
<ul>
<li><p>在类的.h头文件中添加 #include &lt;QtQml&#x2F;qqmlregistration.h&gt;，并在类定义的私有部分添加QML_ELEMENT等宏；</p>
</li>
<li><p>将CONFIG+&#x3D;qmltypes、QML_IMPORT_NAME和QML_IMPORT _MAJOR_VERSION添加到.pro项目文件中;</p>
</li>
<li><p>在QML文件中通过导入QML_IMPORT_NAME指定的名称，就可以使用以类名为名称的类—型，以及其属性、函数和信号。</p>
</li>
</ul>
<hr>
<p><strong>2. 注册值类型</strong></p>
<p>具有Q_GADGET宏的任何类都可以注册为QML值类型。一旦在QML类型系统中注册，就可以用作QML代码中的属性类型，任何值类型的属性和方法都可以从QML代码访问。<br>Q_GADGET宏是Q_OBJECT宏的简化版，适用于不从QObject派生但仍希望使用QMetaObject提供的一些相关功能的类。就像Q_OBJECT宏一样，它必须出现在类定义的私有部分中，可以使用Q_ENUM、Q_PROPERTY和Q_INVOKABLE，但不能使用信号和槽。<br>需要注意，与对象类型不同，值类型的名称需要小写。注册值类型的首选方式是使用QML_VALUE_TYPE或QML_ANONYMOUS宏，其过程与前面讲到的对象类型的注册非常相似。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    Q_GADGET</span><br><span class="line">    Q_PROPERTY(QString firstName READ firstName WRITE setFirstName)</span><br><span class="line">    Q_PROPERTY(QString lastName READ lastName WRITE setLastName)</span><br><span class="line">    QML_VALUE_TYPE(person)</span><br><span class="line">public:</span><br><span class="line">    // ...</span><br><span class="line">&#125;;                </span><br></pre></td></tr></table></figure>

<p><strong>3. 注册不可实例化的对象类型</strong></p>
<p>有时需要将QObject派生类注册为不可实例化的对象类型，适用于符合下面情况的C++类：</p>
<ul>
<li>是一个接口类型，不应该被实例化</li>
<li>是不需要向QML公开的基类</li>
<li>仅声明一些可以从QML访问的枚举</li>
<li>是一种应通过单例提供给QML的类型，不应从QML实例化</li>
</ul>
<p>Qt QML模块提供了几个用于注册非实例化类型的宏：</p>
<ul>
<li>QML_ANONYMOUS宏注册不可实例化且无法从QML引用的C++类型。</li>
<li>QML_INTERFACE宏注册Qt接口类型，该类型不能从QML实例化，不过，在QML中使用这种类型的C++属性将执行预期的接口强制转换。</li>
<li>QML_UNCREATABLE(reason)宏要与QML_ELEMENT或QML_NAMED_ELEMENT结合使用，注册一个命名的C++类型，该类型不可实例化，但可以被QML类型系统识别。</li>
<li>QML_SINGLETON宏要与QML_ELEMENT或QML_NAMED_ELEMENT结合使用，注册一个可以从QML导入的单例类型。</li>
</ul>
<hr>
<p><strong>4. 注册单例类型</strong></p>
<p>单例允许QML使用命名空间访问其属性值、信号和函数，而不需要QML客户端手动实例化一个对象实例。QObject单例类型对于提供工具方法或全局属性值尤其有用。单例类型不需要关联QQmlContext，因为它们会被QML引擎中所有上下文共享。QObject单例类型由QQmlEngine构造并持有，直到引擎销毁时才会被销毁。</p>
<p>QObject单例类型只有一个实例，只能通过这种类型的名称访问，而不能使用id进行访问。</p>
<p>QObject单例类型尤其适合实现样式或主题，存储全局状态或提供全局函数。</p>
<p>在下面的代码片段中，ThemeModule命名空间的版本号为1.0，其中注册了一个QObject单例类型，包含一个QColor类型的属性color，则可以这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import ThemeModule 1.0 as Theme</span><br><span class="line"></span><br><span class="line">Rectangle &#123;</span><br><span class="line">    color: Theme.color </span><br><span class="line">&#125;             </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>5. 类型的修订和版本</strong></p>
<p>很多类型都需要提供一个注册类型的版本号。类型的修订和版本允许类型在新版本与旧版本保持兼容的同时，向类型中增加新的属性或函数。比如下面两个QML文件，一个是main.qml，里面使用了MyType类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import QtQuick 1.0</span><br><span class="line">Item &#123;</span><br><span class="line">    id: root</span><br><span class="line">    MyType &#123;&#125;</span><br><span class="line">&#125;           </span><br></pre></td></tr></table></figure>

<p>下面是MyType.qml：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import MyTypes 1.0</span><br><span class="line">CppType &#123;</span><br><span class="line">    value: root.x</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>其中，CppType对应着C++类CppType。假设在新的版本中，CppType的维护者为CppType类增加了一个root属性，使用现在版本的代码就会发生歧义。因为在该版本中，root是顶层组件的id。针对这种情况，CppType的维护者应该指出，从这个特定的版本起，root重新定义为一个全新的属性。</p>
<p>为了解决这一问题，使用REVISION宏标签标记新增的root属性的修订版本号为1。使用Q_INVOKABLE标记的函数、信号和槽也可以使用Q_REVISION(x)宏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class CppType : public BaseType</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line">    Q_PROPERTY(int root READ root WRITE setRoot </span><br><span class="line">               NOTIFY rootChanged REVISION 1)</span><br><span class="line">QML_ELEMENT</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    Q_REVISION(1) void rootChanged();</span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure>

<p>以这种方式给出的修订将自动解释为.pro项目文件中QML_IMPORT _MAJOR_VERSION给出的主要版本的次要版本。在这种情况下，仅在导入MyTypes 1.1或更高版本时root属性才可用，MyTypes 1.0版的导入不受影响。另外，在更高版本中引入时应使用QML_ADDED_in_MINOR_VERSION宏进行标记，这样如果该类型所属的QML模块的导入版本低于以这种方式确定的版本，则QML类型不可见。</p>
<hr>
<h3 id="QML模块提供的C-类"><a href="#QML模块提供的C-类" class="headerlink" title="QML模块提供的C++类"></a>QML模块提供的C++类</h3><p>Qt QML模块提供了一些用于实现QML框架的C++类，客户端可以使用这些类与QML运行时进行交互（例如向对象注入数据，或者调用对象的方法），并且从QML文档实例化对象层次结构。</p>
<p>一个使用C++作为切入点的典型QML应用程序构成了一个QML客户端。</p>
<ul>
<li><p>在启动时，客户端会初始化一个QQmlEngine类作为QML引擎，然后使用QQmlComponent对象加载QML文档。</p>
</li>
<li><p>QML引擎会提供一个默认的QQmlContext对象作为顶层执行上下文，用来执行QML文档中定义的函数和表达式。这个上下文可以通过QQmlEngine::rootContext()函数获取，利用QML引擎可以对其进行修改等操作。</p>
</li>
<li><p>如果在加载QML文档时没有发生任何错误，QML文档定义的对象层次结构将使用QQmlComponent对象的create()函数进行创建。</p>
</li>
<li><p>当所有对象全部创建完毕时，客户端会将控制权移交给应用程序的事件循环，此时，用户输入事件才能够被提交并被应用程序处理。</p>
</li>
</ul>
<p><strong>1. QQmlEngine、QQmlApplicationEngine和QQuickView</strong></p>
<p>QQmlEngine类提供了一个QML引擎，用于管理由QML文档定义的对象层次结构。QML引擎提供了一个默认的QML上下文，也就是根上下文。该上下文是表达式的执行环境，并且保证在需要时对象属性能够被正确更新。QQmlEngine允许将全局设置应用到其管理的所有对象。</p>
<p>QQmlApplicationEngine类是QQmlEngine的子类，它结合了QQmlEngine和QQmlComponent的功能，提供了一种简便的方式从一个单一的QML文件加载一个应用程序，并且为QML提供了一些核心应用程序功能，而这些功能在C++&#x2F;QML混合程序中一般由C++进行控制。</p>
<p>因为QQmlApplicationEngine不会自动创建根窗口，如果使用了Qt Quick中的可视化项目，则需要将它们放置在Window中。</p>
<p>如果想直接显示一个根对象不是Window的QML文件，例如其根对象为Item或者Rectangle，那么可以使用QQuickView类。该类位于Qt Quick模块，提供了QML运行时和显示QML应用程序的可视窗口，当给定QML文件的URL时，将自动加载并显示QML场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QQuickView *view = new QQuickView;</span><br><span class="line">view-&gt;setSource(QUrl::fromLocalFile(&quot;myqmlfile.qml&quot;));</span><br><span class="line">view-&gt;show();      </span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. QQmlContext</strong></p>
<p>QQmlContext提供了对象实例化和表达式执行所需的运行时上下文。所有对象都要在一个特定的上下文中实例化；所有表达式都要在一个特定的上下文中执行。QQmlContext类在QML引擎中定义了这样一个上下文，允许数据暴露给由QML引擎实例化的QML组件。</p>
<p>QQmlContext包含了一系列属性，能够通过名字将数据显式绑定到上下文。可以使用QQmlContext::setContextProperty()函数来定义、更新上下文中的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QQmlEngine engine;</span><br><span class="line">QStringListModel modelData;</span><br><span class="line">QQmlContext *context = engine.rootContext();</span><br><span class="line">context-&gt;setContextProperty(&quot;stringModel&quot;, &amp;modelData);  </span><br></pre></td></tr></table></figure>

<p>注意，QQmlContext的创建者有责任销毁其创建的QQmlContext对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QQmlEngine engine;</span><br><span class="line">QStringListModel modelData;</span><br><span class="line">QQmlContext *context = new QQmlContext(engine.rootContext());</span><br><span class="line">context-&gt;setContextProperty(&quot;stringModel&quot;, &amp;modelData);</span><br><span class="line"></span><br><span class="line">QQmlComponent component(&amp;engine);</span><br><span class="line">component.setData(&quot;import QtQuick; ListView&#123; model: stringModel &#125;&quot;, QUrl());</span><br><span class="line">QObject *window = component.create(context);</span><br></pre></td></tr></table></figure>

<p>另外，上下文之间会组成层次结构，子上下文会继承父上下文的上下文属性；如果在子上下文中设置的上下文属性在父上下文中已经存在了，那么会覆盖父上下文中的属性值。</p>
<p><strong>3. QQmlComponent</strong></p>
<p>动态对象实例化是QML的核心概念之一，QML文档定义的对象类型可以在运行时使用QQmlComponent类进行实例化。QQmlComponent实例既可以使用C++直接创建，也可以通过Qt.createComponnet()函数在QML代码中创建。</p>
<p>组件是可重用的、具有定义好的对外接口的封装QML类型。QQmlComponent封装了QML组件的定义，可以用于加载QML文档。它需要QQmlEngine实例化QML文档中定义的对象层次结构。</p>
<p>如果QQmlComponent需要从URL加载网络资源，或者QML文档引用了网络资源，在创建对象之前，QQmlComponent都要先获取这些网络数据。此时，QQmlComponent会变成Loading状态，只有其状态变成Ready之后，QQmlComponent::create()才能够被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QQmlEngine engine;</span><br><span class="line">QQmlComponent component(&amp;engine,</span><br><span class="line">      QUrl::fromLocalFile(&quot;../myqmlcomponent/main.qml&quot;));</span><br><span class="line">QObject *myObject = component.create();</span><br><span class="line">QQuickItem *item = qobject_cast&lt;QQuickItem*&gt;(myObject);</span><br><span class="line">qreal width = item-&gt;width();</span><br><span class="line">qDebug() &lt;&lt; width;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>4. QQmlExpression</strong></p>
<p>动态执行表达式也是QML的核心概念之一。QQmlExpression允许客户端在C++中，利用一个特定的QML上下文执行JavaScript表达式。表达式的执行结果以QVariant的形式返回，并且遵守QML引擎确定的转换规则。比如下面的main.qml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Item &#123;</span><br><span class="line">    width: 200; height: 200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用下面的C++代码，在一个上下文中执行JavaScript表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QQmlEngine *engine = new QQmlEngine;</span><br><span class="line">QQmlComponent component(engine, QUrl::fromLocalFile(&quot;main.qml&quot;));</span><br><span class="line"></span><br><span class="line">QObject *object = component.create();</span><br><span class="line">QQmlExpression *expr = new QQmlExpression(engine-&gt;rootContext(), </span><br><span class="line">                                     object, &quot;width * 2&quot;);</span><br><span class="line">int result = expr-&gt;evaluate().toInt();  // result = 400</span><br></pre></td></tr></table></figure>

<hr>
<hr>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog2025.github.io/2025/06/26/C++/" rel="prev" title="C++">
                  <i class="fa fa-angle-left"></i> C++
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    
    <!-- 去除心形图案
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    -->
    <span class="post-meta-divider">|</span>

    <span class="author" itemprop="copyrightHolder">lsdyun</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--隐藏网页底部powered by Hexo 强力驱动-->
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
<script src="/blog2025.github.io/js/comments.js"></script><script src="/blog2025.github.io/js/utils.js"></script><script src="/blog2025.github.io/js/motion.js"></script><script src="/blog2025.github.io/js/sidebar.js"></script><script src="/blog2025.github.io/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/blog2025.github.io/js/third-party/search/local-search.js"></script>




  <script src="/blog2025.github.io/js/third-party/fancybox.js"></script>

  <script src="/blog2025.github.io/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
